<?php
/**
 * ItemSpecific
 *
 * PHP version 8.1
 *
 * @package  ck/plenty-client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * plentymarkets REST-API
 *
 * The plentymarkets REST API expands the functionality of the plentymarkets CMS and allows access to resources, i.e. data records, via unique URI paths
 *
 * The version of the OpenAPI document: 1.0.0
 * @generated Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 7.1.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace ck/plenty-client\Model;

use ArrayAccess;
use JsonSerializable;
use InvalidArgumentException;
use ReturnTypeWillChange;
use ck/plenty-client\ObjectSerializer;

/**
 * ItemSpecific Class Doc Comment
 *
 * @package  ck/plenty-client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements ArrayAccess<string, mixed>
 */
class ItemSpecific implements ModelInterface, ArrayAccess, JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static string $openAPIModelName = 'ItemSpecific';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var array<string, string>
      */
    protected static array $openAPITypes = [
        'name' => 'string',
        'min_values' => 'int',
        'max_values' => 'int',
        'selection_mode' => 'string',
        'value_type' => 'string',
        'value_format' => 'string',
        'help_text' => 'string',
        'help_url' => 'string',
        'variation_picture' => 'string',
        'variation_specifics' => 'string',
        'values' => 'object[]'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var array<string, string|null>
      */
    protected static array $openAPIFormats = [
        'name' => null,
        'min_values' => null,
        'max_values' => null,
        'selection_mode' => null,
        'value_type' => null,
        'value_format' => null,
        'help_text' => null,
        'help_url' => null,
        'variation_picture' => null,
        'variation_specifics' => null,
        'values' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var array<string, bool>
      */
    protected static array $openAPINullables = [
        'name' => false,
		'min_values' => false,
		'max_values' => false,
		'selection_mode' => false,
		'value_type' => false,
		'value_format' => false,
		'help_text' => false,
		'help_url' => false,
		'variation_picture' => false,
		'variation_specifics' => false,
		'values' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var array<string, bool>
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array<string, string>
     */
    public static function openAPITypes(): array
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array<string, string>
     */
    public static function openAPIFormats(): array
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array<string, bool>
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return array<string, bool>
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param array<string, bool> $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var array<string, string>
     */
    protected static array $attributeMap = [
        'name' => 'name',
        'min_values' => 'minValues',
        'max_values' => 'maxValues',
        'selection_mode' => 'selectionMode',
        'value_type' => 'valueType',
        'value_format' => 'valueFormat',
        'help_text' => 'helpText',
        'help_url' => 'helpUrl',
        'variation_picture' => 'variationPicture',
        'variation_specifics' => 'variationSpecifics',
        'values' => 'values'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var array<string, string>
     */
    protected static array $setters = [
        'name' => 'setName',
        'min_values' => 'setMinValues',
        'max_values' => 'setMaxValues',
        'selection_mode' => 'setSelectionMode',
        'value_type' => 'setValueType',
        'value_format' => 'setValueFormat',
        'help_text' => 'setHelpText',
        'help_url' => 'setHelpUrl',
        'variation_picture' => 'setVariationPicture',
        'variation_specifics' => 'setVariationSpecifics',
        'values' => 'setValues'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var array<string, string>
     */
    protected static array $getters = [
        'name' => 'getName',
        'min_values' => 'getMinValues',
        'max_values' => 'getMaxValues',
        'selection_mode' => 'getSelectionMode',
        'value_type' => 'getValueType',
        'value_format' => 'getValueFormat',
        'help_text' => 'getHelpText',
        'help_url' => 'getHelpUrl',
        'variation_picture' => 'getVariationPicture',
        'variation_specifics' => 'getVariationSpecifics',
        'values' => 'getValues'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array<string, string>
     */
    public static function attributeMap(): array
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array<string, string>
     */
    public static function setters(): array
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array<string, string>
     */
    public static function getters(): array
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName(): string
    {
        return self::$openAPIModelName;
    }


    /**
     * Associative array for storing property values
     *
     * @var array
     */
    protected array $container = [];

    /**
     * Constructor
     *
     * @param array $data Associated array of property values initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->setIfExists('name', $data ?? [], null);
        $this->setIfExists('min_values', $data ?? [], null);
        $this->setIfExists('max_values', $data ?? [], null);
        $this->setIfExists('selection_mode', $data ?? [], null);
        $this->setIfExists('value_type', $data ?? [], null);
        $this->setIfExists('value_format', $data ?? [], null);
        $this->setIfExists('help_text', $data ?? [], null);
        $this->setIfExists('help_url', $data ?? [], null);
        $this->setIfExists('variation_picture', $data ?? [], null);
        $this->setIfExists('variation_specifics', $data ?? [], null);
        $this->setIfExists('values', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, mixed $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return string[] invalid properties with reasons
     */
    public function listInvalidProperties(): array
    {
        $invalidProperties = [];

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid(): bool
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets name
     *
     * @return string|null
     */
    public function getName(): ?string
    {
        return $this->container['name'];
    }

    /**
     * Sets name
     *
     * @param string|null $name A recommended Item Specific name.
     *
     * @return $this
     */
    public function setName(?string $name): static
    {
        if (is_null($name)) {
            throw new InvalidArgumentException('non-nullable name cannot be null');
        }
        $this->container['name'] = $name;

        return $this;
    }

    /**
     * Gets min_values
     *
     * @return int|null
     */
    public function getMinValues(): ?int
    {
        return $this->container['min_values'];
    }

    /**
     * Sets min_values
     *
     * @param int|null $min_values Minimum number of values that you can specify for this Item Specific.
     *
     * @return $this
     */
    public function setMinValues(?int $min_values): static
    {
        if (is_null($min_values)) {
            throw new InvalidArgumentException('non-nullable min_values cannot be null');
        }
        $this->container['min_values'] = $min_values;

        return $this;
    }

    /**
     * Gets max_values
     *
     * @return int|null
     */
    public function getMaxValues(): ?int
    {
        return $this->container['max_values'];
    }

    /**
     * Sets max_values
     *
     * @param int|null $max_values Maximum number of values that you can specify for this Item Specific.
     *
     * @return $this
     */
    public function setMaxValues(?int $max_values): static
    {
        if (is_null($max_values)) {
            throw new InvalidArgumentException('non-nullable max_values cannot be null');
        }
        $this->container['max_values'] = $max_values;

        return $this;
    }

    /**
     * Gets selection_mode
     *
     * @return string|null
     */
    public function getSelectionMode(): ?string
    {
        return $this->container['selection_mode'];
    }

    /**
     * Sets selection_mode
     *
     * @param string|null $selection_mode Controls whether you can specify your own name and value in listing requests, or if you need to use a name and/or value that eBay has defined.
     *
     * @return $this
     */
    public function setSelectionMode(?string $selection_mode): static
    {
        if (is_null($selection_mode)) {
            throw new InvalidArgumentException('non-nullable selection_mode cannot be null');
        }
        $this->container['selection_mode'] = $selection_mode;

        return $this;
    }

    /**
     * Gets value_type
     *
     * @return string|null
     */
    public function getValueType(): ?string
    {
        return $this->container['value_type'];
    }

    /**
     * Sets value_type
     *
     * @param string|null $value_type The data type (e.g., date) that eBay expects the value to adhere to in listing requests. Only returned if the data type is not Text. In some cases, more details about the data type are returned in the `valueFormat` field.
     *
     * @return $this
     */
    public function setValueType(?string $value_type): static
    {
        if (is_null($value_type)) {
            throw new InvalidArgumentException('non-nullable value_type cannot be null');
        }
        $this->container['value_type'] = $value_type;

        return $this;
    }

    /**
     * Gets value_format
     *
     * @return string|null
     */
    public function getValueFormat(): ?string
    {
        return $this->container['value_format'];
    }

    /**
     * Sets value_format
     *
     * @param string|null $value_format The format of the data type (e.g., date format) that eBay expects the item specific's value to adhere to in listing requests. A data type identified by the `valueType` field may have different representations, and `valueFormat` specifies the precise format that is required.
     *
     * @return $this
     */
    public function setValueFormat(?string $value_format): static
    {
        if (is_null($value_format)) {
            throw new InvalidArgumentException('non-nullable value_format cannot be null');
        }
        $this->container['value_format'] = $value_format;

        return $this;
    }

    /**
     * Gets help_text
     *
     * @return string|null
     */
    public function getHelpText(): ?string
    {
        return $this->container['help_text'];
    }

    /**
     * Sets help_text
     *
     * @param string|null $help_text Help-text defines the purpose of the Item Specific. The help text will be shown only when it is available for the particular Item Specific.
     *
     * @return $this
     */
    public function setHelpText(?string $help_text): static
    {
        if (is_null($help_text)) {
            throw new InvalidArgumentException('non-nullable help_text cannot be null');
        }
        $this->container['help_text'] = $help_text;

        return $this;
    }

    /**
     * Gets help_url
     *
     * @return string|null
     */
    public function getHelpUrl(): ?string
    {
        return $this->container['help_url'];
    }

    /**
     * Sets help_url
     *
     * @param string|null $help_url A page on the eBay Web site with context-specific help tips that provide useful information about this Item Specific. Only returned when an applicable page is available in the system.
     *
     * @return $this
     */
    public function setHelpUrl(?string $help_url): static
    {
        if (is_null($help_url)) {
            throw new InvalidArgumentException('non-nullable help_url cannot be null');
        }
        $this->container['help_url'] = $help_url;

        return $this;
    }

    /**
     * Gets variation_picture
     *
     * @return string|null
     */
    public function getVariationPicture(): ?string
    {
        return $this->container['variation_picture'];
    }

    /**
     * Sets variation_picture
     *
     * @param string|null $variation_picture Indicates whether the name (e.g., Color) can (or must) be used to classify the variation pictures
     *
     * @return $this
     */
    public function setVariationPicture(?string $variation_picture): static
    {
        if (is_null($variation_picture)) {
            throw new InvalidArgumentException('non-nullable variation_picture cannot be null');
        }
        $this->container['variation_picture'] = $variation_picture;

        return $this;
    }

    /**
     * Gets variation_specifics
     *
     * @return string|null
     */
    public function getVariationSpecifics(): ?string
    {
        return $this->container['variation_specifics'];
    }

    /**
     * Sets variation_specifics
     *
     * @param string|null $variation_specifics Indicates whether the recommended name/value pair can be used as variation attributes in a fixed-price listing call. For example, a given category could disable a name like Brand in variation specifics (if Brand is only allowed in the item specifics at the Item level). The same category could enable a name like Size for variation specifics (in addition to recommending it for item specifics). If not returned, then the name/value can be used for both variation specifics and item specifics.
     *
     * @return $this
     */
    public function setVariationSpecifics(?string $variation_specifics): static
    {
        if (is_null($variation_specifics)) {
            throw new InvalidArgumentException('non-nullable variation_specifics cannot be null');
        }
        $this->container['variation_specifics'] = $variation_specifics;

        return $this;
    }

    /**
     * Gets values
     *
     * @return object[]|null
     */
    public function getValues(): ?array
    {
        return $this->container['values'];
    }

    /**
     * Sets values
     *
     * @param object[]|null $values The available values.
     *
     * @return $this
     */
    public function setValues(?array $values): static
    {
        if (is_null($values)) {
            throw new InvalidArgumentException('non-nullable values cannot be null');
        }
        $this->container['values'] = $values;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists(mixed $offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[ReturnTypeWillChange]
    public function offsetGet(mixed $offset): mixed
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet(mixed $offset, mixed $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset(mixed $offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[ReturnTypeWillChange]
    public function jsonSerialize(): mixed
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString(): string
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue(): string
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


