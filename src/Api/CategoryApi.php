<?php
/**
 * CategoryApi
 * PHP version 8.1
 *
 * @package  ck
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * plentymarkets REST-API
 *
 * The plentymarkets REST API expands the functionality of the plentymarkets CMS and allows access to resources, i.e. data records, via unique URI paths
 *
 * The version of the OpenAPI document: 1.0.0
 * @generated Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 7.1.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace ck\Api;

use InvalidArgumentException;
use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use GuzzleHttp\Promise\PromiseInterface;
use ck\ApiException;
use ck\Configuration;
use ck\HeaderSelector;
use ck\ObjectSerializer;

/**
 * CategoryApi Class Doc Comment
 *
 * @package  ck
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class CategoryApi
{
    /**
     * @var ClientInterface
     */
    protected ClientInterface $client;

    /**
     * @var Configuration
     */
    protected Configuration $config;

    /**
     * @var HeaderSelector
     */
    protected HeaderSelector $headerSelector;

    /**
     * @var int Host index
     */
    protected int $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'restCategoriesGet' => [
            'application/json',
        ],
        'restCategoriesIdClientsDelete' => [
            'application/json',
        ],
        'restCategoriesIdDelete' => [
            'application/json',
        ],
        'restCategoriesIdDetailsDelete' => [
            'application/json',
        ],
        'restCategoriesIdGet' => [
            'application/json',
        ],
        'restCategoriesIdPut' => [
            'application/json',
        ],
        'restCategoriesIdTemplatesDelete' => [
            'application/json',
        ],
        'restCategoriesIdTemplatesGet' => [
            'application/json',
        ],
        'restCategoriesIdTemplatesPut' => [
            'application/json',
        ],
        'restCategoriesPost' => [
            'application/json',
        ],
        'restCategoriesPut' => [
            'application/json',
        ],
        'restCategoryBranchesGet' => [
            'application/json',
        ],
        'restCategoryBranchesIdGet' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface|null $client
     * @param Configuration|null   $config
     * @param HeaderSelector|null  $selector
     * @param int                  $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex(int $hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex(): int
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig(): Configuration
    {
        return $this->config;
    }

    /**
     * Operation restCategoriesGet
     *
     * List categories
     *
     * @param  int|null $page The requested page of results (optional)
     * @param  int|null $items_per_page The number of results per page (optional)
     * @param  string|null $with Includes the detail information, the active clients (stores) list of the category, all linked tags and their information and/or the linked Elmar category for each client. Available values: details, clients, elmarCategories, tags (optional)
     * @param  string|null $lang The &lt;a href&#x3D;&#39;https://developers.plentymarkets.com/rest-doc/introduction#countries&#39; target&#x3D;&#39;_blank&#39;&gt;languages&lt;/a&gt; of the category detail information. Several languages must be separated by commas. If no language filter is set, the default language of the system is used. (optional)
     * @param  string|null $type The category type. Available values: item, container, content, blog (optional)
     * @param  int|null $parent_id The unique ID of the parent category (optional)
     * @param  int|null $plenty_id The unique plenty ID of the client (store) (optional)
     * @param  string|null $name The name of the category (optional)
     * @param  string|null $level The level of the category (optional)
     * @param  bool|null $linklist Filter for the linklist of categories (optional)
     * @param  string|null $updated_at Filter restricts the list of results to items updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     * @param  int|null $tag_id Filter restricts the list of results to items with a specific tag (optional)
     * @param  string|null $meta_keywords Filter restricts the list of results to items with a specific meta keyword. Possible search operators are &#39;like&#39; and &#39;eq&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestCategoriesGet200Response
     */
    public function restCategoriesGet(
        ?int $page = null,
        ?int $items_per_page = null,
        ?string $with = null,
        ?string $lang = null,
        ?string $type = null,
        ?int $parent_id = null,
        ?int $plenty_id = null,
        ?string $name = null,
        ?string $level = null,
        ?bool $linklist = null,
        ?string $updated_at = null,
        ?int $tag_id = null,
        ?string $meta_keywords = null,
        string $contentType = self::contentTypes['restCategoriesGet'][0]
    ): \ck\Model\RestCategoriesGet200Response
    {
        list($response) = $this->restCategoriesGetWithHttpInfo($page, $items_per_page, $with, $lang, $type, $parent_id, $plenty_id, $name, $level, $linklist, $updated_at, $tag_id, $meta_keywords, $contentType);
        return $response;
    }

    /**
     * Operation restCategoriesGetWithHttpInfo
     *
     * List categories
     *
     * @param  int|null $page The requested page of results (optional)
     * @param  int|null $items_per_page The number of results per page (optional)
     * @param  string|null $with Includes the detail information, the active clients (stores) list of the category, all linked tags and their information and/or the linked Elmar category for each client. Available values: details, clients, elmarCategories, tags (optional)
     * @param  string|null $lang The &lt;a href&#x3D;&#39;https://developers.plentymarkets.com/rest-doc/introduction#countries&#39; target&#x3D;&#39;_blank&#39;&gt;languages&lt;/a&gt; of the category detail information. Several languages must be separated by commas. If no language filter is set, the default language of the system is used. (optional)
     * @param  string|null $type The category type. Available values: item, container, content, blog (optional)
     * @param  int|null $parent_id The unique ID of the parent category (optional)
     * @param  int|null $plenty_id The unique plenty ID of the client (store) (optional)
     * @param  string|null $name The name of the category (optional)
     * @param  string|null $level The level of the category (optional)
     * @param  bool|null $linklist Filter for the linklist of categories (optional)
     * @param  string|null $updated_at Filter restricts the list of results to items updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     * @param  int|null $tag_id Filter restricts the list of results to items with a specific tag (optional)
     * @param  string|null $meta_keywords Filter restricts the list of results to items with a specific meta keyword. Possible search operators are &#39;like&#39; and &#39;eq&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestCategoriesGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restCategoriesGetWithHttpInfo(
        ?int $page = null,
        ?int $items_per_page = null,
        ?string $with = null,
        ?string $lang = null,
        ?string $type = null,
        ?int $parent_id = null,
        ?int $plenty_id = null,
        ?string $name = null,
        ?string $level = null,
        ?bool $linklist = null,
        ?string $updated_at = null,
        ?int $tag_id = null,
        ?string $meta_keywords = null,
        string $contentType = self::contentTypes['restCategoriesGet'][0]
    ): array
    {
        $request = $this->restCategoriesGetRequest($page, $items_per_page, $with, $lang, $type, $parent_id, $plenty_id, $name, $level, $linklist, $updated_at, $tag_id, $meta_keywords, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestCategoriesGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestCategoriesGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestCategoriesGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestCategoriesGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestCategoriesGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restCategoriesGetAsync
     *
     * List categories
     *
     * @param  int|null $page The requested page of results (optional)
     * @param  int|null $items_per_page The number of results per page (optional)
     * @param  string|null $with Includes the detail information, the active clients (stores) list of the category, all linked tags and their information and/or the linked Elmar category for each client. Available values: details, clients, elmarCategories, tags (optional)
     * @param  string|null $lang The &lt;a href&#x3D;&#39;https://developers.plentymarkets.com/rest-doc/introduction#countries&#39; target&#x3D;&#39;_blank&#39;&gt;languages&lt;/a&gt; of the category detail information. Several languages must be separated by commas. If no language filter is set, the default language of the system is used. (optional)
     * @param  string|null $type The category type. Available values: item, container, content, blog (optional)
     * @param  int|null $parent_id The unique ID of the parent category (optional)
     * @param  int|null $plenty_id The unique plenty ID of the client (store) (optional)
     * @param  string|null $name The name of the category (optional)
     * @param  string|null $level The level of the category (optional)
     * @param  bool|null $linklist Filter for the linklist of categories (optional)
     * @param  string|null $updated_at Filter restricts the list of results to items updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     * @param  int|null $tag_id Filter restricts the list of results to items with a specific tag (optional)
     * @param  string|null $meta_keywords Filter restricts the list of results to items with a specific meta keyword. Possible search operators are &#39;like&#39; and &#39;eq&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restCategoriesGetAsync(
        ?int $page = null,
        ?int $items_per_page = null,
        ?string $with = null,
        ?string $lang = null,
        ?string $type = null,
        ?int $parent_id = null,
        ?int $plenty_id = null,
        ?string $name = null,
        ?string $level = null,
        ?bool $linklist = null,
        ?string $updated_at = null,
        ?int $tag_id = null,
        ?string $meta_keywords = null,
        string $contentType = self::contentTypes['restCategoriesGet'][0]
    ): PromiseInterface
    {
        return $this->restCategoriesGetAsyncWithHttpInfo($page, $items_per_page, $with, $lang, $type, $parent_id, $plenty_id, $name, $level, $linklist, $updated_at, $tag_id, $meta_keywords, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restCategoriesGetAsyncWithHttpInfo
     *
     * List categories
     *
     * @param  int|null $page The requested page of results (optional)
     * @param  int|null $items_per_page The number of results per page (optional)
     * @param  string|null $with Includes the detail information, the active clients (stores) list of the category, all linked tags and their information and/or the linked Elmar category for each client. Available values: details, clients, elmarCategories, tags (optional)
     * @param  string|null $lang The &lt;a href&#x3D;&#39;https://developers.plentymarkets.com/rest-doc/introduction#countries&#39; target&#x3D;&#39;_blank&#39;&gt;languages&lt;/a&gt; of the category detail information. Several languages must be separated by commas. If no language filter is set, the default language of the system is used. (optional)
     * @param  string|null $type The category type. Available values: item, container, content, blog (optional)
     * @param  int|null $parent_id The unique ID of the parent category (optional)
     * @param  int|null $plenty_id The unique plenty ID of the client (store) (optional)
     * @param  string|null $name The name of the category (optional)
     * @param  string|null $level The level of the category (optional)
     * @param  bool|null $linklist Filter for the linklist of categories (optional)
     * @param  string|null $updated_at Filter restricts the list of results to items updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     * @param  int|null $tag_id Filter restricts the list of results to items with a specific tag (optional)
     * @param  string|null $meta_keywords Filter restricts the list of results to items with a specific meta keyword. Possible search operators are &#39;like&#39; and &#39;eq&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restCategoriesGetAsyncWithHttpInfo(
        $page = null,
        $items_per_page = null,
        $with = null,
        $lang = null,
        $type = null,
        $parent_id = null,
        $plenty_id = null,
        $name = null,
        $level = null,
        $linklist = null,
        $updated_at = null,
        $tag_id = null,
        $meta_keywords = null,
        string $contentType = self::contentTypes['restCategoriesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestCategoriesGet200Response';
        $request = $this->restCategoriesGetRequest($page, $items_per_page, $with, $lang, $type, $parent_id, $plenty_id, $name, $level, $linklist, $updated_at, $tag_id, $meta_keywords, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restCategoriesGet'
     *
     * @param  int|null $page The requested page of results (optional)
     * @param  int|null $items_per_page The number of results per page (optional)
     * @param  string|null $with Includes the detail information, the active clients (stores) list of the category, all linked tags and their information and/or the linked Elmar category for each client. Available values: details, clients, elmarCategories, tags (optional)
     * @param  string|null $lang The &lt;a href&#x3D;&#39;https://developers.plentymarkets.com/rest-doc/introduction#countries&#39; target&#x3D;&#39;_blank&#39;&gt;languages&lt;/a&gt; of the category detail information. Several languages must be separated by commas. If no language filter is set, the default language of the system is used. (optional)
     * @param  string|null $type The category type. Available values: item, container, content, blog (optional)
     * @param  int|null $parent_id The unique ID of the parent category (optional)
     * @param  int|null $plenty_id The unique plenty ID of the client (store) (optional)
     * @param  string|null $name The name of the category (optional)
     * @param  string|null $level The level of the category (optional)
     * @param  bool|null $linklist Filter for the linklist of categories (optional)
     * @param  string|null $updated_at Filter restricts the list of results to items updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     * @param  int|null $tag_id Filter restricts the list of results to items with a specific tag (optional)
     * @param  string|null $meta_keywords Filter restricts the list of results to items with a specific meta keyword. Possible search operators are &#39;like&#39; and &#39;eq&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restCategoriesGetRequest(
        $page = null,
        $items_per_page = null,
        $with = null,
        $lang = null,
        $type = null,
        $parent_id = null,
        $plenty_id = null,
        $name = null,
        $level = null,
        $linklist = null,
        $updated_at = null,
        $tag_id = null,
        $meta_keywords = null,
        string $contentType = self::contentTypes['restCategoriesGet'][0]
    ): Request
    {















        $resourcePath = '/rest/categories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $items_per_page,
            'itemsPerPage', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $lang,
            'lang', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $parent_id,
            'parentId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $plenty_id,
            'plentyId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $linklist,
            'linklist', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_at,
            'updatedAt', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag_id,
            'tagId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $meta_keywords,
            'metaKeywords', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restCategoriesIdClientsDelete
     *
     * Deactivate availability for clients
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesIdClientsDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restCategoriesIdClientsDelete(
        int $id,
        string $contentType = self::contentTypes['restCategoriesIdClientsDelete'][0]
    ): object
    {
        list($response) = $this->restCategoriesIdClientsDeleteWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation restCategoriesIdClientsDeleteWithHttpInfo
     *
     * Deactivate availability for clients
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesIdClientsDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restCategoriesIdClientsDeleteWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restCategoriesIdClientsDelete'][0]
    ): array
    {
        $request = $this->restCategoriesIdClientsDeleteRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restCategoriesIdClientsDeleteAsync
     *
     * Deactivate availability for clients
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesIdClientsDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restCategoriesIdClientsDeleteAsync(
        int $id,
        string $contentType = self::contentTypes['restCategoriesIdClientsDelete'][0]
    ): PromiseInterface
    {
        return $this->restCategoriesIdClientsDeleteAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restCategoriesIdClientsDeleteAsyncWithHttpInfo
     *
     * Deactivate availability for clients
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesIdClientsDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restCategoriesIdClientsDeleteAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restCategoriesIdClientsDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restCategoriesIdClientsDeleteRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restCategoriesIdClientsDelete'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesIdClientsDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restCategoriesIdClientsDeleteRequest(
        $id,
        string $contentType = self::contentTypes['restCategoriesIdClientsDelete'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restCategoriesIdClientsDelete'
            );
        }


        $resourcePath = '/rest/categories/{id}/clients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restCategoriesIdDelete
     *
     * Deletes a category
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restCategoriesIdDelete(
        int $id,
        string $contentType = self::contentTypes['restCategoriesIdDelete'][0]
    ): object
    {
        list($response) = $this->restCategoriesIdDeleteWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation restCategoriesIdDeleteWithHttpInfo
     *
     * Deletes a category
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restCategoriesIdDeleteWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restCategoriesIdDelete'][0]
    ): array
    {
        $request = $this->restCategoriesIdDeleteRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restCategoriesIdDeleteAsync
     *
     * Deletes a category
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restCategoriesIdDeleteAsync(
        int $id,
        string $contentType = self::contentTypes['restCategoriesIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restCategoriesIdDeleteAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restCategoriesIdDeleteAsyncWithHttpInfo
     *
     * Deletes a category
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restCategoriesIdDeleteAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restCategoriesIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restCategoriesIdDeleteRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restCategoriesIdDelete'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restCategoriesIdDeleteRequest(
        $id,
        string $contentType = self::contentTypes['restCategoriesIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restCategoriesIdDelete'
            );
        }


        $resourcePath = '/rest/categories/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restCategoriesIdDetailsDelete
     *
     * Delete category details for the specified languages
     *
     * @param  int $id id (required)
     * @param  \ck\Model\RestCategoriesIdDetailsDeleteRequest|null $_rest_categories_id_details _rest_categories_id_details (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesIdDetailsDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restCategoriesIdDetailsDelete(
        int $id,
        ?\ck\Model\RestCategoriesIdDetailsDeleteRequest $_rest_categories_id_details = null,
        string $contentType = self::contentTypes['restCategoriesIdDetailsDelete'][0]
    ): object
    {
        list($response) = $this->restCategoriesIdDetailsDeleteWithHttpInfo($id, $_rest_categories_id_details, $contentType);
        return $response;
    }

    /**
     * Operation restCategoriesIdDetailsDeleteWithHttpInfo
     *
     * Delete category details for the specified languages
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestCategoriesIdDetailsDeleteRequest|null $_rest_categories_id_details (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesIdDetailsDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restCategoriesIdDetailsDeleteWithHttpInfo(
        int $id,
        ?\ck\Model\RestCategoriesIdDetailsDeleteRequest $_rest_categories_id_details = null,
        string $contentType = self::contentTypes['restCategoriesIdDetailsDelete'][0]
    ): array
    {
        $request = $this->restCategoriesIdDetailsDeleteRequest($id, $_rest_categories_id_details, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restCategoriesIdDetailsDeleteAsync
     *
     * Delete category details for the specified languages
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestCategoriesIdDetailsDeleteRequest|null $_rest_categories_id_details (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesIdDetailsDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restCategoriesIdDetailsDeleteAsync(
        int $id,
        ?\ck\Model\RestCategoriesIdDetailsDeleteRequest $_rest_categories_id_details = null,
        string $contentType = self::contentTypes['restCategoriesIdDetailsDelete'][0]
    ): PromiseInterface
    {
        return $this->restCategoriesIdDetailsDeleteAsyncWithHttpInfo($id, $_rest_categories_id_details, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restCategoriesIdDetailsDeleteAsyncWithHttpInfo
     *
     * Delete category details for the specified languages
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestCategoriesIdDetailsDeleteRequest|null $_rest_categories_id_details (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesIdDetailsDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restCategoriesIdDetailsDeleteAsyncWithHttpInfo(
        $id,
        $_rest_categories_id_details = null,
        string $contentType = self::contentTypes['restCategoriesIdDetailsDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restCategoriesIdDetailsDeleteRequest($id, $_rest_categories_id_details, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restCategoriesIdDetailsDelete'
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestCategoriesIdDetailsDeleteRequest|null $_rest_categories_id_details (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesIdDetailsDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restCategoriesIdDetailsDeleteRequest(
        $id,
        $_rest_categories_id_details = null,
        string $contentType = self::contentTypes['restCategoriesIdDetailsDelete'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restCategoriesIdDetailsDelete'
            );
        }



        $resourcePath = '/rest/categories/{id}/details';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_categories_id_details)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_categories_id_details));
            } else {
                $httpBody = $_rest_categories_id_details;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restCategoriesIdGet
     *
     * Get a category
     *
     * @param  int $id The ID of the category (required)
     * @param  int|null $page The requested page of results (optional)
     * @param  int|null $items_per_page The number of results per page (optional)
     * @param  string|null $with Includes the detail information, the active clients (stores) list of the category and/or the linked Elmar category for each client. Available values: details, clients, elmarCategories (optional)
     * @param  string|null $lang The &lt;a href&#x3D;&#39;https://developers.plentymarkets.com/rest-doc/introduction#countries&#39; target&#x3D;&#39;_blank&#39;&gt;languages&lt;/a&gt; of the category detail information. Several languages must be separated by commas. If no language filter is set, the default language of the system is used. (optional)
     * @param  string|null $type The category type. Available values: item, container, content, blog (optional)
     * @param  int|null $parent_id The unique ID of the parent category (optional)
     * @param  int|null $plenty_id The unique plenty ID of the client (store) (optional)
     * @param  string|null $name The name of the category (optional)
     * @param  string|null $level The level of the category (optional)
     * @param  bool|null $linklist Filter for the linklist of categories (optional)
     * @param  string|null $updated_at Filter restricts the list of results to items updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestCategoriesGet200Response
     */
    public function restCategoriesIdGet(
        int $id,
        ?int $page = null,
        ?int $items_per_page = null,
        ?string $with = null,
        ?string $lang = null,
        ?string $type = null,
        ?int $parent_id = null,
        ?int $plenty_id = null,
        ?string $name = null,
        ?string $level = null,
        ?bool $linklist = null,
        ?string $updated_at = null,
        string $contentType = self::contentTypes['restCategoriesIdGet'][0]
    ): \ck\Model\RestCategoriesGet200Response
    {
        list($response) = $this->restCategoriesIdGetWithHttpInfo($id, $page, $items_per_page, $with, $lang, $type, $parent_id, $plenty_id, $name, $level, $linklist, $updated_at, $contentType);
        return $response;
    }

    /**
     * Operation restCategoriesIdGetWithHttpInfo
     *
     * Get a category
     *
     * @param  int $id The ID of the category (required)
     * @param  int|null $page The requested page of results (optional)
     * @param  int|null $items_per_page The number of results per page (optional)
     * @param  string|null $with Includes the detail information, the active clients (stores) list of the category and/or the linked Elmar category for each client. Available values: details, clients, elmarCategories (optional)
     * @param  string|null $lang The &lt;a href&#x3D;&#39;https://developers.plentymarkets.com/rest-doc/introduction#countries&#39; target&#x3D;&#39;_blank&#39;&gt;languages&lt;/a&gt; of the category detail information. Several languages must be separated by commas. If no language filter is set, the default language of the system is used. (optional)
     * @param  string|null $type The category type. Available values: item, container, content, blog (optional)
     * @param  int|null $parent_id The unique ID of the parent category (optional)
     * @param  int|null $plenty_id The unique plenty ID of the client (store) (optional)
     * @param  string|null $name The name of the category (optional)
     * @param  string|null $level The level of the category (optional)
     * @param  bool|null $linklist Filter for the linklist of categories (optional)
     * @param  string|null $updated_at Filter restricts the list of results to items updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestCategoriesGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restCategoriesIdGetWithHttpInfo(
        int $id,
        ?int $page = null,
        ?int $items_per_page = null,
        ?string $with = null,
        ?string $lang = null,
        ?string $type = null,
        ?int $parent_id = null,
        ?int $plenty_id = null,
        ?string $name = null,
        ?string $level = null,
        ?bool $linklist = null,
        ?string $updated_at = null,
        string $contentType = self::contentTypes['restCategoriesIdGet'][0]
    ): array
    {
        $request = $this->restCategoriesIdGetRequest($id, $page, $items_per_page, $with, $lang, $type, $parent_id, $plenty_id, $name, $level, $linklist, $updated_at, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestCategoriesGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestCategoriesGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestCategoriesGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestCategoriesGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestCategoriesGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restCategoriesIdGetAsync
     *
     * Get a category
     *
     * @param  int $id The ID of the category (required)
     * @param  int|null $page The requested page of results (optional)
     * @param  int|null $items_per_page The number of results per page (optional)
     * @param  string|null $with Includes the detail information, the active clients (stores) list of the category and/or the linked Elmar category for each client. Available values: details, clients, elmarCategories (optional)
     * @param  string|null $lang The &lt;a href&#x3D;&#39;https://developers.plentymarkets.com/rest-doc/introduction#countries&#39; target&#x3D;&#39;_blank&#39;&gt;languages&lt;/a&gt; of the category detail information. Several languages must be separated by commas. If no language filter is set, the default language of the system is used. (optional)
     * @param  string|null $type The category type. Available values: item, container, content, blog (optional)
     * @param  int|null $parent_id The unique ID of the parent category (optional)
     * @param  int|null $plenty_id The unique plenty ID of the client (store) (optional)
     * @param  string|null $name The name of the category (optional)
     * @param  string|null $level The level of the category (optional)
     * @param  bool|null $linklist Filter for the linklist of categories (optional)
     * @param  string|null $updated_at Filter restricts the list of results to items updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restCategoriesIdGetAsync(
        int $id,
        ?int $page = null,
        ?int $items_per_page = null,
        ?string $with = null,
        ?string $lang = null,
        ?string $type = null,
        ?int $parent_id = null,
        ?int $plenty_id = null,
        ?string $name = null,
        ?string $level = null,
        ?bool $linklist = null,
        ?string $updated_at = null,
        string $contentType = self::contentTypes['restCategoriesIdGet'][0]
    ): PromiseInterface
    {
        return $this->restCategoriesIdGetAsyncWithHttpInfo($id, $page, $items_per_page, $with, $lang, $type, $parent_id, $plenty_id, $name, $level, $linklist, $updated_at, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restCategoriesIdGetAsyncWithHttpInfo
     *
     * Get a category
     *
     * @param  int $id The ID of the category (required)
     * @param  int|null $page The requested page of results (optional)
     * @param  int|null $items_per_page The number of results per page (optional)
     * @param  string|null $with Includes the detail information, the active clients (stores) list of the category and/or the linked Elmar category for each client. Available values: details, clients, elmarCategories (optional)
     * @param  string|null $lang The &lt;a href&#x3D;&#39;https://developers.plentymarkets.com/rest-doc/introduction#countries&#39; target&#x3D;&#39;_blank&#39;&gt;languages&lt;/a&gt; of the category detail information. Several languages must be separated by commas. If no language filter is set, the default language of the system is used. (optional)
     * @param  string|null $type The category type. Available values: item, container, content, blog (optional)
     * @param  int|null $parent_id The unique ID of the parent category (optional)
     * @param  int|null $plenty_id The unique plenty ID of the client (store) (optional)
     * @param  string|null $name The name of the category (optional)
     * @param  string|null $level The level of the category (optional)
     * @param  bool|null $linklist Filter for the linklist of categories (optional)
     * @param  string|null $updated_at Filter restricts the list of results to items updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restCategoriesIdGetAsyncWithHttpInfo(
        $id,
        $page = null,
        $items_per_page = null,
        $with = null,
        $lang = null,
        $type = null,
        $parent_id = null,
        $plenty_id = null,
        $name = null,
        $level = null,
        $linklist = null,
        $updated_at = null,
        string $contentType = self::contentTypes['restCategoriesIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestCategoriesGet200Response';
        $request = $this->restCategoriesIdGetRequest($id, $page, $items_per_page, $with, $lang, $type, $parent_id, $plenty_id, $name, $level, $linklist, $updated_at, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restCategoriesIdGet'
     *
     * @param  int $id The ID of the category (required)
     * @param  int|null $page The requested page of results (optional)
     * @param  int|null $items_per_page The number of results per page (optional)
     * @param  string|null $with Includes the detail information, the active clients (stores) list of the category and/or the linked Elmar category for each client. Available values: details, clients, elmarCategories (optional)
     * @param  string|null $lang The &lt;a href&#x3D;&#39;https://developers.plentymarkets.com/rest-doc/introduction#countries&#39; target&#x3D;&#39;_blank&#39;&gt;languages&lt;/a&gt; of the category detail information. Several languages must be separated by commas. If no language filter is set, the default language of the system is used. (optional)
     * @param  string|null $type The category type. Available values: item, container, content, blog (optional)
     * @param  int|null $parent_id The unique ID of the parent category (optional)
     * @param  int|null $plenty_id The unique plenty ID of the client (store) (optional)
     * @param  string|null $name The name of the category (optional)
     * @param  string|null $level The level of the category (optional)
     * @param  bool|null $linklist Filter for the linklist of categories (optional)
     * @param  string|null $updated_at Filter restricts the list of results to items updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restCategoriesIdGetRequest(
        $id,
        $page = null,
        $items_per_page = null,
        $with = null,
        $lang = null,
        $type = null,
        $parent_id = null,
        $plenty_id = null,
        $name = null,
        $level = null,
        $linklist = null,
        $updated_at = null,
        string $contentType = self::contentTypes['restCategoriesIdGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restCategoriesIdGet'
            );
        }













        $resourcePath = '/rest/categories/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $items_per_page,
            'itemsPerPage', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $lang,
            'lang', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $parent_id,
            'parentId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $plenty_id,
            'plentyId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $linklist,
            'linklist', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_at,
            'updatedAt', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restCategoriesIdPut
     *
     * Updates one category
     *
     * @param  int $id id (required)
     * @param  \ck\Model\RestCategoriesPutRequest|null $_rest_categories_id _rest_categories_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Category
     */
    public function restCategoriesIdPut(
        int $id,
        ?\ck\Model\RestCategoriesPutRequest $_rest_categories_id = null,
        string $contentType = self::contentTypes['restCategoriesIdPut'][0]
    ): \ck\Model\Category
    {
        list($response) = $this->restCategoriesIdPutWithHttpInfo($id, $_rest_categories_id, $contentType);
        return $response;
    }

    /**
     * Operation restCategoriesIdPutWithHttpInfo
     *
     * Updates one category
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestCategoriesPutRequest|null $_rest_categories_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Category, HTTP status code, HTTP response headers (array of strings)
     */
    public function restCategoriesIdPutWithHttpInfo(
        int $id,
        ?\ck\Model\RestCategoriesPutRequest $_rest_categories_id = null,
        string $contentType = self::contentTypes['restCategoriesIdPut'][0]
    ): array
    {
        $request = $this->restCategoriesIdPutRequest($id, $_rest_categories_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Category' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Category' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Category', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Category';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Category',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restCategoriesIdPutAsync
     *
     * Updates one category
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestCategoriesPutRequest|null $_rest_categories_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restCategoriesIdPutAsync(
        int $id,
        ?\ck\Model\RestCategoriesPutRequest $_rest_categories_id = null,
        string $contentType = self::contentTypes['restCategoriesIdPut'][0]
    ): PromiseInterface
    {
        return $this->restCategoriesIdPutAsyncWithHttpInfo($id, $_rest_categories_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restCategoriesIdPutAsyncWithHttpInfo
     *
     * Updates one category
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestCategoriesPutRequest|null $_rest_categories_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restCategoriesIdPutAsyncWithHttpInfo(
        $id,
        $_rest_categories_id = null,
        string $contentType = self::contentTypes['restCategoriesIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Category';
        $request = $this->restCategoriesIdPutRequest($id, $_rest_categories_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restCategoriesIdPut'
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestCategoriesPutRequest|null $_rest_categories_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restCategoriesIdPutRequest(
        $id,
        $_rest_categories_id = null,
        string $contentType = self::contentTypes['restCategoriesIdPut'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restCategoriesIdPut'
            );
        }



        $resourcePath = '/rest/categories/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_categories_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_categories_id));
            } else {
                $httpBody = $_rest_categories_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restCategoriesIdTemplatesDelete
     *
     * Delete a category template
     *
     * @param  int $id id (required)
     * @param  \ck\Model\RestCategoriesIdTemplatesGetRequest|null $_rest_categories_id_templates _rest_categories_id_templates (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesIdTemplatesDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\CategoryTemplate
     */
    public function restCategoriesIdTemplatesDelete(
        int $id,
        ?\ck\Model\RestCategoriesIdTemplatesGetRequest $_rest_categories_id_templates = null,
        string $contentType = self::contentTypes['restCategoriesIdTemplatesDelete'][0]
    ): \ck\Model\CategoryTemplate
    {
        list($response) = $this->restCategoriesIdTemplatesDeleteWithHttpInfo($id, $_rest_categories_id_templates, $contentType);
        return $response;
    }

    /**
     * Operation restCategoriesIdTemplatesDeleteWithHttpInfo
     *
     * Delete a category template
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestCategoriesIdTemplatesGetRequest|null $_rest_categories_id_templates (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesIdTemplatesDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\CategoryTemplate, HTTP status code, HTTP response headers (array of strings)
     */
    public function restCategoriesIdTemplatesDeleteWithHttpInfo(
        int $id,
        ?\ck\Model\RestCategoriesIdTemplatesGetRequest $_rest_categories_id_templates = null,
        string $contentType = self::contentTypes['restCategoriesIdTemplatesDelete'][0]
    ): array
    {
        $request = $this->restCategoriesIdTemplatesDeleteRequest($id, $_rest_categories_id_templates, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\CategoryTemplate' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\CategoryTemplate' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\CategoryTemplate', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\CategoryTemplate';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\CategoryTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restCategoriesIdTemplatesDeleteAsync
     *
     * Delete a category template
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestCategoriesIdTemplatesGetRequest|null $_rest_categories_id_templates (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesIdTemplatesDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restCategoriesIdTemplatesDeleteAsync(
        int $id,
        ?\ck\Model\RestCategoriesIdTemplatesGetRequest $_rest_categories_id_templates = null,
        string $contentType = self::contentTypes['restCategoriesIdTemplatesDelete'][0]
    ): PromiseInterface
    {
        return $this->restCategoriesIdTemplatesDeleteAsyncWithHttpInfo($id, $_rest_categories_id_templates, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restCategoriesIdTemplatesDeleteAsyncWithHttpInfo
     *
     * Delete a category template
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestCategoriesIdTemplatesGetRequest|null $_rest_categories_id_templates (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesIdTemplatesDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restCategoriesIdTemplatesDeleteAsyncWithHttpInfo(
        $id,
        $_rest_categories_id_templates = null,
        string $contentType = self::contentTypes['restCategoriesIdTemplatesDelete'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\CategoryTemplate';
        $request = $this->restCategoriesIdTemplatesDeleteRequest($id, $_rest_categories_id_templates, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restCategoriesIdTemplatesDelete'
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestCategoriesIdTemplatesGetRequest|null $_rest_categories_id_templates (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesIdTemplatesDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restCategoriesIdTemplatesDeleteRequest(
        $id,
        $_rest_categories_id_templates = null,
        string $contentType = self::contentTypes['restCategoriesIdTemplatesDelete'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restCategoriesIdTemplatesDelete'
            );
        }



        $resourcePath = '/rest/categories/{id}/templates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_categories_id_templates)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_categories_id_templates));
            } else {
                $httpBody = $_rest_categories_id_templates;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restCategoriesIdTemplatesGet
     *
     * Get a category template
     *
     * @param  int $plenty_id The unique plenty ID of the client (store) (required)
     * @param  int $id id (required)
     * @param  string|null $lang The &lt;a href&#x3D;&#39;https://developers.plentymarkets.com/rest-doc/introduction#countries&#39; target&#x3D;&#39;_blank&#39;&gt;language&lt;/a&gt; of the template. If no language filter is set, the default language of the system is used. (optional)
     * @param  \ck\Model\RestCategoriesIdTemplatesGetRequest|null $_rest_categories_id_templates _rest_categories_id_templates (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesIdTemplatesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\CategoryTemplate
     */
    public function restCategoriesIdTemplatesGet(
        int $plenty_id,
        int $id,
        ?string $lang = null,
        ?\ck\Model\RestCategoriesIdTemplatesGetRequest $_rest_categories_id_templates = null,
        string $contentType = self::contentTypes['restCategoriesIdTemplatesGet'][0]
    ): \ck\Model\CategoryTemplate
    {
        list($response) = $this->restCategoriesIdTemplatesGetWithHttpInfo($plenty_id, $id, $lang, $_rest_categories_id_templates, $contentType);
        return $response;
    }

    /**
     * Operation restCategoriesIdTemplatesGetWithHttpInfo
     *
     * Get a category template
     *
     * @param  int $plenty_id The unique plenty ID of the client (store) (required)
     * @param  int $id (required)
     * @param  string|null $lang The &lt;a href&#x3D;&#39;https://developers.plentymarkets.com/rest-doc/introduction#countries&#39; target&#x3D;&#39;_blank&#39;&gt;language&lt;/a&gt; of the template. If no language filter is set, the default language of the system is used. (optional)
     * @param  \ck\Model\RestCategoriesIdTemplatesGetRequest|null $_rest_categories_id_templates (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesIdTemplatesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\CategoryTemplate, HTTP status code, HTTP response headers (array of strings)
     */
    public function restCategoriesIdTemplatesGetWithHttpInfo(
        int $plenty_id,
        int $id,
        ?string $lang = null,
        ?\ck\Model\RestCategoriesIdTemplatesGetRequest $_rest_categories_id_templates = null,
        string $contentType = self::contentTypes['restCategoriesIdTemplatesGet'][0]
    ): array
    {
        $request = $this->restCategoriesIdTemplatesGetRequest($plenty_id, $id, $lang, $_rest_categories_id_templates, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\CategoryTemplate' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\CategoryTemplate' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\CategoryTemplate', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\CategoryTemplate';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\CategoryTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restCategoriesIdTemplatesGetAsync
     *
     * Get a category template
     *
     * @param  int $plenty_id The unique plenty ID of the client (store) (required)
     * @param  int $id (required)
     * @param  string|null $lang The &lt;a href&#x3D;&#39;https://developers.plentymarkets.com/rest-doc/introduction#countries&#39; target&#x3D;&#39;_blank&#39;&gt;language&lt;/a&gt; of the template. If no language filter is set, the default language of the system is used. (optional)
     * @param  \ck\Model\RestCategoriesIdTemplatesGetRequest|null $_rest_categories_id_templates (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesIdTemplatesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restCategoriesIdTemplatesGetAsync(
        int $plenty_id,
        int $id,
        ?string $lang = null,
        ?\ck\Model\RestCategoriesIdTemplatesGetRequest $_rest_categories_id_templates = null,
        string $contentType = self::contentTypes['restCategoriesIdTemplatesGet'][0]
    ): PromiseInterface
    {
        return $this->restCategoriesIdTemplatesGetAsyncWithHttpInfo($plenty_id, $id, $lang, $_rest_categories_id_templates, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restCategoriesIdTemplatesGetAsyncWithHttpInfo
     *
     * Get a category template
     *
     * @param  int $plenty_id The unique plenty ID of the client (store) (required)
     * @param  int $id (required)
     * @param  string|null $lang The &lt;a href&#x3D;&#39;https://developers.plentymarkets.com/rest-doc/introduction#countries&#39; target&#x3D;&#39;_blank&#39;&gt;language&lt;/a&gt; of the template. If no language filter is set, the default language of the system is used. (optional)
     * @param  \ck\Model\RestCategoriesIdTemplatesGetRequest|null $_rest_categories_id_templates (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesIdTemplatesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restCategoriesIdTemplatesGetAsyncWithHttpInfo(
        $plenty_id,
        $id,
        $lang = null,
        $_rest_categories_id_templates = null,
        string $contentType = self::contentTypes['restCategoriesIdTemplatesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\CategoryTemplate';
        $request = $this->restCategoriesIdTemplatesGetRequest($plenty_id, $id, $lang, $_rest_categories_id_templates, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restCategoriesIdTemplatesGet'
     *
     * @param  int $plenty_id The unique plenty ID of the client (store) (required)
     * @param  int $id (required)
     * @param  string|null $lang The &lt;a href&#x3D;&#39;https://developers.plentymarkets.com/rest-doc/introduction#countries&#39; target&#x3D;&#39;_blank&#39;&gt;language&lt;/a&gt; of the template. If no language filter is set, the default language of the system is used. (optional)
     * @param  \ck\Model\RestCategoriesIdTemplatesGetRequest|null $_rest_categories_id_templates (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesIdTemplatesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restCategoriesIdTemplatesGetRequest(
        $plenty_id,
        $id,
        $lang = null,
        $_rest_categories_id_templates = null,
        string $contentType = self::contentTypes['restCategoriesIdTemplatesGet'][0]
    ): Request
    {

        // verify the required parameter 'plenty_id' is set
        if ($plenty_id === null || (is_array($plenty_id) && count($plenty_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $plenty_id when calling restCategoriesIdTemplatesGet'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restCategoriesIdTemplatesGet'
            );
        }




        $resourcePath = '/rest/categories/{id}/templates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $lang,
            'lang', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $plenty_id,
            'plentyId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_categories_id_templates)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_categories_id_templates));
            } else {
                $httpBody = $_rest_categories_id_templates;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restCategoriesIdTemplatesPut
     *
     * Update a category template
     *
     * @param  int $id id (required)
     * @param  \ck\Model\RestCategoriesIdTemplatesPutRequest|null $_rest_categories_id_templates _rest_categories_id_templates (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesIdTemplatesPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\CategoryTemplate
     */
    public function restCategoriesIdTemplatesPut(
        int $id,
        ?\ck\Model\RestCategoriesIdTemplatesPutRequest $_rest_categories_id_templates = null,
        string $contentType = self::contentTypes['restCategoriesIdTemplatesPut'][0]
    ): \ck\Model\CategoryTemplate
    {
        list($response) = $this->restCategoriesIdTemplatesPutWithHttpInfo($id, $_rest_categories_id_templates, $contentType);
        return $response;
    }

    /**
     * Operation restCategoriesIdTemplatesPutWithHttpInfo
     *
     * Update a category template
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestCategoriesIdTemplatesPutRequest|null $_rest_categories_id_templates (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesIdTemplatesPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\CategoryTemplate, HTTP status code, HTTP response headers (array of strings)
     */
    public function restCategoriesIdTemplatesPutWithHttpInfo(
        int $id,
        ?\ck\Model\RestCategoriesIdTemplatesPutRequest $_rest_categories_id_templates = null,
        string $contentType = self::contentTypes['restCategoriesIdTemplatesPut'][0]
    ): array
    {
        $request = $this->restCategoriesIdTemplatesPutRequest($id, $_rest_categories_id_templates, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\CategoryTemplate' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\CategoryTemplate' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\CategoryTemplate', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\CategoryTemplate';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\CategoryTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restCategoriesIdTemplatesPutAsync
     *
     * Update a category template
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestCategoriesIdTemplatesPutRequest|null $_rest_categories_id_templates (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesIdTemplatesPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restCategoriesIdTemplatesPutAsync(
        int $id,
        ?\ck\Model\RestCategoriesIdTemplatesPutRequest $_rest_categories_id_templates = null,
        string $contentType = self::contentTypes['restCategoriesIdTemplatesPut'][0]
    ): PromiseInterface
    {
        return $this->restCategoriesIdTemplatesPutAsyncWithHttpInfo($id, $_rest_categories_id_templates, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restCategoriesIdTemplatesPutAsyncWithHttpInfo
     *
     * Update a category template
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestCategoriesIdTemplatesPutRequest|null $_rest_categories_id_templates (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesIdTemplatesPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restCategoriesIdTemplatesPutAsyncWithHttpInfo(
        $id,
        $_rest_categories_id_templates = null,
        string $contentType = self::contentTypes['restCategoriesIdTemplatesPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\CategoryTemplate';
        $request = $this->restCategoriesIdTemplatesPutRequest($id, $_rest_categories_id_templates, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restCategoriesIdTemplatesPut'
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestCategoriesIdTemplatesPutRequest|null $_rest_categories_id_templates (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesIdTemplatesPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restCategoriesIdTemplatesPutRequest(
        $id,
        $_rest_categories_id_templates = null,
        string $contentType = self::contentTypes['restCategoriesIdTemplatesPut'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restCategoriesIdTemplatesPut'
            );
        }



        $resourcePath = '/rest/categories/{id}/templates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_categories_id_templates)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_categories_id_templates));
            } else {
                $httpBody = $_rest_categories_id_templates;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restCategoriesPost
     *
     * Creates new categories
     *
     * @param  \ck\Model\RestCategoriesPostRequest|null $_rest_categories _rest_categories (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Category[]
     */
    public function restCategoriesPost(
        ?\ck\Model\RestCategoriesPostRequest $_rest_categories = null,
        string $contentType = self::contentTypes['restCategoriesPost'][0]
    ): array
    {
        list($response) = $this->restCategoriesPostWithHttpInfo($_rest_categories, $contentType);
        return $response;
    }

    /**
     * Operation restCategoriesPostWithHttpInfo
     *
     * Creates new categories
     *
     * @param  \ck\Model\RestCategoriesPostRequest|null $_rest_categories (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Category[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restCategoriesPostWithHttpInfo(
        ?\ck\Model\RestCategoriesPostRequest $_rest_categories = null,
        string $contentType = self::contentTypes['restCategoriesPost'][0]
    ): array
    {
        $request = $this->restCategoriesPostRequest($_rest_categories, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Category[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Category[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Category[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Category[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Category[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restCategoriesPostAsync
     *
     * Creates new categories
     *
     * @param  \ck\Model\RestCategoriesPostRequest|null $_rest_categories (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restCategoriesPostAsync(
        ?\ck\Model\RestCategoriesPostRequest $_rest_categories = null,
        string $contentType = self::contentTypes['restCategoriesPost'][0]
    ): PromiseInterface
    {
        return $this->restCategoriesPostAsyncWithHttpInfo($_rest_categories, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restCategoriesPostAsyncWithHttpInfo
     *
     * Creates new categories
     *
     * @param  \ck\Model\RestCategoriesPostRequest|null $_rest_categories (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restCategoriesPostAsyncWithHttpInfo(
        $_rest_categories = null,
        string $contentType = self::contentTypes['restCategoriesPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Category[]';
        $request = $this->restCategoriesPostRequest($_rest_categories, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restCategoriesPost'
     *
     * @param  \ck\Model\RestCategoriesPostRequest|null $_rest_categories (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restCategoriesPostRequest(
        $_rest_categories = null,
        string $contentType = self::contentTypes['restCategoriesPost'][0]
    ): Request
    {



        $resourcePath = '/rest/categories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_categories)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_categories));
            } else {
                $httpBody = $_rest_categories;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restCategoriesPut
     *
     * Updates categories
     *
     * @param  \ck\Model\RestCategoriesPutRequest|null $_rest_categories _rest_categories (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Category[]
     */
    public function restCategoriesPut(
        ?\ck\Model\RestCategoriesPutRequest $_rest_categories = null,
        string $contentType = self::contentTypes['restCategoriesPut'][0]
    ): array
    {
        list($response) = $this->restCategoriesPutWithHttpInfo($_rest_categories, $contentType);
        return $response;
    }

    /**
     * Operation restCategoriesPutWithHttpInfo
     *
     * Updates categories
     *
     * @param  \ck\Model\RestCategoriesPutRequest|null $_rest_categories (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Category[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restCategoriesPutWithHttpInfo(
        ?\ck\Model\RestCategoriesPutRequest $_rest_categories = null,
        string $contentType = self::contentTypes['restCategoriesPut'][0]
    ): array
    {
        $request = $this->restCategoriesPutRequest($_rest_categories, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Category[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Category[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Category[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Category[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Category[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restCategoriesPutAsync
     *
     * Updates categories
     *
     * @param  \ck\Model\RestCategoriesPutRequest|null $_rest_categories (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restCategoriesPutAsync(
        ?\ck\Model\RestCategoriesPutRequest $_rest_categories = null,
        string $contentType = self::contentTypes['restCategoriesPut'][0]
    ): PromiseInterface
    {
        return $this->restCategoriesPutAsyncWithHttpInfo($_rest_categories, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restCategoriesPutAsyncWithHttpInfo
     *
     * Updates categories
     *
     * @param  \ck\Model\RestCategoriesPutRequest|null $_rest_categories (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restCategoriesPutAsyncWithHttpInfo(
        $_rest_categories = null,
        string $contentType = self::contentTypes['restCategoriesPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Category[]';
        $request = $this->restCategoriesPutRequest($_rest_categories, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restCategoriesPut'
     *
     * @param  \ck\Model\RestCategoriesPutRequest|null $_rest_categories (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoriesPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restCategoriesPutRequest(
        $_rest_categories = null,
        string $contentType = self::contentTypes['restCategoriesPut'][0]
    ): Request
    {



        $resourcePath = '/rest/categories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_categories)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_categories));
            } else {
                $httpBody = $_rest_categories;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restCategoryBranchesGet
     *
     * Get category trees
     *
     * @param  int|null $page The requested page of results (optional)
     * @param  int|null $items_per_page The number of results per page (optional)
     * @param  string|null $type The category type. Available values: item, container, content, blog (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoryBranchesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restCategoryBranchesGet(
        ?int $page = null,
        ?int $items_per_page = null,
        ?string $type = null,
        string $contentType = self::contentTypes['restCategoryBranchesGet'][0]
    ): object
    {
        list($response) = $this->restCategoryBranchesGetWithHttpInfo($page, $items_per_page, $type, $contentType);
        return $response;
    }

    /**
     * Operation restCategoryBranchesGetWithHttpInfo
     *
     * Get category trees
     *
     * @param  int|null $page The requested page of results (optional)
     * @param  int|null $items_per_page The number of results per page (optional)
     * @param  string|null $type The category type. Available values: item, container, content, blog (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoryBranchesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restCategoryBranchesGetWithHttpInfo(
        ?int $page = null,
        ?int $items_per_page = null,
        ?string $type = null,
        string $contentType = self::contentTypes['restCategoryBranchesGet'][0]
    ): array
    {
        $request = $this->restCategoryBranchesGetRequest($page, $items_per_page, $type, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restCategoryBranchesGetAsync
     *
     * Get category trees
     *
     * @param  int|null $page The requested page of results (optional)
     * @param  int|null $items_per_page The number of results per page (optional)
     * @param  string|null $type The category type. Available values: item, container, content, blog (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoryBranchesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restCategoryBranchesGetAsync(
        ?int $page = null,
        ?int $items_per_page = null,
        ?string $type = null,
        string $contentType = self::contentTypes['restCategoryBranchesGet'][0]
    ): PromiseInterface
    {
        return $this->restCategoryBranchesGetAsyncWithHttpInfo($page, $items_per_page, $type, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restCategoryBranchesGetAsyncWithHttpInfo
     *
     * Get category trees
     *
     * @param  int|null $page The requested page of results (optional)
     * @param  int|null $items_per_page The number of results per page (optional)
     * @param  string|null $type The category type. Available values: item, container, content, blog (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoryBranchesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restCategoryBranchesGetAsyncWithHttpInfo(
        $page = null,
        $items_per_page = null,
        $type = null,
        string $contentType = self::contentTypes['restCategoryBranchesGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restCategoryBranchesGetRequest($page, $items_per_page, $type, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restCategoryBranchesGet'
     *
     * @param  int|null $page The requested page of results (optional)
     * @param  int|null $items_per_page The number of results per page (optional)
     * @param  string|null $type The category type. Available values: item, container, content, blog (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoryBranchesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restCategoryBranchesGetRequest(
        $page = null,
        $items_per_page = null,
        $type = null,
        string $contentType = self::contentTypes['restCategoryBranchesGet'][0]
    ): Request
    {





        $resourcePath = '/rest/category_branches';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $items_per_page,
            'itemsPerPage', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restCategoryBranchesIdGet
     *
     * Get category tree
     *
     * @param  int $id The unique category ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoryBranchesIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\CategoryBranch
     */
    public function restCategoryBranchesIdGet(
        int $id,
        string $contentType = self::contentTypes['restCategoryBranchesIdGet'][0]
    ): \ck\Model\CategoryBranch
    {
        list($response) = $this->restCategoryBranchesIdGetWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation restCategoryBranchesIdGetWithHttpInfo
     *
     * Get category tree
     *
     * @param  int $id The unique category ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoryBranchesIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\CategoryBranch, HTTP status code, HTTP response headers (array of strings)
     */
    public function restCategoryBranchesIdGetWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restCategoryBranchesIdGet'][0]
    ): array
    {
        $request = $this->restCategoryBranchesIdGetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\CategoryBranch' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\CategoryBranch' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\CategoryBranch', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\CategoryBranch';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\CategoryBranch',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restCategoryBranchesIdGetAsync
     *
     * Get category tree
     *
     * @param  int $id The unique category ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoryBranchesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restCategoryBranchesIdGetAsync(
        int $id,
        string $contentType = self::contentTypes['restCategoryBranchesIdGet'][0]
    ): PromiseInterface
    {
        return $this->restCategoryBranchesIdGetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restCategoryBranchesIdGetAsyncWithHttpInfo
     *
     * Get category tree
     *
     * @param  int $id The unique category ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoryBranchesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restCategoryBranchesIdGetAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restCategoryBranchesIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\CategoryBranch';
        $request = $this->restCategoryBranchesIdGetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restCategoryBranchesIdGet'
     *
     * @param  int $id The unique category ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restCategoryBranchesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restCategoryBranchesIdGetRequest(
        $id,
        string $contentType = self::contentTypes['restCategoryBranchesIdGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restCategoryBranchesIdGet'
            );
        }


        $resourcePath = '/rest/category_branches/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption(): array
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
