<?php
/**
 * PropertyApi
 * PHP version 8.1
 *
 * @package  ck/plenty-client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * plentymarkets REST-API
 *
 * The plentymarkets REST API expands the functionality of the plentymarkets CMS and allows access to resources, i.e. data records, via unique URI paths
 *
 * The version of the OpenAPI document: 1.0.0
 * @generated Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 7.1.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace ck/plenty-client\Api;

use InvalidArgumentException;
use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use GuzzleHttp\Promise\PromiseInterface;
use ck/plenty-client\ApiException;
use ck/plenty-client\Configuration;
use ck/plenty-client\HeaderSelector;
use ck/plenty-client\ObjectSerializer;

/**
 * PropertyApi Class Doc Comment
 *
 * @package  ck/plenty-client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class PropertyApi
{
    /**
     * @var ClientInterface
     */
    protected ClientInterface $client;

    /**
     * @var Configuration
     */
    protected Configuration $config;

    /**
     * @var HeaderSelector
     */
    protected HeaderSelector $headerSelector;

    /**
     * @var int Host index
     */
    protected int $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'restPropertiesAmazonsGet' => [
            'application/json',
        ],
        'restPropertiesAmazonsPost' => [
            'application/json',
        ],
        'restPropertiesAmazonsPropertyAmazonIdDelete' => [
            'application/json',
        ],
        'restPropertiesAmazonsPropertyAmazonIdGet' => [
            'application/json',
        ],
        'restPropertiesAmazonsPut' => [
            'application/json',
        ],
        'restPropertiesAvailabilitiesAvailabilityIdDelete' => [
            'application/json',
        ],
        'restPropertiesAvailabilitiesAvailabilityIdGet' => [
            'application/json',
        ],
        'restPropertiesAvailabilitiesAvailabilityIdPut' => [
            'application/json',
        ],
        'restPropertiesAvailabilitiesGet' => [
            'application/json',
        ],
        'restPropertiesAvailabilitiesPost' => [
            'application/json',
        ],
        'restPropertiesDestinationsGet' => [
            'application/json',
        ],
        'restPropertiesGet' => [
            'application/json',
        ],
        'restPropertiesGroupsGet' => [
            'application/json',
        ],
        'restPropertiesGroupsGroupIdGet' => [
            'application/json',
        ],
        'restPropertiesGroupsGroupIdPropertiesPost' => [
            'application/json',
        ],
        'restPropertiesGroupsGroupIdPropertiesPropertyIdDelete' => [
            'application/json',
        ],
        'restPropertiesGroupsGroupIdPropertiesPropertyIdPost' => [
            'application/json',
        ],
        'restPropertiesGroupsGroupIdPut' => [
            'application/json',
        ],
        'restPropertiesGroupsNamesGet' => [
            'application/json',
        ],
        'restPropertiesGroupsNamesGroupNameIdDelete' => [
            'application/json',
        ],
        'restPropertiesGroupsNamesGroupNameIdGet' => [
            'application/json',
        ],
        'restPropertiesGroupsNamesGroupNameIdPut' => [
            'application/json',
        ],
        'restPropertiesGroupsNamesPost' => [
            'application/json',
        ],
        'restPropertiesGroupsOptionsGet' => [
            'application/json',
        ],
        'restPropertiesGroupsOptionsGroupOptionIdDelete' => [
            'application/json',
        ],
        'restPropertiesGroupsOptionsGroupOptionIdGet' => [
            'application/json',
        ],
        'restPropertiesGroupsOptionsGroupOptionIdPut' => [
            'application/json',
        ],
        'restPropertiesGroupsOptionsPost' => [
            'application/json',
        ],
        'restPropertiesGroupsPost' => [
            'application/json',
        ],
        'restPropertiesGroupsPropertyIdDelete' => [
            'application/json',
        ],
        'restPropertiesGroupsSurchargeTypesGet' => [
            'application/json',
        ],
        'restPropertiesGroupsTypesGet' => [
            'application/json',
        ],
        'restPropertiesMarketsGet' => [
            'application/json',
        ],
        'restPropertiesMarketsPost' => [
            'application/json',
        ],
        'restPropertiesMarketsPropertiesMarketIdDelete' => [
            'application/json',
        ],
        'restPropertiesMarketsPropertiesMarketIdGet' => [
            'application/json',
        ],
        'restPropertiesMarketsPropertiesMarketIdPut' => [
            'application/json',
        ],
        'restPropertiesMultipleOptionsDelete' => [
            'application/json',
        ],
        'restPropertiesMultipleOptionsPost' => [
            'application/json',
        ],
        'restPropertiesNamesGet' => [
            'application/json',
        ],
        'restPropertiesNamesNameIdDelete' => [
            'application/json',
        ],
        'restPropertiesNamesNameIdGet' => [
            'application/json',
        ],
        'restPropertiesNamesNameIdPut' => [
            'application/json',
        ],
        'restPropertiesNamesPost' => [
            'application/json',
        ],
        'restPropertiesOptionsGet' => [
            'application/json',
        ],
        'restPropertiesOptionsPost' => [
            'application/json',
        ],
        'restPropertiesOptionsPropertyOptionIdDelete' => [
            'application/json',
        ],
        'restPropertiesOptionsPropertyOptionIdGet' => [
            'application/json',
        ],
        'restPropertiesOptionsPropertyOptionIdPut' => [
            'application/json',
        ],
        'restPropertiesPost' => [
            'application/json',
        ],
        'restPropertiesPropertyIdDelete' => [
            'application/json',
        ],
        'restPropertiesPropertyIdGet' => [
            'application/json',
        ],
        'restPropertiesPropertyIdPut' => [
            'application/json',
        ],
        'restPropertiesRelationsDelete' => [
            'application/json',
        ],
        'restPropertiesRelationsGet' => [
            'application/json',
        ],
        'restPropertiesRelationsMarkupsGet' => [
            'application/json',
        ],
        'restPropertiesRelationsMarkupsPost' => [
            'application/json',
        ],
        'restPropertiesRelationsMarkupsRelationMarkupIdDelete' => [
            'application/json',
        ],
        'restPropertiesRelationsMarkupsRelationMarkupIdGet' => [
            'application/json',
        ],
        'restPropertiesRelationsMarkupsRelationMarkupIdPut' => [
            'application/json',
        ],
        'restPropertiesRelationsPost' => [
            'application/json',
        ],
        'restPropertiesRelationsPut' => [
            'application/json',
        ],
        'restPropertiesRelationsRelationIdDelete' => [
            'application/json',
        ],
        'restPropertiesRelationsRelationIdFilePost' => [
            'application/json',
        ],
        'restPropertiesRelationsRelationIdGet' => [
            'application/json',
        ],
        'restPropertiesRelationsRelationIdPut' => [
            'application/json',
        ],
        'restPropertiesRelationsRelationIdValuesDelete' => [
            'application/json',
        ],
        'restPropertiesRelationsValuesGet' => [
            'application/json',
        ],
        'restPropertiesRelationsValuesPost' => [
            'application/json',
        ],
        'restPropertiesRelationsValuesPropertiesRelationValueIdDelete' => [
            'application/json',
        ],
        'restPropertiesRelationsValuesPropertiesRelationValueIdPut' => [
            'application/json',
        ],
        'restPropertiesRelationsValuesPut' => [
            'application/json',
        ],
        'restPropertiesRelationsValuesRelationMarkupIdGet' => [
            'application/json',
        ],
        'restPropertiesSelectionsGet' => [
            'application/json',
        ],
        'restPropertiesSelectionsPost' => [
            'application/json',
        ],
        'restPropertiesSelectionsPropertySelectionIdDelete' => [
            'application/json',
        ],
        'restPropertiesSelectionsPropertySelectionIdGet' => [
            'application/json',
        ],
        'restPropertiesSelectionsPropertySelectionIdPut' => [
            'application/json',
        ],
        'restPropertiesSystemlangGet' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface|null $client
     * @param Configuration|null   $config
     * @param HeaderSelector|null  $selector
     * @param int                  $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex(int $hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex(): int
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig(): Configuration
    {
        return $this->config;
    }

    /**
     * Operation restPropertiesAmazonsGet
     *
     * List property amazons
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesAmazonsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\PropertyAmazon[]
     */
    public function restPropertiesAmazonsGet(
        string $contentType = self::contentTypes['restPropertiesAmazonsGet'][0]
    ): array
    {
        list($response) = $this->restPropertiesAmazonsGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restPropertiesAmazonsGetWithHttpInfo
     *
     * List property amazons
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesAmazonsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\PropertyAmazon[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesAmazonsGetWithHttpInfo(
        string $contentType = self::contentTypes['restPropertiesAmazonsGet'][0]
    ): array
    {
        $request = $this->restPropertiesAmazonsGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\PropertyAmazon[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\PropertyAmazon[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\PropertyAmazon[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\PropertyAmazon[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\PropertyAmazon[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesAmazonsGetAsync
     *
     * List property amazons
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesAmazonsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesAmazonsGetAsync(
        string $contentType = self::contentTypes['restPropertiesAmazonsGet'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesAmazonsGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesAmazonsGetAsyncWithHttpInfo
     *
     * List property amazons
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesAmazonsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesAmazonsGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restPropertiesAmazonsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\PropertyAmazon[]';
        $request = $this->restPropertiesAmazonsGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesAmazonsGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesAmazonsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesAmazonsGetRequest(
        string $contentType = self::contentTypes['restPropertiesAmazonsGet'][0]
    ): Request
    {


        $resourcePath = '/rest/properties/amazons';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesAmazonsPost
     *
     * Create one or multiple property amazon
     *
     * @param  int $property_id The ID of the property (required)
     * @param  string $platform The platform of the property amazon (required)
     * @param  string $category The category of the property amazon (required)
     * @param  string $field The field of the property amazon (required)
     * @param  \ck/plenty-client\Model\RestPropertiesAmazonsPostRequest|null $_rest_properties_amazons _rest_properties_amazons (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesAmazonsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\PropertyAmazon
     */
    public function restPropertiesAmazonsPost(
        int $property_id,
        string $platform,
        string $category,
        string $field,
        ?\ck/plenty-client\Model\RestPropertiesAmazonsPostRequest $_rest_properties_amazons = null,
        string $contentType = self::contentTypes['restPropertiesAmazonsPost'][0]
    ): \ck/plenty-client\Model\PropertyAmazon
    {
        list($response) = $this->restPropertiesAmazonsPostWithHttpInfo($property_id, $platform, $category, $field, $_rest_properties_amazons, $contentType);
        return $response;
    }

    /**
     * Operation restPropertiesAmazonsPostWithHttpInfo
     *
     * Create one or multiple property amazon
     *
     * @param  int $property_id The ID of the property (required)
     * @param  string $platform The platform of the property amazon (required)
     * @param  string $category The category of the property amazon (required)
     * @param  string $field The field of the property amazon (required)
     * @param  \ck/plenty-client\Model\RestPropertiesAmazonsPostRequest|null $_rest_properties_amazons (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesAmazonsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\PropertyAmazon, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesAmazonsPostWithHttpInfo(
        int $property_id,
        string $platform,
        string $category,
        string $field,
        ?\ck/plenty-client\Model\RestPropertiesAmazonsPostRequest $_rest_properties_amazons = null,
        string $contentType = self::contentTypes['restPropertiesAmazonsPost'][0]
    ): array
    {
        $request = $this->restPropertiesAmazonsPostRequest($property_id, $platform, $category, $field, $_rest_properties_amazons, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\PropertyAmazon' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\PropertyAmazon' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\PropertyAmazon', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\PropertyAmazon';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\PropertyAmazon',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesAmazonsPostAsync
     *
     * Create one or multiple property amazon
     *
     * @param  int $property_id The ID of the property (required)
     * @param  string $platform The platform of the property amazon (required)
     * @param  string $category The category of the property amazon (required)
     * @param  string $field The field of the property amazon (required)
     * @param  \ck/plenty-client\Model\RestPropertiesAmazonsPostRequest|null $_rest_properties_amazons (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesAmazonsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesAmazonsPostAsync(
        int $property_id,
        string $platform,
        string $category,
        string $field,
        ?\ck/plenty-client\Model\RestPropertiesAmazonsPostRequest $_rest_properties_amazons = null,
        string $contentType = self::contentTypes['restPropertiesAmazonsPost'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesAmazonsPostAsyncWithHttpInfo($property_id, $platform, $category, $field, $_rest_properties_amazons, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesAmazonsPostAsyncWithHttpInfo
     *
     * Create one or multiple property amazon
     *
     * @param  int $property_id The ID of the property (required)
     * @param  string $platform The platform of the property amazon (required)
     * @param  string $category The category of the property amazon (required)
     * @param  string $field The field of the property amazon (required)
     * @param  \ck/plenty-client\Model\RestPropertiesAmazonsPostRequest|null $_rest_properties_amazons (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesAmazonsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesAmazonsPostAsyncWithHttpInfo(
        $property_id,
        $platform,
        $category,
        $field,
        $_rest_properties_amazons = null,
        string $contentType = self::contentTypes['restPropertiesAmazonsPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\PropertyAmazon';
        $request = $this->restPropertiesAmazonsPostRequest($property_id, $platform, $category, $field, $_rest_properties_amazons, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesAmazonsPost'
     *
     * @param  int $property_id The ID of the property (required)
     * @param  string $platform The platform of the property amazon (required)
     * @param  string $category The category of the property amazon (required)
     * @param  string $field The field of the property amazon (required)
     * @param  \ck/plenty-client\Model\RestPropertiesAmazonsPostRequest|null $_rest_properties_amazons (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesAmazonsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesAmazonsPostRequest(
        $property_id,
        $platform,
        $category,
        $field,
        $_rest_properties_amazons = null,
        string $contentType = self::contentTypes['restPropertiesAmazonsPost'][0]
    ): Request
    {

        // verify the required parameter 'property_id' is set
        if ($property_id === null || (is_array($property_id) && count($property_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $property_id when calling restPropertiesAmazonsPost'
            );
        }

        // verify the required parameter 'platform' is set
        if ($platform === null || (is_array($platform) && count($platform) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $platform when calling restPropertiesAmazonsPost'
            );
        }

        // verify the required parameter 'category' is set
        if ($category === null || (is_array($category) && count($category) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $category when calling restPropertiesAmazonsPost'
            );
        }

        // verify the required parameter 'field' is set
        if ($field === null || (is_array($field) && count($field) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $field when calling restPropertiesAmazonsPost'
            );
        }



        $resourcePath = '/rest/properties/amazons';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $property_id,
            'propertyId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $platform,
            'platform', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $category,
            'category', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $field,
            'field', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_properties_amazons)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_properties_amazons));
            } else {
                $httpBody = $_rest_properties_amazons;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesAmazonsPropertyAmazonIdDelete
     *
     * Delete a property amazon
     *
     * @param  int $property_amazon_id The ID of the property amazon (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesAmazonsPropertyAmazonIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restPropertiesAmazonsPropertyAmazonIdDelete(
        int $property_amazon_id,
        string $contentType = self::contentTypes['restPropertiesAmazonsPropertyAmazonIdDelete'][0]
    ): void
    {
        $this->restPropertiesAmazonsPropertyAmazonIdDeleteWithHttpInfo($property_amazon_id, $contentType);
    }

    /**
     * Operation restPropertiesAmazonsPropertyAmazonIdDeleteWithHttpInfo
     *
     * Delete a property amazon
     *
     * @param  int $property_amazon_id The ID of the property amazon (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesAmazonsPropertyAmazonIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesAmazonsPropertyAmazonIdDeleteWithHttpInfo(
        int $property_amazon_id,
        string $contentType = self::contentTypes['restPropertiesAmazonsPropertyAmazonIdDelete'][0]
    ): array
    {
        $request = $this->restPropertiesAmazonsPropertyAmazonIdDeleteRequest($property_amazon_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesAmazonsPropertyAmazonIdDeleteAsync
     *
     * Delete a property amazon
     *
     * @param  int $property_amazon_id The ID of the property amazon (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesAmazonsPropertyAmazonIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesAmazonsPropertyAmazonIdDeleteAsync(
        int $property_amazon_id,
        string $contentType = self::contentTypes['restPropertiesAmazonsPropertyAmazonIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesAmazonsPropertyAmazonIdDeleteAsyncWithHttpInfo($property_amazon_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesAmazonsPropertyAmazonIdDeleteAsyncWithHttpInfo
     *
     * Delete a property amazon
     *
     * @param  int $property_amazon_id The ID of the property amazon (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesAmazonsPropertyAmazonIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesAmazonsPropertyAmazonIdDeleteAsyncWithHttpInfo(
        $property_amazon_id,
        string $contentType = self::contentTypes['restPropertiesAmazonsPropertyAmazonIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restPropertiesAmazonsPropertyAmazonIdDeleteRequest($property_amazon_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesAmazonsPropertyAmazonIdDelete'
     *
     * @param  int $property_amazon_id The ID of the property amazon (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesAmazonsPropertyAmazonIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesAmazonsPropertyAmazonIdDeleteRequest(
        $property_amazon_id,
        string $contentType = self::contentTypes['restPropertiesAmazonsPropertyAmazonIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'property_amazon_id' is set
        if ($property_amazon_id === null || (is_array($property_amazon_id) && count($property_amazon_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $property_amazon_id when calling restPropertiesAmazonsPropertyAmazonIdDelete'
            );
        }


        $resourcePath = '/rest/properties/amazons/{propertyAmazonId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($property_amazon_id !== null) {
            $resourcePath = str_replace(
                '{' . 'propertyAmazonId' . '}',
                ObjectSerializer::toPathValue($property_amazon_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesAmazonsPropertyAmazonIdGet
     *
     * Get a property amazon
     *
     * @param  int $property_amazon_id The ID of the property amazon (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesAmazonsPropertyAmazonIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\PropertyAmazon
     */
    public function restPropertiesAmazonsPropertyAmazonIdGet(
        int $property_amazon_id,
        string $contentType = self::contentTypes['restPropertiesAmazonsPropertyAmazonIdGet'][0]
    ): \ck/plenty-client\Model\PropertyAmazon
    {
        list($response) = $this->restPropertiesAmazonsPropertyAmazonIdGetWithHttpInfo($property_amazon_id, $contentType);
        return $response;
    }

    /**
     * Operation restPropertiesAmazonsPropertyAmazonIdGetWithHttpInfo
     *
     * Get a property amazon
     *
     * @param  int $property_amazon_id The ID of the property amazon (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesAmazonsPropertyAmazonIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\PropertyAmazon, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesAmazonsPropertyAmazonIdGetWithHttpInfo(
        int $property_amazon_id,
        string $contentType = self::contentTypes['restPropertiesAmazonsPropertyAmazonIdGet'][0]
    ): array
    {
        $request = $this->restPropertiesAmazonsPropertyAmazonIdGetRequest($property_amazon_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\PropertyAmazon' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\PropertyAmazon' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\PropertyAmazon', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\PropertyAmazon';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\PropertyAmazon',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesAmazonsPropertyAmazonIdGetAsync
     *
     * Get a property amazon
     *
     * @param  int $property_amazon_id The ID of the property amazon (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesAmazonsPropertyAmazonIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesAmazonsPropertyAmazonIdGetAsync(
        int $property_amazon_id,
        string $contentType = self::contentTypes['restPropertiesAmazonsPropertyAmazonIdGet'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesAmazonsPropertyAmazonIdGetAsyncWithHttpInfo($property_amazon_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesAmazonsPropertyAmazonIdGetAsyncWithHttpInfo
     *
     * Get a property amazon
     *
     * @param  int $property_amazon_id The ID of the property amazon (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesAmazonsPropertyAmazonIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesAmazonsPropertyAmazonIdGetAsyncWithHttpInfo(
        $property_amazon_id,
        string $contentType = self::contentTypes['restPropertiesAmazonsPropertyAmazonIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\PropertyAmazon';
        $request = $this->restPropertiesAmazonsPropertyAmazonIdGetRequest($property_amazon_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesAmazonsPropertyAmazonIdGet'
     *
     * @param  int $property_amazon_id The ID of the property amazon (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesAmazonsPropertyAmazonIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesAmazonsPropertyAmazonIdGetRequest(
        $property_amazon_id,
        string $contentType = self::contentTypes['restPropertiesAmazonsPropertyAmazonIdGet'][0]
    ): Request
    {

        // verify the required parameter 'property_amazon_id' is set
        if ($property_amazon_id === null || (is_array($property_amazon_id) && count($property_amazon_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $property_amazon_id when calling restPropertiesAmazonsPropertyAmazonIdGet'
            );
        }


        $resourcePath = '/rest/properties/amazons/{propertyAmazonId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($property_amazon_id !== null) {
            $resourcePath = str_replace(
                '{' . 'propertyAmazonId' . '}',
                ObjectSerializer::toPathValue($property_amazon_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesAmazonsPut
     *
     * Update one or multiple property amazon
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesAmazonsPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\PropertyAmazon
     */
    public function restPropertiesAmazonsPut(
        string $contentType = self::contentTypes['restPropertiesAmazonsPut'][0]
    ): \ck/plenty-client\Model\PropertyAmazon
    {
        list($response) = $this->restPropertiesAmazonsPutWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restPropertiesAmazonsPutWithHttpInfo
     *
     * Update one or multiple property amazon
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesAmazonsPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\PropertyAmazon, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesAmazonsPutWithHttpInfo(
        string $contentType = self::contentTypes['restPropertiesAmazonsPut'][0]
    ): array
    {
        $request = $this->restPropertiesAmazonsPutRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\PropertyAmazon' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\PropertyAmazon' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\PropertyAmazon', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\PropertyAmazon';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\PropertyAmazon',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesAmazonsPutAsync
     *
     * Update one or multiple property amazon
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesAmazonsPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesAmazonsPutAsync(
        string $contentType = self::contentTypes['restPropertiesAmazonsPut'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesAmazonsPutAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesAmazonsPutAsyncWithHttpInfo
     *
     * Update one or multiple property amazon
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesAmazonsPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesAmazonsPutAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restPropertiesAmazonsPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\PropertyAmazon';
        $request = $this->restPropertiesAmazonsPutRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesAmazonsPut'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesAmazonsPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesAmazonsPutRequest(
        string $contentType = self::contentTypes['restPropertiesAmazonsPut'][0]
    ): Request
    {


        $resourcePath = '/rest/properties/amazons';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesAvailabilitiesAvailabilityIdDelete
     *
     * Delete an availability
     *
     * @param  int $availability_id The ID of the availability (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesAvailabilitiesAvailabilityIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restPropertiesAvailabilitiesAvailabilityIdDelete(
        int $availability_id,
        string $contentType = self::contentTypes['restPropertiesAvailabilitiesAvailabilityIdDelete'][0]
    ): void
    {
        $this->restPropertiesAvailabilitiesAvailabilityIdDeleteWithHttpInfo($availability_id, $contentType);
    }

    /**
     * Operation restPropertiesAvailabilitiesAvailabilityIdDeleteWithHttpInfo
     *
     * Delete an availability
     *
     * @param  int $availability_id The ID of the availability (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesAvailabilitiesAvailabilityIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesAvailabilitiesAvailabilityIdDeleteWithHttpInfo(
        int $availability_id,
        string $contentType = self::contentTypes['restPropertiesAvailabilitiesAvailabilityIdDelete'][0]
    ): array
    {
        $request = $this->restPropertiesAvailabilitiesAvailabilityIdDeleteRequest($availability_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesAvailabilitiesAvailabilityIdDeleteAsync
     *
     * Delete an availability
     *
     * @param  int $availability_id The ID of the availability (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesAvailabilitiesAvailabilityIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesAvailabilitiesAvailabilityIdDeleteAsync(
        int $availability_id,
        string $contentType = self::contentTypes['restPropertiesAvailabilitiesAvailabilityIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesAvailabilitiesAvailabilityIdDeleteAsyncWithHttpInfo($availability_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesAvailabilitiesAvailabilityIdDeleteAsyncWithHttpInfo
     *
     * Delete an availability
     *
     * @param  int $availability_id The ID of the availability (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesAvailabilitiesAvailabilityIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesAvailabilitiesAvailabilityIdDeleteAsyncWithHttpInfo(
        $availability_id,
        string $contentType = self::contentTypes['restPropertiesAvailabilitiesAvailabilityIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restPropertiesAvailabilitiesAvailabilityIdDeleteRequest($availability_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesAvailabilitiesAvailabilityIdDelete'
     *
     * @param  int $availability_id The ID of the availability (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesAvailabilitiesAvailabilityIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesAvailabilitiesAvailabilityIdDeleteRequest(
        $availability_id,
        string $contentType = self::contentTypes['restPropertiesAvailabilitiesAvailabilityIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'availability_id' is set
        if ($availability_id === null || (is_array($availability_id) && count($availability_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $availability_id when calling restPropertiesAvailabilitiesAvailabilityIdDelete'
            );
        }


        $resourcePath = '/rest/properties/availabilities/{availabilityId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($availability_id !== null) {
            $resourcePath = str_replace(
                '{' . 'availabilityId' . '}',
                ObjectSerializer::toPathValue($availability_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesAvailabilitiesAvailabilityIdGet
     *
     * Get an availability
     *
     * @param  int $availability_id The ID of the property availability (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesAvailabilitiesAvailabilityIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\PropertyAvailability
     */
    public function restPropertiesAvailabilitiesAvailabilityIdGet(
        int $availability_id,
        string $contentType = self::contentTypes['restPropertiesAvailabilitiesAvailabilityIdGet'][0]
    ): \ck/plenty-client\Model\PropertyAvailability
    {
        list($response) = $this->restPropertiesAvailabilitiesAvailabilityIdGetWithHttpInfo($availability_id, $contentType);
        return $response;
    }

    /**
     * Operation restPropertiesAvailabilitiesAvailabilityIdGetWithHttpInfo
     *
     * Get an availability
     *
     * @param  int $availability_id The ID of the property availability (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesAvailabilitiesAvailabilityIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\PropertyAvailability, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesAvailabilitiesAvailabilityIdGetWithHttpInfo(
        int $availability_id,
        string $contentType = self::contentTypes['restPropertiesAvailabilitiesAvailabilityIdGet'][0]
    ): array
    {
        $request = $this->restPropertiesAvailabilitiesAvailabilityIdGetRequest($availability_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\PropertyAvailability' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\PropertyAvailability' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\PropertyAvailability', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\PropertyAvailability';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\PropertyAvailability',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesAvailabilitiesAvailabilityIdGetAsync
     *
     * Get an availability
     *
     * @param  int $availability_id The ID of the property availability (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesAvailabilitiesAvailabilityIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesAvailabilitiesAvailabilityIdGetAsync(
        int $availability_id,
        string $contentType = self::contentTypes['restPropertiesAvailabilitiesAvailabilityIdGet'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesAvailabilitiesAvailabilityIdGetAsyncWithHttpInfo($availability_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesAvailabilitiesAvailabilityIdGetAsyncWithHttpInfo
     *
     * Get an availability
     *
     * @param  int $availability_id The ID of the property availability (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesAvailabilitiesAvailabilityIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesAvailabilitiesAvailabilityIdGetAsyncWithHttpInfo(
        $availability_id,
        string $contentType = self::contentTypes['restPropertiesAvailabilitiesAvailabilityIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\PropertyAvailability';
        $request = $this->restPropertiesAvailabilitiesAvailabilityIdGetRequest($availability_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesAvailabilitiesAvailabilityIdGet'
     *
     * @param  int $availability_id The ID of the property availability (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesAvailabilitiesAvailabilityIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesAvailabilitiesAvailabilityIdGetRequest(
        $availability_id,
        string $contentType = self::contentTypes['restPropertiesAvailabilitiesAvailabilityIdGet'][0]
    ): Request
    {

        // verify the required parameter 'availability_id' is set
        if ($availability_id === null || (is_array($availability_id) && count($availability_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $availability_id when calling restPropertiesAvailabilitiesAvailabilityIdGet'
            );
        }


        $resourcePath = '/rest/properties/availabilities/{availabilityId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($availability_id !== null) {
            $resourcePath = str_replace(
                '{' . 'availabilityId' . '}',
                ObjectSerializer::toPathValue($availability_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesAvailabilitiesAvailabilityIdPut
     *
     * Update an availability
     *
     * @param  int $availability_id The ID of the availability (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesAvailabilitiesAvailabilityIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\PropertyAvailability
     */
    public function restPropertiesAvailabilitiesAvailabilityIdPut(
        int $availability_id,
        string $contentType = self::contentTypes['restPropertiesAvailabilitiesAvailabilityIdPut'][0]
    ): \ck/plenty-client\Model\PropertyAvailability
    {
        list($response) = $this->restPropertiesAvailabilitiesAvailabilityIdPutWithHttpInfo($availability_id, $contentType);
        return $response;
    }

    /**
     * Operation restPropertiesAvailabilitiesAvailabilityIdPutWithHttpInfo
     *
     * Update an availability
     *
     * @param  int $availability_id The ID of the availability (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesAvailabilitiesAvailabilityIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\PropertyAvailability, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesAvailabilitiesAvailabilityIdPutWithHttpInfo(
        int $availability_id,
        string $contentType = self::contentTypes['restPropertiesAvailabilitiesAvailabilityIdPut'][0]
    ): array
    {
        $request = $this->restPropertiesAvailabilitiesAvailabilityIdPutRequest($availability_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\PropertyAvailability' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\PropertyAvailability' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\PropertyAvailability', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\PropertyAvailability';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\PropertyAvailability',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesAvailabilitiesAvailabilityIdPutAsync
     *
     * Update an availability
     *
     * @param  int $availability_id The ID of the availability (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesAvailabilitiesAvailabilityIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesAvailabilitiesAvailabilityIdPutAsync(
        int $availability_id,
        string $contentType = self::contentTypes['restPropertiesAvailabilitiesAvailabilityIdPut'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesAvailabilitiesAvailabilityIdPutAsyncWithHttpInfo($availability_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesAvailabilitiesAvailabilityIdPutAsyncWithHttpInfo
     *
     * Update an availability
     *
     * @param  int $availability_id The ID of the availability (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesAvailabilitiesAvailabilityIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesAvailabilitiesAvailabilityIdPutAsyncWithHttpInfo(
        $availability_id,
        string $contentType = self::contentTypes['restPropertiesAvailabilitiesAvailabilityIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\PropertyAvailability';
        $request = $this->restPropertiesAvailabilitiesAvailabilityIdPutRequest($availability_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesAvailabilitiesAvailabilityIdPut'
     *
     * @param  int $availability_id The ID of the availability (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesAvailabilitiesAvailabilityIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesAvailabilitiesAvailabilityIdPutRequest(
        $availability_id,
        string $contentType = self::contentTypes['restPropertiesAvailabilitiesAvailabilityIdPut'][0]
    ): Request
    {

        // verify the required parameter 'availability_id' is set
        if ($availability_id === null || (is_array($availability_id) && count($availability_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $availability_id when calling restPropertiesAvailabilitiesAvailabilityIdPut'
            );
        }


        $resourcePath = '/rest/properties/availabilities/{availabilityId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($availability_id !== null) {
            $resourcePath = str_replace(
                '{' . 'availabilityId' . '}',
                ObjectSerializer::toPathValue($availability_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesAvailabilitiesGet
     *
     * List availabilities
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesAvailabilitiesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\PropertyAvailability[]
     */
    public function restPropertiesAvailabilitiesGet(
        string $contentType = self::contentTypes['restPropertiesAvailabilitiesGet'][0]
    ): array
    {
        list($response) = $this->restPropertiesAvailabilitiesGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restPropertiesAvailabilitiesGetWithHttpInfo
     *
     * List availabilities
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesAvailabilitiesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\PropertyAvailability[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesAvailabilitiesGetWithHttpInfo(
        string $contentType = self::contentTypes['restPropertiesAvailabilitiesGet'][0]
    ): array
    {
        $request = $this->restPropertiesAvailabilitiesGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\PropertyAvailability[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\PropertyAvailability[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\PropertyAvailability[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\PropertyAvailability[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\PropertyAvailability[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesAvailabilitiesGetAsync
     *
     * List availabilities
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesAvailabilitiesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesAvailabilitiesGetAsync(
        string $contentType = self::contentTypes['restPropertiesAvailabilitiesGet'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesAvailabilitiesGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesAvailabilitiesGetAsyncWithHttpInfo
     *
     * List availabilities
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesAvailabilitiesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesAvailabilitiesGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restPropertiesAvailabilitiesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\PropertyAvailability[]';
        $request = $this->restPropertiesAvailabilitiesGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesAvailabilitiesGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesAvailabilitiesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesAvailabilitiesGetRequest(
        string $contentType = self::contentTypes['restPropertiesAvailabilitiesGet'][0]
    ): Request
    {


        $resourcePath = '/rest/properties/availabilities';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesAvailabilitiesPost
     *
     * Create an availability
     *
     * @param  int $property_id The ID of the property (required)
     * @param  int $type The type of the availability (required)
     * @param  int $value The value of the availability (required)
     * @param  \ck/plenty-client\Model\RestPropertiesAvailabilitiesPostRequest|null $_rest_properties_availabilities _rest_properties_availabilities (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesAvailabilitiesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\PropertyAvailability
     */
    public function restPropertiesAvailabilitiesPost(
        int $property_id,
        int $type,
        int $value,
        ?\ck/plenty-client\Model\RestPropertiesAvailabilitiesPostRequest $_rest_properties_availabilities = null,
        string $contentType = self::contentTypes['restPropertiesAvailabilitiesPost'][0]
    ): \ck/plenty-client\Model\PropertyAvailability
    {
        list($response) = $this->restPropertiesAvailabilitiesPostWithHttpInfo($property_id, $type, $value, $_rest_properties_availabilities, $contentType);
        return $response;
    }

    /**
     * Operation restPropertiesAvailabilitiesPostWithHttpInfo
     *
     * Create an availability
     *
     * @param  int $property_id The ID of the property (required)
     * @param  int $type The type of the availability (required)
     * @param  int $value The value of the availability (required)
     * @param  \ck/plenty-client\Model\RestPropertiesAvailabilitiesPostRequest|null $_rest_properties_availabilities (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesAvailabilitiesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\PropertyAvailability, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesAvailabilitiesPostWithHttpInfo(
        int $property_id,
        int $type,
        int $value,
        ?\ck/plenty-client\Model\RestPropertiesAvailabilitiesPostRequest $_rest_properties_availabilities = null,
        string $contentType = self::contentTypes['restPropertiesAvailabilitiesPost'][0]
    ): array
    {
        $request = $this->restPropertiesAvailabilitiesPostRequest($property_id, $type, $value, $_rest_properties_availabilities, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\PropertyAvailability' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\PropertyAvailability' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\PropertyAvailability', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\PropertyAvailability';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\PropertyAvailability',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesAvailabilitiesPostAsync
     *
     * Create an availability
     *
     * @param  int $property_id The ID of the property (required)
     * @param  int $type The type of the availability (required)
     * @param  int $value The value of the availability (required)
     * @param  \ck/plenty-client\Model\RestPropertiesAvailabilitiesPostRequest|null $_rest_properties_availabilities (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesAvailabilitiesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesAvailabilitiesPostAsync(
        int $property_id,
        int $type,
        int $value,
        ?\ck/plenty-client\Model\RestPropertiesAvailabilitiesPostRequest $_rest_properties_availabilities = null,
        string $contentType = self::contentTypes['restPropertiesAvailabilitiesPost'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesAvailabilitiesPostAsyncWithHttpInfo($property_id, $type, $value, $_rest_properties_availabilities, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesAvailabilitiesPostAsyncWithHttpInfo
     *
     * Create an availability
     *
     * @param  int $property_id The ID of the property (required)
     * @param  int $type The type of the availability (required)
     * @param  int $value The value of the availability (required)
     * @param  \ck/plenty-client\Model\RestPropertiesAvailabilitiesPostRequest|null $_rest_properties_availabilities (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesAvailabilitiesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesAvailabilitiesPostAsyncWithHttpInfo(
        $property_id,
        $type,
        $value,
        $_rest_properties_availabilities = null,
        string $contentType = self::contentTypes['restPropertiesAvailabilitiesPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\PropertyAvailability';
        $request = $this->restPropertiesAvailabilitiesPostRequest($property_id, $type, $value, $_rest_properties_availabilities, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesAvailabilitiesPost'
     *
     * @param  int $property_id The ID of the property (required)
     * @param  int $type The type of the availability (required)
     * @param  int $value The value of the availability (required)
     * @param  \ck/plenty-client\Model\RestPropertiesAvailabilitiesPostRequest|null $_rest_properties_availabilities (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesAvailabilitiesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesAvailabilitiesPostRequest(
        $property_id,
        $type,
        $value,
        $_rest_properties_availabilities = null,
        string $contentType = self::contentTypes['restPropertiesAvailabilitiesPost'][0]
    ): Request
    {

        // verify the required parameter 'property_id' is set
        if ($property_id === null || (is_array($property_id) && count($property_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $property_id when calling restPropertiesAvailabilitiesPost'
            );
        }

        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $type when calling restPropertiesAvailabilitiesPost'
            );
        }

        // verify the required parameter 'value' is set
        if ($value === null || (is_array($value) && count($value) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $value when calling restPropertiesAvailabilitiesPost'
            );
        }



        $resourcePath = '/rest/properties/availabilities';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $property_id,
            'propertyId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $value,
            'value', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_properties_availabilities)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_properties_availabilities));
            } else {
                $httpBody = $_rest_properties_availabilities;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesDestinationsGet
     *
     * Get property destinations
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesDestinationsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restPropertiesDestinationsGet(
        string $contentType = self::contentTypes['restPropertiesDestinationsGet'][0]
    ): object
    {
        list($response) = $this->restPropertiesDestinationsGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restPropertiesDestinationsGetWithHttpInfo
     *
     * Get property destinations
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesDestinationsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesDestinationsGetWithHttpInfo(
        string $contentType = self::contentTypes['restPropertiesDestinationsGet'][0]
    ): array
    {
        $request = $this->restPropertiesDestinationsGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesDestinationsGetAsync
     *
     * Get property destinations
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesDestinationsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesDestinationsGetAsync(
        string $contentType = self::contentTypes['restPropertiesDestinationsGet'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesDestinationsGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesDestinationsGetAsyncWithHttpInfo
     *
     * Get property destinations
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesDestinationsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesDestinationsGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restPropertiesDestinationsGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restPropertiesDestinationsGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesDestinationsGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesDestinationsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesDestinationsGetRequest(
        string $contentType = self::contentTypes['restPropertiesDestinationsGet'][0]
    ): Request
    {


        $resourcePath = '/rest/properties/destinations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesGet
     *
     * List properties
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\Property[]
     */
    public function restPropertiesGet(
        string $contentType = self::contentTypes['restPropertiesGet'][0]
    ): array
    {
        list($response) = $this->restPropertiesGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restPropertiesGetWithHttpInfo
     *
     * List properties
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\Property[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesGetWithHttpInfo(
        string $contentType = self::contentTypes['restPropertiesGet'][0]
    ): array
    {
        $request = $this->restPropertiesGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\Property[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\Property[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\Property[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\Property[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\Property[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesGetAsync
     *
     * List properties
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesGetAsync(
        string $contentType = self::contentTypes['restPropertiesGet'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesGetAsyncWithHttpInfo
     *
     * List properties
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restPropertiesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\Property[]';
        $request = $this->restPropertiesGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesGetRequest(
        string $contentType = self::contentTypes['restPropertiesGet'][0]
    ): Request
    {


        $resourcePath = '/rest/properties';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesGroupsGet
     *
     * List property groups
     *
     * @param  int $group_id The ID of the group (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\PropertyGroup[]
     */
    public function restPropertiesGroupsGet(
        int $group_id,
        string $contentType = self::contentTypes['restPropertiesGroupsGet'][0]
    ): array
    {
        list($response) = $this->restPropertiesGroupsGetWithHttpInfo($group_id, $contentType);
        return $response;
    }

    /**
     * Operation restPropertiesGroupsGetWithHttpInfo
     *
     * List property groups
     *
     * @param  int $group_id The ID of the group (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\PropertyGroup[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesGroupsGetWithHttpInfo(
        int $group_id,
        string $contentType = self::contentTypes['restPropertiesGroupsGet'][0]
    ): array
    {
        $request = $this->restPropertiesGroupsGetRequest($group_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\PropertyGroup[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\PropertyGroup[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\PropertyGroup[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\PropertyGroup[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\PropertyGroup[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesGroupsGetAsync
     *
     * List property groups
     *
     * @param  int $group_id The ID of the group (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesGroupsGetAsync(
        int $group_id,
        string $contentType = self::contentTypes['restPropertiesGroupsGet'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesGroupsGetAsyncWithHttpInfo($group_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesGroupsGetAsyncWithHttpInfo
     *
     * List property groups
     *
     * @param  int $group_id The ID of the group (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesGroupsGetAsyncWithHttpInfo(
        $group_id,
        string $contentType = self::contentTypes['restPropertiesGroupsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\PropertyGroup[]';
        $request = $this->restPropertiesGroupsGetRequest($group_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesGroupsGet'
     *
     * @param  int $group_id The ID of the group (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesGroupsGetRequest(
        $group_id,
        string $contentType = self::contentTypes['restPropertiesGroupsGet'][0]
    ): Request
    {

        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $group_id when calling restPropertiesGroupsGet'
            );
        }


        $resourcePath = '/rest/properties/groups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group_id,
            'groupId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesGroupsGroupIdGet
     *
     * Get a property group
     *
     * @param  int $group_id The ID of the group (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsGroupIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\PropertyGroup
     */
    public function restPropertiesGroupsGroupIdGet(
        int $group_id,
        string $contentType = self::contentTypes['restPropertiesGroupsGroupIdGet'][0]
    ): \ck/plenty-client\Model\PropertyGroup
    {
        list($response) = $this->restPropertiesGroupsGroupIdGetWithHttpInfo($group_id, $contentType);
        return $response;
    }

    /**
     * Operation restPropertiesGroupsGroupIdGetWithHttpInfo
     *
     * Get a property group
     *
     * @param  int $group_id The ID of the group (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsGroupIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\PropertyGroup, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesGroupsGroupIdGetWithHttpInfo(
        int $group_id,
        string $contentType = self::contentTypes['restPropertiesGroupsGroupIdGet'][0]
    ): array
    {
        $request = $this->restPropertiesGroupsGroupIdGetRequest($group_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\PropertyGroup' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\PropertyGroup' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\PropertyGroup', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\PropertyGroup';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\PropertyGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesGroupsGroupIdGetAsync
     *
     * Get a property group
     *
     * @param  int $group_id The ID of the group (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsGroupIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesGroupsGroupIdGetAsync(
        int $group_id,
        string $contentType = self::contentTypes['restPropertiesGroupsGroupIdGet'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesGroupsGroupIdGetAsyncWithHttpInfo($group_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesGroupsGroupIdGetAsyncWithHttpInfo
     *
     * Get a property group
     *
     * @param  int $group_id The ID of the group (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsGroupIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesGroupsGroupIdGetAsyncWithHttpInfo(
        $group_id,
        string $contentType = self::contentTypes['restPropertiesGroupsGroupIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\PropertyGroup';
        $request = $this->restPropertiesGroupsGroupIdGetRequest($group_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesGroupsGroupIdGet'
     *
     * @param  int $group_id The ID of the group (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsGroupIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesGroupsGroupIdGetRequest(
        $group_id,
        string $contentType = self::contentTypes['restPropertiesGroupsGroupIdGet'][0]
    ): Request
    {

        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $group_id when calling restPropertiesGroupsGroupIdGet'
            );
        }


        $resourcePath = '/rest/properties/groups/{groupId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesGroupsGroupIdPropertiesPost
     *
     * Mass attach propertyId and groupId collection into the pivot table.
     *
     * @param  int $group_id The ID of the group (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsGroupIdPropertiesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restPropertiesGroupsGroupIdPropertiesPost(
        int $group_id,
        string $contentType = self::contentTypes['restPropertiesGroupsGroupIdPropertiesPost'][0]
    ): object
    {
        list($response) = $this->restPropertiesGroupsGroupIdPropertiesPostWithHttpInfo($group_id, $contentType);
        return $response;
    }

    /**
     * Operation restPropertiesGroupsGroupIdPropertiesPostWithHttpInfo
     *
     * Mass attach propertyId and groupId collection into the pivot table.
     *
     * @param  int $group_id The ID of the group (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsGroupIdPropertiesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesGroupsGroupIdPropertiesPostWithHttpInfo(
        int $group_id,
        string $contentType = self::contentTypes['restPropertiesGroupsGroupIdPropertiesPost'][0]
    ): array
    {
        $request = $this->restPropertiesGroupsGroupIdPropertiesPostRequest($group_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesGroupsGroupIdPropertiesPostAsync
     *
     * Mass attach propertyId and groupId collection into the pivot table.
     *
     * @param  int $group_id The ID of the group (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsGroupIdPropertiesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesGroupsGroupIdPropertiesPostAsync(
        int $group_id,
        string $contentType = self::contentTypes['restPropertiesGroupsGroupIdPropertiesPost'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesGroupsGroupIdPropertiesPostAsyncWithHttpInfo($group_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesGroupsGroupIdPropertiesPostAsyncWithHttpInfo
     *
     * Mass attach propertyId and groupId collection into the pivot table.
     *
     * @param  int $group_id The ID of the group (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsGroupIdPropertiesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesGroupsGroupIdPropertiesPostAsyncWithHttpInfo(
        $group_id,
        string $contentType = self::contentTypes['restPropertiesGroupsGroupIdPropertiesPost'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restPropertiesGroupsGroupIdPropertiesPostRequest($group_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesGroupsGroupIdPropertiesPost'
     *
     * @param  int $group_id The ID of the group (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsGroupIdPropertiesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesGroupsGroupIdPropertiesPostRequest(
        $group_id,
        string $contentType = self::contentTypes['restPropertiesGroupsGroupIdPropertiesPost'][0]
    ): Request
    {

        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $group_id when calling restPropertiesGroupsGroupIdPropertiesPost'
            );
        }


        $resourcePath = '/rest/properties/groups/{groupId}/properties';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesGroupsGroupIdPropertiesPropertyIdDelete
     *
     * Detach a property from a property group.
     *
     * @param  int $group_id The ID of the group (required)
     * @param  int $property_id The ID of the property (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsGroupIdPropertiesPropertyIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restPropertiesGroupsGroupIdPropertiesPropertyIdDelete(
        int $group_id,
        int $property_id,
        string $contentType = self::contentTypes['restPropertiesGroupsGroupIdPropertiesPropertyIdDelete'][0]
    ): object
    {
        list($response) = $this->restPropertiesGroupsGroupIdPropertiesPropertyIdDeleteWithHttpInfo($group_id, $property_id, $contentType);
        return $response;
    }

    /**
     * Operation restPropertiesGroupsGroupIdPropertiesPropertyIdDeleteWithHttpInfo
     *
     * Detach a property from a property group.
     *
     * @param  int $group_id The ID of the group (required)
     * @param  int $property_id The ID of the property (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsGroupIdPropertiesPropertyIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesGroupsGroupIdPropertiesPropertyIdDeleteWithHttpInfo(
        int $group_id,
        int $property_id,
        string $contentType = self::contentTypes['restPropertiesGroupsGroupIdPropertiesPropertyIdDelete'][0]
    ): array
    {
        $request = $this->restPropertiesGroupsGroupIdPropertiesPropertyIdDeleteRequest($group_id, $property_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesGroupsGroupIdPropertiesPropertyIdDeleteAsync
     *
     * Detach a property from a property group.
     *
     * @param  int $group_id The ID of the group (required)
     * @param  int $property_id The ID of the property (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsGroupIdPropertiesPropertyIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesGroupsGroupIdPropertiesPropertyIdDeleteAsync(
        int $group_id,
        int $property_id,
        string $contentType = self::contentTypes['restPropertiesGroupsGroupIdPropertiesPropertyIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesGroupsGroupIdPropertiesPropertyIdDeleteAsyncWithHttpInfo($group_id, $property_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesGroupsGroupIdPropertiesPropertyIdDeleteAsyncWithHttpInfo
     *
     * Detach a property from a property group.
     *
     * @param  int $group_id The ID of the group (required)
     * @param  int $property_id The ID of the property (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsGroupIdPropertiesPropertyIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesGroupsGroupIdPropertiesPropertyIdDeleteAsyncWithHttpInfo(
        $group_id,
        $property_id,
        string $contentType = self::contentTypes['restPropertiesGroupsGroupIdPropertiesPropertyIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restPropertiesGroupsGroupIdPropertiesPropertyIdDeleteRequest($group_id, $property_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesGroupsGroupIdPropertiesPropertyIdDelete'
     *
     * @param  int $group_id The ID of the group (required)
     * @param  int $property_id The ID of the property (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsGroupIdPropertiesPropertyIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesGroupsGroupIdPropertiesPropertyIdDeleteRequest(
        $group_id,
        $property_id,
        string $contentType = self::contentTypes['restPropertiesGroupsGroupIdPropertiesPropertyIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $group_id when calling restPropertiesGroupsGroupIdPropertiesPropertyIdDelete'
            );
        }

        // verify the required parameter 'property_id' is set
        if ($property_id === null || (is_array($property_id) && count($property_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $property_id when calling restPropertiesGroupsGroupIdPropertiesPropertyIdDelete'
            );
        }


        $resourcePath = '/rest/properties/groups/{groupId}/properties/{propertyId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }
        // path params
        if ($property_id !== null) {
            $resourcePath = str_replace(
                '{' . 'propertyId' . '}',
                ObjectSerializer::toPathValue($property_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesGroupsGroupIdPropertiesPropertyIdPost
     *
     * Attach a property to a property group
     *
     * @param  int $group_id The ID of the group (required)
     * @param  int $property_id The ID of the property (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsGroupIdPropertiesPropertyIdPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restPropertiesGroupsGroupIdPropertiesPropertyIdPost(
        int $group_id,
        int $property_id,
        string $contentType = self::contentTypes['restPropertiesGroupsGroupIdPropertiesPropertyIdPost'][0]
    ): object
    {
        list($response) = $this->restPropertiesGroupsGroupIdPropertiesPropertyIdPostWithHttpInfo($group_id, $property_id, $contentType);
        return $response;
    }

    /**
     * Operation restPropertiesGroupsGroupIdPropertiesPropertyIdPostWithHttpInfo
     *
     * Attach a property to a property group
     *
     * @param  int $group_id The ID of the group (required)
     * @param  int $property_id The ID of the property (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsGroupIdPropertiesPropertyIdPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesGroupsGroupIdPropertiesPropertyIdPostWithHttpInfo(
        int $group_id,
        int $property_id,
        string $contentType = self::contentTypes['restPropertiesGroupsGroupIdPropertiesPropertyIdPost'][0]
    ): array
    {
        $request = $this->restPropertiesGroupsGroupIdPropertiesPropertyIdPostRequest($group_id, $property_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesGroupsGroupIdPropertiesPropertyIdPostAsync
     *
     * Attach a property to a property group
     *
     * @param  int $group_id The ID of the group (required)
     * @param  int $property_id The ID of the property (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsGroupIdPropertiesPropertyIdPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesGroupsGroupIdPropertiesPropertyIdPostAsync(
        int $group_id,
        int $property_id,
        string $contentType = self::contentTypes['restPropertiesGroupsGroupIdPropertiesPropertyIdPost'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesGroupsGroupIdPropertiesPropertyIdPostAsyncWithHttpInfo($group_id, $property_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesGroupsGroupIdPropertiesPropertyIdPostAsyncWithHttpInfo
     *
     * Attach a property to a property group
     *
     * @param  int $group_id The ID of the group (required)
     * @param  int $property_id The ID of the property (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsGroupIdPropertiesPropertyIdPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesGroupsGroupIdPropertiesPropertyIdPostAsyncWithHttpInfo(
        $group_id,
        $property_id,
        string $contentType = self::contentTypes['restPropertiesGroupsGroupIdPropertiesPropertyIdPost'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restPropertiesGroupsGroupIdPropertiesPropertyIdPostRequest($group_id, $property_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesGroupsGroupIdPropertiesPropertyIdPost'
     *
     * @param  int $group_id The ID of the group (required)
     * @param  int $property_id The ID of the property (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsGroupIdPropertiesPropertyIdPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesGroupsGroupIdPropertiesPropertyIdPostRequest(
        $group_id,
        $property_id,
        string $contentType = self::contentTypes['restPropertiesGroupsGroupIdPropertiesPropertyIdPost'][0]
    ): Request
    {

        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $group_id when calling restPropertiesGroupsGroupIdPropertiesPropertyIdPost'
            );
        }

        // verify the required parameter 'property_id' is set
        if ($property_id === null || (is_array($property_id) && count($property_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $property_id when calling restPropertiesGroupsGroupIdPropertiesPropertyIdPost'
            );
        }


        $resourcePath = '/rest/properties/groups/{groupId}/properties/{propertyId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }
        // path params
        if ($property_id !== null) {
            $resourcePath = str_replace(
                '{' . 'propertyId' . '}',
                ObjectSerializer::toPathValue($property_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesGroupsGroupIdPut
     *
     * Update a property group
     *
     * @param  int $group_id group_id (required)
     * @param  int|null $position The position  of the group (optional)
     * @param  int|null $names The names of the group. (optional)
     * @param  int|null $options The options of the group (optional)
     * @param  \ck/plenty-client\Model\RestPropertiesGroupsPostRequest|null $_rest_properties_groups_group_id _rest_properties_groups_group_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsGroupIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\PropertyGroup
     */
    public function restPropertiesGroupsGroupIdPut(
        int $group_id,
        ?int $position = null,
        ?int $names = null,
        ?int $options = null,
        ?\ck/plenty-client\Model\RestPropertiesGroupsPostRequest $_rest_properties_groups_group_id = null,
        string $contentType = self::contentTypes['restPropertiesGroupsGroupIdPut'][0]
    ): \ck/plenty-client\Model\PropertyGroup
    {
        list($response) = $this->restPropertiesGroupsGroupIdPutWithHttpInfo($group_id, $position, $names, $options, $_rest_properties_groups_group_id, $contentType);
        return $response;
    }

    /**
     * Operation restPropertiesGroupsGroupIdPutWithHttpInfo
     *
     * Update a property group
     *
     * @param  int $group_id (required)
     * @param  int|null $position The position  of the group (optional)
     * @param  int|null $names The names of the group. (optional)
     * @param  int|null $options The options of the group (optional)
     * @param  \ck/plenty-client\Model\RestPropertiesGroupsPostRequest|null $_rest_properties_groups_group_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsGroupIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\PropertyGroup, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesGroupsGroupIdPutWithHttpInfo(
        int $group_id,
        ?int $position = null,
        ?int $names = null,
        ?int $options = null,
        ?\ck/plenty-client\Model\RestPropertiesGroupsPostRequest $_rest_properties_groups_group_id = null,
        string $contentType = self::contentTypes['restPropertiesGroupsGroupIdPut'][0]
    ): array
    {
        $request = $this->restPropertiesGroupsGroupIdPutRequest($group_id, $position, $names, $options, $_rest_properties_groups_group_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\PropertyGroup' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\PropertyGroup' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\PropertyGroup', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\PropertyGroup';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\PropertyGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesGroupsGroupIdPutAsync
     *
     * Update a property group
     *
     * @param  int $group_id (required)
     * @param  int|null $position The position  of the group (optional)
     * @param  int|null $names The names of the group. (optional)
     * @param  int|null $options The options of the group (optional)
     * @param  \ck/plenty-client\Model\RestPropertiesGroupsPostRequest|null $_rest_properties_groups_group_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsGroupIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesGroupsGroupIdPutAsync(
        int $group_id,
        ?int $position = null,
        ?int $names = null,
        ?int $options = null,
        ?\ck/plenty-client\Model\RestPropertiesGroupsPostRequest $_rest_properties_groups_group_id = null,
        string $contentType = self::contentTypes['restPropertiesGroupsGroupIdPut'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesGroupsGroupIdPutAsyncWithHttpInfo($group_id, $position, $names, $options, $_rest_properties_groups_group_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesGroupsGroupIdPutAsyncWithHttpInfo
     *
     * Update a property group
     *
     * @param  int $group_id (required)
     * @param  int|null $position The position  of the group (optional)
     * @param  int|null $names The names of the group. (optional)
     * @param  int|null $options The options of the group (optional)
     * @param  \ck/plenty-client\Model\RestPropertiesGroupsPostRequest|null $_rest_properties_groups_group_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsGroupIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesGroupsGroupIdPutAsyncWithHttpInfo(
        $group_id,
        $position = null,
        $names = null,
        $options = null,
        $_rest_properties_groups_group_id = null,
        string $contentType = self::contentTypes['restPropertiesGroupsGroupIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\PropertyGroup';
        $request = $this->restPropertiesGroupsGroupIdPutRequest($group_id, $position, $names, $options, $_rest_properties_groups_group_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesGroupsGroupIdPut'
     *
     * @param  int $group_id (required)
     * @param  int|null $position The position  of the group (optional)
     * @param  int|null $names The names of the group. (optional)
     * @param  int|null $options The options of the group (optional)
     * @param  \ck/plenty-client\Model\RestPropertiesGroupsPostRequest|null $_rest_properties_groups_group_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsGroupIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesGroupsGroupIdPutRequest(
        $group_id,
        $position = null,
        $names = null,
        $options = null,
        $_rest_properties_groups_group_id = null,
        string $contentType = self::contentTypes['restPropertiesGroupsGroupIdPut'][0]
    ): Request
    {

        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $group_id when calling restPropertiesGroupsGroupIdPut'
            );
        }






        $resourcePath = '/rest/properties/groups/{groupId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $position,
            'position', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $names,
            'names', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $options,
            'options', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_properties_groups_group_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_properties_groups_group_id));
            } else {
                $httpBody = $_rest_properties_groups_group_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesGroupsNamesGet
     *
     * List group names
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsNamesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\PropertyGroupName[]
     */
    public function restPropertiesGroupsNamesGet(
        string $contentType = self::contentTypes['restPropertiesGroupsNamesGet'][0]
    ): array
    {
        list($response) = $this->restPropertiesGroupsNamesGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restPropertiesGroupsNamesGetWithHttpInfo
     *
     * List group names
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsNamesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\PropertyGroupName[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesGroupsNamesGetWithHttpInfo(
        string $contentType = self::contentTypes['restPropertiesGroupsNamesGet'][0]
    ): array
    {
        $request = $this->restPropertiesGroupsNamesGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\PropertyGroupName[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\PropertyGroupName[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\PropertyGroupName[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\PropertyGroupName[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\PropertyGroupName[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesGroupsNamesGetAsync
     *
     * List group names
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsNamesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesGroupsNamesGetAsync(
        string $contentType = self::contentTypes['restPropertiesGroupsNamesGet'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesGroupsNamesGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesGroupsNamesGetAsyncWithHttpInfo
     *
     * List group names
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsNamesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesGroupsNamesGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restPropertiesGroupsNamesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\PropertyGroupName[]';
        $request = $this->restPropertiesGroupsNamesGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesGroupsNamesGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsNamesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesGroupsNamesGetRequest(
        string $contentType = self::contentTypes['restPropertiesGroupsNamesGet'][0]
    ): Request
    {


        $resourcePath = '/rest/properties/groups/names';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesGroupsNamesGroupNameIdDelete
     *
     * Delete a group name
     *
     * @param  int $group_name_id The ID of the group name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsNamesGroupNameIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restPropertiesGroupsNamesGroupNameIdDelete(
        int $group_name_id,
        string $contentType = self::contentTypes['restPropertiesGroupsNamesGroupNameIdDelete'][0]
    ): void
    {
        $this->restPropertiesGroupsNamesGroupNameIdDeleteWithHttpInfo($group_name_id, $contentType);
    }

    /**
     * Operation restPropertiesGroupsNamesGroupNameIdDeleteWithHttpInfo
     *
     * Delete a group name
     *
     * @param  int $group_name_id The ID of the group name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsNamesGroupNameIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesGroupsNamesGroupNameIdDeleteWithHttpInfo(
        int $group_name_id,
        string $contentType = self::contentTypes['restPropertiesGroupsNamesGroupNameIdDelete'][0]
    ): array
    {
        $request = $this->restPropertiesGroupsNamesGroupNameIdDeleteRequest($group_name_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesGroupsNamesGroupNameIdDeleteAsync
     *
     * Delete a group name
     *
     * @param  int $group_name_id The ID of the group name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsNamesGroupNameIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesGroupsNamesGroupNameIdDeleteAsync(
        int $group_name_id,
        string $contentType = self::contentTypes['restPropertiesGroupsNamesGroupNameIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesGroupsNamesGroupNameIdDeleteAsyncWithHttpInfo($group_name_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesGroupsNamesGroupNameIdDeleteAsyncWithHttpInfo
     *
     * Delete a group name
     *
     * @param  int $group_name_id The ID of the group name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsNamesGroupNameIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesGroupsNamesGroupNameIdDeleteAsyncWithHttpInfo(
        $group_name_id,
        string $contentType = self::contentTypes['restPropertiesGroupsNamesGroupNameIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restPropertiesGroupsNamesGroupNameIdDeleteRequest($group_name_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesGroupsNamesGroupNameIdDelete'
     *
     * @param  int $group_name_id The ID of the group name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsNamesGroupNameIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesGroupsNamesGroupNameIdDeleteRequest(
        $group_name_id,
        string $contentType = self::contentTypes['restPropertiesGroupsNamesGroupNameIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'group_name_id' is set
        if ($group_name_id === null || (is_array($group_name_id) && count($group_name_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $group_name_id when calling restPropertiesGroupsNamesGroupNameIdDelete'
            );
        }


        $resourcePath = '/rest/properties/groups/names/{groupNameId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($group_name_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupNameId' . '}',
                ObjectSerializer::toPathValue($group_name_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesGroupsNamesGroupNameIdGet
     *
     * Get a group name
     *
     * @param  int $group_name_id The ID of the group name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsNamesGroupNameIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\PropertyGroupName
     */
    public function restPropertiesGroupsNamesGroupNameIdGet(
        int $group_name_id,
        string $contentType = self::contentTypes['restPropertiesGroupsNamesGroupNameIdGet'][0]
    ): \ck/plenty-client\Model\PropertyGroupName
    {
        list($response) = $this->restPropertiesGroupsNamesGroupNameIdGetWithHttpInfo($group_name_id, $contentType);
        return $response;
    }

    /**
     * Operation restPropertiesGroupsNamesGroupNameIdGetWithHttpInfo
     *
     * Get a group name
     *
     * @param  int $group_name_id The ID of the group name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsNamesGroupNameIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\PropertyGroupName, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesGroupsNamesGroupNameIdGetWithHttpInfo(
        int $group_name_id,
        string $contentType = self::contentTypes['restPropertiesGroupsNamesGroupNameIdGet'][0]
    ): array
    {
        $request = $this->restPropertiesGroupsNamesGroupNameIdGetRequest($group_name_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\PropertyGroupName' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\PropertyGroupName' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\PropertyGroupName', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\PropertyGroupName';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\PropertyGroupName',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesGroupsNamesGroupNameIdGetAsync
     *
     * Get a group name
     *
     * @param  int $group_name_id The ID of the group name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsNamesGroupNameIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesGroupsNamesGroupNameIdGetAsync(
        int $group_name_id,
        string $contentType = self::contentTypes['restPropertiesGroupsNamesGroupNameIdGet'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesGroupsNamesGroupNameIdGetAsyncWithHttpInfo($group_name_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesGroupsNamesGroupNameIdGetAsyncWithHttpInfo
     *
     * Get a group name
     *
     * @param  int $group_name_id The ID of the group name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsNamesGroupNameIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesGroupsNamesGroupNameIdGetAsyncWithHttpInfo(
        $group_name_id,
        string $contentType = self::contentTypes['restPropertiesGroupsNamesGroupNameIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\PropertyGroupName';
        $request = $this->restPropertiesGroupsNamesGroupNameIdGetRequest($group_name_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesGroupsNamesGroupNameIdGet'
     *
     * @param  int $group_name_id The ID of the group name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsNamesGroupNameIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesGroupsNamesGroupNameIdGetRequest(
        $group_name_id,
        string $contentType = self::contentTypes['restPropertiesGroupsNamesGroupNameIdGet'][0]
    ): Request
    {

        // verify the required parameter 'group_name_id' is set
        if ($group_name_id === null || (is_array($group_name_id) && count($group_name_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $group_name_id when calling restPropertiesGroupsNamesGroupNameIdGet'
            );
        }


        $resourcePath = '/rest/properties/groups/names/{groupNameId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($group_name_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupNameId' . '}',
                ObjectSerializer::toPathValue($group_name_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesGroupsNamesGroupNameIdPut
     *
     * Update a group name
     *
     * @param  int $group_name_id The ID of the group name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsNamesGroupNameIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\PropertyGroupName
     */
    public function restPropertiesGroupsNamesGroupNameIdPut(
        int $group_name_id,
        string $contentType = self::contentTypes['restPropertiesGroupsNamesGroupNameIdPut'][0]
    ): \ck/plenty-client\Model\PropertyGroupName
    {
        list($response) = $this->restPropertiesGroupsNamesGroupNameIdPutWithHttpInfo($group_name_id, $contentType);
        return $response;
    }

    /**
     * Operation restPropertiesGroupsNamesGroupNameIdPutWithHttpInfo
     *
     * Update a group name
     *
     * @param  int $group_name_id The ID of the group name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsNamesGroupNameIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\PropertyGroupName, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesGroupsNamesGroupNameIdPutWithHttpInfo(
        int $group_name_id,
        string $contentType = self::contentTypes['restPropertiesGroupsNamesGroupNameIdPut'][0]
    ): array
    {
        $request = $this->restPropertiesGroupsNamesGroupNameIdPutRequest($group_name_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\PropertyGroupName' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\PropertyGroupName' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\PropertyGroupName', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\PropertyGroupName';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\PropertyGroupName',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesGroupsNamesGroupNameIdPutAsync
     *
     * Update a group name
     *
     * @param  int $group_name_id The ID of the group name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsNamesGroupNameIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesGroupsNamesGroupNameIdPutAsync(
        int $group_name_id,
        string $contentType = self::contentTypes['restPropertiesGroupsNamesGroupNameIdPut'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesGroupsNamesGroupNameIdPutAsyncWithHttpInfo($group_name_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesGroupsNamesGroupNameIdPutAsyncWithHttpInfo
     *
     * Update a group name
     *
     * @param  int $group_name_id The ID of the group name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsNamesGroupNameIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesGroupsNamesGroupNameIdPutAsyncWithHttpInfo(
        $group_name_id,
        string $contentType = self::contentTypes['restPropertiesGroupsNamesGroupNameIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\PropertyGroupName';
        $request = $this->restPropertiesGroupsNamesGroupNameIdPutRequest($group_name_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesGroupsNamesGroupNameIdPut'
     *
     * @param  int $group_name_id The ID of the group name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsNamesGroupNameIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesGroupsNamesGroupNameIdPutRequest(
        $group_name_id,
        string $contentType = self::contentTypes['restPropertiesGroupsNamesGroupNameIdPut'][0]
    ): Request
    {

        // verify the required parameter 'group_name_id' is set
        if ($group_name_id === null || (is_array($group_name_id) && count($group_name_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $group_name_id when calling restPropertiesGroupsNamesGroupNameIdPut'
            );
        }


        $resourcePath = '/rest/properties/groups/names/{groupNameId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($group_name_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupNameId' . '}',
                ObjectSerializer::toPathValue($group_name_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesGroupsNamesPost
     *
     * Create an group name
     *
     * @param  int $property_id The ID of the property (required)
     * @param  string $lang The lang of the group name (required)
     * @param  string $name The name of the group name (required)
     * @param  \ck/plenty-client\Model\RestPropertiesGroupsNamesPostRequest|null $_rest_properties_groups_names _rest_properties_groups_names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsNamesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\PropertyGroupName
     */
    public function restPropertiesGroupsNamesPost(
        int $property_id,
        string $lang,
        string $name,
        ?\ck/plenty-client\Model\RestPropertiesGroupsNamesPostRequest $_rest_properties_groups_names = null,
        string $contentType = self::contentTypes['restPropertiesGroupsNamesPost'][0]
    ): \ck/plenty-client\Model\PropertyGroupName
    {
        list($response) = $this->restPropertiesGroupsNamesPostWithHttpInfo($property_id, $lang, $name, $_rest_properties_groups_names, $contentType);
        return $response;
    }

    /**
     * Operation restPropertiesGroupsNamesPostWithHttpInfo
     *
     * Create an group name
     *
     * @param  int $property_id The ID of the property (required)
     * @param  string $lang The lang of the group name (required)
     * @param  string $name The name of the group name (required)
     * @param  \ck/plenty-client\Model\RestPropertiesGroupsNamesPostRequest|null $_rest_properties_groups_names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsNamesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\PropertyGroupName, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesGroupsNamesPostWithHttpInfo(
        int $property_id,
        string $lang,
        string $name,
        ?\ck/plenty-client\Model\RestPropertiesGroupsNamesPostRequest $_rest_properties_groups_names = null,
        string $contentType = self::contentTypes['restPropertiesGroupsNamesPost'][0]
    ): array
    {
        $request = $this->restPropertiesGroupsNamesPostRequest($property_id, $lang, $name, $_rest_properties_groups_names, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\PropertyGroupName' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\PropertyGroupName' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\PropertyGroupName', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\PropertyGroupName';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\PropertyGroupName',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesGroupsNamesPostAsync
     *
     * Create an group name
     *
     * @param  int $property_id The ID of the property (required)
     * @param  string $lang The lang of the group name (required)
     * @param  string $name The name of the group name (required)
     * @param  \ck/plenty-client\Model\RestPropertiesGroupsNamesPostRequest|null $_rest_properties_groups_names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsNamesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesGroupsNamesPostAsync(
        int $property_id,
        string $lang,
        string $name,
        ?\ck/plenty-client\Model\RestPropertiesGroupsNamesPostRequest $_rest_properties_groups_names = null,
        string $contentType = self::contentTypes['restPropertiesGroupsNamesPost'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesGroupsNamesPostAsyncWithHttpInfo($property_id, $lang, $name, $_rest_properties_groups_names, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesGroupsNamesPostAsyncWithHttpInfo
     *
     * Create an group name
     *
     * @param  int $property_id The ID of the property (required)
     * @param  string $lang The lang of the group name (required)
     * @param  string $name The name of the group name (required)
     * @param  \ck/plenty-client\Model\RestPropertiesGroupsNamesPostRequest|null $_rest_properties_groups_names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsNamesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesGroupsNamesPostAsyncWithHttpInfo(
        $property_id,
        $lang,
        $name,
        $_rest_properties_groups_names = null,
        string $contentType = self::contentTypes['restPropertiesGroupsNamesPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\PropertyGroupName';
        $request = $this->restPropertiesGroupsNamesPostRequest($property_id, $lang, $name, $_rest_properties_groups_names, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesGroupsNamesPost'
     *
     * @param  int $property_id The ID of the property (required)
     * @param  string $lang The lang of the group name (required)
     * @param  string $name The name of the group name (required)
     * @param  \ck/plenty-client\Model\RestPropertiesGroupsNamesPostRequest|null $_rest_properties_groups_names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsNamesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesGroupsNamesPostRequest(
        $property_id,
        $lang,
        $name,
        $_rest_properties_groups_names = null,
        string $contentType = self::contentTypes['restPropertiesGroupsNamesPost'][0]
    ): Request
    {

        // verify the required parameter 'property_id' is set
        if ($property_id === null || (is_array($property_id) && count($property_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $property_id when calling restPropertiesGroupsNamesPost'
            );
        }

        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $lang when calling restPropertiesGroupsNamesPost'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $name when calling restPropertiesGroupsNamesPost'
            );
        }



        $resourcePath = '/rest/properties/groups/names';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $property_id,
            'propertyId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $lang,
            'lang', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_properties_groups_names)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_properties_groups_names));
            } else {
                $httpBody = $_rest_properties_groups_names;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesGroupsOptionsGet
     *
     * List group options
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsOptionsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\PropertyGroupOption[]
     */
    public function restPropertiesGroupsOptionsGet(
        string $contentType = self::contentTypes['restPropertiesGroupsOptionsGet'][0]
    ): array
    {
        list($response) = $this->restPropertiesGroupsOptionsGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restPropertiesGroupsOptionsGetWithHttpInfo
     *
     * List group options
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsOptionsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\PropertyGroupOption[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesGroupsOptionsGetWithHttpInfo(
        string $contentType = self::contentTypes['restPropertiesGroupsOptionsGet'][0]
    ): array
    {
        $request = $this->restPropertiesGroupsOptionsGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\PropertyGroupOption[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\PropertyGroupOption[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\PropertyGroupOption[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\PropertyGroupOption[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\PropertyGroupOption[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesGroupsOptionsGetAsync
     *
     * List group options
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsOptionsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesGroupsOptionsGetAsync(
        string $contentType = self::contentTypes['restPropertiesGroupsOptionsGet'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesGroupsOptionsGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesGroupsOptionsGetAsyncWithHttpInfo
     *
     * List group options
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsOptionsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesGroupsOptionsGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restPropertiesGroupsOptionsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\PropertyGroupOption[]';
        $request = $this->restPropertiesGroupsOptionsGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesGroupsOptionsGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsOptionsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesGroupsOptionsGetRequest(
        string $contentType = self::contentTypes['restPropertiesGroupsOptionsGet'][0]
    ): Request
    {


        $resourcePath = '/rest/properties/groups/options';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesGroupsOptionsGroupOptionIdDelete
     *
     * Delete a group option
     *
     * @param  int $group_option_id The ID of the group option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsOptionsGroupOptionIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restPropertiesGroupsOptionsGroupOptionIdDelete(
        int $group_option_id,
        string $contentType = self::contentTypes['restPropertiesGroupsOptionsGroupOptionIdDelete'][0]
    ): void
    {
        $this->restPropertiesGroupsOptionsGroupOptionIdDeleteWithHttpInfo($group_option_id, $contentType);
    }

    /**
     * Operation restPropertiesGroupsOptionsGroupOptionIdDeleteWithHttpInfo
     *
     * Delete a group option
     *
     * @param  int $group_option_id The ID of the group option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsOptionsGroupOptionIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesGroupsOptionsGroupOptionIdDeleteWithHttpInfo(
        int $group_option_id,
        string $contentType = self::contentTypes['restPropertiesGroupsOptionsGroupOptionIdDelete'][0]
    ): array
    {
        $request = $this->restPropertiesGroupsOptionsGroupOptionIdDeleteRequest($group_option_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesGroupsOptionsGroupOptionIdDeleteAsync
     *
     * Delete a group option
     *
     * @param  int $group_option_id The ID of the group option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsOptionsGroupOptionIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesGroupsOptionsGroupOptionIdDeleteAsync(
        int $group_option_id,
        string $contentType = self::contentTypes['restPropertiesGroupsOptionsGroupOptionIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesGroupsOptionsGroupOptionIdDeleteAsyncWithHttpInfo($group_option_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesGroupsOptionsGroupOptionIdDeleteAsyncWithHttpInfo
     *
     * Delete a group option
     *
     * @param  int $group_option_id The ID of the group option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsOptionsGroupOptionIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesGroupsOptionsGroupOptionIdDeleteAsyncWithHttpInfo(
        $group_option_id,
        string $contentType = self::contentTypes['restPropertiesGroupsOptionsGroupOptionIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restPropertiesGroupsOptionsGroupOptionIdDeleteRequest($group_option_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesGroupsOptionsGroupOptionIdDelete'
     *
     * @param  int $group_option_id The ID of the group option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsOptionsGroupOptionIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesGroupsOptionsGroupOptionIdDeleteRequest(
        $group_option_id,
        string $contentType = self::contentTypes['restPropertiesGroupsOptionsGroupOptionIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'group_option_id' is set
        if ($group_option_id === null || (is_array($group_option_id) && count($group_option_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $group_option_id when calling restPropertiesGroupsOptionsGroupOptionIdDelete'
            );
        }


        $resourcePath = '/rest/properties/groups/options/{groupOptionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($group_option_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupOptionId' . '}',
                ObjectSerializer::toPathValue($group_option_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesGroupsOptionsGroupOptionIdGet
     *
     * Get a group option
     *
     * @param  int $group_option_id The ID of the group option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsOptionsGroupOptionIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\PropertyGroupOption
     */
    public function restPropertiesGroupsOptionsGroupOptionIdGet(
        int $group_option_id,
        string $contentType = self::contentTypes['restPropertiesGroupsOptionsGroupOptionIdGet'][0]
    ): \ck/plenty-client\Model\PropertyGroupOption
    {
        list($response) = $this->restPropertiesGroupsOptionsGroupOptionIdGetWithHttpInfo($group_option_id, $contentType);
        return $response;
    }

    /**
     * Operation restPropertiesGroupsOptionsGroupOptionIdGetWithHttpInfo
     *
     * Get a group option
     *
     * @param  int $group_option_id The ID of the group option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsOptionsGroupOptionIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\PropertyGroupOption, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesGroupsOptionsGroupOptionIdGetWithHttpInfo(
        int $group_option_id,
        string $contentType = self::contentTypes['restPropertiesGroupsOptionsGroupOptionIdGet'][0]
    ): array
    {
        $request = $this->restPropertiesGroupsOptionsGroupOptionIdGetRequest($group_option_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\PropertyGroupOption' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\PropertyGroupOption' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\PropertyGroupOption', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\PropertyGroupOption';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\PropertyGroupOption',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesGroupsOptionsGroupOptionIdGetAsync
     *
     * Get a group option
     *
     * @param  int $group_option_id The ID of the group option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsOptionsGroupOptionIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesGroupsOptionsGroupOptionIdGetAsync(
        int $group_option_id,
        string $contentType = self::contentTypes['restPropertiesGroupsOptionsGroupOptionIdGet'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesGroupsOptionsGroupOptionIdGetAsyncWithHttpInfo($group_option_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesGroupsOptionsGroupOptionIdGetAsyncWithHttpInfo
     *
     * Get a group option
     *
     * @param  int $group_option_id The ID of the group option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsOptionsGroupOptionIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesGroupsOptionsGroupOptionIdGetAsyncWithHttpInfo(
        $group_option_id,
        string $contentType = self::contentTypes['restPropertiesGroupsOptionsGroupOptionIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\PropertyGroupOption';
        $request = $this->restPropertiesGroupsOptionsGroupOptionIdGetRequest($group_option_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesGroupsOptionsGroupOptionIdGet'
     *
     * @param  int $group_option_id The ID of the group option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsOptionsGroupOptionIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesGroupsOptionsGroupOptionIdGetRequest(
        $group_option_id,
        string $contentType = self::contentTypes['restPropertiesGroupsOptionsGroupOptionIdGet'][0]
    ): Request
    {

        // verify the required parameter 'group_option_id' is set
        if ($group_option_id === null || (is_array($group_option_id) && count($group_option_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $group_option_id when calling restPropertiesGroupsOptionsGroupOptionIdGet'
            );
        }


        $resourcePath = '/rest/properties/groups/options/{groupOptionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($group_option_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupOptionId' . '}',
                ObjectSerializer::toPathValue($group_option_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesGroupsOptionsGroupOptionIdPut
     *
     * Update a group option
     *
     * @param  int $group_option_id The ID of the group option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsOptionsGroupOptionIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\PropertyGroupOption
     */
    public function restPropertiesGroupsOptionsGroupOptionIdPut(
        int $group_option_id,
        string $contentType = self::contentTypes['restPropertiesGroupsOptionsGroupOptionIdPut'][0]
    ): \ck/plenty-client\Model\PropertyGroupOption
    {
        list($response) = $this->restPropertiesGroupsOptionsGroupOptionIdPutWithHttpInfo($group_option_id, $contentType);
        return $response;
    }

    /**
     * Operation restPropertiesGroupsOptionsGroupOptionIdPutWithHttpInfo
     *
     * Update a group option
     *
     * @param  int $group_option_id The ID of the group option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsOptionsGroupOptionIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\PropertyGroupOption, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesGroupsOptionsGroupOptionIdPutWithHttpInfo(
        int $group_option_id,
        string $contentType = self::contentTypes['restPropertiesGroupsOptionsGroupOptionIdPut'][0]
    ): array
    {
        $request = $this->restPropertiesGroupsOptionsGroupOptionIdPutRequest($group_option_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\PropertyGroupOption' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\PropertyGroupOption' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\PropertyGroupOption', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\PropertyGroupOption';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\PropertyGroupOption',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesGroupsOptionsGroupOptionIdPutAsync
     *
     * Update a group option
     *
     * @param  int $group_option_id The ID of the group option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsOptionsGroupOptionIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesGroupsOptionsGroupOptionIdPutAsync(
        int $group_option_id,
        string $contentType = self::contentTypes['restPropertiesGroupsOptionsGroupOptionIdPut'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesGroupsOptionsGroupOptionIdPutAsyncWithHttpInfo($group_option_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesGroupsOptionsGroupOptionIdPutAsyncWithHttpInfo
     *
     * Update a group option
     *
     * @param  int $group_option_id The ID of the group option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsOptionsGroupOptionIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesGroupsOptionsGroupOptionIdPutAsyncWithHttpInfo(
        $group_option_id,
        string $contentType = self::contentTypes['restPropertiesGroupsOptionsGroupOptionIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\PropertyGroupOption';
        $request = $this->restPropertiesGroupsOptionsGroupOptionIdPutRequest($group_option_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesGroupsOptionsGroupOptionIdPut'
     *
     * @param  int $group_option_id The ID of the group option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsOptionsGroupOptionIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesGroupsOptionsGroupOptionIdPutRequest(
        $group_option_id,
        string $contentType = self::contentTypes['restPropertiesGroupsOptionsGroupOptionIdPut'][0]
    ): Request
    {

        // verify the required parameter 'group_option_id' is set
        if ($group_option_id === null || (is_array($group_option_id) && count($group_option_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $group_option_id when calling restPropertiesGroupsOptionsGroupOptionIdPut'
            );
        }


        $resourcePath = '/rest/properties/groups/options/{groupOptionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($group_option_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupOptionId' . '}',
                ObjectSerializer::toPathValue($group_option_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesGroupsOptionsPost
     *
     * Create a group option
     *
     * @param  int $property_group_id The ID of the property group (required)
     * @param  string $group_option_identifier The groupOptionIdentifier of the group name (required)
     * @param  string $value The value of the group name (required)
     * @param  \ck/plenty-client\Model\RestPropertiesGroupsOptionsPostRequest|null $_rest_properties_groups_options _rest_properties_groups_options (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsOptionsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\PropertyGroupOption
     */
    public function restPropertiesGroupsOptionsPost(
        int $property_group_id,
        string $group_option_identifier,
        string $value,
        ?\ck/plenty-client\Model\RestPropertiesGroupsOptionsPostRequest $_rest_properties_groups_options = null,
        string $contentType = self::contentTypes['restPropertiesGroupsOptionsPost'][0]
    ): \ck/plenty-client\Model\PropertyGroupOption
    {
        list($response) = $this->restPropertiesGroupsOptionsPostWithHttpInfo($property_group_id, $group_option_identifier, $value, $_rest_properties_groups_options, $contentType);
        return $response;
    }

    /**
     * Operation restPropertiesGroupsOptionsPostWithHttpInfo
     *
     * Create a group option
     *
     * @param  int $property_group_id The ID of the property group (required)
     * @param  string $group_option_identifier The groupOptionIdentifier of the group name (required)
     * @param  string $value The value of the group name (required)
     * @param  \ck/plenty-client\Model\RestPropertiesGroupsOptionsPostRequest|null $_rest_properties_groups_options (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsOptionsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\PropertyGroupOption, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesGroupsOptionsPostWithHttpInfo(
        int $property_group_id,
        string $group_option_identifier,
        string $value,
        ?\ck/plenty-client\Model\RestPropertiesGroupsOptionsPostRequest $_rest_properties_groups_options = null,
        string $contentType = self::contentTypes['restPropertiesGroupsOptionsPost'][0]
    ): array
    {
        $request = $this->restPropertiesGroupsOptionsPostRequest($property_group_id, $group_option_identifier, $value, $_rest_properties_groups_options, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\PropertyGroupOption' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\PropertyGroupOption' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\PropertyGroupOption', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\PropertyGroupOption';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\PropertyGroupOption',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesGroupsOptionsPostAsync
     *
     * Create a group option
     *
     * @param  int $property_group_id The ID of the property group (required)
     * @param  string $group_option_identifier The groupOptionIdentifier of the group name (required)
     * @param  string $value The value of the group name (required)
     * @param  \ck/plenty-client\Model\RestPropertiesGroupsOptionsPostRequest|null $_rest_properties_groups_options (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsOptionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesGroupsOptionsPostAsync(
        int $property_group_id,
        string $group_option_identifier,
        string $value,
        ?\ck/plenty-client\Model\RestPropertiesGroupsOptionsPostRequest $_rest_properties_groups_options = null,
        string $contentType = self::contentTypes['restPropertiesGroupsOptionsPost'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesGroupsOptionsPostAsyncWithHttpInfo($property_group_id, $group_option_identifier, $value, $_rest_properties_groups_options, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesGroupsOptionsPostAsyncWithHttpInfo
     *
     * Create a group option
     *
     * @param  int $property_group_id The ID of the property group (required)
     * @param  string $group_option_identifier The groupOptionIdentifier of the group name (required)
     * @param  string $value The value of the group name (required)
     * @param  \ck/plenty-client\Model\RestPropertiesGroupsOptionsPostRequest|null $_rest_properties_groups_options (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsOptionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesGroupsOptionsPostAsyncWithHttpInfo(
        $property_group_id,
        $group_option_identifier,
        $value,
        $_rest_properties_groups_options = null,
        string $contentType = self::contentTypes['restPropertiesGroupsOptionsPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\PropertyGroupOption';
        $request = $this->restPropertiesGroupsOptionsPostRequest($property_group_id, $group_option_identifier, $value, $_rest_properties_groups_options, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesGroupsOptionsPost'
     *
     * @param  int $property_group_id The ID of the property group (required)
     * @param  string $group_option_identifier The groupOptionIdentifier of the group name (required)
     * @param  string $value The value of the group name (required)
     * @param  \ck/plenty-client\Model\RestPropertiesGroupsOptionsPostRequest|null $_rest_properties_groups_options (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsOptionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesGroupsOptionsPostRequest(
        $property_group_id,
        $group_option_identifier,
        $value,
        $_rest_properties_groups_options = null,
        string $contentType = self::contentTypes['restPropertiesGroupsOptionsPost'][0]
    ): Request
    {

        // verify the required parameter 'property_group_id' is set
        if ($property_group_id === null || (is_array($property_group_id) && count($property_group_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $property_group_id when calling restPropertiesGroupsOptionsPost'
            );
        }

        // verify the required parameter 'group_option_identifier' is set
        if ($group_option_identifier === null || (is_array($group_option_identifier) && count($group_option_identifier) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $group_option_identifier when calling restPropertiesGroupsOptionsPost'
            );
        }

        // verify the required parameter 'value' is set
        if ($value === null || (is_array($value) && count($value) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $value when calling restPropertiesGroupsOptionsPost'
            );
        }



        $resourcePath = '/rest/properties/groups/options';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $property_group_id,
            'propertyGroupId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group_option_identifier,
            'groupOptionIdentifier', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $value,
            'value', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_properties_groups_options)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_properties_groups_options));
            } else {
                $httpBody = $_rest_properties_groups_options;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesGroupsPost
     *
     * Create a property group
     *
     * @param  int $position The position  of the group (required)
     * @param  int|null $names The names of the group. (optional)
     * @param  int|null $options The options of the group (optional)
     * @param  \ck/plenty-client\Model\RestPropertiesGroupsPostRequest|null $_rest_properties_groups _rest_properties_groups (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\PropertyGroup
     */
    public function restPropertiesGroupsPost(
        int $position,
        ?int $names = null,
        ?int $options = null,
        ?\ck/plenty-client\Model\RestPropertiesGroupsPostRequest $_rest_properties_groups = null,
        string $contentType = self::contentTypes['restPropertiesGroupsPost'][0]
    ): \ck/plenty-client\Model\PropertyGroup
    {
        list($response) = $this->restPropertiesGroupsPostWithHttpInfo($position, $names, $options, $_rest_properties_groups, $contentType);
        return $response;
    }

    /**
     * Operation restPropertiesGroupsPostWithHttpInfo
     *
     * Create a property group
     *
     * @param  int $position The position  of the group (required)
     * @param  int|null $names The names of the group. (optional)
     * @param  int|null $options The options of the group (optional)
     * @param  \ck/plenty-client\Model\RestPropertiesGroupsPostRequest|null $_rest_properties_groups (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\PropertyGroup, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesGroupsPostWithHttpInfo(
        int $position,
        ?int $names = null,
        ?int $options = null,
        ?\ck/plenty-client\Model\RestPropertiesGroupsPostRequest $_rest_properties_groups = null,
        string $contentType = self::contentTypes['restPropertiesGroupsPost'][0]
    ): array
    {
        $request = $this->restPropertiesGroupsPostRequest($position, $names, $options, $_rest_properties_groups, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\PropertyGroup' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\PropertyGroup' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\PropertyGroup', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\PropertyGroup';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\PropertyGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesGroupsPostAsync
     *
     * Create a property group
     *
     * @param  int $position The position  of the group (required)
     * @param  int|null $names The names of the group. (optional)
     * @param  int|null $options The options of the group (optional)
     * @param  \ck/plenty-client\Model\RestPropertiesGroupsPostRequest|null $_rest_properties_groups (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesGroupsPostAsync(
        int $position,
        ?int $names = null,
        ?int $options = null,
        ?\ck/plenty-client\Model\RestPropertiesGroupsPostRequest $_rest_properties_groups = null,
        string $contentType = self::contentTypes['restPropertiesGroupsPost'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesGroupsPostAsyncWithHttpInfo($position, $names, $options, $_rest_properties_groups, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesGroupsPostAsyncWithHttpInfo
     *
     * Create a property group
     *
     * @param  int $position The position  of the group (required)
     * @param  int|null $names The names of the group. (optional)
     * @param  int|null $options The options of the group (optional)
     * @param  \ck/plenty-client\Model\RestPropertiesGroupsPostRequest|null $_rest_properties_groups (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesGroupsPostAsyncWithHttpInfo(
        $position,
        $names = null,
        $options = null,
        $_rest_properties_groups = null,
        string $contentType = self::contentTypes['restPropertiesGroupsPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\PropertyGroup';
        $request = $this->restPropertiesGroupsPostRequest($position, $names, $options, $_rest_properties_groups, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesGroupsPost'
     *
     * @param  int $position The position  of the group (required)
     * @param  int|null $names The names of the group. (optional)
     * @param  int|null $options The options of the group (optional)
     * @param  \ck/plenty-client\Model\RestPropertiesGroupsPostRequest|null $_rest_properties_groups (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesGroupsPostRequest(
        $position,
        $names = null,
        $options = null,
        $_rest_properties_groups = null,
        string $contentType = self::contentTypes['restPropertiesGroupsPost'][0]
    ): Request
    {

        // verify the required parameter 'position' is set
        if ($position === null || (is_array($position) && count($position) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $position when calling restPropertiesGroupsPost'
            );
        }





        $resourcePath = '/rest/properties/groups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $position,
            'position', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $names,
            'names', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $options,
            'options', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_properties_groups)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_properties_groups));
            } else {
                $httpBody = $_rest_properties_groups;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesGroupsPropertyIdDelete
     *
     * Delete a property group
     *
     * @param  int $group_id The ID of the group (required)
     * @param  int $property_id property_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsPropertyIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restPropertiesGroupsPropertyIdDelete(
        int $group_id,
        int $property_id,
        string $contentType = self::contentTypes['restPropertiesGroupsPropertyIdDelete'][0]
    ): void
    {
        $this->restPropertiesGroupsPropertyIdDeleteWithHttpInfo($group_id, $property_id, $contentType);
    }

    /**
     * Operation restPropertiesGroupsPropertyIdDeleteWithHttpInfo
     *
     * Delete a property group
     *
     * @param  int $group_id The ID of the group (required)
     * @param  int $property_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsPropertyIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesGroupsPropertyIdDeleteWithHttpInfo(
        int $group_id,
        int $property_id,
        string $contentType = self::contentTypes['restPropertiesGroupsPropertyIdDelete'][0]
    ): array
    {
        $request = $this->restPropertiesGroupsPropertyIdDeleteRequest($group_id, $property_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesGroupsPropertyIdDeleteAsync
     *
     * Delete a property group
     *
     * @param  int $group_id The ID of the group (required)
     * @param  int $property_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsPropertyIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesGroupsPropertyIdDeleteAsync(
        int $group_id,
        int $property_id,
        string $contentType = self::contentTypes['restPropertiesGroupsPropertyIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesGroupsPropertyIdDeleteAsyncWithHttpInfo($group_id, $property_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesGroupsPropertyIdDeleteAsyncWithHttpInfo
     *
     * Delete a property group
     *
     * @param  int $group_id The ID of the group (required)
     * @param  int $property_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsPropertyIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesGroupsPropertyIdDeleteAsyncWithHttpInfo(
        $group_id,
        $property_id,
        string $contentType = self::contentTypes['restPropertiesGroupsPropertyIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restPropertiesGroupsPropertyIdDeleteRequest($group_id, $property_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesGroupsPropertyIdDelete'
     *
     * @param  int $group_id The ID of the group (required)
     * @param  int $property_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsPropertyIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesGroupsPropertyIdDeleteRequest(
        $group_id,
        $property_id,
        string $contentType = self::contentTypes['restPropertiesGroupsPropertyIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $group_id when calling restPropertiesGroupsPropertyIdDelete'
            );
        }

        // verify the required parameter 'property_id' is set
        if ($property_id === null || (is_array($property_id) && count($property_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $property_id when calling restPropertiesGroupsPropertyIdDelete'
            );
        }


        $resourcePath = '/rest/properties/groups/{propertyId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group_id,
            'groupId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);


        // path params
        if ($property_id !== null) {
            $resourcePath = str_replace(
                '{' . 'propertyId' . '}',
                ObjectSerializer::toPathValue($property_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesGroupsSurchargeTypesGet
     *
     * Get surcharge types from module configuration
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsSurchargeTypesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restPropertiesGroupsSurchargeTypesGet(
        string $contentType = self::contentTypes['restPropertiesGroupsSurchargeTypesGet'][0]
    ): void
    {
        $this->restPropertiesGroupsSurchargeTypesGetWithHttpInfo($contentType);
    }

    /**
     * Operation restPropertiesGroupsSurchargeTypesGetWithHttpInfo
     *
     * Get surcharge types from module configuration
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsSurchargeTypesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesGroupsSurchargeTypesGetWithHttpInfo(
        string $contentType = self::contentTypes['restPropertiesGroupsSurchargeTypesGet'][0]
    ): array
    {
        $request = $this->restPropertiesGroupsSurchargeTypesGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesGroupsSurchargeTypesGetAsync
     *
     * Get surcharge types from module configuration
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsSurchargeTypesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesGroupsSurchargeTypesGetAsync(
        string $contentType = self::contentTypes['restPropertiesGroupsSurchargeTypesGet'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesGroupsSurchargeTypesGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesGroupsSurchargeTypesGetAsyncWithHttpInfo
     *
     * Get surcharge types from module configuration
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsSurchargeTypesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesGroupsSurchargeTypesGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restPropertiesGroupsSurchargeTypesGet'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restPropertiesGroupsSurchargeTypesGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesGroupsSurchargeTypesGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsSurchargeTypesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesGroupsSurchargeTypesGetRequest(
        string $contentType = self::contentTypes['restPropertiesGroupsSurchargeTypesGet'][0]
    ): Request
    {


        $resourcePath = '/rest/properties/groups/surcharge/types';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesGroupsTypesGet
     *
     * Get group types from module configuration
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsTypesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restPropertiesGroupsTypesGet(
        string $contentType = self::contentTypes['restPropertiesGroupsTypesGet'][0]
    ): void
    {
        $this->restPropertiesGroupsTypesGetWithHttpInfo($contentType);
    }

    /**
     * Operation restPropertiesGroupsTypesGetWithHttpInfo
     *
     * Get group types from module configuration
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsTypesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesGroupsTypesGetWithHttpInfo(
        string $contentType = self::contentTypes['restPropertiesGroupsTypesGet'][0]
    ): array
    {
        $request = $this->restPropertiesGroupsTypesGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesGroupsTypesGetAsync
     *
     * Get group types from module configuration
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsTypesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesGroupsTypesGetAsync(
        string $contentType = self::contentTypes['restPropertiesGroupsTypesGet'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesGroupsTypesGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesGroupsTypesGetAsyncWithHttpInfo
     *
     * Get group types from module configuration
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsTypesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesGroupsTypesGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restPropertiesGroupsTypesGet'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restPropertiesGroupsTypesGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesGroupsTypesGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesGroupsTypesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesGroupsTypesGetRequest(
        string $contentType = self::contentTypes['restPropertiesGroupsTypesGet'][0]
    ): Request
    {


        $resourcePath = '/rest/properties/groups/types';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesMarketsGet
     *
     * List property markets
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesMarketsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\PropertyMarket[]
     */
    public function restPropertiesMarketsGet(
        string $contentType = self::contentTypes['restPropertiesMarketsGet'][0]
    ): array
    {
        list($response) = $this->restPropertiesMarketsGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restPropertiesMarketsGetWithHttpInfo
     *
     * List property markets
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesMarketsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\PropertyMarket[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesMarketsGetWithHttpInfo(
        string $contentType = self::contentTypes['restPropertiesMarketsGet'][0]
    ): array
    {
        $request = $this->restPropertiesMarketsGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\PropertyMarket[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\PropertyMarket[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\PropertyMarket[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\PropertyMarket[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\PropertyMarket[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesMarketsGetAsync
     *
     * List property markets
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesMarketsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesMarketsGetAsync(
        string $contentType = self::contentTypes['restPropertiesMarketsGet'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesMarketsGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesMarketsGetAsyncWithHttpInfo
     *
     * List property markets
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesMarketsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesMarketsGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restPropertiesMarketsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\PropertyMarket[]';
        $request = $this->restPropertiesMarketsGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesMarketsGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesMarketsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesMarketsGetRequest(
        string $contentType = self::contentTypes['restPropertiesMarketsGet'][0]
    ): Request
    {


        $resourcePath = '/rest/properties/markets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesMarketsPost
     *
     * Create a property market
     *
     * @param  int $property_id Property id (required)
     * @param  float $referrer_id The referrer id of the property market (required)
     * @param  int $referrer_sub_id The referrer sub id of the property market (required)
     * @param  string $value The value of the property market (required)
     * @param  \ck/plenty-client\Model\RestPropertiesMarketsPostRequest|null $_rest_properties_markets _rest_properties_markets (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesMarketsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\PropertyMarket
     */
    public function restPropertiesMarketsPost(
        int $property_id,
        float $referrer_id,
        int $referrer_sub_id,
        string $value,
        ?\ck/plenty-client\Model\RestPropertiesMarketsPostRequest $_rest_properties_markets = null,
        string $contentType = self::contentTypes['restPropertiesMarketsPost'][0]
    ): \ck/plenty-client\Model\PropertyMarket
    {
        list($response) = $this->restPropertiesMarketsPostWithHttpInfo($property_id, $referrer_id, $referrer_sub_id, $value, $_rest_properties_markets, $contentType);
        return $response;
    }

    /**
     * Operation restPropertiesMarketsPostWithHttpInfo
     *
     * Create a property market
     *
     * @param  int $property_id Property id (required)
     * @param  float $referrer_id The referrer id of the property market (required)
     * @param  int $referrer_sub_id The referrer sub id of the property market (required)
     * @param  string $value The value of the property market (required)
     * @param  \ck/plenty-client\Model\RestPropertiesMarketsPostRequest|null $_rest_properties_markets (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesMarketsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\PropertyMarket, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesMarketsPostWithHttpInfo(
        int $property_id,
        float $referrer_id,
        int $referrer_sub_id,
        string $value,
        ?\ck/plenty-client\Model\RestPropertiesMarketsPostRequest $_rest_properties_markets = null,
        string $contentType = self::contentTypes['restPropertiesMarketsPost'][0]
    ): array
    {
        $request = $this->restPropertiesMarketsPostRequest($property_id, $referrer_id, $referrer_sub_id, $value, $_rest_properties_markets, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\PropertyMarket' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\PropertyMarket' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\PropertyMarket', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\PropertyMarket';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\PropertyMarket',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesMarketsPostAsync
     *
     * Create a property market
     *
     * @param  int $property_id Property id (required)
     * @param  float $referrer_id The referrer id of the property market (required)
     * @param  int $referrer_sub_id The referrer sub id of the property market (required)
     * @param  string $value The value of the property market (required)
     * @param  \ck/plenty-client\Model\RestPropertiesMarketsPostRequest|null $_rest_properties_markets (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesMarketsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesMarketsPostAsync(
        int $property_id,
        float $referrer_id,
        int $referrer_sub_id,
        string $value,
        ?\ck/plenty-client\Model\RestPropertiesMarketsPostRequest $_rest_properties_markets = null,
        string $contentType = self::contentTypes['restPropertiesMarketsPost'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesMarketsPostAsyncWithHttpInfo($property_id, $referrer_id, $referrer_sub_id, $value, $_rest_properties_markets, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesMarketsPostAsyncWithHttpInfo
     *
     * Create a property market
     *
     * @param  int $property_id Property id (required)
     * @param  float $referrer_id The referrer id of the property market (required)
     * @param  int $referrer_sub_id The referrer sub id of the property market (required)
     * @param  string $value The value of the property market (required)
     * @param  \ck/plenty-client\Model\RestPropertiesMarketsPostRequest|null $_rest_properties_markets (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesMarketsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesMarketsPostAsyncWithHttpInfo(
        $property_id,
        $referrer_id,
        $referrer_sub_id,
        $value,
        $_rest_properties_markets = null,
        string $contentType = self::contentTypes['restPropertiesMarketsPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\PropertyMarket';
        $request = $this->restPropertiesMarketsPostRequest($property_id, $referrer_id, $referrer_sub_id, $value, $_rest_properties_markets, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesMarketsPost'
     *
     * @param  int $property_id Property id (required)
     * @param  float $referrer_id The referrer id of the property market (required)
     * @param  int $referrer_sub_id The referrer sub id of the property market (required)
     * @param  string $value The value of the property market (required)
     * @param  \ck/plenty-client\Model\RestPropertiesMarketsPostRequest|null $_rest_properties_markets (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesMarketsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesMarketsPostRequest(
        $property_id,
        $referrer_id,
        $referrer_sub_id,
        $value,
        $_rest_properties_markets = null,
        string $contentType = self::contentTypes['restPropertiesMarketsPost'][0]
    ): Request
    {

        // verify the required parameter 'property_id' is set
        if ($property_id === null || (is_array($property_id) && count($property_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $property_id when calling restPropertiesMarketsPost'
            );
        }

        // verify the required parameter 'referrer_id' is set
        if ($referrer_id === null || (is_array($referrer_id) && count($referrer_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $referrer_id when calling restPropertiesMarketsPost'
            );
        }

        // verify the required parameter 'referrer_sub_id' is set
        if ($referrer_sub_id === null || (is_array($referrer_sub_id) && count($referrer_sub_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $referrer_sub_id when calling restPropertiesMarketsPost'
            );
        }

        // verify the required parameter 'value' is set
        if ($value === null || (is_array($value) && count($value) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $value when calling restPropertiesMarketsPost'
            );
        }



        $resourcePath = '/rest/properties/markets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $property_id,
            'propertyId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $referrer_id,
            'referrerId', // param base name
            'number', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $referrer_sub_id,
            'referrerSubId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $value,
            'value', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_properties_markets)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_properties_markets));
            } else {
                $httpBody = $_rest_properties_markets;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesMarketsPropertiesMarketIdDelete
     *
     * Delete a property market
     *
     * @param  int $property_market_id The ID of the property market (required)
     * @param  int $properties_market_id properties_market_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesMarketsPropertiesMarketIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restPropertiesMarketsPropertiesMarketIdDelete(
        int $property_market_id,
        int $properties_market_id,
        string $contentType = self::contentTypes['restPropertiesMarketsPropertiesMarketIdDelete'][0]
    ): void
    {
        $this->restPropertiesMarketsPropertiesMarketIdDeleteWithHttpInfo($property_market_id, $properties_market_id, $contentType);
    }

    /**
     * Operation restPropertiesMarketsPropertiesMarketIdDeleteWithHttpInfo
     *
     * Delete a property market
     *
     * @param  int $property_market_id The ID of the property market (required)
     * @param  int $properties_market_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesMarketsPropertiesMarketIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesMarketsPropertiesMarketIdDeleteWithHttpInfo(
        int $property_market_id,
        int $properties_market_id,
        string $contentType = self::contentTypes['restPropertiesMarketsPropertiesMarketIdDelete'][0]
    ): array
    {
        $request = $this->restPropertiesMarketsPropertiesMarketIdDeleteRequest($property_market_id, $properties_market_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesMarketsPropertiesMarketIdDeleteAsync
     *
     * Delete a property market
     *
     * @param  int $property_market_id The ID of the property market (required)
     * @param  int $properties_market_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesMarketsPropertiesMarketIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesMarketsPropertiesMarketIdDeleteAsync(
        int $property_market_id,
        int $properties_market_id,
        string $contentType = self::contentTypes['restPropertiesMarketsPropertiesMarketIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesMarketsPropertiesMarketIdDeleteAsyncWithHttpInfo($property_market_id, $properties_market_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesMarketsPropertiesMarketIdDeleteAsyncWithHttpInfo
     *
     * Delete a property market
     *
     * @param  int $property_market_id The ID of the property market (required)
     * @param  int $properties_market_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesMarketsPropertiesMarketIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesMarketsPropertiesMarketIdDeleteAsyncWithHttpInfo(
        $property_market_id,
        $properties_market_id,
        string $contentType = self::contentTypes['restPropertiesMarketsPropertiesMarketIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restPropertiesMarketsPropertiesMarketIdDeleteRequest($property_market_id, $properties_market_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesMarketsPropertiesMarketIdDelete'
     *
     * @param  int $property_market_id The ID of the property market (required)
     * @param  int $properties_market_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesMarketsPropertiesMarketIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesMarketsPropertiesMarketIdDeleteRequest(
        $property_market_id,
        $properties_market_id,
        string $contentType = self::contentTypes['restPropertiesMarketsPropertiesMarketIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'property_market_id' is set
        if ($property_market_id === null || (is_array($property_market_id) && count($property_market_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $property_market_id when calling restPropertiesMarketsPropertiesMarketIdDelete'
            );
        }

        // verify the required parameter 'properties_market_id' is set
        if ($properties_market_id === null || (is_array($properties_market_id) && count($properties_market_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $properties_market_id when calling restPropertiesMarketsPropertiesMarketIdDelete'
            );
        }


        $resourcePath = '/rest/properties/markets/{propertiesMarketId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $property_market_id,
            'propertyMarketId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);


        // path params
        if ($properties_market_id !== null) {
            $resourcePath = str_replace(
                '{' . 'propertiesMarketId' . '}',
                ObjectSerializer::toPathValue($properties_market_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesMarketsPropertiesMarketIdGet
     *
     * Get a property market
     *
     * @param  int $property_market_id The ID of the property market (required)
     * @param  int $properties_market_id properties_market_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesMarketsPropertiesMarketIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\PropertyMarket
     */
    public function restPropertiesMarketsPropertiesMarketIdGet(
        int $property_market_id,
        int $properties_market_id,
        string $contentType = self::contentTypes['restPropertiesMarketsPropertiesMarketIdGet'][0]
    ): \ck/plenty-client\Model\PropertyMarket
    {
        list($response) = $this->restPropertiesMarketsPropertiesMarketIdGetWithHttpInfo($property_market_id, $properties_market_id, $contentType);
        return $response;
    }

    /**
     * Operation restPropertiesMarketsPropertiesMarketIdGetWithHttpInfo
     *
     * Get a property market
     *
     * @param  int $property_market_id The ID of the property market (required)
     * @param  int $properties_market_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesMarketsPropertiesMarketIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\PropertyMarket, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesMarketsPropertiesMarketIdGetWithHttpInfo(
        int $property_market_id,
        int $properties_market_id,
        string $contentType = self::contentTypes['restPropertiesMarketsPropertiesMarketIdGet'][0]
    ): array
    {
        $request = $this->restPropertiesMarketsPropertiesMarketIdGetRequest($property_market_id, $properties_market_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\PropertyMarket' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\PropertyMarket' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\PropertyMarket', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\PropertyMarket';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\PropertyMarket',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesMarketsPropertiesMarketIdGetAsync
     *
     * Get a property market
     *
     * @param  int $property_market_id The ID of the property market (required)
     * @param  int $properties_market_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesMarketsPropertiesMarketIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesMarketsPropertiesMarketIdGetAsync(
        int $property_market_id,
        int $properties_market_id,
        string $contentType = self::contentTypes['restPropertiesMarketsPropertiesMarketIdGet'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesMarketsPropertiesMarketIdGetAsyncWithHttpInfo($property_market_id, $properties_market_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesMarketsPropertiesMarketIdGetAsyncWithHttpInfo
     *
     * Get a property market
     *
     * @param  int $property_market_id The ID of the property market (required)
     * @param  int $properties_market_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesMarketsPropertiesMarketIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesMarketsPropertiesMarketIdGetAsyncWithHttpInfo(
        $property_market_id,
        $properties_market_id,
        string $contentType = self::contentTypes['restPropertiesMarketsPropertiesMarketIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\PropertyMarket';
        $request = $this->restPropertiesMarketsPropertiesMarketIdGetRequest($property_market_id, $properties_market_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesMarketsPropertiesMarketIdGet'
     *
     * @param  int $property_market_id The ID of the property market (required)
     * @param  int $properties_market_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesMarketsPropertiesMarketIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesMarketsPropertiesMarketIdGetRequest(
        $property_market_id,
        $properties_market_id,
        string $contentType = self::contentTypes['restPropertiesMarketsPropertiesMarketIdGet'][0]
    ): Request
    {

        // verify the required parameter 'property_market_id' is set
        if ($property_market_id === null || (is_array($property_market_id) && count($property_market_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $property_market_id when calling restPropertiesMarketsPropertiesMarketIdGet'
            );
        }

        // verify the required parameter 'properties_market_id' is set
        if ($properties_market_id === null || (is_array($properties_market_id) && count($properties_market_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $properties_market_id when calling restPropertiesMarketsPropertiesMarketIdGet'
            );
        }


        $resourcePath = '/rest/properties/markets/{propertiesMarketId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $property_market_id,
            'propertyMarketId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);


        // path params
        if ($properties_market_id !== null) {
            $resourcePath = str_replace(
                '{' . 'propertiesMarketId' . '}',
                ObjectSerializer::toPathValue($properties_market_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesMarketsPropertiesMarketIdPut
     *
     * Update a property market
     *
     * @param  int $properties_market_id properties_market_id (required)
     * @param  \ck/plenty-client\Model\RestPropertiesMarketsPropertiesMarketIdPutRequest|null $_rest_properties_markets_properties_market_id _rest_properties_markets_properties_market_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesMarketsPropertiesMarketIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\PropertyMarket
     */
    public function restPropertiesMarketsPropertiesMarketIdPut(
        int $properties_market_id,
        ?\ck/plenty-client\Model\RestPropertiesMarketsPropertiesMarketIdPutRequest $_rest_properties_markets_properties_market_id = null,
        string $contentType = self::contentTypes['restPropertiesMarketsPropertiesMarketIdPut'][0]
    ): \ck/plenty-client\Model\PropertyMarket
    {
        list($response) = $this->restPropertiesMarketsPropertiesMarketIdPutWithHttpInfo($properties_market_id, $_rest_properties_markets_properties_market_id, $contentType);
        return $response;
    }

    /**
     * Operation restPropertiesMarketsPropertiesMarketIdPutWithHttpInfo
     *
     * Update a property market
     *
     * @param  int $properties_market_id (required)
     * @param  \ck/plenty-client\Model\RestPropertiesMarketsPropertiesMarketIdPutRequest|null $_rest_properties_markets_properties_market_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesMarketsPropertiesMarketIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\PropertyMarket, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesMarketsPropertiesMarketIdPutWithHttpInfo(
        int $properties_market_id,
        ?\ck/plenty-client\Model\RestPropertiesMarketsPropertiesMarketIdPutRequest $_rest_properties_markets_properties_market_id = null,
        string $contentType = self::contentTypes['restPropertiesMarketsPropertiesMarketIdPut'][0]
    ): array
    {
        $request = $this->restPropertiesMarketsPropertiesMarketIdPutRequest($properties_market_id, $_rest_properties_markets_properties_market_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\PropertyMarket' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\PropertyMarket' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\PropertyMarket', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\PropertyMarket';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\PropertyMarket',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesMarketsPropertiesMarketIdPutAsync
     *
     * Update a property market
     *
     * @param  int $properties_market_id (required)
     * @param  \ck/plenty-client\Model\RestPropertiesMarketsPropertiesMarketIdPutRequest|null $_rest_properties_markets_properties_market_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesMarketsPropertiesMarketIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesMarketsPropertiesMarketIdPutAsync(
        int $properties_market_id,
        ?\ck/plenty-client\Model\RestPropertiesMarketsPropertiesMarketIdPutRequest $_rest_properties_markets_properties_market_id = null,
        string $contentType = self::contentTypes['restPropertiesMarketsPropertiesMarketIdPut'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesMarketsPropertiesMarketIdPutAsyncWithHttpInfo($properties_market_id, $_rest_properties_markets_properties_market_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesMarketsPropertiesMarketIdPutAsyncWithHttpInfo
     *
     * Update a property market
     *
     * @param  int $properties_market_id (required)
     * @param  \ck/plenty-client\Model\RestPropertiesMarketsPropertiesMarketIdPutRequest|null $_rest_properties_markets_properties_market_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesMarketsPropertiesMarketIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesMarketsPropertiesMarketIdPutAsyncWithHttpInfo(
        $properties_market_id,
        $_rest_properties_markets_properties_market_id = null,
        string $contentType = self::contentTypes['restPropertiesMarketsPropertiesMarketIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\PropertyMarket';
        $request = $this->restPropertiesMarketsPropertiesMarketIdPutRequest($properties_market_id, $_rest_properties_markets_properties_market_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesMarketsPropertiesMarketIdPut'
     *
     * @param  int $properties_market_id (required)
     * @param  \ck/plenty-client\Model\RestPropertiesMarketsPropertiesMarketIdPutRequest|null $_rest_properties_markets_properties_market_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesMarketsPropertiesMarketIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesMarketsPropertiesMarketIdPutRequest(
        $properties_market_id,
        $_rest_properties_markets_properties_market_id = null,
        string $contentType = self::contentTypes['restPropertiesMarketsPropertiesMarketIdPut'][0]
    ): Request
    {

        // verify the required parameter 'properties_market_id' is set
        if ($properties_market_id === null || (is_array($properties_market_id) && count($properties_market_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $properties_market_id when calling restPropertiesMarketsPropertiesMarketIdPut'
            );
        }



        $resourcePath = '/rest/properties/markets/{propertiesMarketId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($properties_market_id !== null) {
            $resourcePath = str_replace(
                '{' . 'propertiesMarketId' . '}',
                ObjectSerializer::toPathValue($properties_market_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_properties_markets_properties_market_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_properties_markets_properties_market_id));
            } else {
                $httpBody = $_rest_properties_markets_properties_market_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesMultipleOptionsDelete
     *
     * Delete property options
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesMultipleOptionsDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restPropertiesMultipleOptionsDelete(
        string $contentType = self::contentTypes['restPropertiesMultipleOptionsDelete'][0]
    ): void
    {
        $this->restPropertiesMultipleOptionsDeleteWithHttpInfo($contentType);
    }

    /**
     * Operation restPropertiesMultipleOptionsDeleteWithHttpInfo
     *
     * Delete property options
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesMultipleOptionsDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesMultipleOptionsDeleteWithHttpInfo(
        string $contentType = self::contentTypes['restPropertiesMultipleOptionsDelete'][0]
    ): array
    {
        $request = $this->restPropertiesMultipleOptionsDeleteRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesMultipleOptionsDeleteAsync
     *
     * Delete property options
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesMultipleOptionsDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesMultipleOptionsDeleteAsync(
        string $contentType = self::contentTypes['restPropertiesMultipleOptionsDelete'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesMultipleOptionsDeleteAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesMultipleOptionsDeleteAsyncWithHttpInfo
     *
     * Delete property options
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesMultipleOptionsDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesMultipleOptionsDeleteAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restPropertiesMultipleOptionsDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restPropertiesMultipleOptionsDeleteRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesMultipleOptionsDelete'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesMultipleOptionsDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesMultipleOptionsDeleteRequest(
        string $contentType = self::contentTypes['restPropertiesMultipleOptionsDelete'][0]
    ): Request
    {


        $resourcePath = '/rest/properties/multiple/options';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesMultipleOptionsPost
     *
     * Create property options
     *
     * @param  int $property_id ID of the property (required)
     * @param  string $type_option_identifier The identifier of the property option type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesMultipleOptionsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\PropertyOption
     */
    public function restPropertiesMultipleOptionsPost(
        int $property_id,
        string $type_option_identifier,
        string $contentType = self::contentTypes['restPropertiesMultipleOptionsPost'][0]
    ): \ck/plenty-client\Model\PropertyOption
    {
        list($response) = $this->restPropertiesMultipleOptionsPostWithHttpInfo($property_id, $type_option_identifier, $contentType);
        return $response;
    }

    /**
     * Operation restPropertiesMultipleOptionsPostWithHttpInfo
     *
     * Create property options
     *
     * @param  int $property_id ID of the property (required)
     * @param  string $type_option_identifier The identifier of the property option type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesMultipleOptionsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\PropertyOption, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesMultipleOptionsPostWithHttpInfo(
        int $property_id,
        string $type_option_identifier,
        string $contentType = self::contentTypes['restPropertiesMultipleOptionsPost'][0]
    ): array
    {
        $request = $this->restPropertiesMultipleOptionsPostRequest($property_id, $type_option_identifier, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\PropertyOption' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\PropertyOption' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\PropertyOption', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\PropertyOption';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\PropertyOption',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesMultipleOptionsPostAsync
     *
     * Create property options
     *
     * @param  int $property_id ID of the property (required)
     * @param  string $type_option_identifier The identifier of the property option type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesMultipleOptionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesMultipleOptionsPostAsync(
        int $property_id,
        string $type_option_identifier,
        string $contentType = self::contentTypes['restPropertiesMultipleOptionsPost'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesMultipleOptionsPostAsyncWithHttpInfo($property_id, $type_option_identifier, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesMultipleOptionsPostAsyncWithHttpInfo
     *
     * Create property options
     *
     * @param  int $property_id ID of the property (required)
     * @param  string $type_option_identifier The identifier of the property option type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesMultipleOptionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesMultipleOptionsPostAsyncWithHttpInfo(
        $property_id,
        $type_option_identifier,
        string $contentType = self::contentTypes['restPropertiesMultipleOptionsPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\PropertyOption';
        $request = $this->restPropertiesMultipleOptionsPostRequest($property_id, $type_option_identifier, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesMultipleOptionsPost'
     *
     * @param  int $property_id ID of the property (required)
     * @param  string $type_option_identifier The identifier of the property option type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesMultipleOptionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesMultipleOptionsPostRequest(
        $property_id,
        $type_option_identifier,
        string $contentType = self::contentTypes['restPropertiesMultipleOptionsPost'][0]
    ): Request
    {

        // verify the required parameter 'property_id' is set
        if ($property_id === null || (is_array($property_id) && count($property_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $property_id when calling restPropertiesMultipleOptionsPost'
            );
        }

        // verify the required parameter 'type_option_identifier' is set
        if ($type_option_identifier === null || (is_array($type_option_identifier) && count($type_option_identifier) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $type_option_identifier when calling restPropertiesMultipleOptionsPost'
            );
        }


        $resourcePath = '/rest/properties/multiple/options';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $property_id,
            'propertyId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type_option_identifier,
            'typeOptionIdentifier', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesNamesGet
     *
     * List names
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesNamesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\PropertyName[]
     */
    public function restPropertiesNamesGet(
        string $contentType = self::contentTypes['restPropertiesNamesGet'][0]
    ): array
    {
        list($response) = $this->restPropertiesNamesGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restPropertiesNamesGetWithHttpInfo
     *
     * List names
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesNamesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\PropertyName[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesNamesGetWithHttpInfo(
        string $contentType = self::contentTypes['restPropertiesNamesGet'][0]
    ): array
    {
        $request = $this->restPropertiesNamesGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\PropertyName[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\PropertyName[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\PropertyName[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\PropertyName[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\PropertyName[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesNamesGetAsync
     *
     * List names
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesNamesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesNamesGetAsync(
        string $contentType = self::contentTypes['restPropertiesNamesGet'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesNamesGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesNamesGetAsyncWithHttpInfo
     *
     * List names
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesNamesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesNamesGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restPropertiesNamesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\PropertyName[]';
        $request = $this->restPropertiesNamesGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesNamesGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesNamesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesNamesGetRequest(
        string $contentType = self::contentTypes['restPropertiesNamesGet'][0]
    ): Request
    {


        $resourcePath = '/rest/properties/names';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesNamesNameIdDelete
     *
     * Delete a property name
     *
     * @param  int $name_id The ID of the property name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesNamesNameIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restPropertiesNamesNameIdDelete(
        int $name_id,
        string $contentType = self::contentTypes['restPropertiesNamesNameIdDelete'][0]
    ): void
    {
        $this->restPropertiesNamesNameIdDeleteWithHttpInfo($name_id, $contentType);
    }

    /**
     * Operation restPropertiesNamesNameIdDeleteWithHttpInfo
     *
     * Delete a property name
     *
     * @param  int $name_id The ID of the property name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesNamesNameIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesNamesNameIdDeleteWithHttpInfo(
        int $name_id,
        string $contentType = self::contentTypes['restPropertiesNamesNameIdDelete'][0]
    ): array
    {
        $request = $this->restPropertiesNamesNameIdDeleteRequest($name_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesNamesNameIdDeleteAsync
     *
     * Delete a property name
     *
     * @param  int $name_id The ID of the property name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesNamesNameIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesNamesNameIdDeleteAsync(
        int $name_id,
        string $contentType = self::contentTypes['restPropertiesNamesNameIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesNamesNameIdDeleteAsyncWithHttpInfo($name_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesNamesNameIdDeleteAsyncWithHttpInfo
     *
     * Delete a property name
     *
     * @param  int $name_id The ID of the property name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesNamesNameIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesNamesNameIdDeleteAsyncWithHttpInfo(
        $name_id,
        string $contentType = self::contentTypes['restPropertiesNamesNameIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restPropertiesNamesNameIdDeleteRequest($name_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesNamesNameIdDelete'
     *
     * @param  int $name_id The ID of the property name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesNamesNameIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesNamesNameIdDeleteRequest(
        $name_id,
        string $contentType = self::contentTypes['restPropertiesNamesNameIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'name_id' is set
        if ($name_id === null || (is_array($name_id) && count($name_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $name_id when calling restPropertiesNamesNameIdDelete'
            );
        }


        $resourcePath = '/rest/properties/names/{nameId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($name_id !== null) {
            $resourcePath = str_replace(
                '{' . 'nameId' . '}',
                ObjectSerializer::toPathValue($name_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesNamesNameIdGet
     *
     * Get a property name
     *
     * @param  int $name_id The ID of the property name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesNamesNameIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\PropertyName
     */
    public function restPropertiesNamesNameIdGet(
        int $name_id,
        string $contentType = self::contentTypes['restPropertiesNamesNameIdGet'][0]
    ): \ck/plenty-client\Model\PropertyName
    {
        list($response) = $this->restPropertiesNamesNameIdGetWithHttpInfo($name_id, $contentType);
        return $response;
    }

    /**
     * Operation restPropertiesNamesNameIdGetWithHttpInfo
     *
     * Get a property name
     *
     * @param  int $name_id The ID of the property name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesNamesNameIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\PropertyName, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesNamesNameIdGetWithHttpInfo(
        int $name_id,
        string $contentType = self::contentTypes['restPropertiesNamesNameIdGet'][0]
    ): array
    {
        $request = $this->restPropertiesNamesNameIdGetRequest($name_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\PropertyName' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\PropertyName' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\PropertyName', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\PropertyName';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\PropertyName',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesNamesNameIdGetAsync
     *
     * Get a property name
     *
     * @param  int $name_id The ID of the property name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesNamesNameIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesNamesNameIdGetAsync(
        int $name_id,
        string $contentType = self::contentTypes['restPropertiesNamesNameIdGet'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesNamesNameIdGetAsyncWithHttpInfo($name_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesNamesNameIdGetAsyncWithHttpInfo
     *
     * Get a property name
     *
     * @param  int $name_id The ID of the property name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesNamesNameIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesNamesNameIdGetAsyncWithHttpInfo(
        $name_id,
        string $contentType = self::contentTypes['restPropertiesNamesNameIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\PropertyName';
        $request = $this->restPropertiesNamesNameIdGetRequest($name_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesNamesNameIdGet'
     *
     * @param  int $name_id The ID of the property name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesNamesNameIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesNamesNameIdGetRequest(
        $name_id,
        string $contentType = self::contentTypes['restPropertiesNamesNameIdGet'][0]
    ): Request
    {

        // verify the required parameter 'name_id' is set
        if ($name_id === null || (is_array($name_id) && count($name_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $name_id when calling restPropertiesNamesNameIdGet'
            );
        }


        $resourcePath = '/rest/properties/names/{nameId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($name_id !== null) {
            $resourcePath = str_replace(
                '{' . 'nameId' . '}',
                ObjectSerializer::toPathValue($name_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesNamesNameIdPut
     *
     * Update a property name
     *
     * @param  int $name_id The ID of the property name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesNamesNameIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\PropertyName
     */
    public function restPropertiesNamesNameIdPut(
        int $name_id,
        string $contentType = self::contentTypes['restPropertiesNamesNameIdPut'][0]
    ): \ck/plenty-client\Model\PropertyName
    {
        list($response) = $this->restPropertiesNamesNameIdPutWithHttpInfo($name_id, $contentType);
        return $response;
    }

    /**
     * Operation restPropertiesNamesNameIdPutWithHttpInfo
     *
     * Update a property name
     *
     * @param  int $name_id The ID of the property name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesNamesNameIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\PropertyName, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesNamesNameIdPutWithHttpInfo(
        int $name_id,
        string $contentType = self::contentTypes['restPropertiesNamesNameIdPut'][0]
    ): array
    {
        $request = $this->restPropertiesNamesNameIdPutRequest($name_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\PropertyName' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\PropertyName' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\PropertyName', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\PropertyName';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\PropertyName',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesNamesNameIdPutAsync
     *
     * Update a property name
     *
     * @param  int $name_id The ID of the property name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesNamesNameIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesNamesNameIdPutAsync(
        int $name_id,
        string $contentType = self::contentTypes['restPropertiesNamesNameIdPut'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesNamesNameIdPutAsyncWithHttpInfo($name_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesNamesNameIdPutAsyncWithHttpInfo
     *
     * Update a property name
     *
     * @param  int $name_id The ID of the property name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesNamesNameIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesNamesNameIdPutAsyncWithHttpInfo(
        $name_id,
        string $contentType = self::contentTypes['restPropertiesNamesNameIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\PropertyName';
        $request = $this->restPropertiesNamesNameIdPutRequest($name_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesNamesNameIdPut'
     *
     * @param  int $name_id The ID of the property name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesNamesNameIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesNamesNameIdPutRequest(
        $name_id,
        string $contentType = self::contentTypes['restPropertiesNamesNameIdPut'][0]
    ): Request
    {

        // verify the required parameter 'name_id' is set
        if ($name_id === null || (is_array($name_id) && count($name_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $name_id when calling restPropertiesNamesNameIdPut'
            );
        }


        $resourcePath = '/rest/properties/names/{nameId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($name_id !== null) {
            $resourcePath = str_replace(
                '{' . 'nameId' . '}',
                ObjectSerializer::toPathValue($name_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesNamesPost
     *
     * Create a name
     *
     * @param  int $property_id The id of the property name (required)
     * @param  string $lang The lang of the property name (required)
     * @param  string $name The name of the property name (required)
     * @param  string|null $description The description of the property name (optional)
     * @param  \ck/plenty-client\Model\RestPropertiesNamesPostRequest|null $_rest_properties_names _rest_properties_names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesNamesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\PropertyName
     */
    public function restPropertiesNamesPost(
        int $property_id,
        string $lang,
        string $name,
        ?string $description = null,
        ?\ck/plenty-client\Model\RestPropertiesNamesPostRequest $_rest_properties_names = null,
        string $contentType = self::contentTypes['restPropertiesNamesPost'][0]
    ): \ck/plenty-client\Model\PropertyName
    {
        list($response) = $this->restPropertiesNamesPostWithHttpInfo($property_id, $lang, $name, $description, $_rest_properties_names, $contentType);
        return $response;
    }

    /**
     * Operation restPropertiesNamesPostWithHttpInfo
     *
     * Create a name
     *
     * @param  int $property_id The id of the property name (required)
     * @param  string $lang The lang of the property name (required)
     * @param  string $name The name of the property name (required)
     * @param  string|null $description The description of the property name (optional)
     * @param  \ck/plenty-client\Model\RestPropertiesNamesPostRequest|null $_rest_properties_names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesNamesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\PropertyName, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesNamesPostWithHttpInfo(
        int $property_id,
        string $lang,
        string $name,
        ?string $description = null,
        ?\ck/plenty-client\Model\RestPropertiesNamesPostRequest $_rest_properties_names = null,
        string $contentType = self::contentTypes['restPropertiesNamesPost'][0]
    ): array
    {
        $request = $this->restPropertiesNamesPostRequest($property_id, $lang, $name, $description, $_rest_properties_names, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\PropertyName' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\PropertyName' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\PropertyName', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\PropertyName';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\PropertyName',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesNamesPostAsync
     *
     * Create a name
     *
     * @param  int $property_id The id of the property name (required)
     * @param  string $lang The lang of the property name (required)
     * @param  string $name The name of the property name (required)
     * @param  string|null $description The description of the property name (optional)
     * @param  \ck/plenty-client\Model\RestPropertiesNamesPostRequest|null $_rest_properties_names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesNamesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesNamesPostAsync(
        int $property_id,
        string $lang,
        string $name,
        ?string $description = null,
        ?\ck/plenty-client\Model\RestPropertiesNamesPostRequest $_rest_properties_names = null,
        string $contentType = self::contentTypes['restPropertiesNamesPost'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesNamesPostAsyncWithHttpInfo($property_id, $lang, $name, $description, $_rest_properties_names, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesNamesPostAsyncWithHttpInfo
     *
     * Create a name
     *
     * @param  int $property_id The id of the property name (required)
     * @param  string $lang The lang of the property name (required)
     * @param  string $name The name of the property name (required)
     * @param  string|null $description The description of the property name (optional)
     * @param  \ck/plenty-client\Model\RestPropertiesNamesPostRequest|null $_rest_properties_names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesNamesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesNamesPostAsyncWithHttpInfo(
        $property_id,
        $lang,
        $name,
        $description = null,
        $_rest_properties_names = null,
        string $contentType = self::contentTypes['restPropertiesNamesPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\PropertyName';
        $request = $this->restPropertiesNamesPostRequest($property_id, $lang, $name, $description, $_rest_properties_names, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesNamesPost'
     *
     * @param  int $property_id The id of the property name (required)
     * @param  string $lang The lang of the property name (required)
     * @param  string $name The name of the property name (required)
     * @param  string|null $description The description of the property name (optional)
     * @param  \ck/plenty-client\Model\RestPropertiesNamesPostRequest|null $_rest_properties_names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesNamesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesNamesPostRequest(
        $property_id,
        $lang,
        $name,
        $description = null,
        $_rest_properties_names = null,
        string $contentType = self::contentTypes['restPropertiesNamesPost'][0]
    ): Request
    {

        // verify the required parameter 'property_id' is set
        if ($property_id === null || (is_array($property_id) && count($property_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $property_id when calling restPropertiesNamesPost'
            );
        }

        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $lang when calling restPropertiesNamesPost'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $name when calling restPropertiesNamesPost'
            );
        }




        $resourcePath = '/rest/properties/names';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $property_id,
            'propertyId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $lang,
            'lang', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_properties_names)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_properties_names));
            } else {
                $httpBody = $_rest_properties_names;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesOptionsGet
     *
     * List property options
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesOptionsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\PropertyOption[]
     */
    public function restPropertiesOptionsGet(
        string $contentType = self::contentTypes['restPropertiesOptionsGet'][0]
    ): array
    {
        list($response) = $this->restPropertiesOptionsGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restPropertiesOptionsGetWithHttpInfo
     *
     * List property options
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesOptionsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\PropertyOption[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesOptionsGetWithHttpInfo(
        string $contentType = self::contentTypes['restPropertiesOptionsGet'][0]
    ): array
    {
        $request = $this->restPropertiesOptionsGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\PropertyOption[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\PropertyOption[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\PropertyOption[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\PropertyOption[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\PropertyOption[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesOptionsGetAsync
     *
     * List property options
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesOptionsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesOptionsGetAsync(
        string $contentType = self::contentTypes['restPropertiesOptionsGet'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesOptionsGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesOptionsGetAsyncWithHttpInfo
     *
     * List property options
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesOptionsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesOptionsGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restPropertiesOptionsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\PropertyOption[]';
        $request = $this->restPropertiesOptionsGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesOptionsGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesOptionsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesOptionsGetRequest(
        string $contentType = self::contentTypes['restPropertiesOptionsGet'][0]
    ): Request
    {


        $resourcePath = '/rest/properties/options';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesOptionsPost
     *
     * Create a property option
     *
     * @param  int $property_id ID of the property (required)
     * @param  string $type_option_identifier The identifier of the property option type (required)
     * @param  \ck/plenty-client\Model\RestPropertiesOptionsPostRequest|null $_rest_properties_options _rest_properties_options (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesOptionsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\PropertyOption
     */
    public function restPropertiesOptionsPost(
        int $property_id,
        string $type_option_identifier,
        ?\ck/plenty-client\Model\RestPropertiesOptionsPostRequest $_rest_properties_options = null,
        string $contentType = self::contentTypes['restPropertiesOptionsPost'][0]
    ): \ck/plenty-client\Model\PropertyOption
    {
        list($response) = $this->restPropertiesOptionsPostWithHttpInfo($property_id, $type_option_identifier, $_rest_properties_options, $contentType);
        return $response;
    }

    /**
     * Operation restPropertiesOptionsPostWithHttpInfo
     *
     * Create a property option
     *
     * @param  int $property_id ID of the property (required)
     * @param  string $type_option_identifier The identifier of the property option type (required)
     * @param  \ck/plenty-client\Model\RestPropertiesOptionsPostRequest|null $_rest_properties_options (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesOptionsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\PropertyOption, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesOptionsPostWithHttpInfo(
        int $property_id,
        string $type_option_identifier,
        ?\ck/plenty-client\Model\RestPropertiesOptionsPostRequest $_rest_properties_options = null,
        string $contentType = self::contentTypes['restPropertiesOptionsPost'][0]
    ): array
    {
        $request = $this->restPropertiesOptionsPostRequest($property_id, $type_option_identifier, $_rest_properties_options, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\PropertyOption' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\PropertyOption' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\PropertyOption', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\PropertyOption';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\PropertyOption',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesOptionsPostAsync
     *
     * Create a property option
     *
     * @param  int $property_id ID of the property (required)
     * @param  string $type_option_identifier The identifier of the property option type (required)
     * @param  \ck/plenty-client\Model\RestPropertiesOptionsPostRequest|null $_rest_properties_options (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesOptionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesOptionsPostAsync(
        int $property_id,
        string $type_option_identifier,
        ?\ck/plenty-client\Model\RestPropertiesOptionsPostRequest $_rest_properties_options = null,
        string $contentType = self::contentTypes['restPropertiesOptionsPost'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesOptionsPostAsyncWithHttpInfo($property_id, $type_option_identifier, $_rest_properties_options, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesOptionsPostAsyncWithHttpInfo
     *
     * Create a property option
     *
     * @param  int $property_id ID of the property (required)
     * @param  string $type_option_identifier The identifier of the property option type (required)
     * @param  \ck/plenty-client\Model\RestPropertiesOptionsPostRequest|null $_rest_properties_options (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesOptionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesOptionsPostAsyncWithHttpInfo(
        $property_id,
        $type_option_identifier,
        $_rest_properties_options = null,
        string $contentType = self::contentTypes['restPropertiesOptionsPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\PropertyOption';
        $request = $this->restPropertiesOptionsPostRequest($property_id, $type_option_identifier, $_rest_properties_options, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesOptionsPost'
     *
     * @param  int $property_id ID of the property (required)
     * @param  string $type_option_identifier The identifier of the property option type (required)
     * @param  \ck/plenty-client\Model\RestPropertiesOptionsPostRequest|null $_rest_properties_options (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesOptionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesOptionsPostRequest(
        $property_id,
        $type_option_identifier,
        $_rest_properties_options = null,
        string $contentType = self::contentTypes['restPropertiesOptionsPost'][0]
    ): Request
    {

        // verify the required parameter 'property_id' is set
        if ($property_id === null || (is_array($property_id) && count($property_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $property_id when calling restPropertiesOptionsPost'
            );
        }

        // verify the required parameter 'type_option_identifier' is set
        if ($type_option_identifier === null || (is_array($type_option_identifier) && count($type_option_identifier) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $type_option_identifier when calling restPropertiesOptionsPost'
            );
        }



        $resourcePath = '/rest/properties/options';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $property_id,
            'propertyId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type_option_identifier,
            'typeOptionIdentifier', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_properties_options)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_properties_options));
            } else {
                $httpBody = $_rest_properties_options;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesOptionsPropertyOptionIdDelete
     *
     * Delete a property option
     *
     * @param  int $property_option_id The ID of the property option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesOptionsPropertyOptionIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restPropertiesOptionsPropertyOptionIdDelete(
        int $property_option_id,
        string $contentType = self::contentTypes['restPropertiesOptionsPropertyOptionIdDelete'][0]
    ): void
    {
        $this->restPropertiesOptionsPropertyOptionIdDeleteWithHttpInfo($property_option_id, $contentType);
    }

    /**
     * Operation restPropertiesOptionsPropertyOptionIdDeleteWithHttpInfo
     *
     * Delete a property option
     *
     * @param  int $property_option_id The ID of the property option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesOptionsPropertyOptionIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesOptionsPropertyOptionIdDeleteWithHttpInfo(
        int $property_option_id,
        string $contentType = self::contentTypes['restPropertiesOptionsPropertyOptionIdDelete'][0]
    ): array
    {
        $request = $this->restPropertiesOptionsPropertyOptionIdDeleteRequest($property_option_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesOptionsPropertyOptionIdDeleteAsync
     *
     * Delete a property option
     *
     * @param  int $property_option_id The ID of the property option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesOptionsPropertyOptionIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesOptionsPropertyOptionIdDeleteAsync(
        int $property_option_id,
        string $contentType = self::contentTypes['restPropertiesOptionsPropertyOptionIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesOptionsPropertyOptionIdDeleteAsyncWithHttpInfo($property_option_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesOptionsPropertyOptionIdDeleteAsyncWithHttpInfo
     *
     * Delete a property option
     *
     * @param  int $property_option_id The ID of the property option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesOptionsPropertyOptionIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesOptionsPropertyOptionIdDeleteAsyncWithHttpInfo(
        $property_option_id,
        string $contentType = self::contentTypes['restPropertiesOptionsPropertyOptionIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restPropertiesOptionsPropertyOptionIdDeleteRequest($property_option_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesOptionsPropertyOptionIdDelete'
     *
     * @param  int $property_option_id The ID of the property option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesOptionsPropertyOptionIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesOptionsPropertyOptionIdDeleteRequest(
        $property_option_id,
        string $contentType = self::contentTypes['restPropertiesOptionsPropertyOptionIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'property_option_id' is set
        if ($property_option_id === null || (is_array($property_option_id) && count($property_option_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $property_option_id when calling restPropertiesOptionsPropertyOptionIdDelete'
            );
        }


        $resourcePath = '/rest/properties/options/{propertyOptionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($property_option_id !== null) {
            $resourcePath = str_replace(
                '{' . 'propertyOptionId' . '}',
                ObjectSerializer::toPathValue($property_option_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesOptionsPropertyOptionIdGet
     *
     * Get a property option
     *
     * @param  int $property_option_id The ID of the property option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesOptionsPropertyOptionIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\PropertyOption
     */
    public function restPropertiesOptionsPropertyOptionIdGet(
        int $property_option_id,
        string $contentType = self::contentTypes['restPropertiesOptionsPropertyOptionIdGet'][0]
    ): \ck/plenty-client\Model\PropertyOption
    {
        list($response) = $this->restPropertiesOptionsPropertyOptionIdGetWithHttpInfo($property_option_id, $contentType);
        return $response;
    }

    /**
     * Operation restPropertiesOptionsPropertyOptionIdGetWithHttpInfo
     *
     * Get a property option
     *
     * @param  int $property_option_id The ID of the property option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesOptionsPropertyOptionIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\PropertyOption, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesOptionsPropertyOptionIdGetWithHttpInfo(
        int $property_option_id,
        string $contentType = self::contentTypes['restPropertiesOptionsPropertyOptionIdGet'][0]
    ): array
    {
        $request = $this->restPropertiesOptionsPropertyOptionIdGetRequest($property_option_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\PropertyOption' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\PropertyOption' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\PropertyOption', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\PropertyOption';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\PropertyOption',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesOptionsPropertyOptionIdGetAsync
     *
     * Get a property option
     *
     * @param  int $property_option_id The ID of the property option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesOptionsPropertyOptionIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesOptionsPropertyOptionIdGetAsync(
        int $property_option_id,
        string $contentType = self::contentTypes['restPropertiesOptionsPropertyOptionIdGet'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesOptionsPropertyOptionIdGetAsyncWithHttpInfo($property_option_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesOptionsPropertyOptionIdGetAsyncWithHttpInfo
     *
     * Get a property option
     *
     * @param  int $property_option_id The ID of the property option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesOptionsPropertyOptionIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesOptionsPropertyOptionIdGetAsyncWithHttpInfo(
        $property_option_id,
        string $contentType = self::contentTypes['restPropertiesOptionsPropertyOptionIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\PropertyOption';
        $request = $this->restPropertiesOptionsPropertyOptionIdGetRequest($property_option_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesOptionsPropertyOptionIdGet'
     *
     * @param  int $property_option_id The ID of the property option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesOptionsPropertyOptionIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesOptionsPropertyOptionIdGetRequest(
        $property_option_id,
        string $contentType = self::contentTypes['restPropertiesOptionsPropertyOptionIdGet'][0]
    ): Request
    {

        // verify the required parameter 'property_option_id' is set
        if ($property_option_id === null || (is_array($property_option_id) && count($property_option_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $property_option_id when calling restPropertiesOptionsPropertyOptionIdGet'
            );
        }


        $resourcePath = '/rest/properties/options/{propertyOptionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($property_option_id !== null) {
            $resourcePath = str_replace(
                '{' . 'propertyOptionId' . '}',
                ObjectSerializer::toPathValue($property_option_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesOptionsPropertyOptionIdPut
     *
     * Update a property option
     *
     * @param  int $property_option_id The ID of the property option (required)
     * @param  int $property_option_id2 property_option_id2 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesOptionsPropertyOptionIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\PropertyOption
     */
    public function restPropertiesOptionsPropertyOptionIdPut(
        int $property_option_id,
        int $property_option_id2,
        string $contentType = self::contentTypes['restPropertiesOptionsPropertyOptionIdPut'][0]
    ): \ck/plenty-client\Model\PropertyOption
    {
        list($response) = $this->restPropertiesOptionsPropertyOptionIdPutWithHttpInfo($property_option_id, $property_option_id2, $contentType);
        return $response;
    }

    /**
     * Operation restPropertiesOptionsPropertyOptionIdPutWithHttpInfo
     *
     * Update a property option
     *
     * @param  int $property_option_id The ID of the property option (required)
     * @param  int $property_option_id2 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesOptionsPropertyOptionIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\PropertyOption, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesOptionsPropertyOptionIdPutWithHttpInfo(
        int $property_option_id,
        int $property_option_id2,
        string $contentType = self::contentTypes['restPropertiesOptionsPropertyOptionIdPut'][0]
    ): array
    {
        $request = $this->restPropertiesOptionsPropertyOptionIdPutRequest($property_option_id, $property_option_id2, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\PropertyOption' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\PropertyOption' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\PropertyOption', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\PropertyOption';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\PropertyOption',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesOptionsPropertyOptionIdPutAsync
     *
     * Update a property option
     *
     * @param  int $property_option_id The ID of the property option (required)
     * @param  int $property_option_id2 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesOptionsPropertyOptionIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesOptionsPropertyOptionIdPutAsync(
        int $property_option_id,
        int $property_option_id2,
        string $contentType = self::contentTypes['restPropertiesOptionsPropertyOptionIdPut'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesOptionsPropertyOptionIdPutAsyncWithHttpInfo($property_option_id, $property_option_id2, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesOptionsPropertyOptionIdPutAsyncWithHttpInfo
     *
     * Update a property option
     *
     * @param  int $property_option_id The ID of the property option (required)
     * @param  int $property_option_id2 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesOptionsPropertyOptionIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesOptionsPropertyOptionIdPutAsyncWithHttpInfo(
        $property_option_id,
        $property_option_id2,
        string $contentType = self::contentTypes['restPropertiesOptionsPropertyOptionIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\PropertyOption';
        $request = $this->restPropertiesOptionsPropertyOptionIdPutRequest($property_option_id, $property_option_id2, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesOptionsPropertyOptionIdPut'
     *
     * @param  int $property_option_id The ID of the property option (required)
     * @param  int $property_option_id2 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesOptionsPropertyOptionIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesOptionsPropertyOptionIdPutRequest(
        $property_option_id,
        $property_option_id2,
        string $contentType = self::contentTypes['restPropertiesOptionsPropertyOptionIdPut'][0]
    ): Request
    {

        // verify the required parameter 'property_option_id' is set
        if ($property_option_id === null || (is_array($property_option_id) && count($property_option_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $property_option_id when calling restPropertiesOptionsPropertyOptionIdPut'
            );
        }

        // verify the required parameter 'property_option_id2' is set
        if ($property_option_id2 === null || (is_array($property_option_id2) && count($property_option_id2) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $property_option_id2 when calling restPropertiesOptionsPropertyOptionIdPut'
            );
        }


        $resourcePath = '/rest/properties/options/{propertyOptionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $property_option_id,
            '$propertyOptionId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);


        // path params
        if ($property_option_id2 !== null) {
            $resourcePath = str_replace(
                '{' . 'propertyOptionId' . '}',
                ObjectSerializer::toPathValue($property_option_id2),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesPost
     *
     * Create a property
     *
     * @param  string $cast The cast of the property (required)
     * @param  string $type_identifier The identifier of the property type (required)
     * @param  int $position The position of the property (required)
     * @param  \ck/plenty-client\Model\RestPropertiesPostRequest|null $_rest_properties _rest_properties (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\Property
     */
    public function restPropertiesPost(
        string $cast,
        string $type_identifier,
        int $position,
        ?\ck/plenty-client\Model\RestPropertiesPostRequest $_rest_properties = null,
        string $contentType = self::contentTypes['restPropertiesPost'][0]
    ): \ck/plenty-client\Model\Property
    {
        list($response) = $this->restPropertiesPostWithHttpInfo($cast, $type_identifier, $position, $_rest_properties, $contentType);
        return $response;
    }

    /**
     * Operation restPropertiesPostWithHttpInfo
     *
     * Create a property
     *
     * @param  string $cast The cast of the property (required)
     * @param  string $type_identifier The identifier of the property type (required)
     * @param  int $position The position of the property (required)
     * @param  \ck/plenty-client\Model\RestPropertiesPostRequest|null $_rest_properties (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\Property, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesPostWithHttpInfo(
        string $cast,
        string $type_identifier,
        int $position,
        ?\ck/plenty-client\Model\RestPropertiesPostRequest $_rest_properties = null,
        string $contentType = self::contentTypes['restPropertiesPost'][0]
    ): array
    {
        $request = $this->restPropertiesPostRequest($cast, $type_identifier, $position, $_rest_properties, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\Property' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\Property' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\Property', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\Property';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\Property',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesPostAsync
     *
     * Create a property
     *
     * @param  string $cast The cast of the property (required)
     * @param  string $type_identifier The identifier of the property type (required)
     * @param  int $position The position of the property (required)
     * @param  \ck/plenty-client\Model\RestPropertiesPostRequest|null $_rest_properties (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesPostAsync(
        string $cast,
        string $type_identifier,
        int $position,
        ?\ck/plenty-client\Model\RestPropertiesPostRequest $_rest_properties = null,
        string $contentType = self::contentTypes['restPropertiesPost'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesPostAsyncWithHttpInfo($cast, $type_identifier, $position, $_rest_properties, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesPostAsyncWithHttpInfo
     *
     * Create a property
     *
     * @param  string $cast The cast of the property (required)
     * @param  string $type_identifier The identifier of the property type (required)
     * @param  int $position The position of the property (required)
     * @param  \ck/plenty-client\Model\RestPropertiesPostRequest|null $_rest_properties (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesPostAsyncWithHttpInfo(
        $cast,
        $type_identifier,
        $position,
        $_rest_properties = null,
        string $contentType = self::contentTypes['restPropertiesPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\Property';
        $request = $this->restPropertiesPostRequest($cast, $type_identifier, $position, $_rest_properties, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesPost'
     *
     * @param  string $cast The cast of the property (required)
     * @param  string $type_identifier The identifier of the property type (required)
     * @param  int $position The position of the property (required)
     * @param  \ck/plenty-client\Model\RestPropertiesPostRequest|null $_rest_properties (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesPostRequest(
        $cast,
        $type_identifier,
        $position,
        $_rest_properties = null,
        string $contentType = self::contentTypes['restPropertiesPost'][0]
    ): Request
    {

        // verify the required parameter 'cast' is set
        if ($cast === null || (is_array($cast) && count($cast) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $cast when calling restPropertiesPost'
            );
        }

        // verify the required parameter 'type_identifier' is set
        if ($type_identifier === null || (is_array($type_identifier) && count($type_identifier) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $type_identifier when calling restPropertiesPost'
            );
        }

        // verify the required parameter 'position' is set
        if ($position === null || (is_array($position) && count($position) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $position when calling restPropertiesPost'
            );
        }



        $resourcePath = '/rest/properties';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cast,
            'cast', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type_identifier,
            'typeIdentifier', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $position,
            'position', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_properties)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_properties));
            } else {
                $httpBody = $_rest_properties;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesPropertyIdDelete
     *
     * Delete a property
     *
     * @param  int $property_id The ID of the property (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesPropertyIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restPropertiesPropertyIdDelete(
        int $property_id,
        string $contentType = self::contentTypes['restPropertiesPropertyIdDelete'][0]
    ): void
    {
        $this->restPropertiesPropertyIdDeleteWithHttpInfo($property_id, $contentType);
    }

    /**
     * Operation restPropertiesPropertyIdDeleteWithHttpInfo
     *
     * Delete a property
     *
     * @param  int $property_id The ID of the property (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesPropertyIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesPropertyIdDeleteWithHttpInfo(
        int $property_id,
        string $contentType = self::contentTypes['restPropertiesPropertyIdDelete'][0]
    ): array
    {
        $request = $this->restPropertiesPropertyIdDeleteRequest($property_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesPropertyIdDeleteAsync
     *
     * Delete a property
     *
     * @param  int $property_id The ID of the property (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesPropertyIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesPropertyIdDeleteAsync(
        int $property_id,
        string $contentType = self::contentTypes['restPropertiesPropertyIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesPropertyIdDeleteAsyncWithHttpInfo($property_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesPropertyIdDeleteAsyncWithHttpInfo
     *
     * Delete a property
     *
     * @param  int $property_id The ID of the property (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesPropertyIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesPropertyIdDeleteAsyncWithHttpInfo(
        $property_id,
        string $contentType = self::contentTypes['restPropertiesPropertyIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restPropertiesPropertyIdDeleteRequest($property_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesPropertyIdDelete'
     *
     * @param  int $property_id The ID of the property (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesPropertyIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesPropertyIdDeleteRequest(
        $property_id,
        string $contentType = self::contentTypes['restPropertiesPropertyIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'property_id' is set
        if ($property_id === null || (is_array($property_id) && count($property_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $property_id when calling restPropertiesPropertyIdDelete'
            );
        }


        $resourcePath = '/rest/properties/{propertyId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($property_id !== null) {
            $resourcePath = str_replace(
                '{' . 'propertyId' . '}',
                ObjectSerializer::toPathValue($property_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesPropertyIdGet
     *
     * Get a property.
     *
     * @param  int $property_id The ID of the property (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesPropertyIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\Property
     */
    public function restPropertiesPropertyIdGet(
        int $property_id,
        string $contentType = self::contentTypes['restPropertiesPropertyIdGet'][0]
    ): \ck/plenty-client\Model\Property
    {
        list($response) = $this->restPropertiesPropertyIdGetWithHttpInfo($property_id, $contentType);
        return $response;
    }

    /**
     * Operation restPropertiesPropertyIdGetWithHttpInfo
     *
     * Get a property.
     *
     * @param  int $property_id The ID of the property (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesPropertyIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\Property, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesPropertyIdGetWithHttpInfo(
        int $property_id,
        string $contentType = self::contentTypes['restPropertiesPropertyIdGet'][0]
    ): array
    {
        $request = $this->restPropertiesPropertyIdGetRequest($property_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\Property' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\Property' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\Property', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\Property';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\Property',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesPropertyIdGetAsync
     *
     * Get a property.
     *
     * @param  int $property_id The ID of the property (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesPropertyIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesPropertyIdGetAsync(
        int $property_id,
        string $contentType = self::contentTypes['restPropertiesPropertyIdGet'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesPropertyIdGetAsyncWithHttpInfo($property_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesPropertyIdGetAsyncWithHttpInfo
     *
     * Get a property.
     *
     * @param  int $property_id The ID of the property (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesPropertyIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesPropertyIdGetAsyncWithHttpInfo(
        $property_id,
        string $contentType = self::contentTypes['restPropertiesPropertyIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\Property';
        $request = $this->restPropertiesPropertyIdGetRequest($property_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesPropertyIdGet'
     *
     * @param  int $property_id The ID of the property (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesPropertyIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesPropertyIdGetRequest(
        $property_id,
        string $contentType = self::contentTypes['restPropertiesPropertyIdGet'][0]
    ): Request
    {

        // verify the required parameter 'property_id' is set
        if ($property_id === null || (is_array($property_id) && count($property_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $property_id when calling restPropertiesPropertyIdGet'
            );
        }


        $resourcePath = '/rest/properties/{propertyId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($property_id !== null) {
            $resourcePath = str_replace(
                '{' . 'propertyId' . '}',
                ObjectSerializer::toPathValue($property_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesPropertyIdPut
     *
     * Update a property
     *
     * @param  int $property_id The ID of the property (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesPropertyIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\Property
     */
    public function restPropertiesPropertyIdPut(
        int $property_id,
        string $contentType = self::contentTypes['restPropertiesPropertyIdPut'][0]
    ): \ck/plenty-client\Model\Property
    {
        list($response) = $this->restPropertiesPropertyIdPutWithHttpInfo($property_id, $contentType);
        return $response;
    }

    /**
     * Operation restPropertiesPropertyIdPutWithHttpInfo
     *
     * Update a property
     *
     * @param  int $property_id The ID of the property (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesPropertyIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\Property, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesPropertyIdPutWithHttpInfo(
        int $property_id,
        string $contentType = self::contentTypes['restPropertiesPropertyIdPut'][0]
    ): array
    {
        $request = $this->restPropertiesPropertyIdPutRequest($property_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\Property' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\Property' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\Property', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\Property';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\Property',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesPropertyIdPutAsync
     *
     * Update a property
     *
     * @param  int $property_id The ID of the property (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesPropertyIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesPropertyIdPutAsync(
        int $property_id,
        string $contentType = self::contentTypes['restPropertiesPropertyIdPut'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesPropertyIdPutAsyncWithHttpInfo($property_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesPropertyIdPutAsyncWithHttpInfo
     *
     * Update a property
     *
     * @param  int $property_id The ID of the property (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesPropertyIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesPropertyIdPutAsyncWithHttpInfo(
        $property_id,
        string $contentType = self::contentTypes['restPropertiesPropertyIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\Property';
        $request = $this->restPropertiesPropertyIdPutRequest($property_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesPropertyIdPut'
     *
     * @param  int $property_id The ID of the property (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesPropertyIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesPropertyIdPutRequest(
        $property_id,
        string $contentType = self::contentTypes['restPropertiesPropertyIdPut'][0]
    ): Request
    {

        // verify the required parameter 'property_id' is set
        if ($property_id === null || (is_array($property_id) && count($property_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $property_id when calling restPropertiesPropertyIdPut'
            );
        }


        $resourcePath = '/rest/properties/{propertyId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($property_id !== null) {
            $resourcePath = str_replace(
                '{' . 'propertyId' . '}',
                ObjectSerializer::toPathValue($property_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesRelationsDelete
     *
     * Delete property relations
     *
     * @param  int $relation_id The ID of the property relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restPropertiesRelationsDelete(
        int $relation_id,
        string $contentType = self::contentTypes['restPropertiesRelationsDelete'][0]
    ): void
    {
        $this->restPropertiesRelationsDeleteWithHttpInfo($relation_id, $contentType);
    }

    /**
     * Operation restPropertiesRelationsDeleteWithHttpInfo
     *
     * Delete property relations
     *
     * @param  int $relation_id The ID of the property relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesRelationsDeleteWithHttpInfo(
        int $relation_id,
        string $contentType = self::contentTypes['restPropertiesRelationsDelete'][0]
    ): array
    {
        $request = $this->restPropertiesRelationsDeleteRequest($relation_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesRelationsDeleteAsync
     *
     * Delete property relations
     *
     * @param  int $relation_id The ID of the property relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesRelationsDeleteAsync(
        int $relation_id,
        string $contentType = self::contentTypes['restPropertiesRelationsDelete'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesRelationsDeleteAsyncWithHttpInfo($relation_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesRelationsDeleteAsyncWithHttpInfo
     *
     * Delete property relations
     *
     * @param  int $relation_id The ID of the property relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesRelationsDeleteAsyncWithHttpInfo(
        $relation_id,
        string $contentType = self::contentTypes['restPropertiesRelationsDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restPropertiesRelationsDeleteRequest($relation_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesRelationsDelete'
     *
     * @param  int $relation_id The ID of the property relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesRelationsDeleteRequest(
        $relation_id,
        string $contentType = self::contentTypes['restPropertiesRelationsDelete'][0]
    ): Request
    {

        // verify the required parameter 'relation_id' is set
        if ($relation_id === null || (is_array($relation_id) && count($relation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $relation_id when calling restPropertiesRelationsDelete'
            );
        }


        $resourcePath = '/rest/properties/relations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $relation_id,
            'relationId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesRelationsGet
     *
     * List property relations
     *
     * @param  int|null $page Current page of the response (optional)
     * @param  int|null $items_per_page The requested amount of items per result page (optional)
     * @param  int|null $paginate The condition that determines if the pagination should be used (default value is set to 0) (optional)
     * @param  string|null $relation_type_identifier The parameter that decides the type of relation (optional)
     * @param  int|null $relation_target_id The ID of the target of the relation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\PropertyRelation[]
     */
    public function restPropertiesRelationsGet(
        ?int $page = null,
        ?int $items_per_page = null,
        ?int $paginate = null,
        ?string $relation_type_identifier = null,
        ?int $relation_target_id = null,
        string $contentType = self::contentTypes['restPropertiesRelationsGet'][0]
    ): array
    {
        list($response) = $this->restPropertiesRelationsGetWithHttpInfo($page, $items_per_page, $paginate, $relation_type_identifier, $relation_target_id, $contentType);
        return $response;
    }

    /**
     * Operation restPropertiesRelationsGetWithHttpInfo
     *
     * List property relations
     *
     * @param  int|null $page Current page of the response (optional)
     * @param  int|null $items_per_page The requested amount of items per result page (optional)
     * @param  int|null $paginate The condition that determines if the pagination should be used (default value is set to 0) (optional)
     * @param  string|null $relation_type_identifier The parameter that decides the type of relation (optional)
     * @param  int|null $relation_target_id The ID of the target of the relation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\PropertyRelation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesRelationsGetWithHttpInfo(
        ?int $page = null,
        ?int $items_per_page = null,
        ?int $paginate = null,
        ?string $relation_type_identifier = null,
        ?int $relation_target_id = null,
        string $contentType = self::contentTypes['restPropertiesRelationsGet'][0]
    ): array
    {
        $request = $this->restPropertiesRelationsGetRequest($page, $items_per_page, $paginate, $relation_type_identifier, $relation_target_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\PropertyRelation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\PropertyRelation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\PropertyRelation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\PropertyRelation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\PropertyRelation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesRelationsGetAsync
     *
     * List property relations
     *
     * @param  int|null $page Current page of the response (optional)
     * @param  int|null $items_per_page The requested amount of items per result page (optional)
     * @param  int|null $paginate The condition that determines if the pagination should be used (default value is set to 0) (optional)
     * @param  string|null $relation_type_identifier The parameter that decides the type of relation (optional)
     * @param  int|null $relation_target_id The ID of the target of the relation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesRelationsGetAsync(
        ?int $page = null,
        ?int $items_per_page = null,
        ?int $paginate = null,
        ?string $relation_type_identifier = null,
        ?int $relation_target_id = null,
        string $contentType = self::contentTypes['restPropertiesRelationsGet'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesRelationsGetAsyncWithHttpInfo($page, $items_per_page, $paginate, $relation_type_identifier, $relation_target_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesRelationsGetAsyncWithHttpInfo
     *
     * List property relations
     *
     * @param  int|null $page Current page of the response (optional)
     * @param  int|null $items_per_page The requested amount of items per result page (optional)
     * @param  int|null $paginate The condition that determines if the pagination should be used (default value is set to 0) (optional)
     * @param  string|null $relation_type_identifier The parameter that decides the type of relation (optional)
     * @param  int|null $relation_target_id The ID of the target of the relation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesRelationsGetAsyncWithHttpInfo(
        $page = null,
        $items_per_page = null,
        $paginate = null,
        $relation_type_identifier = null,
        $relation_target_id = null,
        string $contentType = self::contentTypes['restPropertiesRelationsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\PropertyRelation[]';
        $request = $this->restPropertiesRelationsGetRequest($page, $items_per_page, $paginate, $relation_type_identifier, $relation_target_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesRelationsGet'
     *
     * @param  int|null $page Current page of the response (optional)
     * @param  int|null $items_per_page The requested amount of items per result page (optional)
     * @param  int|null $paginate The condition that determines if the pagination should be used (default value is set to 0) (optional)
     * @param  string|null $relation_type_identifier The parameter that decides the type of relation (optional)
     * @param  int|null $relation_target_id The ID of the target of the relation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesRelationsGetRequest(
        $page = null,
        $items_per_page = null,
        $paginate = null,
        $relation_type_identifier = null,
        $relation_target_id = null,
        string $contentType = self::contentTypes['restPropertiesRelationsGet'][0]
    ): Request
    {







        $resourcePath = '/rest/properties/relations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $items_per_page,
            'itemsPerPage', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $paginate,
            'paginate', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $relation_type_identifier,
            'relationTypeIdentifier', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $relation_target_id,
            'relationTargetId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesRelationsMarkupsGet
     *
     * List relation markups
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsMarkupsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\PropertyRelationMarkup[]
     */
    public function restPropertiesRelationsMarkupsGet(
        string $contentType = self::contentTypes['restPropertiesRelationsMarkupsGet'][0]
    ): array
    {
        list($response) = $this->restPropertiesRelationsMarkupsGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restPropertiesRelationsMarkupsGetWithHttpInfo
     *
     * List relation markups
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsMarkupsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\PropertyRelationMarkup[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesRelationsMarkupsGetWithHttpInfo(
        string $contentType = self::contentTypes['restPropertiesRelationsMarkupsGet'][0]
    ): array
    {
        $request = $this->restPropertiesRelationsMarkupsGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\PropertyRelationMarkup[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\PropertyRelationMarkup[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\PropertyRelationMarkup[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\PropertyRelationMarkup[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\PropertyRelationMarkup[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesRelationsMarkupsGetAsync
     *
     * List relation markups
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsMarkupsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesRelationsMarkupsGetAsync(
        string $contentType = self::contentTypes['restPropertiesRelationsMarkupsGet'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesRelationsMarkupsGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesRelationsMarkupsGetAsyncWithHttpInfo
     *
     * List relation markups
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsMarkupsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesRelationsMarkupsGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restPropertiesRelationsMarkupsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\PropertyRelationMarkup[]';
        $request = $this->restPropertiesRelationsMarkupsGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesRelationsMarkupsGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsMarkupsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesRelationsMarkupsGetRequest(
        string $contentType = self::contentTypes['restPropertiesRelationsMarkupsGet'][0]
    ): Request
    {


        $resourcePath = '/rest/properties/relations/markups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesRelationsMarkupsPost
     *
     * Create a property relation markup
     *
     * @param  int $property_relation_id The ID of the property elation (required)
     * @param  int $variation_sales_price_id The ID of a variation&#39;s sales price (required)
     * @param  float $markup The property relation markup (required)
     * @param  \ck/plenty-client\Model\RestPropertiesRelationsMarkupsPostRequest|null $_rest_properties_relations_markups _rest_properties_relations_markups (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsMarkupsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\PropertyRelationMarkup
     */
    public function restPropertiesRelationsMarkupsPost(
        int $property_relation_id,
        int $variation_sales_price_id,
        float $markup,
        ?\ck/plenty-client\Model\RestPropertiesRelationsMarkupsPostRequest $_rest_properties_relations_markups = null,
        string $contentType = self::contentTypes['restPropertiesRelationsMarkupsPost'][0]
    ): \ck/plenty-client\Model\PropertyRelationMarkup
    {
        list($response) = $this->restPropertiesRelationsMarkupsPostWithHttpInfo($property_relation_id, $variation_sales_price_id, $markup, $_rest_properties_relations_markups, $contentType);
        return $response;
    }

    /**
     * Operation restPropertiesRelationsMarkupsPostWithHttpInfo
     *
     * Create a property relation markup
     *
     * @param  int $property_relation_id The ID of the property elation (required)
     * @param  int $variation_sales_price_id The ID of a variation&#39;s sales price (required)
     * @param  float $markup The property relation markup (required)
     * @param  \ck/plenty-client\Model\RestPropertiesRelationsMarkupsPostRequest|null $_rest_properties_relations_markups (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsMarkupsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\PropertyRelationMarkup, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesRelationsMarkupsPostWithHttpInfo(
        int $property_relation_id,
        int $variation_sales_price_id,
        float $markup,
        ?\ck/plenty-client\Model\RestPropertiesRelationsMarkupsPostRequest $_rest_properties_relations_markups = null,
        string $contentType = self::contentTypes['restPropertiesRelationsMarkupsPost'][0]
    ): array
    {
        $request = $this->restPropertiesRelationsMarkupsPostRequest($property_relation_id, $variation_sales_price_id, $markup, $_rest_properties_relations_markups, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\PropertyRelationMarkup' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\PropertyRelationMarkup' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\PropertyRelationMarkup', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\PropertyRelationMarkup';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\PropertyRelationMarkup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesRelationsMarkupsPostAsync
     *
     * Create a property relation markup
     *
     * @param  int $property_relation_id The ID of the property elation (required)
     * @param  int $variation_sales_price_id The ID of a variation&#39;s sales price (required)
     * @param  float $markup The property relation markup (required)
     * @param  \ck/plenty-client\Model\RestPropertiesRelationsMarkupsPostRequest|null $_rest_properties_relations_markups (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsMarkupsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesRelationsMarkupsPostAsync(
        int $property_relation_id,
        int $variation_sales_price_id,
        float $markup,
        ?\ck/plenty-client\Model\RestPropertiesRelationsMarkupsPostRequest $_rest_properties_relations_markups = null,
        string $contentType = self::contentTypes['restPropertiesRelationsMarkupsPost'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesRelationsMarkupsPostAsyncWithHttpInfo($property_relation_id, $variation_sales_price_id, $markup, $_rest_properties_relations_markups, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesRelationsMarkupsPostAsyncWithHttpInfo
     *
     * Create a property relation markup
     *
     * @param  int $property_relation_id The ID of the property elation (required)
     * @param  int $variation_sales_price_id The ID of a variation&#39;s sales price (required)
     * @param  float $markup The property relation markup (required)
     * @param  \ck/plenty-client\Model\RestPropertiesRelationsMarkupsPostRequest|null $_rest_properties_relations_markups (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsMarkupsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesRelationsMarkupsPostAsyncWithHttpInfo(
        $property_relation_id,
        $variation_sales_price_id,
        $markup,
        $_rest_properties_relations_markups = null,
        string $contentType = self::contentTypes['restPropertiesRelationsMarkupsPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\PropertyRelationMarkup';
        $request = $this->restPropertiesRelationsMarkupsPostRequest($property_relation_id, $variation_sales_price_id, $markup, $_rest_properties_relations_markups, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesRelationsMarkupsPost'
     *
     * @param  int $property_relation_id The ID of the property elation (required)
     * @param  int $variation_sales_price_id The ID of a variation&#39;s sales price (required)
     * @param  float $markup The property relation markup (required)
     * @param  \ck/plenty-client\Model\RestPropertiesRelationsMarkupsPostRequest|null $_rest_properties_relations_markups (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsMarkupsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesRelationsMarkupsPostRequest(
        $property_relation_id,
        $variation_sales_price_id,
        $markup,
        $_rest_properties_relations_markups = null,
        string $contentType = self::contentTypes['restPropertiesRelationsMarkupsPost'][0]
    ): Request
    {

        // verify the required parameter 'property_relation_id' is set
        if ($property_relation_id === null || (is_array($property_relation_id) && count($property_relation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $property_relation_id when calling restPropertiesRelationsMarkupsPost'
            );
        }

        // verify the required parameter 'variation_sales_price_id' is set
        if ($variation_sales_price_id === null || (is_array($variation_sales_price_id) && count($variation_sales_price_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_sales_price_id when calling restPropertiesRelationsMarkupsPost'
            );
        }

        // verify the required parameter 'markup' is set
        if ($markup === null || (is_array($markup) && count($markup) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $markup when calling restPropertiesRelationsMarkupsPost'
            );
        }



        $resourcePath = '/rest/properties/relations/markups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $property_relation_id,
            'propertyRelationId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $variation_sales_price_id,
            'variationSalesPriceId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $markup,
            'markup', // param base name
            'number', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_properties_relations_markups)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_properties_relations_markups));
            } else {
                $httpBody = $_rest_properties_relations_markups;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesRelationsMarkupsRelationMarkupIdDelete
     *
     * Delete a property relation markup
     *
     * @param  int $relation_markup_id The ID of the relation markup (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsMarkupsRelationMarkupIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restPropertiesRelationsMarkupsRelationMarkupIdDelete(
        int $relation_markup_id,
        string $contentType = self::contentTypes['restPropertiesRelationsMarkupsRelationMarkupIdDelete'][0]
    ): void
    {
        $this->restPropertiesRelationsMarkupsRelationMarkupIdDeleteWithHttpInfo($relation_markup_id, $contentType);
    }

    /**
     * Operation restPropertiesRelationsMarkupsRelationMarkupIdDeleteWithHttpInfo
     *
     * Delete a property relation markup
     *
     * @param  int $relation_markup_id The ID of the relation markup (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsMarkupsRelationMarkupIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesRelationsMarkupsRelationMarkupIdDeleteWithHttpInfo(
        int $relation_markup_id,
        string $contentType = self::contentTypes['restPropertiesRelationsMarkupsRelationMarkupIdDelete'][0]
    ): array
    {
        $request = $this->restPropertiesRelationsMarkupsRelationMarkupIdDeleteRequest($relation_markup_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesRelationsMarkupsRelationMarkupIdDeleteAsync
     *
     * Delete a property relation markup
     *
     * @param  int $relation_markup_id The ID of the relation markup (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsMarkupsRelationMarkupIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesRelationsMarkupsRelationMarkupIdDeleteAsync(
        int $relation_markup_id,
        string $contentType = self::contentTypes['restPropertiesRelationsMarkupsRelationMarkupIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesRelationsMarkupsRelationMarkupIdDeleteAsyncWithHttpInfo($relation_markup_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesRelationsMarkupsRelationMarkupIdDeleteAsyncWithHttpInfo
     *
     * Delete a property relation markup
     *
     * @param  int $relation_markup_id The ID of the relation markup (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsMarkupsRelationMarkupIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesRelationsMarkupsRelationMarkupIdDeleteAsyncWithHttpInfo(
        $relation_markup_id,
        string $contentType = self::contentTypes['restPropertiesRelationsMarkupsRelationMarkupIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restPropertiesRelationsMarkupsRelationMarkupIdDeleteRequest($relation_markup_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesRelationsMarkupsRelationMarkupIdDelete'
     *
     * @param  int $relation_markup_id The ID of the relation markup (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsMarkupsRelationMarkupIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesRelationsMarkupsRelationMarkupIdDeleteRequest(
        $relation_markup_id,
        string $contentType = self::contentTypes['restPropertiesRelationsMarkupsRelationMarkupIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'relation_markup_id' is set
        if ($relation_markup_id === null || (is_array($relation_markup_id) && count($relation_markup_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $relation_markup_id when calling restPropertiesRelationsMarkupsRelationMarkupIdDelete'
            );
        }


        $resourcePath = '/rest/properties/relations/markups/{relationMarkupId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($relation_markup_id !== null) {
            $resourcePath = str_replace(
                '{' . 'relationMarkupId' . '}',
                ObjectSerializer::toPathValue($relation_markup_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesRelationsMarkupsRelationMarkupIdGet
     *
     * Get a property relation markup
     *
     * @param  int $relation_markup_id The ID of the relation markup (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsMarkupsRelationMarkupIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\PropertyRelationMarkup
     */
    public function restPropertiesRelationsMarkupsRelationMarkupIdGet(
        int $relation_markup_id,
        string $contentType = self::contentTypes['restPropertiesRelationsMarkupsRelationMarkupIdGet'][0]
    ): \ck/plenty-client\Model\PropertyRelationMarkup
    {
        list($response) = $this->restPropertiesRelationsMarkupsRelationMarkupIdGetWithHttpInfo($relation_markup_id, $contentType);
        return $response;
    }

    /**
     * Operation restPropertiesRelationsMarkupsRelationMarkupIdGetWithHttpInfo
     *
     * Get a property relation markup
     *
     * @param  int $relation_markup_id The ID of the relation markup (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsMarkupsRelationMarkupIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\PropertyRelationMarkup, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesRelationsMarkupsRelationMarkupIdGetWithHttpInfo(
        int $relation_markup_id,
        string $contentType = self::contentTypes['restPropertiesRelationsMarkupsRelationMarkupIdGet'][0]
    ): array
    {
        $request = $this->restPropertiesRelationsMarkupsRelationMarkupIdGetRequest($relation_markup_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\PropertyRelationMarkup' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\PropertyRelationMarkup' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\PropertyRelationMarkup', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\PropertyRelationMarkup';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\PropertyRelationMarkup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesRelationsMarkupsRelationMarkupIdGetAsync
     *
     * Get a property relation markup
     *
     * @param  int $relation_markup_id The ID of the relation markup (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsMarkupsRelationMarkupIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesRelationsMarkupsRelationMarkupIdGetAsync(
        int $relation_markup_id,
        string $contentType = self::contentTypes['restPropertiesRelationsMarkupsRelationMarkupIdGet'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesRelationsMarkupsRelationMarkupIdGetAsyncWithHttpInfo($relation_markup_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesRelationsMarkupsRelationMarkupIdGetAsyncWithHttpInfo
     *
     * Get a property relation markup
     *
     * @param  int $relation_markup_id The ID of the relation markup (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsMarkupsRelationMarkupIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesRelationsMarkupsRelationMarkupIdGetAsyncWithHttpInfo(
        $relation_markup_id,
        string $contentType = self::contentTypes['restPropertiesRelationsMarkupsRelationMarkupIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\PropertyRelationMarkup';
        $request = $this->restPropertiesRelationsMarkupsRelationMarkupIdGetRequest($relation_markup_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesRelationsMarkupsRelationMarkupIdGet'
     *
     * @param  int $relation_markup_id The ID of the relation markup (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsMarkupsRelationMarkupIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesRelationsMarkupsRelationMarkupIdGetRequest(
        $relation_markup_id,
        string $contentType = self::contentTypes['restPropertiesRelationsMarkupsRelationMarkupIdGet'][0]
    ): Request
    {

        // verify the required parameter 'relation_markup_id' is set
        if ($relation_markup_id === null || (is_array($relation_markup_id) && count($relation_markup_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $relation_markup_id when calling restPropertiesRelationsMarkupsRelationMarkupIdGet'
            );
        }


        $resourcePath = '/rest/properties/relations/markups/{relationMarkupId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($relation_markup_id !== null) {
            $resourcePath = str_replace(
                '{' . 'relationMarkupId' . '}',
                ObjectSerializer::toPathValue($relation_markup_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesRelationsMarkupsRelationMarkupIdPut
     *
     * Update a property relation markup
     *
     * @param  int $relation_markup_id The ID of the property relation markup (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsMarkupsRelationMarkupIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\PropertyRelationMarkup
     */
    public function restPropertiesRelationsMarkupsRelationMarkupIdPut(
        int $relation_markup_id,
        string $contentType = self::contentTypes['restPropertiesRelationsMarkupsRelationMarkupIdPut'][0]
    ): \ck/plenty-client\Model\PropertyRelationMarkup
    {
        list($response) = $this->restPropertiesRelationsMarkupsRelationMarkupIdPutWithHttpInfo($relation_markup_id, $contentType);
        return $response;
    }

    /**
     * Operation restPropertiesRelationsMarkupsRelationMarkupIdPutWithHttpInfo
     *
     * Update a property relation markup
     *
     * @param  int $relation_markup_id The ID of the property relation markup (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsMarkupsRelationMarkupIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\PropertyRelationMarkup, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesRelationsMarkupsRelationMarkupIdPutWithHttpInfo(
        int $relation_markup_id,
        string $contentType = self::contentTypes['restPropertiesRelationsMarkupsRelationMarkupIdPut'][0]
    ): array
    {
        $request = $this->restPropertiesRelationsMarkupsRelationMarkupIdPutRequest($relation_markup_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\PropertyRelationMarkup' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\PropertyRelationMarkup' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\PropertyRelationMarkup', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\PropertyRelationMarkup';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\PropertyRelationMarkup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesRelationsMarkupsRelationMarkupIdPutAsync
     *
     * Update a property relation markup
     *
     * @param  int $relation_markup_id The ID of the property relation markup (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsMarkupsRelationMarkupIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesRelationsMarkupsRelationMarkupIdPutAsync(
        int $relation_markup_id,
        string $contentType = self::contentTypes['restPropertiesRelationsMarkupsRelationMarkupIdPut'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesRelationsMarkupsRelationMarkupIdPutAsyncWithHttpInfo($relation_markup_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesRelationsMarkupsRelationMarkupIdPutAsyncWithHttpInfo
     *
     * Update a property relation markup
     *
     * @param  int $relation_markup_id The ID of the property relation markup (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsMarkupsRelationMarkupIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesRelationsMarkupsRelationMarkupIdPutAsyncWithHttpInfo(
        $relation_markup_id,
        string $contentType = self::contentTypes['restPropertiesRelationsMarkupsRelationMarkupIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\PropertyRelationMarkup';
        $request = $this->restPropertiesRelationsMarkupsRelationMarkupIdPutRequest($relation_markup_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesRelationsMarkupsRelationMarkupIdPut'
     *
     * @param  int $relation_markup_id The ID of the property relation markup (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsMarkupsRelationMarkupIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesRelationsMarkupsRelationMarkupIdPutRequest(
        $relation_markup_id,
        string $contentType = self::contentTypes['restPropertiesRelationsMarkupsRelationMarkupIdPut'][0]
    ): Request
    {

        // verify the required parameter 'relation_markup_id' is set
        if ($relation_markup_id === null || (is_array($relation_markup_id) && count($relation_markup_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $relation_markup_id when calling restPropertiesRelationsMarkupsRelationMarkupIdPut'
            );
        }


        $resourcePath = '/rest/properties/relations/markups/{relationMarkupId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($relation_markup_id !== null) {
            $resourcePath = str_replace(
                '{' . 'relationMarkupId' . '}',
                ObjectSerializer::toPathValue($relation_markup_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesRelationsPost
     *
     * Create a property relation
     *
     * @param  int $property_id The ID of the property (required)
     * @param  string $relation_type_identifier The identifier of the property relation type (required)
     * @param  int $relation_target_id The ID of the property relation target (required)
     * @param  int $selection_relation_id The ID of the property selection relation (required)
     * @param  \ck/plenty-client\Model\RestPropertiesRelationsPostRequest|null $_rest_properties_relations _rest_properties_relations (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\PropertyRelation
     */
    public function restPropertiesRelationsPost(
        int $property_id,
        string $relation_type_identifier,
        int $relation_target_id,
        int $selection_relation_id,
        ?\ck/plenty-client\Model\RestPropertiesRelationsPostRequest $_rest_properties_relations = null,
        string $contentType = self::contentTypes['restPropertiesRelationsPost'][0]
    ): \ck/plenty-client\Model\PropertyRelation
    {
        list($response) = $this->restPropertiesRelationsPostWithHttpInfo($property_id, $relation_type_identifier, $relation_target_id, $selection_relation_id, $_rest_properties_relations, $contentType);
        return $response;
    }

    /**
     * Operation restPropertiesRelationsPostWithHttpInfo
     *
     * Create a property relation
     *
     * @param  int $property_id The ID of the property (required)
     * @param  string $relation_type_identifier The identifier of the property relation type (required)
     * @param  int $relation_target_id The ID of the property relation target (required)
     * @param  int $selection_relation_id The ID of the property selection relation (required)
     * @param  \ck/plenty-client\Model\RestPropertiesRelationsPostRequest|null $_rest_properties_relations (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\PropertyRelation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesRelationsPostWithHttpInfo(
        int $property_id,
        string $relation_type_identifier,
        int $relation_target_id,
        int $selection_relation_id,
        ?\ck/plenty-client\Model\RestPropertiesRelationsPostRequest $_rest_properties_relations = null,
        string $contentType = self::contentTypes['restPropertiesRelationsPost'][0]
    ): array
    {
        $request = $this->restPropertiesRelationsPostRequest($property_id, $relation_type_identifier, $relation_target_id, $selection_relation_id, $_rest_properties_relations, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\PropertyRelation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\PropertyRelation' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\PropertyRelation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\PropertyRelation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\PropertyRelation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesRelationsPostAsync
     *
     * Create a property relation
     *
     * @param  int $property_id The ID of the property (required)
     * @param  string $relation_type_identifier The identifier of the property relation type (required)
     * @param  int $relation_target_id The ID of the property relation target (required)
     * @param  int $selection_relation_id The ID of the property selection relation (required)
     * @param  \ck/plenty-client\Model\RestPropertiesRelationsPostRequest|null $_rest_properties_relations (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesRelationsPostAsync(
        int $property_id,
        string $relation_type_identifier,
        int $relation_target_id,
        int $selection_relation_id,
        ?\ck/plenty-client\Model\RestPropertiesRelationsPostRequest $_rest_properties_relations = null,
        string $contentType = self::contentTypes['restPropertiesRelationsPost'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesRelationsPostAsyncWithHttpInfo($property_id, $relation_type_identifier, $relation_target_id, $selection_relation_id, $_rest_properties_relations, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesRelationsPostAsyncWithHttpInfo
     *
     * Create a property relation
     *
     * @param  int $property_id The ID of the property (required)
     * @param  string $relation_type_identifier The identifier of the property relation type (required)
     * @param  int $relation_target_id The ID of the property relation target (required)
     * @param  int $selection_relation_id The ID of the property selection relation (required)
     * @param  \ck/plenty-client\Model\RestPropertiesRelationsPostRequest|null $_rest_properties_relations (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesRelationsPostAsyncWithHttpInfo(
        $property_id,
        $relation_type_identifier,
        $relation_target_id,
        $selection_relation_id,
        $_rest_properties_relations = null,
        string $contentType = self::contentTypes['restPropertiesRelationsPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\PropertyRelation';
        $request = $this->restPropertiesRelationsPostRequest($property_id, $relation_type_identifier, $relation_target_id, $selection_relation_id, $_rest_properties_relations, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesRelationsPost'
     *
     * @param  int $property_id The ID of the property (required)
     * @param  string $relation_type_identifier The identifier of the property relation type (required)
     * @param  int $relation_target_id The ID of the property relation target (required)
     * @param  int $selection_relation_id The ID of the property selection relation (required)
     * @param  \ck/plenty-client\Model\RestPropertiesRelationsPostRequest|null $_rest_properties_relations (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesRelationsPostRequest(
        $property_id,
        $relation_type_identifier,
        $relation_target_id,
        $selection_relation_id,
        $_rest_properties_relations = null,
        string $contentType = self::contentTypes['restPropertiesRelationsPost'][0]
    ): Request
    {

        // verify the required parameter 'property_id' is set
        if ($property_id === null || (is_array($property_id) && count($property_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $property_id when calling restPropertiesRelationsPost'
            );
        }

        // verify the required parameter 'relation_type_identifier' is set
        if ($relation_type_identifier === null || (is_array($relation_type_identifier) && count($relation_type_identifier) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $relation_type_identifier when calling restPropertiesRelationsPost'
            );
        }

        // verify the required parameter 'relation_target_id' is set
        if ($relation_target_id === null || (is_array($relation_target_id) && count($relation_target_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $relation_target_id when calling restPropertiesRelationsPost'
            );
        }

        // verify the required parameter 'selection_relation_id' is set
        if ($selection_relation_id === null || (is_array($selection_relation_id) && count($selection_relation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $selection_relation_id when calling restPropertiesRelationsPost'
            );
        }



        $resourcePath = '/rest/properties/relations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $property_id,
            'propertyId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $relation_type_identifier,
            'relationTypeIdentifier', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $relation_target_id,
            'relationTargetId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $selection_relation_id,
            'selectionRelationId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_properties_relations)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_properties_relations));
            } else {
                $httpBody = $_rest_properties_relations;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesRelationsPut
     *
     * Update relations
     *
     * @param  int $relation_id The ID of the property relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\PropertyRelation[]
     */
    public function restPropertiesRelationsPut(
        int $relation_id,
        string $contentType = self::contentTypes['restPropertiesRelationsPut'][0]
    ): array
    {
        list($response) = $this->restPropertiesRelationsPutWithHttpInfo($relation_id, $contentType);
        return $response;
    }

    /**
     * Operation restPropertiesRelationsPutWithHttpInfo
     *
     * Update relations
     *
     * @param  int $relation_id The ID of the property relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\PropertyRelation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesRelationsPutWithHttpInfo(
        int $relation_id,
        string $contentType = self::contentTypes['restPropertiesRelationsPut'][0]
    ): array
    {
        $request = $this->restPropertiesRelationsPutRequest($relation_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\PropertyRelation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\PropertyRelation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\PropertyRelation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\PropertyRelation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\PropertyRelation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesRelationsPutAsync
     *
     * Update relations
     *
     * @param  int $relation_id The ID of the property relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesRelationsPutAsync(
        int $relation_id,
        string $contentType = self::contentTypes['restPropertiesRelationsPut'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesRelationsPutAsyncWithHttpInfo($relation_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesRelationsPutAsyncWithHttpInfo
     *
     * Update relations
     *
     * @param  int $relation_id The ID of the property relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesRelationsPutAsyncWithHttpInfo(
        $relation_id,
        string $contentType = self::contentTypes['restPropertiesRelationsPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\PropertyRelation[]';
        $request = $this->restPropertiesRelationsPutRequest($relation_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesRelationsPut'
     *
     * @param  int $relation_id The ID of the property relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesRelationsPutRequest(
        $relation_id,
        string $contentType = self::contentTypes['restPropertiesRelationsPut'][0]
    ): Request
    {

        // verify the required parameter 'relation_id' is set
        if ($relation_id === null || (is_array($relation_id) && count($relation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $relation_id when calling restPropertiesRelationsPut'
            );
        }


        $resourcePath = '/rest/properties/relations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $relation_id,
            'relationId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesRelationsRelationIdDelete
     *
     * Delete a property relation
     *
     * @param  int $relation_id The ID of the property relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsRelationIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restPropertiesRelationsRelationIdDelete(
        int $relation_id,
        string $contentType = self::contentTypes['restPropertiesRelationsRelationIdDelete'][0]
    ): void
    {
        $this->restPropertiesRelationsRelationIdDeleteWithHttpInfo($relation_id, $contentType);
    }

    /**
     * Operation restPropertiesRelationsRelationIdDeleteWithHttpInfo
     *
     * Delete a property relation
     *
     * @param  int $relation_id The ID of the property relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsRelationIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesRelationsRelationIdDeleteWithHttpInfo(
        int $relation_id,
        string $contentType = self::contentTypes['restPropertiesRelationsRelationIdDelete'][0]
    ): array
    {
        $request = $this->restPropertiesRelationsRelationIdDeleteRequest($relation_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesRelationsRelationIdDeleteAsync
     *
     * Delete a property relation
     *
     * @param  int $relation_id The ID of the property relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsRelationIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesRelationsRelationIdDeleteAsync(
        int $relation_id,
        string $contentType = self::contentTypes['restPropertiesRelationsRelationIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesRelationsRelationIdDeleteAsyncWithHttpInfo($relation_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesRelationsRelationIdDeleteAsyncWithHttpInfo
     *
     * Delete a property relation
     *
     * @param  int $relation_id The ID of the property relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsRelationIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesRelationsRelationIdDeleteAsyncWithHttpInfo(
        $relation_id,
        string $contentType = self::contentTypes['restPropertiesRelationsRelationIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restPropertiesRelationsRelationIdDeleteRequest($relation_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesRelationsRelationIdDelete'
     *
     * @param  int $relation_id The ID of the property relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsRelationIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesRelationsRelationIdDeleteRequest(
        $relation_id,
        string $contentType = self::contentTypes['restPropertiesRelationsRelationIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'relation_id' is set
        if ($relation_id === null || (is_array($relation_id) && count($relation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $relation_id when calling restPropertiesRelationsRelationIdDelete'
            );
        }


        $resourcePath = '/rest/properties/relations/{relationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($relation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'relationId' . '}',
                ObjectSerializer::toPathValue($relation_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesRelationsRelationIdFilePost
     *
     * Save property relation file to S3
     *
     * @param  int $relation_id The ID of the property relation (required)
     * @param  string $key The name of the file that needs to be saved (required)
     * @param  string $content The actual file content in text format (required)
     * @param  bool $delete_if_exists Condition for the check of already existing file (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsRelationIdFilePost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restPropertiesRelationsRelationIdFilePost(
        int $relation_id,
        string $key,
        string $content,
        bool $delete_if_exists,
        string $contentType = self::contentTypes['restPropertiesRelationsRelationIdFilePost'][0]
    ): object
    {
        list($response) = $this->restPropertiesRelationsRelationIdFilePostWithHttpInfo($relation_id, $key, $content, $delete_if_exists, $contentType);
        return $response;
    }

    /**
     * Operation restPropertiesRelationsRelationIdFilePostWithHttpInfo
     *
     * Save property relation file to S3
     *
     * @param  int $relation_id The ID of the property relation (required)
     * @param  string $key The name of the file that needs to be saved (required)
     * @param  string $content The actual file content in text format (required)
     * @param  bool $delete_if_exists Condition for the check of already existing file (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsRelationIdFilePost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesRelationsRelationIdFilePostWithHttpInfo(
        int $relation_id,
        string $key,
        string $content,
        bool $delete_if_exists,
        string $contentType = self::contentTypes['restPropertiesRelationsRelationIdFilePost'][0]
    ): array
    {
        $request = $this->restPropertiesRelationsRelationIdFilePostRequest($relation_id, $key, $content, $delete_if_exists, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesRelationsRelationIdFilePostAsync
     *
     * Save property relation file to S3
     *
     * @param  int $relation_id The ID of the property relation (required)
     * @param  string $key The name of the file that needs to be saved (required)
     * @param  string $content The actual file content in text format (required)
     * @param  bool $delete_if_exists Condition for the check of already existing file (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsRelationIdFilePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesRelationsRelationIdFilePostAsync(
        int $relation_id,
        string $key,
        string $content,
        bool $delete_if_exists,
        string $contentType = self::contentTypes['restPropertiesRelationsRelationIdFilePost'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesRelationsRelationIdFilePostAsyncWithHttpInfo($relation_id, $key, $content, $delete_if_exists, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesRelationsRelationIdFilePostAsyncWithHttpInfo
     *
     * Save property relation file to S3
     *
     * @param  int $relation_id The ID of the property relation (required)
     * @param  string $key The name of the file that needs to be saved (required)
     * @param  string $content The actual file content in text format (required)
     * @param  bool $delete_if_exists Condition for the check of already existing file (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsRelationIdFilePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesRelationsRelationIdFilePostAsyncWithHttpInfo(
        $relation_id,
        $key,
        $content,
        $delete_if_exists,
        string $contentType = self::contentTypes['restPropertiesRelationsRelationIdFilePost'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restPropertiesRelationsRelationIdFilePostRequest($relation_id, $key, $content, $delete_if_exists, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesRelationsRelationIdFilePost'
     *
     * @param  int $relation_id The ID of the property relation (required)
     * @param  string $key The name of the file that needs to be saved (required)
     * @param  string $content The actual file content in text format (required)
     * @param  bool $delete_if_exists Condition for the check of already existing file (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsRelationIdFilePost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesRelationsRelationIdFilePostRequest(
        $relation_id,
        $key,
        $content,
        $delete_if_exists,
        string $contentType = self::contentTypes['restPropertiesRelationsRelationIdFilePost'][0]
    ): Request
    {

        // verify the required parameter 'relation_id' is set
        if ($relation_id === null || (is_array($relation_id) && count($relation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $relation_id when calling restPropertiesRelationsRelationIdFilePost'
            );
        }

        // verify the required parameter 'key' is set
        if ($key === null || (is_array($key) && count($key) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $key when calling restPropertiesRelationsRelationIdFilePost'
            );
        }

        // verify the required parameter 'content' is set
        if ($content === null || (is_array($content) && count($content) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $content when calling restPropertiesRelationsRelationIdFilePost'
            );
        }

        // verify the required parameter 'delete_if_exists' is set
        if ($delete_if_exists === null || (is_array($delete_if_exists) && count($delete_if_exists) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $delete_if_exists when calling restPropertiesRelationsRelationIdFilePost'
            );
        }


        $resourcePath = '/rest/properties/relations/{relationId}/file';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $key,
            'key', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $content,
            'content', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $delete_if_exists,
            'deleteIfExists', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);


        // path params
        if ($relation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'relationId' . '}',
                ObjectSerializer::toPathValue($relation_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesRelationsRelationIdGet
     *
     * Get a property relation
     *
     * @param  int $relation_id The ID of the relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsRelationIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\PropertyRelation
     */
    public function restPropertiesRelationsRelationIdGet(
        int $relation_id,
        string $contentType = self::contentTypes['restPropertiesRelationsRelationIdGet'][0]
    ): \ck/plenty-client\Model\PropertyRelation
    {
        list($response) = $this->restPropertiesRelationsRelationIdGetWithHttpInfo($relation_id, $contentType);
        return $response;
    }

    /**
     * Operation restPropertiesRelationsRelationIdGetWithHttpInfo
     *
     * Get a property relation
     *
     * @param  int $relation_id The ID of the relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsRelationIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\PropertyRelation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesRelationsRelationIdGetWithHttpInfo(
        int $relation_id,
        string $contentType = self::contentTypes['restPropertiesRelationsRelationIdGet'][0]
    ): array
    {
        $request = $this->restPropertiesRelationsRelationIdGetRequest($relation_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\PropertyRelation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\PropertyRelation' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\PropertyRelation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\PropertyRelation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\PropertyRelation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesRelationsRelationIdGetAsync
     *
     * Get a property relation
     *
     * @param  int $relation_id The ID of the relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsRelationIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesRelationsRelationIdGetAsync(
        int $relation_id,
        string $contentType = self::contentTypes['restPropertiesRelationsRelationIdGet'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesRelationsRelationIdGetAsyncWithHttpInfo($relation_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesRelationsRelationIdGetAsyncWithHttpInfo
     *
     * Get a property relation
     *
     * @param  int $relation_id The ID of the relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsRelationIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesRelationsRelationIdGetAsyncWithHttpInfo(
        $relation_id,
        string $contentType = self::contentTypes['restPropertiesRelationsRelationIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\PropertyRelation';
        $request = $this->restPropertiesRelationsRelationIdGetRequest($relation_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesRelationsRelationIdGet'
     *
     * @param  int $relation_id The ID of the relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsRelationIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesRelationsRelationIdGetRequest(
        $relation_id,
        string $contentType = self::contentTypes['restPropertiesRelationsRelationIdGet'][0]
    ): Request
    {

        // verify the required parameter 'relation_id' is set
        if ($relation_id === null || (is_array($relation_id) && count($relation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $relation_id when calling restPropertiesRelationsRelationIdGet'
            );
        }


        $resourcePath = '/rest/properties/relations/{relationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($relation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'relationId' . '}',
                ObjectSerializer::toPathValue($relation_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesRelationsRelationIdPut
     *
     * Update a property relation
     *
     * @param  int $relation_id The ID of the property relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsRelationIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\PropertyRelation
     */
    public function restPropertiesRelationsRelationIdPut(
        int $relation_id,
        string $contentType = self::contentTypes['restPropertiesRelationsRelationIdPut'][0]
    ): \ck/plenty-client\Model\PropertyRelation
    {
        list($response) = $this->restPropertiesRelationsRelationIdPutWithHttpInfo($relation_id, $contentType);
        return $response;
    }

    /**
     * Operation restPropertiesRelationsRelationIdPutWithHttpInfo
     *
     * Update a property relation
     *
     * @param  int $relation_id The ID of the property relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsRelationIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\PropertyRelation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesRelationsRelationIdPutWithHttpInfo(
        int $relation_id,
        string $contentType = self::contentTypes['restPropertiesRelationsRelationIdPut'][0]
    ): array
    {
        $request = $this->restPropertiesRelationsRelationIdPutRequest($relation_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\PropertyRelation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\PropertyRelation' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\PropertyRelation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\PropertyRelation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\PropertyRelation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesRelationsRelationIdPutAsync
     *
     * Update a property relation
     *
     * @param  int $relation_id The ID of the property relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsRelationIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesRelationsRelationIdPutAsync(
        int $relation_id,
        string $contentType = self::contentTypes['restPropertiesRelationsRelationIdPut'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesRelationsRelationIdPutAsyncWithHttpInfo($relation_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesRelationsRelationIdPutAsyncWithHttpInfo
     *
     * Update a property relation
     *
     * @param  int $relation_id The ID of the property relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsRelationIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesRelationsRelationIdPutAsyncWithHttpInfo(
        $relation_id,
        string $contentType = self::contentTypes['restPropertiesRelationsRelationIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\PropertyRelation';
        $request = $this->restPropertiesRelationsRelationIdPutRequest($relation_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesRelationsRelationIdPut'
     *
     * @param  int $relation_id The ID of the property relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsRelationIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesRelationsRelationIdPutRequest(
        $relation_id,
        string $contentType = self::contentTypes['restPropertiesRelationsRelationIdPut'][0]
    ): Request
    {

        // verify the required parameter 'relation_id' is set
        if ($relation_id === null || (is_array($relation_id) && count($relation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $relation_id when calling restPropertiesRelationsRelationIdPut'
            );
        }


        $resourcePath = '/rest/properties/relations/{relationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($relation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'relationId' . '}',
                ObjectSerializer::toPathValue($relation_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesRelationsRelationIdValuesDelete
     *
     * Delete all property relation values of a specified property relation
     *
     * @param  int $relation_id relation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsRelationIdValuesDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restPropertiesRelationsRelationIdValuesDelete(
        int $relation_id,
        string $contentType = self::contentTypes['restPropertiesRelationsRelationIdValuesDelete'][0]
    ): void
    {
        $this->restPropertiesRelationsRelationIdValuesDeleteWithHttpInfo($relation_id, $contentType);
    }

    /**
     * Operation restPropertiesRelationsRelationIdValuesDeleteWithHttpInfo
     *
     * Delete all property relation values of a specified property relation
     *
     * @param  int $relation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsRelationIdValuesDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesRelationsRelationIdValuesDeleteWithHttpInfo(
        int $relation_id,
        string $contentType = self::contentTypes['restPropertiesRelationsRelationIdValuesDelete'][0]
    ): array
    {
        $request = $this->restPropertiesRelationsRelationIdValuesDeleteRequest($relation_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesRelationsRelationIdValuesDeleteAsync
     *
     * Delete all property relation values of a specified property relation
     *
     * @param  int $relation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsRelationIdValuesDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesRelationsRelationIdValuesDeleteAsync(
        int $relation_id,
        string $contentType = self::contentTypes['restPropertiesRelationsRelationIdValuesDelete'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesRelationsRelationIdValuesDeleteAsyncWithHttpInfo($relation_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesRelationsRelationIdValuesDeleteAsyncWithHttpInfo
     *
     * Delete all property relation values of a specified property relation
     *
     * @param  int $relation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsRelationIdValuesDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesRelationsRelationIdValuesDeleteAsyncWithHttpInfo(
        $relation_id,
        string $contentType = self::contentTypes['restPropertiesRelationsRelationIdValuesDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restPropertiesRelationsRelationIdValuesDeleteRequest($relation_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesRelationsRelationIdValuesDelete'
     *
     * @param  int $relation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsRelationIdValuesDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesRelationsRelationIdValuesDeleteRequest(
        $relation_id,
        string $contentType = self::contentTypes['restPropertiesRelationsRelationIdValuesDelete'][0]
    ): Request
    {

        // verify the required parameter 'relation_id' is set
        if ($relation_id === null || (is_array($relation_id) && count($relation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $relation_id when calling restPropertiesRelationsRelationIdValuesDelete'
            );
        }


        $resourcePath = '/rest/properties/relations/{relationId}/values';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($relation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'relationId' . '}',
                ObjectSerializer::toPathValue($relation_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesRelationsValuesGet
     *
     * List property relation values
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsValuesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\PropertyRelationValue[]
     */
    public function restPropertiesRelationsValuesGet(
        string $contentType = self::contentTypes['restPropertiesRelationsValuesGet'][0]
    ): array
    {
        list($response) = $this->restPropertiesRelationsValuesGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restPropertiesRelationsValuesGetWithHttpInfo
     *
     * List property relation values
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsValuesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\PropertyRelationValue[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesRelationsValuesGetWithHttpInfo(
        string $contentType = self::contentTypes['restPropertiesRelationsValuesGet'][0]
    ): array
    {
        $request = $this->restPropertiesRelationsValuesGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\PropertyRelationValue[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\PropertyRelationValue[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\PropertyRelationValue[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\PropertyRelationValue[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\PropertyRelationValue[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesRelationsValuesGetAsync
     *
     * List property relation values
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsValuesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesRelationsValuesGetAsync(
        string $contentType = self::contentTypes['restPropertiesRelationsValuesGet'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesRelationsValuesGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesRelationsValuesGetAsyncWithHttpInfo
     *
     * List property relation values
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsValuesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesRelationsValuesGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restPropertiesRelationsValuesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\PropertyRelationValue[]';
        $request = $this->restPropertiesRelationsValuesGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesRelationsValuesGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsValuesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesRelationsValuesGetRequest(
        string $contentType = self::contentTypes['restPropertiesRelationsValuesGet'][0]
    ): Request
    {


        $resourcePath = '/rest/properties/relations/values';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesRelationsValuesPost
     *
     * Create a property relation value
     *
     * @param  int $property_id The ID of the property (required)
     * @param  string $lang The lang of the property relation value (required)
     * @param  string $value The value of the property relation (required)
     * @param  \ck/plenty-client\Model\RestPropertiesRelationsValuesPostRequest|null $_rest_properties_relations_values _rest_properties_relations_values (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsValuesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\PropertyRelationValue
     */
    public function restPropertiesRelationsValuesPost(
        int $property_id,
        string $lang,
        string $value,
        ?\ck/plenty-client\Model\RestPropertiesRelationsValuesPostRequest $_rest_properties_relations_values = null,
        string $contentType = self::contentTypes['restPropertiesRelationsValuesPost'][0]
    ): \ck/plenty-client\Model\PropertyRelationValue
    {
        list($response) = $this->restPropertiesRelationsValuesPostWithHttpInfo($property_id, $lang, $value, $_rest_properties_relations_values, $contentType);
        return $response;
    }

    /**
     * Operation restPropertiesRelationsValuesPostWithHttpInfo
     *
     * Create a property relation value
     *
     * @param  int $property_id The ID of the property (required)
     * @param  string $lang The lang of the property relation value (required)
     * @param  string $value The value of the property relation (required)
     * @param  \ck/plenty-client\Model\RestPropertiesRelationsValuesPostRequest|null $_rest_properties_relations_values (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsValuesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\PropertyRelationValue, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesRelationsValuesPostWithHttpInfo(
        int $property_id,
        string $lang,
        string $value,
        ?\ck/plenty-client\Model\RestPropertiesRelationsValuesPostRequest $_rest_properties_relations_values = null,
        string $contentType = self::contentTypes['restPropertiesRelationsValuesPost'][0]
    ): array
    {
        $request = $this->restPropertiesRelationsValuesPostRequest($property_id, $lang, $value, $_rest_properties_relations_values, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\PropertyRelationValue' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\PropertyRelationValue' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\PropertyRelationValue', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\PropertyRelationValue';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\PropertyRelationValue',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesRelationsValuesPostAsync
     *
     * Create a property relation value
     *
     * @param  int $property_id The ID of the property (required)
     * @param  string $lang The lang of the property relation value (required)
     * @param  string $value The value of the property relation (required)
     * @param  \ck/plenty-client\Model\RestPropertiesRelationsValuesPostRequest|null $_rest_properties_relations_values (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsValuesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesRelationsValuesPostAsync(
        int $property_id,
        string $lang,
        string $value,
        ?\ck/plenty-client\Model\RestPropertiesRelationsValuesPostRequest $_rest_properties_relations_values = null,
        string $contentType = self::contentTypes['restPropertiesRelationsValuesPost'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesRelationsValuesPostAsyncWithHttpInfo($property_id, $lang, $value, $_rest_properties_relations_values, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesRelationsValuesPostAsyncWithHttpInfo
     *
     * Create a property relation value
     *
     * @param  int $property_id The ID of the property (required)
     * @param  string $lang The lang of the property relation value (required)
     * @param  string $value The value of the property relation (required)
     * @param  \ck/plenty-client\Model\RestPropertiesRelationsValuesPostRequest|null $_rest_properties_relations_values (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsValuesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesRelationsValuesPostAsyncWithHttpInfo(
        $property_id,
        $lang,
        $value,
        $_rest_properties_relations_values = null,
        string $contentType = self::contentTypes['restPropertiesRelationsValuesPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\PropertyRelationValue';
        $request = $this->restPropertiesRelationsValuesPostRequest($property_id, $lang, $value, $_rest_properties_relations_values, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesRelationsValuesPost'
     *
     * @param  int $property_id The ID of the property (required)
     * @param  string $lang The lang of the property relation value (required)
     * @param  string $value The value of the property relation (required)
     * @param  \ck/plenty-client\Model\RestPropertiesRelationsValuesPostRequest|null $_rest_properties_relations_values (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsValuesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesRelationsValuesPostRequest(
        $property_id,
        $lang,
        $value,
        $_rest_properties_relations_values = null,
        string $contentType = self::contentTypes['restPropertiesRelationsValuesPost'][0]
    ): Request
    {

        // verify the required parameter 'property_id' is set
        if ($property_id === null || (is_array($property_id) && count($property_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $property_id when calling restPropertiesRelationsValuesPost'
            );
        }

        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $lang when calling restPropertiesRelationsValuesPost'
            );
        }

        // verify the required parameter 'value' is set
        if ($value === null || (is_array($value) && count($value) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $value when calling restPropertiesRelationsValuesPost'
            );
        }



        $resourcePath = '/rest/properties/relations/values';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $property_id,
            'propertyId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $lang,
            'lang', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $value,
            'value', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_properties_relations_values)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_properties_relations_values));
            } else {
                $httpBody = $_rest_properties_relations_values;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesRelationsValuesPropertiesRelationValueIdDelete
     *
     * Delete a property relation value
     *
     * @param  int $property_relation_value_id The ID of the property relation value (required)
     * @param  int $properties_relation_value_id properties_relation_value_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsValuesPropertiesRelationValueIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restPropertiesRelationsValuesPropertiesRelationValueIdDelete(
        int $property_relation_value_id,
        int $properties_relation_value_id,
        string $contentType = self::contentTypes['restPropertiesRelationsValuesPropertiesRelationValueIdDelete'][0]
    ): void
    {
        $this->restPropertiesRelationsValuesPropertiesRelationValueIdDeleteWithHttpInfo($property_relation_value_id, $properties_relation_value_id, $contentType);
    }

    /**
     * Operation restPropertiesRelationsValuesPropertiesRelationValueIdDeleteWithHttpInfo
     *
     * Delete a property relation value
     *
     * @param  int $property_relation_value_id The ID of the property relation value (required)
     * @param  int $properties_relation_value_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsValuesPropertiesRelationValueIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesRelationsValuesPropertiesRelationValueIdDeleteWithHttpInfo(
        int $property_relation_value_id,
        int $properties_relation_value_id,
        string $contentType = self::contentTypes['restPropertiesRelationsValuesPropertiesRelationValueIdDelete'][0]
    ): array
    {
        $request = $this->restPropertiesRelationsValuesPropertiesRelationValueIdDeleteRequest($property_relation_value_id, $properties_relation_value_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesRelationsValuesPropertiesRelationValueIdDeleteAsync
     *
     * Delete a property relation value
     *
     * @param  int $property_relation_value_id The ID of the property relation value (required)
     * @param  int $properties_relation_value_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsValuesPropertiesRelationValueIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesRelationsValuesPropertiesRelationValueIdDeleteAsync(
        int $property_relation_value_id,
        int $properties_relation_value_id,
        string $contentType = self::contentTypes['restPropertiesRelationsValuesPropertiesRelationValueIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesRelationsValuesPropertiesRelationValueIdDeleteAsyncWithHttpInfo($property_relation_value_id, $properties_relation_value_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesRelationsValuesPropertiesRelationValueIdDeleteAsyncWithHttpInfo
     *
     * Delete a property relation value
     *
     * @param  int $property_relation_value_id The ID of the property relation value (required)
     * @param  int $properties_relation_value_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsValuesPropertiesRelationValueIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesRelationsValuesPropertiesRelationValueIdDeleteAsyncWithHttpInfo(
        $property_relation_value_id,
        $properties_relation_value_id,
        string $contentType = self::contentTypes['restPropertiesRelationsValuesPropertiesRelationValueIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restPropertiesRelationsValuesPropertiesRelationValueIdDeleteRequest($property_relation_value_id, $properties_relation_value_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesRelationsValuesPropertiesRelationValueIdDelete'
     *
     * @param  int $property_relation_value_id The ID of the property relation value (required)
     * @param  int $properties_relation_value_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsValuesPropertiesRelationValueIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesRelationsValuesPropertiesRelationValueIdDeleteRequest(
        $property_relation_value_id,
        $properties_relation_value_id,
        string $contentType = self::contentTypes['restPropertiesRelationsValuesPropertiesRelationValueIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'property_relation_value_id' is set
        if ($property_relation_value_id === null || (is_array($property_relation_value_id) && count($property_relation_value_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $property_relation_value_id when calling restPropertiesRelationsValuesPropertiesRelationValueIdDelete'
            );
        }

        // verify the required parameter 'properties_relation_value_id' is set
        if ($properties_relation_value_id === null || (is_array($properties_relation_value_id) && count($properties_relation_value_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $properties_relation_value_id when calling restPropertiesRelationsValuesPropertiesRelationValueIdDelete'
            );
        }


        $resourcePath = '/rest/properties/relations/values/{propertiesRelationValueId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $property_relation_value_id,
            'propertyRelationValueId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);


        // path params
        if ($properties_relation_value_id !== null) {
            $resourcePath = str_replace(
                '{' . 'propertiesRelationValueId' . '}',
                ObjectSerializer::toPathValue($properties_relation_value_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesRelationsValuesPropertiesRelationValueIdPut
     *
     * Update a property relation value
     *
     * @param  int $property_relation_value_id The ID of the property relation value (required)
     * @param  int $properties_relation_value_id properties_relation_value_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsValuesPropertiesRelationValueIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\PropertyRelationValue
     */
    public function restPropertiesRelationsValuesPropertiesRelationValueIdPut(
        int $property_relation_value_id,
        int $properties_relation_value_id,
        string $contentType = self::contentTypes['restPropertiesRelationsValuesPropertiesRelationValueIdPut'][0]
    ): \ck/plenty-client\Model\PropertyRelationValue
    {
        list($response) = $this->restPropertiesRelationsValuesPropertiesRelationValueIdPutWithHttpInfo($property_relation_value_id, $properties_relation_value_id, $contentType);
        return $response;
    }

    /**
     * Operation restPropertiesRelationsValuesPropertiesRelationValueIdPutWithHttpInfo
     *
     * Update a property relation value
     *
     * @param  int $property_relation_value_id The ID of the property relation value (required)
     * @param  int $properties_relation_value_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsValuesPropertiesRelationValueIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\PropertyRelationValue, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesRelationsValuesPropertiesRelationValueIdPutWithHttpInfo(
        int $property_relation_value_id,
        int $properties_relation_value_id,
        string $contentType = self::contentTypes['restPropertiesRelationsValuesPropertiesRelationValueIdPut'][0]
    ): array
    {
        $request = $this->restPropertiesRelationsValuesPropertiesRelationValueIdPutRequest($property_relation_value_id, $properties_relation_value_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\PropertyRelationValue' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\PropertyRelationValue' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\PropertyRelationValue', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\PropertyRelationValue';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\PropertyRelationValue',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesRelationsValuesPropertiesRelationValueIdPutAsync
     *
     * Update a property relation value
     *
     * @param  int $property_relation_value_id The ID of the property relation value (required)
     * @param  int $properties_relation_value_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsValuesPropertiesRelationValueIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesRelationsValuesPropertiesRelationValueIdPutAsync(
        int $property_relation_value_id,
        int $properties_relation_value_id,
        string $contentType = self::contentTypes['restPropertiesRelationsValuesPropertiesRelationValueIdPut'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesRelationsValuesPropertiesRelationValueIdPutAsyncWithHttpInfo($property_relation_value_id, $properties_relation_value_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesRelationsValuesPropertiesRelationValueIdPutAsyncWithHttpInfo
     *
     * Update a property relation value
     *
     * @param  int $property_relation_value_id The ID of the property relation value (required)
     * @param  int $properties_relation_value_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsValuesPropertiesRelationValueIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesRelationsValuesPropertiesRelationValueIdPutAsyncWithHttpInfo(
        $property_relation_value_id,
        $properties_relation_value_id,
        string $contentType = self::contentTypes['restPropertiesRelationsValuesPropertiesRelationValueIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\PropertyRelationValue';
        $request = $this->restPropertiesRelationsValuesPropertiesRelationValueIdPutRequest($property_relation_value_id, $properties_relation_value_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesRelationsValuesPropertiesRelationValueIdPut'
     *
     * @param  int $property_relation_value_id The ID of the property relation value (required)
     * @param  int $properties_relation_value_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsValuesPropertiesRelationValueIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesRelationsValuesPropertiesRelationValueIdPutRequest(
        $property_relation_value_id,
        $properties_relation_value_id,
        string $contentType = self::contentTypes['restPropertiesRelationsValuesPropertiesRelationValueIdPut'][0]
    ): Request
    {

        // verify the required parameter 'property_relation_value_id' is set
        if ($property_relation_value_id === null || (is_array($property_relation_value_id) && count($property_relation_value_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $property_relation_value_id when calling restPropertiesRelationsValuesPropertiesRelationValueIdPut'
            );
        }

        // verify the required parameter 'properties_relation_value_id' is set
        if ($properties_relation_value_id === null || (is_array($properties_relation_value_id) && count($properties_relation_value_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $properties_relation_value_id when calling restPropertiesRelationsValuesPropertiesRelationValueIdPut'
            );
        }


        $resourcePath = '/rest/properties/relations/values/{propertiesRelationValueId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $property_relation_value_id,
            '$propertyRelationValueId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);


        // path params
        if ($properties_relation_value_id !== null) {
            $resourcePath = str_replace(
                '{' . 'propertiesRelationValueId' . '}',
                ObjectSerializer::toPathValue($properties_relation_value_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesRelationsValuesPut
     *
     * Update multiple property relation value
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsValuesPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\PropertyRelationValue
     */
    public function restPropertiesRelationsValuesPut(
        string $contentType = self::contentTypes['restPropertiesRelationsValuesPut'][0]
    ): \ck/plenty-client\Model\PropertyRelationValue
    {
        list($response) = $this->restPropertiesRelationsValuesPutWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restPropertiesRelationsValuesPutWithHttpInfo
     *
     * Update multiple property relation value
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsValuesPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\PropertyRelationValue, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesRelationsValuesPutWithHttpInfo(
        string $contentType = self::contentTypes['restPropertiesRelationsValuesPut'][0]
    ): array
    {
        $request = $this->restPropertiesRelationsValuesPutRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\PropertyRelationValue' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\PropertyRelationValue' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\PropertyRelationValue', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\PropertyRelationValue';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\PropertyRelationValue',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesRelationsValuesPutAsync
     *
     * Update multiple property relation value
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsValuesPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesRelationsValuesPutAsync(
        string $contentType = self::contentTypes['restPropertiesRelationsValuesPut'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesRelationsValuesPutAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesRelationsValuesPutAsyncWithHttpInfo
     *
     * Update multiple property relation value
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsValuesPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesRelationsValuesPutAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restPropertiesRelationsValuesPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\PropertyRelationValue';
        $request = $this->restPropertiesRelationsValuesPutRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesRelationsValuesPut'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsValuesPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesRelationsValuesPutRequest(
        string $contentType = self::contentTypes['restPropertiesRelationsValuesPut'][0]
    ): Request
    {


        $resourcePath = '/rest/properties/relations/values';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesRelationsValuesRelationMarkupIdGet
     *
     * Get a property relation value
     *
     * @param  int $property_relation_id The ID of the property relation (required)
     * @param  int $relation_markup_id relation_markup_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsValuesRelationMarkupIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\PropertyRelationValue
     */
    public function restPropertiesRelationsValuesRelationMarkupIdGet(
        int $property_relation_id,
        int $relation_markup_id,
        string $contentType = self::contentTypes['restPropertiesRelationsValuesRelationMarkupIdGet'][0]
    ): \ck/plenty-client\Model\PropertyRelationValue
    {
        list($response) = $this->restPropertiesRelationsValuesRelationMarkupIdGetWithHttpInfo($property_relation_id, $relation_markup_id, $contentType);
        return $response;
    }

    /**
     * Operation restPropertiesRelationsValuesRelationMarkupIdGetWithHttpInfo
     *
     * Get a property relation value
     *
     * @param  int $property_relation_id The ID of the property relation (required)
     * @param  int $relation_markup_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsValuesRelationMarkupIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\PropertyRelationValue, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesRelationsValuesRelationMarkupIdGetWithHttpInfo(
        int $property_relation_id,
        int $relation_markup_id,
        string $contentType = self::contentTypes['restPropertiesRelationsValuesRelationMarkupIdGet'][0]
    ): array
    {
        $request = $this->restPropertiesRelationsValuesRelationMarkupIdGetRequest($property_relation_id, $relation_markup_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\PropertyRelationValue' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\PropertyRelationValue' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\PropertyRelationValue', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\PropertyRelationValue';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\PropertyRelationValue',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesRelationsValuesRelationMarkupIdGetAsync
     *
     * Get a property relation value
     *
     * @param  int $property_relation_id The ID of the property relation (required)
     * @param  int $relation_markup_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsValuesRelationMarkupIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesRelationsValuesRelationMarkupIdGetAsync(
        int $property_relation_id,
        int $relation_markup_id,
        string $contentType = self::contentTypes['restPropertiesRelationsValuesRelationMarkupIdGet'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesRelationsValuesRelationMarkupIdGetAsyncWithHttpInfo($property_relation_id, $relation_markup_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesRelationsValuesRelationMarkupIdGetAsyncWithHttpInfo
     *
     * Get a property relation value
     *
     * @param  int $property_relation_id The ID of the property relation (required)
     * @param  int $relation_markup_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsValuesRelationMarkupIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesRelationsValuesRelationMarkupIdGetAsyncWithHttpInfo(
        $property_relation_id,
        $relation_markup_id,
        string $contentType = self::contentTypes['restPropertiesRelationsValuesRelationMarkupIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\PropertyRelationValue';
        $request = $this->restPropertiesRelationsValuesRelationMarkupIdGetRequest($property_relation_id, $relation_markup_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesRelationsValuesRelationMarkupIdGet'
     *
     * @param  int $property_relation_id The ID of the property relation (required)
     * @param  int $relation_markup_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesRelationsValuesRelationMarkupIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesRelationsValuesRelationMarkupIdGetRequest(
        $property_relation_id,
        $relation_markup_id,
        string $contentType = self::contentTypes['restPropertiesRelationsValuesRelationMarkupIdGet'][0]
    ): Request
    {

        // verify the required parameter 'property_relation_id' is set
        if ($property_relation_id === null || (is_array($property_relation_id) && count($property_relation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $property_relation_id when calling restPropertiesRelationsValuesRelationMarkupIdGet'
            );
        }

        // verify the required parameter 'relation_markup_id' is set
        if ($relation_markup_id === null || (is_array($relation_markup_id) && count($relation_markup_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $relation_markup_id when calling restPropertiesRelationsValuesRelationMarkupIdGet'
            );
        }


        $resourcePath = '/rest/properties/relations/values/{relationMarkupId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $property_relation_id,
            'propertyRelationId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);


        // path params
        if ($relation_markup_id !== null) {
            $resourcePath = str_replace(
                '{' . 'relationMarkupId' . '}',
                ObjectSerializer::toPathValue($relation_markup_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesSelectionsGet
     *
     * List property selections
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesSelectionsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\PropertySelection[]
     */
    public function restPropertiesSelectionsGet(
        string $contentType = self::contentTypes['restPropertiesSelectionsGet'][0]
    ): array
    {
        list($response) = $this->restPropertiesSelectionsGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restPropertiesSelectionsGetWithHttpInfo
     *
     * List property selections
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesSelectionsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\PropertySelection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesSelectionsGetWithHttpInfo(
        string $contentType = self::contentTypes['restPropertiesSelectionsGet'][0]
    ): array
    {
        $request = $this->restPropertiesSelectionsGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\PropertySelection[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\PropertySelection[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\PropertySelection[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\PropertySelection[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\PropertySelection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesSelectionsGetAsync
     *
     * List property selections
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesSelectionsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesSelectionsGetAsync(
        string $contentType = self::contentTypes['restPropertiesSelectionsGet'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesSelectionsGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesSelectionsGetAsyncWithHttpInfo
     *
     * List property selections
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesSelectionsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesSelectionsGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restPropertiesSelectionsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\PropertySelection[]';
        $request = $this->restPropertiesSelectionsGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesSelectionsGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesSelectionsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesSelectionsGetRequest(
        string $contentType = self::contentTypes['restPropertiesSelectionsGet'][0]
    ): Request
    {


        $resourcePath = '/rest/properties/selections';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesSelectionsPost
     *
     * Create a property selection
     *
     * @param  int $property_id The ID of the property (required)
     * @param  int $position The position of the property selection (required)
     * @param  \ck/plenty-client\Model\RestPropertiesSelectionsPostRequest|null $_rest_properties_selections _rest_properties_selections (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesSelectionsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\PropertySelection
     */
    public function restPropertiesSelectionsPost(
        int $property_id,
        int $position,
        ?\ck/plenty-client\Model\RestPropertiesSelectionsPostRequest $_rest_properties_selections = null,
        string $contentType = self::contentTypes['restPropertiesSelectionsPost'][0]
    ): \ck/plenty-client\Model\PropertySelection
    {
        list($response) = $this->restPropertiesSelectionsPostWithHttpInfo($property_id, $position, $_rest_properties_selections, $contentType);
        return $response;
    }

    /**
     * Operation restPropertiesSelectionsPostWithHttpInfo
     *
     * Create a property selection
     *
     * @param  int $property_id The ID of the property (required)
     * @param  int $position The position of the property selection (required)
     * @param  \ck/plenty-client\Model\RestPropertiesSelectionsPostRequest|null $_rest_properties_selections (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesSelectionsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\PropertySelection, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesSelectionsPostWithHttpInfo(
        int $property_id,
        int $position,
        ?\ck/plenty-client\Model\RestPropertiesSelectionsPostRequest $_rest_properties_selections = null,
        string $contentType = self::contentTypes['restPropertiesSelectionsPost'][0]
    ): array
    {
        $request = $this->restPropertiesSelectionsPostRequest($property_id, $position, $_rest_properties_selections, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\PropertySelection' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\PropertySelection' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\PropertySelection', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\PropertySelection';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\PropertySelection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesSelectionsPostAsync
     *
     * Create a property selection
     *
     * @param  int $property_id The ID of the property (required)
     * @param  int $position The position of the property selection (required)
     * @param  \ck/plenty-client\Model\RestPropertiesSelectionsPostRequest|null $_rest_properties_selections (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesSelectionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesSelectionsPostAsync(
        int $property_id,
        int $position,
        ?\ck/plenty-client\Model\RestPropertiesSelectionsPostRequest $_rest_properties_selections = null,
        string $contentType = self::contentTypes['restPropertiesSelectionsPost'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesSelectionsPostAsyncWithHttpInfo($property_id, $position, $_rest_properties_selections, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesSelectionsPostAsyncWithHttpInfo
     *
     * Create a property selection
     *
     * @param  int $property_id The ID of the property (required)
     * @param  int $position The position of the property selection (required)
     * @param  \ck/plenty-client\Model\RestPropertiesSelectionsPostRequest|null $_rest_properties_selections (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesSelectionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesSelectionsPostAsyncWithHttpInfo(
        $property_id,
        $position,
        $_rest_properties_selections = null,
        string $contentType = self::contentTypes['restPropertiesSelectionsPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\PropertySelection';
        $request = $this->restPropertiesSelectionsPostRequest($property_id, $position, $_rest_properties_selections, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesSelectionsPost'
     *
     * @param  int $property_id The ID of the property (required)
     * @param  int $position The position of the property selection (required)
     * @param  \ck/plenty-client\Model\RestPropertiesSelectionsPostRequest|null $_rest_properties_selections (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesSelectionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesSelectionsPostRequest(
        $property_id,
        $position,
        $_rest_properties_selections = null,
        string $contentType = self::contentTypes['restPropertiesSelectionsPost'][0]
    ): Request
    {

        // verify the required parameter 'property_id' is set
        if ($property_id === null || (is_array($property_id) && count($property_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $property_id when calling restPropertiesSelectionsPost'
            );
        }

        // verify the required parameter 'position' is set
        if ($position === null || (is_array($position) && count($position) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $position when calling restPropertiesSelectionsPost'
            );
        }



        $resourcePath = '/rest/properties/selections';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $property_id,
            'propertyId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $position,
            'position', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_properties_selections)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_properties_selections));
            } else {
                $httpBody = $_rest_properties_selections;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesSelectionsPropertySelectionIdDelete
     *
     * Delete a property selection
     *
     * @param  int $property_selection_id The ID of the property selection (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesSelectionsPropertySelectionIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restPropertiesSelectionsPropertySelectionIdDelete(
        int $property_selection_id,
        string $contentType = self::contentTypes['restPropertiesSelectionsPropertySelectionIdDelete'][0]
    ): void
    {
        $this->restPropertiesSelectionsPropertySelectionIdDeleteWithHttpInfo($property_selection_id, $contentType);
    }

    /**
     * Operation restPropertiesSelectionsPropertySelectionIdDeleteWithHttpInfo
     *
     * Delete a property selection
     *
     * @param  int $property_selection_id The ID of the property selection (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesSelectionsPropertySelectionIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesSelectionsPropertySelectionIdDeleteWithHttpInfo(
        int $property_selection_id,
        string $contentType = self::contentTypes['restPropertiesSelectionsPropertySelectionIdDelete'][0]
    ): array
    {
        $request = $this->restPropertiesSelectionsPropertySelectionIdDeleteRequest($property_selection_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesSelectionsPropertySelectionIdDeleteAsync
     *
     * Delete a property selection
     *
     * @param  int $property_selection_id The ID of the property selection (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesSelectionsPropertySelectionIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesSelectionsPropertySelectionIdDeleteAsync(
        int $property_selection_id,
        string $contentType = self::contentTypes['restPropertiesSelectionsPropertySelectionIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesSelectionsPropertySelectionIdDeleteAsyncWithHttpInfo($property_selection_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesSelectionsPropertySelectionIdDeleteAsyncWithHttpInfo
     *
     * Delete a property selection
     *
     * @param  int $property_selection_id The ID of the property selection (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesSelectionsPropertySelectionIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesSelectionsPropertySelectionIdDeleteAsyncWithHttpInfo(
        $property_selection_id,
        string $contentType = self::contentTypes['restPropertiesSelectionsPropertySelectionIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restPropertiesSelectionsPropertySelectionIdDeleteRequest($property_selection_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesSelectionsPropertySelectionIdDelete'
     *
     * @param  int $property_selection_id The ID of the property selection (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesSelectionsPropertySelectionIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesSelectionsPropertySelectionIdDeleteRequest(
        $property_selection_id,
        string $contentType = self::contentTypes['restPropertiesSelectionsPropertySelectionIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'property_selection_id' is set
        if ($property_selection_id === null || (is_array($property_selection_id) && count($property_selection_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $property_selection_id when calling restPropertiesSelectionsPropertySelectionIdDelete'
            );
        }


        $resourcePath = '/rest/properties/selections/{propertySelectionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($property_selection_id !== null) {
            $resourcePath = str_replace(
                '{' . 'propertySelectionId' . '}',
                ObjectSerializer::toPathValue($property_selection_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesSelectionsPropertySelectionIdGet
     *
     * Get a property selection
     *
     * @param  int $property_selection_id The ID of the property selection (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesSelectionsPropertySelectionIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\PropertySelection
     */
    public function restPropertiesSelectionsPropertySelectionIdGet(
        int $property_selection_id,
        string $contentType = self::contentTypes['restPropertiesSelectionsPropertySelectionIdGet'][0]
    ): \ck/plenty-client\Model\PropertySelection
    {
        list($response) = $this->restPropertiesSelectionsPropertySelectionIdGetWithHttpInfo($property_selection_id, $contentType);
        return $response;
    }

    /**
     * Operation restPropertiesSelectionsPropertySelectionIdGetWithHttpInfo
     *
     * Get a property selection
     *
     * @param  int $property_selection_id The ID of the property selection (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesSelectionsPropertySelectionIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\PropertySelection, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesSelectionsPropertySelectionIdGetWithHttpInfo(
        int $property_selection_id,
        string $contentType = self::contentTypes['restPropertiesSelectionsPropertySelectionIdGet'][0]
    ): array
    {
        $request = $this->restPropertiesSelectionsPropertySelectionIdGetRequest($property_selection_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\PropertySelection' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\PropertySelection' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\PropertySelection', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\PropertySelection';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\PropertySelection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesSelectionsPropertySelectionIdGetAsync
     *
     * Get a property selection
     *
     * @param  int $property_selection_id The ID of the property selection (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesSelectionsPropertySelectionIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesSelectionsPropertySelectionIdGetAsync(
        int $property_selection_id,
        string $contentType = self::contentTypes['restPropertiesSelectionsPropertySelectionIdGet'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesSelectionsPropertySelectionIdGetAsyncWithHttpInfo($property_selection_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesSelectionsPropertySelectionIdGetAsyncWithHttpInfo
     *
     * Get a property selection
     *
     * @param  int $property_selection_id The ID of the property selection (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesSelectionsPropertySelectionIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesSelectionsPropertySelectionIdGetAsyncWithHttpInfo(
        $property_selection_id,
        string $contentType = self::contentTypes['restPropertiesSelectionsPropertySelectionIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\PropertySelection';
        $request = $this->restPropertiesSelectionsPropertySelectionIdGetRequest($property_selection_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesSelectionsPropertySelectionIdGet'
     *
     * @param  int $property_selection_id The ID of the property selection (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesSelectionsPropertySelectionIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesSelectionsPropertySelectionIdGetRequest(
        $property_selection_id,
        string $contentType = self::contentTypes['restPropertiesSelectionsPropertySelectionIdGet'][0]
    ): Request
    {

        // verify the required parameter 'property_selection_id' is set
        if ($property_selection_id === null || (is_array($property_selection_id) && count($property_selection_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $property_selection_id when calling restPropertiesSelectionsPropertySelectionIdGet'
            );
        }


        $resourcePath = '/rest/properties/selections/{propertySelectionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($property_selection_id !== null) {
            $resourcePath = str_replace(
                '{' . 'propertySelectionId' . '}',
                ObjectSerializer::toPathValue($property_selection_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesSelectionsPropertySelectionIdPut
     *
     * Update a property selection
     *
     * @param  int $property_selection_id The ID of the property selection (required)
     * @param  int $property_selection_id2 property_selection_id2 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesSelectionsPropertySelectionIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\PropertySelection
     */
    public function restPropertiesSelectionsPropertySelectionIdPut(
        int $property_selection_id,
        int $property_selection_id2,
        string $contentType = self::contentTypes['restPropertiesSelectionsPropertySelectionIdPut'][0]
    ): \ck/plenty-client\Model\PropertySelection
    {
        list($response) = $this->restPropertiesSelectionsPropertySelectionIdPutWithHttpInfo($property_selection_id, $property_selection_id2, $contentType);
        return $response;
    }

    /**
     * Operation restPropertiesSelectionsPropertySelectionIdPutWithHttpInfo
     *
     * Update a property selection
     *
     * @param  int $property_selection_id The ID of the property selection (required)
     * @param  int $property_selection_id2 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesSelectionsPropertySelectionIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\PropertySelection, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesSelectionsPropertySelectionIdPutWithHttpInfo(
        int $property_selection_id,
        int $property_selection_id2,
        string $contentType = self::contentTypes['restPropertiesSelectionsPropertySelectionIdPut'][0]
    ): array
    {
        $request = $this->restPropertiesSelectionsPropertySelectionIdPutRequest($property_selection_id, $property_selection_id2, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\PropertySelection' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\PropertySelection' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\PropertySelection', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\PropertySelection';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\PropertySelection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesSelectionsPropertySelectionIdPutAsync
     *
     * Update a property selection
     *
     * @param  int $property_selection_id The ID of the property selection (required)
     * @param  int $property_selection_id2 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesSelectionsPropertySelectionIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesSelectionsPropertySelectionIdPutAsync(
        int $property_selection_id,
        int $property_selection_id2,
        string $contentType = self::contentTypes['restPropertiesSelectionsPropertySelectionIdPut'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesSelectionsPropertySelectionIdPutAsyncWithHttpInfo($property_selection_id, $property_selection_id2, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesSelectionsPropertySelectionIdPutAsyncWithHttpInfo
     *
     * Update a property selection
     *
     * @param  int $property_selection_id The ID of the property selection (required)
     * @param  int $property_selection_id2 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesSelectionsPropertySelectionIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesSelectionsPropertySelectionIdPutAsyncWithHttpInfo(
        $property_selection_id,
        $property_selection_id2,
        string $contentType = self::contentTypes['restPropertiesSelectionsPropertySelectionIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\PropertySelection';
        $request = $this->restPropertiesSelectionsPropertySelectionIdPutRequest($property_selection_id, $property_selection_id2, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesSelectionsPropertySelectionIdPut'
     *
     * @param  int $property_selection_id The ID of the property selection (required)
     * @param  int $property_selection_id2 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesSelectionsPropertySelectionIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesSelectionsPropertySelectionIdPutRequest(
        $property_selection_id,
        $property_selection_id2,
        string $contentType = self::contentTypes['restPropertiesSelectionsPropertySelectionIdPut'][0]
    ): Request
    {

        // verify the required parameter 'property_selection_id' is set
        if ($property_selection_id === null || (is_array($property_selection_id) && count($property_selection_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $property_selection_id when calling restPropertiesSelectionsPropertySelectionIdPut'
            );
        }

        // verify the required parameter 'property_selection_id2' is set
        if ($property_selection_id2 === null || (is_array($property_selection_id2) && count($property_selection_id2) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $property_selection_id2 when calling restPropertiesSelectionsPropertySelectionIdPut'
            );
        }


        $resourcePath = '/rest/properties/selections/{propertySelectionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $property_selection_id,
            '$propertySelectionId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);


        // path params
        if ($property_selection_id2 !== null) {
            $resourcePath = str_replace(
                '{' . 'propertySelectionId' . '}',
                ObjectSerializer::toPathValue($property_selection_id2),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restPropertiesSystemlangGet
     *
     * Get system language
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesSystemlangGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restPropertiesSystemlangGet(
        string $contentType = self::contentTypes['restPropertiesSystemlangGet'][0]
    ): object
    {
        list($response) = $this->restPropertiesSystemlangGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restPropertiesSystemlangGetWithHttpInfo
     *
     * Get system language
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesSystemlangGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restPropertiesSystemlangGetWithHttpInfo(
        string $contentType = self::contentTypes['restPropertiesSystemlangGet'][0]
    ): array
    {
        $request = $this->restPropertiesSystemlangGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restPropertiesSystemlangGetAsync
     *
     * Get system language
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesSystemlangGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesSystemlangGetAsync(
        string $contentType = self::contentTypes['restPropertiesSystemlangGet'][0]
    ): PromiseInterface
    {
        return $this->restPropertiesSystemlangGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restPropertiesSystemlangGetAsyncWithHttpInfo
     *
     * Get system language
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesSystemlangGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restPropertiesSystemlangGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restPropertiesSystemlangGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restPropertiesSystemlangGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restPropertiesSystemlangGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restPropertiesSystemlangGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restPropertiesSystemlangGetRequest(
        string $contentType = self::contentTypes['restPropertiesSystemlangGet'][0]
    ): Request
    {


        $resourcePath = '/rest/properties/systemlang';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption(): array
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
