<?php
/**
 * NewsletterApi
 * PHP version 8.1
 *
 * @package  ck/plenty-client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * plentymarkets REST-API
 *
 * The plentymarkets REST API expands the functionality of the plentymarkets CMS and allows access to resources, i.e. data records, via unique URI paths
 *
 * The version of the OpenAPI document: 1.0.0
 * @generated Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 7.1.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace ck/plenty-client\Api;

use InvalidArgumentException;
use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use GuzzleHttp\Promise\PromiseInterface;
use ck/plenty-client\ApiException;
use ck/plenty-client\Configuration;
use ck/plenty-client\HeaderSelector;
use ck/plenty-client\ObjectSerializer;

/**
 * NewsletterApi Class Doc Comment
 *
 * @package  ck/plenty-client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class NewsletterApi
{
    /**
     * @var ClientInterface
     */
    protected ClientInterface $client;

    /**
     * @var Configuration
     */
    protected Configuration $config;

    /**
     * @var HeaderSelector
     */
    protected HeaderSelector $headerSelector;

    /**
     * @var int Host index
     */
    protected int $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'restNewslettersDelete' => [
            'application/json',
        ],
        'restNewslettersDoubleOptInContactIdPost' => [
            'application/json',
        ],
        'restNewslettersEntryIdDelete' => [
            'application/json',
        ],
        'restNewslettersEntryIdGet' => [
            'application/json',
        ],
        'restNewslettersEntryIdPut' => [
            'application/json',
        ],
        'restNewslettersFoldersDelete' => [
            'application/json',
        ],
        'restNewslettersFoldersFolderIdDelete' => [
            'application/json',
        ],
        'restNewslettersFoldersFolderIdGet' => [
            'application/json',
        ],
        'restNewslettersFoldersFolderIdPut' => [
            'application/json',
        ],
        'restNewslettersFoldersFolderIdRecipientsGet' => [
            'application/json',
        ],
        'restNewslettersFoldersGet' => [
            'application/json',
        ],
        'restNewslettersFoldersPost' => [
            'application/json',
        ],
        'restNewslettersGet' => [
            'application/json',
        ],
        'restNewslettersListRecipientsGet' => [
            'application/json',
        ],
        'restNewslettersPost' => [
            'application/json',
        ],
        'restNewslettersRecipientsDelete' => [
            'application/json',
        ],
        'restNewslettersRecipientsGet' => [
            'application/json',
        ],
        'restNewslettersRecipientsPost' => [
            'application/json',
        ],
        'restNewslettersRecipientsRecipientIdDelete' => [
            'application/json',
        ],
        'restNewslettersRecipientsRecipientIdGet' => [
            'application/json',
        ],
        'restNewslettersRecipientsRecipientIdPut' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface|null $client
     * @param Configuration|null   $config
     * @param HeaderSelector|null  $selector
     * @param int                  $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex(int $hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex(): int
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig(): Configuration
    {
        return $this->config;
    }

    /**
     * Operation restNewslettersDelete
     *
     * Delete entries
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\Entry[]
     */
    public function restNewslettersDelete(
        string $contentType = self::contentTypes['restNewslettersDelete'][0]
    ): array
    {
        list($response) = $this->restNewslettersDeleteWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restNewslettersDeleteWithHttpInfo
     *
     * Delete entries
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\Entry[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersDeleteWithHttpInfo(
        string $contentType = self::contentTypes['restNewslettersDelete'][0]
    ): array
    {
        $request = $this->restNewslettersDeleteRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\Entry[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\Entry[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\Entry[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\Entry[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\Entry[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersDeleteAsync
     *
     * Delete entries
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restNewslettersDeleteAsync(
        string $contentType = self::contentTypes['restNewslettersDelete'][0]
    ): PromiseInterface
    {
        return $this->restNewslettersDeleteAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersDeleteAsyncWithHttpInfo
     *
     * Delete entries
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restNewslettersDeleteAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restNewslettersDelete'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\Entry[]';
        $request = $this->restNewslettersDeleteRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersDelete'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restNewslettersDeleteRequest(
        string $contentType = self::contentTypes['restNewslettersDelete'][0]
    ): Request
    {


        $resourcePath = '/rest/newsletters';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersDoubleOptInContactIdPost
     *
     * Send doubleOptIn mail
     *
     * @param  int $contact_id The ID of the costumer contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersDoubleOptInContactIdPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restNewslettersDoubleOptInContactIdPost(
        int $contact_id,
        string $contentType = self::contentTypes['restNewslettersDoubleOptInContactIdPost'][0]
    ): object
    {
        list($response) = $this->restNewslettersDoubleOptInContactIdPostWithHttpInfo($contact_id, $contentType);
        return $response;
    }

    /**
     * Operation restNewslettersDoubleOptInContactIdPostWithHttpInfo
     *
     * Send doubleOptIn mail
     *
     * @param  int $contact_id The ID of the costumer contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersDoubleOptInContactIdPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersDoubleOptInContactIdPostWithHttpInfo(
        int $contact_id,
        string $contentType = self::contentTypes['restNewslettersDoubleOptInContactIdPost'][0]
    ): array
    {
        $request = $this->restNewslettersDoubleOptInContactIdPostRequest($contact_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersDoubleOptInContactIdPostAsync
     *
     * Send doubleOptIn mail
     *
     * @param  int $contact_id The ID of the costumer contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersDoubleOptInContactIdPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restNewslettersDoubleOptInContactIdPostAsync(
        int $contact_id,
        string $contentType = self::contentTypes['restNewslettersDoubleOptInContactIdPost'][0]
    ): PromiseInterface
    {
        return $this->restNewslettersDoubleOptInContactIdPostAsyncWithHttpInfo($contact_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersDoubleOptInContactIdPostAsyncWithHttpInfo
     *
     * Send doubleOptIn mail
     *
     * @param  int $contact_id The ID of the costumer contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersDoubleOptInContactIdPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restNewslettersDoubleOptInContactIdPostAsyncWithHttpInfo(
        $contact_id,
        string $contentType = self::contentTypes['restNewslettersDoubleOptInContactIdPost'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restNewslettersDoubleOptInContactIdPostRequest($contact_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersDoubleOptInContactIdPost'
     *
     * @param  int $contact_id The ID of the costumer contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersDoubleOptInContactIdPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restNewslettersDoubleOptInContactIdPostRequest(
        $contact_id,
        string $contentType = self::contentTypes['restNewslettersDoubleOptInContactIdPost'][0]
    ): Request
    {

        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restNewslettersDoubleOptInContactIdPost'
            );
        }


        $resourcePath = '/rest/newsletters/double_opt_in/{contactId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersEntryIdDelete
     *
     * Delete entry
     *
     * @param  int $entry_id The ID of the newsletter entry (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersEntryIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\Entry
     */
    public function restNewslettersEntryIdDelete(
        int $entry_id,
        string $contentType = self::contentTypes['restNewslettersEntryIdDelete'][0]
    ): \ck/plenty-client\Model\Entry
    {
        list($response) = $this->restNewslettersEntryIdDeleteWithHttpInfo($entry_id, $contentType);
        return $response;
    }

    /**
     * Operation restNewslettersEntryIdDeleteWithHttpInfo
     *
     * Delete entry
     *
     * @param  int $entry_id The ID of the newsletter entry (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersEntryIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\Entry, HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersEntryIdDeleteWithHttpInfo(
        int $entry_id,
        string $contentType = self::contentTypes['restNewslettersEntryIdDelete'][0]
    ): array
    {
        $request = $this->restNewslettersEntryIdDeleteRequest($entry_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\Entry' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\Entry' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\Entry', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\Entry';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\Entry',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersEntryIdDeleteAsync
     *
     * Delete entry
     *
     * @param  int $entry_id The ID of the newsletter entry (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersEntryIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restNewslettersEntryIdDeleteAsync(
        int $entry_id,
        string $contentType = self::contentTypes['restNewslettersEntryIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restNewslettersEntryIdDeleteAsyncWithHttpInfo($entry_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersEntryIdDeleteAsyncWithHttpInfo
     *
     * Delete entry
     *
     * @param  int $entry_id The ID of the newsletter entry (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersEntryIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restNewslettersEntryIdDeleteAsyncWithHttpInfo(
        $entry_id,
        string $contentType = self::contentTypes['restNewslettersEntryIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\Entry';
        $request = $this->restNewslettersEntryIdDeleteRequest($entry_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersEntryIdDelete'
     *
     * @param  int $entry_id The ID of the newsletter entry (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersEntryIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restNewslettersEntryIdDeleteRequest(
        $entry_id,
        string $contentType = self::contentTypes['restNewslettersEntryIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'entry_id' is set
        if ($entry_id === null || (is_array($entry_id) && count($entry_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $entry_id when calling restNewslettersEntryIdDelete'
            );
        }


        $resourcePath = '/rest/newsletters/{entryId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($entry_id !== null) {
            $resourcePath = str_replace(
                '{' . 'entryId' . '}',
                ObjectSerializer::toPathValue($entry_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersEntryIdGet
     *
     * List details of an entry
     *
     * @param  int $entry_id The ID of the newsletter entry. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersEntryIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\Entry
     */
    public function restNewslettersEntryIdGet(
        int $entry_id,
        string $contentType = self::contentTypes['restNewslettersEntryIdGet'][0]
    ): \ck/plenty-client\Model\Entry
    {
        list($response) = $this->restNewslettersEntryIdGetWithHttpInfo($entry_id, $contentType);
        return $response;
    }

    /**
     * Operation restNewslettersEntryIdGetWithHttpInfo
     *
     * List details of an entry
     *
     * @param  int $entry_id The ID of the newsletter entry. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersEntryIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\Entry, HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersEntryIdGetWithHttpInfo(
        int $entry_id,
        string $contentType = self::contentTypes['restNewslettersEntryIdGet'][0]
    ): array
    {
        $request = $this->restNewslettersEntryIdGetRequest($entry_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\Entry' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\Entry' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\Entry', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\Entry';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\Entry',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersEntryIdGetAsync
     *
     * List details of an entry
     *
     * @param  int $entry_id The ID of the newsletter entry. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersEntryIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restNewslettersEntryIdGetAsync(
        int $entry_id,
        string $contentType = self::contentTypes['restNewslettersEntryIdGet'][0]
    ): PromiseInterface
    {
        return $this->restNewslettersEntryIdGetAsyncWithHttpInfo($entry_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersEntryIdGetAsyncWithHttpInfo
     *
     * List details of an entry
     *
     * @param  int $entry_id The ID of the newsletter entry. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersEntryIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restNewslettersEntryIdGetAsyncWithHttpInfo(
        $entry_id,
        string $contentType = self::contentTypes['restNewslettersEntryIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\Entry';
        $request = $this->restNewslettersEntryIdGetRequest($entry_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersEntryIdGet'
     *
     * @param  int $entry_id The ID of the newsletter entry. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersEntryIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restNewslettersEntryIdGetRequest(
        $entry_id,
        string $contentType = self::contentTypes['restNewslettersEntryIdGet'][0]
    ): Request
    {

        // verify the required parameter 'entry_id' is set
        if ($entry_id === null || (is_array($entry_id) && count($entry_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $entry_id when calling restNewslettersEntryIdGet'
            );
        }


        $resourcePath = '/rest/newsletters/{entryId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($entry_id !== null) {
            $resourcePath = str_replace(
                '{' . 'entryId' . '}',
                ObjectSerializer::toPathValue($entry_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersEntryIdPut
     *
     * Update entry
     *
     * @param  int $entry_id The ID of the entry (required)
     * @param  int $folder_id The ID of the newsletter folder (required)
     * @param  string|null $subject The subject of the entry (optional)
     * @param  string|null $body The body of the entry (optional)
     * @param  string|null $kind The type of the entry. The content can be saved as plain text or in HTML format. Possible values: [&#39;plain&#39;, &#39;html&#39;]. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersEntryIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\Entry
     */
    public function restNewslettersEntryIdPut(
        int $entry_id,
        int $folder_id,
        ?string $subject = null,
        ?string $body = null,
        ?string $kind = null,
        string $contentType = self::contentTypes['restNewslettersEntryIdPut'][0]
    ): \ck/plenty-client\Model\Entry
    {
        list($response) = $this->restNewslettersEntryIdPutWithHttpInfo($entry_id, $folder_id, $subject, $body, $kind, $contentType);
        return $response;
    }

    /**
     * Operation restNewslettersEntryIdPutWithHttpInfo
     *
     * Update entry
     *
     * @param  int $entry_id The ID of the entry (required)
     * @param  int $folder_id The ID of the newsletter folder (required)
     * @param  string|null $subject The subject of the entry (optional)
     * @param  string|null $body The body of the entry (optional)
     * @param  string|null $kind The type of the entry. The content can be saved as plain text or in HTML format. Possible values: [&#39;plain&#39;, &#39;html&#39;]. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersEntryIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\Entry, HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersEntryIdPutWithHttpInfo(
        int $entry_id,
        int $folder_id,
        ?string $subject = null,
        ?string $body = null,
        ?string $kind = null,
        string $contentType = self::contentTypes['restNewslettersEntryIdPut'][0]
    ): array
    {
        $request = $this->restNewslettersEntryIdPutRequest($entry_id, $folder_id, $subject, $body, $kind, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\Entry' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\Entry' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\Entry', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\Entry';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\Entry',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersEntryIdPutAsync
     *
     * Update entry
     *
     * @param  int $entry_id The ID of the entry (required)
     * @param  int $folder_id The ID of the newsletter folder (required)
     * @param  string|null $subject The subject of the entry (optional)
     * @param  string|null $body The body of the entry (optional)
     * @param  string|null $kind The type of the entry. The content can be saved as plain text or in HTML format. Possible values: [&#39;plain&#39;, &#39;html&#39;]. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersEntryIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restNewslettersEntryIdPutAsync(
        int $entry_id,
        int $folder_id,
        ?string $subject = null,
        ?string $body = null,
        ?string $kind = null,
        string $contentType = self::contentTypes['restNewslettersEntryIdPut'][0]
    ): PromiseInterface
    {
        return $this->restNewslettersEntryIdPutAsyncWithHttpInfo($entry_id, $folder_id, $subject, $body, $kind, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersEntryIdPutAsyncWithHttpInfo
     *
     * Update entry
     *
     * @param  int $entry_id The ID of the entry (required)
     * @param  int $folder_id The ID of the newsletter folder (required)
     * @param  string|null $subject The subject of the entry (optional)
     * @param  string|null $body The body of the entry (optional)
     * @param  string|null $kind The type of the entry. The content can be saved as plain text or in HTML format. Possible values: [&#39;plain&#39;, &#39;html&#39;]. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersEntryIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restNewslettersEntryIdPutAsyncWithHttpInfo(
        $entry_id,
        $folder_id,
        $subject = null,
        $body = null,
        $kind = null,
        string $contentType = self::contentTypes['restNewslettersEntryIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\Entry';
        $request = $this->restNewslettersEntryIdPutRequest($entry_id, $folder_id, $subject, $body, $kind, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersEntryIdPut'
     *
     * @param  int $entry_id The ID of the entry (required)
     * @param  int $folder_id The ID of the newsletter folder (required)
     * @param  string|null $subject The subject of the entry (optional)
     * @param  string|null $body The body of the entry (optional)
     * @param  string|null $kind The type of the entry. The content can be saved as plain text or in HTML format. Possible values: [&#39;plain&#39;, &#39;html&#39;]. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersEntryIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restNewslettersEntryIdPutRequest(
        $entry_id,
        $folder_id,
        $subject = null,
        $body = null,
        $kind = null,
        string $contentType = self::contentTypes['restNewslettersEntryIdPut'][0]
    ): Request
    {

        // verify the required parameter 'entry_id' is set
        if ($entry_id === null || (is_array($entry_id) && count($entry_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $entry_id when calling restNewslettersEntryIdPut'
            );
        }

        // verify the required parameter 'folder_id' is set
        if ($folder_id === null || (is_array($folder_id) && count($folder_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $folder_id when calling restNewslettersEntryIdPut'
            );
        }





        $resourcePath = '/rest/newsletters/{entryId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $subject,
            'subject', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $body,
            'body', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $kind,
            'kind', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $folder_id,
            'folderId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);


        // path params
        if ($entry_id !== null) {
            $resourcePath = str_replace(
                '{' . 'entryId' . '}',
                ObjectSerializer::toPathValue($entry_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersFoldersDelete
     *
     * Delete folders
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersFoldersDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\Folder[]
     */
    public function restNewslettersFoldersDelete(
        string $contentType = self::contentTypes['restNewslettersFoldersDelete'][0]
    ): array
    {
        list($response) = $this->restNewslettersFoldersDeleteWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restNewslettersFoldersDeleteWithHttpInfo
     *
     * Delete folders
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersFoldersDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\Folder[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersFoldersDeleteWithHttpInfo(
        string $contentType = self::contentTypes['restNewslettersFoldersDelete'][0]
    ): array
    {
        $request = $this->restNewslettersFoldersDeleteRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\Folder[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\Folder[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\Folder[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\Folder[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\Folder[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersFoldersDeleteAsync
     *
     * Delete folders
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersFoldersDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restNewslettersFoldersDeleteAsync(
        string $contentType = self::contentTypes['restNewslettersFoldersDelete'][0]
    ): PromiseInterface
    {
        return $this->restNewslettersFoldersDeleteAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersFoldersDeleteAsyncWithHttpInfo
     *
     * Delete folders
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersFoldersDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restNewslettersFoldersDeleteAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restNewslettersFoldersDelete'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\Folder[]';
        $request = $this->restNewslettersFoldersDeleteRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersFoldersDelete'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersFoldersDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restNewslettersFoldersDeleteRequest(
        string $contentType = self::contentTypes['restNewslettersFoldersDelete'][0]
    ): Request
    {


        $resourcePath = '/rest/newsletters/folders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersFoldersFolderIdDelete
     *
     * Delete folder
     *
     * @param  int $folder_id The ID of the newsletter folder (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersFoldersFolderIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\Folder
     */
    public function restNewslettersFoldersFolderIdDelete(
        int $folder_id,
        string $contentType = self::contentTypes['restNewslettersFoldersFolderIdDelete'][0]
    ): \ck/plenty-client\Model\Folder
    {
        list($response) = $this->restNewslettersFoldersFolderIdDeleteWithHttpInfo($folder_id, $contentType);
        return $response;
    }

    /**
     * Operation restNewslettersFoldersFolderIdDeleteWithHttpInfo
     *
     * Delete folder
     *
     * @param  int $folder_id The ID of the newsletter folder (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersFoldersFolderIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\Folder, HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersFoldersFolderIdDeleteWithHttpInfo(
        int $folder_id,
        string $contentType = self::contentTypes['restNewslettersFoldersFolderIdDelete'][0]
    ): array
    {
        $request = $this->restNewslettersFoldersFolderIdDeleteRequest($folder_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\Folder' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\Folder' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\Folder', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\Folder';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\Folder',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersFoldersFolderIdDeleteAsync
     *
     * Delete folder
     *
     * @param  int $folder_id The ID of the newsletter folder (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersFoldersFolderIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restNewslettersFoldersFolderIdDeleteAsync(
        int $folder_id,
        string $contentType = self::contentTypes['restNewslettersFoldersFolderIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restNewslettersFoldersFolderIdDeleteAsyncWithHttpInfo($folder_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersFoldersFolderIdDeleteAsyncWithHttpInfo
     *
     * Delete folder
     *
     * @param  int $folder_id The ID of the newsletter folder (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersFoldersFolderIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restNewslettersFoldersFolderIdDeleteAsyncWithHttpInfo(
        $folder_id,
        string $contentType = self::contentTypes['restNewslettersFoldersFolderIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\Folder';
        $request = $this->restNewslettersFoldersFolderIdDeleteRequest($folder_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersFoldersFolderIdDelete'
     *
     * @param  int $folder_id The ID of the newsletter folder (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersFoldersFolderIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restNewslettersFoldersFolderIdDeleteRequest(
        $folder_id,
        string $contentType = self::contentTypes['restNewslettersFoldersFolderIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'folder_id' is set
        if ($folder_id === null || (is_array($folder_id) && count($folder_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $folder_id when calling restNewslettersFoldersFolderIdDelete'
            );
        }


        $resourcePath = '/rest/newsletters/folders/{folderId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($folder_id !== null) {
            $resourcePath = str_replace(
                '{' . 'folderId' . '}',
                ObjectSerializer::toPathValue($folder_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersFoldersFolderIdGet
     *
     * List details of a folder
     *
     * @param  int $folder_id The ID of the newsletter folder. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersFoldersFolderIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\Folder
     */
    public function restNewslettersFoldersFolderIdGet(
        int $folder_id,
        string $contentType = self::contentTypes['restNewslettersFoldersFolderIdGet'][0]
    ): \ck/plenty-client\Model\Folder
    {
        list($response) = $this->restNewslettersFoldersFolderIdGetWithHttpInfo($folder_id, $contentType);
        return $response;
    }

    /**
     * Operation restNewslettersFoldersFolderIdGetWithHttpInfo
     *
     * List details of a folder
     *
     * @param  int $folder_id The ID of the newsletter folder. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersFoldersFolderIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\Folder, HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersFoldersFolderIdGetWithHttpInfo(
        int $folder_id,
        string $contentType = self::contentTypes['restNewslettersFoldersFolderIdGet'][0]
    ): array
    {
        $request = $this->restNewslettersFoldersFolderIdGetRequest($folder_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\Folder' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\Folder' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\Folder', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\Folder';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\Folder',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersFoldersFolderIdGetAsync
     *
     * List details of a folder
     *
     * @param  int $folder_id The ID of the newsletter folder. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersFoldersFolderIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restNewslettersFoldersFolderIdGetAsync(
        int $folder_id,
        string $contentType = self::contentTypes['restNewslettersFoldersFolderIdGet'][0]
    ): PromiseInterface
    {
        return $this->restNewslettersFoldersFolderIdGetAsyncWithHttpInfo($folder_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersFoldersFolderIdGetAsyncWithHttpInfo
     *
     * List details of a folder
     *
     * @param  int $folder_id The ID of the newsletter folder. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersFoldersFolderIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restNewslettersFoldersFolderIdGetAsyncWithHttpInfo(
        $folder_id,
        string $contentType = self::contentTypes['restNewslettersFoldersFolderIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\Folder';
        $request = $this->restNewslettersFoldersFolderIdGetRequest($folder_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersFoldersFolderIdGet'
     *
     * @param  int $folder_id The ID of the newsletter folder. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersFoldersFolderIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restNewslettersFoldersFolderIdGetRequest(
        $folder_id,
        string $contentType = self::contentTypes['restNewslettersFoldersFolderIdGet'][0]
    ): Request
    {

        // verify the required parameter 'folder_id' is set
        if ($folder_id === null || (is_array($folder_id) && count($folder_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $folder_id when calling restNewslettersFoldersFolderIdGet'
            );
        }


        $resourcePath = '/rest/newsletters/folders/{folderId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($folder_id !== null) {
            $resourcePath = str_replace(
                '{' . 'folderId' . '}',
                ObjectSerializer::toPathValue($folder_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersFoldersFolderIdPut
     *
     * Update folder
     *
     * @param  int $folder_id The ID of the newsletter folder (required)
     * @param  string|null $name The name of the newsletter folder (optional)
     * @param  int|null $position The position of the newsletter folder (optional)
     * @param  int|null $client_ids The IDs of the clients (stores). It is possible to determine which clients (stores) the newsletter folder is visible for. (optional)
     * @param  bool|null $is_deletable Flag that indicates if the newsletter folder can be deleted. The folders &#39;Customers&#39; and &#39;Interested parties&#39; are available by default and cannot be deleted. (optional)
     * @param  bool|null $is_selectable Flag that indicates if the newsletter folder can be selected by customers in the online store. If it is allowed, the folder will be displayed in the My account area of the online store. Customers will then be able to subscribe to the newsletters that are included in this folder. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersFoldersFolderIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\Folder
     */
    public function restNewslettersFoldersFolderIdPut(
        int $folder_id,
        ?string $name = null,
        ?int $position = null,
        ?int $client_ids = null,
        ?bool $is_deletable = null,
        ?bool $is_selectable = null,
        string $contentType = self::contentTypes['restNewslettersFoldersFolderIdPut'][0]
    ): \ck/plenty-client\Model\Folder
    {
        list($response) = $this->restNewslettersFoldersFolderIdPutWithHttpInfo($folder_id, $name, $position, $client_ids, $is_deletable, $is_selectable, $contentType);
        return $response;
    }

    /**
     * Operation restNewslettersFoldersFolderIdPutWithHttpInfo
     *
     * Update folder
     *
     * @param  int $folder_id The ID of the newsletter folder (required)
     * @param  string|null $name The name of the newsletter folder (optional)
     * @param  int|null $position The position of the newsletter folder (optional)
     * @param  int|null $client_ids The IDs of the clients (stores). It is possible to determine which clients (stores) the newsletter folder is visible for. (optional)
     * @param  bool|null $is_deletable Flag that indicates if the newsletter folder can be deleted. The folders &#39;Customers&#39; and &#39;Interested parties&#39; are available by default and cannot be deleted. (optional)
     * @param  bool|null $is_selectable Flag that indicates if the newsletter folder can be selected by customers in the online store. If it is allowed, the folder will be displayed in the My account area of the online store. Customers will then be able to subscribe to the newsletters that are included in this folder. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersFoldersFolderIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\Folder, HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersFoldersFolderIdPutWithHttpInfo(
        int $folder_id,
        ?string $name = null,
        ?int $position = null,
        ?int $client_ids = null,
        ?bool $is_deletable = null,
        ?bool $is_selectable = null,
        string $contentType = self::contentTypes['restNewslettersFoldersFolderIdPut'][0]
    ): array
    {
        $request = $this->restNewslettersFoldersFolderIdPutRequest($folder_id, $name, $position, $client_ids, $is_deletable, $is_selectable, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\Folder' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\Folder' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\Folder', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\Folder';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\Folder',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersFoldersFolderIdPutAsync
     *
     * Update folder
     *
     * @param  int $folder_id The ID of the newsletter folder (required)
     * @param  string|null $name The name of the newsletter folder (optional)
     * @param  int|null $position The position of the newsletter folder (optional)
     * @param  int|null $client_ids The IDs of the clients (stores). It is possible to determine which clients (stores) the newsletter folder is visible for. (optional)
     * @param  bool|null $is_deletable Flag that indicates if the newsletter folder can be deleted. The folders &#39;Customers&#39; and &#39;Interested parties&#39; are available by default and cannot be deleted. (optional)
     * @param  bool|null $is_selectable Flag that indicates if the newsletter folder can be selected by customers in the online store. If it is allowed, the folder will be displayed in the My account area of the online store. Customers will then be able to subscribe to the newsletters that are included in this folder. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersFoldersFolderIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restNewslettersFoldersFolderIdPutAsync(
        int $folder_id,
        ?string $name = null,
        ?int $position = null,
        ?int $client_ids = null,
        ?bool $is_deletable = null,
        ?bool $is_selectable = null,
        string $contentType = self::contentTypes['restNewslettersFoldersFolderIdPut'][0]
    ): PromiseInterface
    {
        return $this->restNewslettersFoldersFolderIdPutAsyncWithHttpInfo($folder_id, $name, $position, $client_ids, $is_deletable, $is_selectable, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersFoldersFolderIdPutAsyncWithHttpInfo
     *
     * Update folder
     *
     * @param  int $folder_id The ID of the newsletter folder (required)
     * @param  string|null $name The name of the newsletter folder (optional)
     * @param  int|null $position The position of the newsletter folder (optional)
     * @param  int|null $client_ids The IDs of the clients (stores). It is possible to determine which clients (stores) the newsletter folder is visible for. (optional)
     * @param  bool|null $is_deletable Flag that indicates if the newsletter folder can be deleted. The folders &#39;Customers&#39; and &#39;Interested parties&#39; are available by default and cannot be deleted. (optional)
     * @param  bool|null $is_selectable Flag that indicates if the newsletter folder can be selected by customers in the online store. If it is allowed, the folder will be displayed in the My account area of the online store. Customers will then be able to subscribe to the newsletters that are included in this folder. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersFoldersFolderIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restNewslettersFoldersFolderIdPutAsyncWithHttpInfo(
        $folder_id,
        $name = null,
        $position = null,
        $client_ids = null,
        $is_deletable = null,
        $is_selectable = null,
        string $contentType = self::contentTypes['restNewslettersFoldersFolderIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\Folder';
        $request = $this->restNewslettersFoldersFolderIdPutRequest($folder_id, $name, $position, $client_ids, $is_deletable, $is_selectable, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersFoldersFolderIdPut'
     *
     * @param  int $folder_id The ID of the newsletter folder (required)
     * @param  string|null $name The name of the newsletter folder (optional)
     * @param  int|null $position The position of the newsletter folder (optional)
     * @param  int|null $client_ids The IDs of the clients (stores). It is possible to determine which clients (stores) the newsletter folder is visible for. (optional)
     * @param  bool|null $is_deletable Flag that indicates if the newsletter folder can be deleted. The folders &#39;Customers&#39; and &#39;Interested parties&#39; are available by default and cannot be deleted. (optional)
     * @param  bool|null $is_selectable Flag that indicates if the newsletter folder can be selected by customers in the online store. If it is allowed, the folder will be displayed in the My account area of the online store. Customers will then be able to subscribe to the newsletters that are included in this folder. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersFoldersFolderIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restNewslettersFoldersFolderIdPutRequest(
        $folder_id,
        $name = null,
        $position = null,
        $client_ids = null,
        $is_deletable = null,
        $is_selectable = null,
        string $contentType = self::contentTypes['restNewslettersFoldersFolderIdPut'][0]
    ): Request
    {

        // verify the required parameter 'folder_id' is set
        if ($folder_id === null || (is_array($folder_id) && count($folder_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $folder_id when calling restNewslettersFoldersFolderIdPut'
            );
        }







        $resourcePath = '/rest/newsletters/folders/{folderId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $position,
            'position', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $client_ids,
            'clientIds', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_deletable,
            'isDeletable', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_selectable,
            'isSelectable', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($folder_id !== null) {
            $resourcePath = str_replace(
                '{' . 'folderId' . '}',
                ObjectSerializer::toPathValue($folder_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersFoldersFolderIdRecipientsGet
     *
     * List all recipients of a folder
     *
     * @param  int $folder_id The ID of the newsletter folder. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersFoldersFolderIdRecipientsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\Recipient[]
     */
    public function restNewslettersFoldersFolderIdRecipientsGet(
        int $folder_id,
        string $contentType = self::contentTypes['restNewslettersFoldersFolderIdRecipientsGet'][0]
    ): array
    {
        list($response) = $this->restNewslettersFoldersFolderIdRecipientsGetWithHttpInfo($folder_id, $contentType);
        return $response;
    }

    /**
     * Operation restNewslettersFoldersFolderIdRecipientsGetWithHttpInfo
     *
     * List all recipients of a folder
     *
     * @param  int $folder_id The ID of the newsletter folder. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersFoldersFolderIdRecipientsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\Recipient[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersFoldersFolderIdRecipientsGetWithHttpInfo(
        int $folder_id,
        string $contentType = self::contentTypes['restNewslettersFoldersFolderIdRecipientsGet'][0]
    ): array
    {
        $request = $this->restNewslettersFoldersFolderIdRecipientsGetRequest($folder_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\Recipient[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\Recipient[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\Recipient[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\Recipient[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\Recipient[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersFoldersFolderIdRecipientsGetAsync
     *
     * List all recipients of a folder
     *
     * @param  int $folder_id The ID of the newsletter folder. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersFoldersFolderIdRecipientsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restNewslettersFoldersFolderIdRecipientsGetAsync(
        int $folder_id,
        string $contentType = self::contentTypes['restNewslettersFoldersFolderIdRecipientsGet'][0]
    ): PromiseInterface
    {
        return $this->restNewslettersFoldersFolderIdRecipientsGetAsyncWithHttpInfo($folder_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersFoldersFolderIdRecipientsGetAsyncWithHttpInfo
     *
     * List all recipients of a folder
     *
     * @param  int $folder_id The ID of the newsletter folder. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersFoldersFolderIdRecipientsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restNewslettersFoldersFolderIdRecipientsGetAsyncWithHttpInfo(
        $folder_id,
        string $contentType = self::contentTypes['restNewslettersFoldersFolderIdRecipientsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\Recipient[]';
        $request = $this->restNewslettersFoldersFolderIdRecipientsGetRequest($folder_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersFoldersFolderIdRecipientsGet'
     *
     * @param  int $folder_id The ID of the newsletter folder. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersFoldersFolderIdRecipientsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restNewslettersFoldersFolderIdRecipientsGetRequest(
        $folder_id,
        string $contentType = self::contentTypes['restNewslettersFoldersFolderIdRecipientsGet'][0]
    ): Request
    {

        // verify the required parameter 'folder_id' is set
        if ($folder_id === null || (is_array($folder_id) && count($folder_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $folder_id when calling restNewslettersFoldersFolderIdRecipientsGet'
            );
        }


        $resourcePath = '/rest/newsletters/folders/{folderId}/recipients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($folder_id !== null) {
            $resourcePath = str_replace(
                '{' . 'folderId' . '}',
                ObjectSerializer::toPathValue($folder_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersFoldersGet
     *
     * List newsletter folders
     *
     * @param  int $folder_id The ID of the newsletter folder (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersFoldersGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\Recipient[]
     */
    public function restNewslettersFoldersGet(
        int $folder_id,
        string $contentType = self::contentTypes['restNewslettersFoldersGet'][0]
    ): array
    {
        list($response) = $this->restNewslettersFoldersGetWithHttpInfo($folder_id, $contentType);
        return $response;
    }

    /**
     * Operation restNewslettersFoldersGetWithHttpInfo
     *
     * List newsletter folders
     *
     * @param  int $folder_id The ID of the newsletter folder (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersFoldersGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\Recipient[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersFoldersGetWithHttpInfo(
        int $folder_id,
        string $contentType = self::contentTypes['restNewslettersFoldersGet'][0]
    ): array
    {
        $request = $this->restNewslettersFoldersGetRequest($folder_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\Recipient[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\Recipient[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\Recipient[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\Recipient[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\Recipient[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersFoldersGetAsync
     *
     * List newsletter folders
     *
     * @param  int $folder_id The ID of the newsletter folder (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersFoldersGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restNewslettersFoldersGetAsync(
        int $folder_id,
        string $contentType = self::contentTypes['restNewslettersFoldersGet'][0]
    ): PromiseInterface
    {
        return $this->restNewslettersFoldersGetAsyncWithHttpInfo($folder_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersFoldersGetAsyncWithHttpInfo
     *
     * List newsletter folders
     *
     * @param  int $folder_id The ID of the newsletter folder (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersFoldersGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restNewslettersFoldersGetAsyncWithHttpInfo(
        $folder_id,
        string $contentType = self::contentTypes['restNewslettersFoldersGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\Recipient[]';
        $request = $this->restNewslettersFoldersGetRequest($folder_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersFoldersGet'
     *
     * @param  int $folder_id The ID of the newsletter folder (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersFoldersGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restNewslettersFoldersGetRequest(
        $folder_id,
        string $contentType = self::contentTypes['restNewslettersFoldersGet'][0]
    ): Request
    {

        // verify the required parameter 'folder_id' is set
        if ($folder_id === null || (is_array($folder_id) && count($folder_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $folder_id when calling restNewslettersFoldersGet'
            );
        }


        $resourcePath = '/rest/newsletters/folders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $folder_id,
            'folderId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersFoldersPost
     *
     * Create folder
     *
     * @param  int|null $id The ID of the newsletter folder (optional)
     * @param  string|null $name The name of the newsletter folder (optional)
     * @param  int|null $position The position of the newsletter folder (optional)
     * @param  bool|null $is_deletable Flag that indicates if the newsletter folder can be deleted. Default value of is deletable is 1. The folders &#39;Customers&#39; and &#39;Interested parties&#39; are available by default and cannot be deleted. (optional)
     * @param  bool|null $is_selectable Flag that indicates if the newsletter folder can be selected by customers in the online store. If it is allowed, the folder will be displayed in the My account area of the online store. Customers will then be able to subscribe to the newsletters that are included in this folder. (optional)
     * @param  \ck/plenty-client\Model\RestNewslettersFoldersPostRequest|null $_rest_newsletters_folders _rest_newsletters_folders (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersFoldersPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\Folder
     */
    public function restNewslettersFoldersPost(
        ?int $id = null,
        ?string $name = null,
        ?int $position = null,
        ?bool $is_deletable = null,
        ?bool $is_selectable = null,
        ?\ck/plenty-client\Model\RestNewslettersFoldersPostRequest $_rest_newsletters_folders = null,
        string $contentType = self::contentTypes['restNewslettersFoldersPost'][0]
    ): \ck/plenty-client\Model\Folder
    {
        list($response) = $this->restNewslettersFoldersPostWithHttpInfo($id, $name, $position, $is_deletable, $is_selectable, $_rest_newsletters_folders, $contentType);
        return $response;
    }

    /**
     * Operation restNewslettersFoldersPostWithHttpInfo
     *
     * Create folder
     *
     * @param  int|null $id The ID of the newsletter folder (optional)
     * @param  string|null $name The name of the newsletter folder (optional)
     * @param  int|null $position The position of the newsletter folder (optional)
     * @param  bool|null $is_deletable Flag that indicates if the newsletter folder can be deleted. Default value of is deletable is 1. The folders &#39;Customers&#39; and &#39;Interested parties&#39; are available by default and cannot be deleted. (optional)
     * @param  bool|null $is_selectable Flag that indicates if the newsletter folder can be selected by customers in the online store. If it is allowed, the folder will be displayed in the My account area of the online store. Customers will then be able to subscribe to the newsletters that are included in this folder. (optional)
     * @param  \ck/plenty-client\Model\RestNewslettersFoldersPostRequest|null $_rest_newsletters_folders (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersFoldersPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\Folder, HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersFoldersPostWithHttpInfo(
        ?int $id = null,
        ?string $name = null,
        ?int $position = null,
        ?bool $is_deletable = null,
        ?bool $is_selectable = null,
        ?\ck/plenty-client\Model\RestNewslettersFoldersPostRequest $_rest_newsletters_folders = null,
        string $contentType = self::contentTypes['restNewslettersFoldersPost'][0]
    ): array
    {
        $request = $this->restNewslettersFoldersPostRequest($id, $name, $position, $is_deletable, $is_selectable, $_rest_newsletters_folders, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\Folder' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\Folder' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\Folder', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\Folder';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\Folder',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersFoldersPostAsync
     *
     * Create folder
     *
     * @param  int|null $id The ID of the newsletter folder (optional)
     * @param  string|null $name The name of the newsletter folder (optional)
     * @param  int|null $position The position of the newsletter folder (optional)
     * @param  bool|null $is_deletable Flag that indicates if the newsletter folder can be deleted. Default value of is deletable is 1. The folders &#39;Customers&#39; and &#39;Interested parties&#39; are available by default and cannot be deleted. (optional)
     * @param  bool|null $is_selectable Flag that indicates if the newsletter folder can be selected by customers in the online store. If it is allowed, the folder will be displayed in the My account area of the online store. Customers will then be able to subscribe to the newsletters that are included in this folder. (optional)
     * @param  \ck/plenty-client\Model\RestNewslettersFoldersPostRequest|null $_rest_newsletters_folders (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersFoldersPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restNewslettersFoldersPostAsync(
        ?int $id = null,
        ?string $name = null,
        ?int $position = null,
        ?bool $is_deletable = null,
        ?bool $is_selectable = null,
        ?\ck/plenty-client\Model\RestNewslettersFoldersPostRequest $_rest_newsletters_folders = null,
        string $contentType = self::contentTypes['restNewslettersFoldersPost'][0]
    ): PromiseInterface
    {
        return $this->restNewslettersFoldersPostAsyncWithHttpInfo($id, $name, $position, $is_deletable, $is_selectable, $_rest_newsletters_folders, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersFoldersPostAsyncWithHttpInfo
     *
     * Create folder
     *
     * @param  int|null $id The ID of the newsletter folder (optional)
     * @param  string|null $name The name of the newsletter folder (optional)
     * @param  int|null $position The position of the newsletter folder (optional)
     * @param  bool|null $is_deletable Flag that indicates if the newsletter folder can be deleted. Default value of is deletable is 1. The folders &#39;Customers&#39; and &#39;Interested parties&#39; are available by default and cannot be deleted. (optional)
     * @param  bool|null $is_selectable Flag that indicates if the newsletter folder can be selected by customers in the online store. If it is allowed, the folder will be displayed in the My account area of the online store. Customers will then be able to subscribe to the newsletters that are included in this folder. (optional)
     * @param  \ck/plenty-client\Model\RestNewslettersFoldersPostRequest|null $_rest_newsletters_folders (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersFoldersPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restNewslettersFoldersPostAsyncWithHttpInfo(
        $id = null,
        $name = null,
        $position = null,
        $is_deletable = null,
        $is_selectable = null,
        $_rest_newsletters_folders = null,
        string $contentType = self::contentTypes['restNewslettersFoldersPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\Folder';
        $request = $this->restNewslettersFoldersPostRequest($id, $name, $position, $is_deletable, $is_selectable, $_rest_newsletters_folders, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersFoldersPost'
     *
     * @param  int|null $id The ID of the newsletter folder (optional)
     * @param  string|null $name The name of the newsletter folder (optional)
     * @param  int|null $position The position of the newsletter folder (optional)
     * @param  bool|null $is_deletable Flag that indicates if the newsletter folder can be deleted. Default value of is deletable is 1. The folders &#39;Customers&#39; and &#39;Interested parties&#39; are available by default and cannot be deleted. (optional)
     * @param  bool|null $is_selectable Flag that indicates if the newsletter folder can be selected by customers in the online store. If it is allowed, the folder will be displayed in the My account area of the online store. Customers will then be able to subscribe to the newsletters that are included in this folder. (optional)
     * @param  \ck/plenty-client\Model\RestNewslettersFoldersPostRequest|null $_rest_newsletters_folders (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersFoldersPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restNewslettersFoldersPostRequest(
        $id = null,
        $name = null,
        $position = null,
        $is_deletable = null,
        $is_selectable = null,
        $_rest_newsletters_folders = null,
        string $contentType = self::contentTypes['restNewslettersFoldersPost'][0]
    ): Request
    {








        $resourcePath = '/rest/newsletters/folders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $position,
            'position', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_deletable,
            'isDeletable', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_selectable,
            'isSelectable', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_newsletters_folders)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_newsletters_folders));
            } else {
                $httpBody = $_rest_newsletters_folders;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersGet
     *
     * List newsletter entries
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\Entry[]
     */
    public function restNewslettersGet(
        string $contentType = self::contentTypes['restNewslettersGet'][0]
    ): array
    {
        list($response) = $this->restNewslettersGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restNewslettersGetWithHttpInfo
     *
     * List newsletter entries
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\Entry[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersGetWithHttpInfo(
        string $contentType = self::contentTypes['restNewslettersGet'][0]
    ): array
    {
        $request = $this->restNewslettersGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\Entry[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\Entry[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\Entry[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\Entry[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\Entry[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersGetAsync
     *
     * List newsletter entries
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restNewslettersGetAsync(
        string $contentType = self::contentTypes['restNewslettersGet'][0]
    ): PromiseInterface
    {
        return $this->restNewslettersGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersGetAsyncWithHttpInfo
     *
     * List newsletter entries
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restNewslettersGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restNewslettersGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\Entry[]';
        $request = $this->restNewslettersGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restNewslettersGetRequest(
        string $contentType = self::contentTypes['restNewslettersGet'][0]
    ): Request
    {


        $resourcePath = '/rest/newsletters';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersListRecipientsGet
     *
     * List recipients
     *
     * @param  int $recipient_id The ID of the recipient (required)
     * @param  int|null $columns Filter that restricts the search result to specific columns (optional)
     * @param  int|null $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int|null $items_per_page The number of orders to be displayed per page. The default number of orders per page is 50. (optional)
     * @param  int|null $folder_id Filter that restricts the search result to a specific folderId. (optional)
     * @param  bool|null $is_confirmed Filter that restricts the search result to confirmed recipients. (optional)
     * @param  int|null $with Load additional relations for a Recipient. CURRENTLY NOT AVAILABLE (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersListRecipientsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response
     */
    public function restNewslettersListRecipientsGet(
        int $recipient_id,
        ?int $columns = null,
        ?int $page = null,
        ?int $items_per_page = null,
        ?int $folder_id = null,
        ?bool $is_confirmed = null,
        ?int $with = null,
        string $contentType = self::contentTypes['restNewslettersListRecipientsGet'][0]
    ): \ck/plenty-client\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response
    {
        list($response) = $this->restNewslettersListRecipientsGetWithHttpInfo($recipient_id, $columns, $page, $items_per_page, $folder_id, $is_confirmed, $with, $contentType);
        return $response;
    }

    /**
     * Operation restNewslettersListRecipientsGetWithHttpInfo
     *
     * List recipients
     *
     * @param  int $recipient_id The ID of the recipient (required)
     * @param  int|null $columns Filter that restricts the search result to specific columns (optional)
     * @param  int|null $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int|null $items_per_page The number of orders to be displayed per page. The default number of orders per page is 50. (optional)
     * @param  int|null $folder_id Filter that restricts the search result to a specific folderId. (optional)
     * @param  bool|null $is_confirmed Filter that restricts the search result to confirmed recipients. (optional)
     * @param  int|null $with Load additional relations for a Recipient. CURRENTLY NOT AVAILABLE (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersListRecipientsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersListRecipientsGetWithHttpInfo(
        int $recipient_id,
        ?int $columns = null,
        ?int $page = null,
        ?int $items_per_page = null,
        ?int $folder_id = null,
        ?bool $is_confirmed = null,
        ?int $with = null,
        string $contentType = self::contentTypes['restNewslettersListRecipientsGet'][0]
    ): array
    {
        $request = $this->restNewslettersListRecipientsGetRequest($recipient_id, $columns, $page, $items_per_page, $folder_id, $is_confirmed, $with, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersListRecipientsGetAsync
     *
     * List recipients
     *
     * @param  int $recipient_id The ID of the recipient (required)
     * @param  int|null $columns Filter that restricts the search result to specific columns (optional)
     * @param  int|null $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int|null $items_per_page The number of orders to be displayed per page. The default number of orders per page is 50. (optional)
     * @param  int|null $folder_id Filter that restricts the search result to a specific folderId. (optional)
     * @param  bool|null $is_confirmed Filter that restricts the search result to confirmed recipients. (optional)
     * @param  int|null $with Load additional relations for a Recipient. CURRENTLY NOT AVAILABLE (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersListRecipientsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restNewslettersListRecipientsGetAsync(
        int $recipient_id,
        ?int $columns = null,
        ?int $page = null,
        ?int $items_per_page = null,
        ?int $folder_id = null,
        ?bool $is_confirmed = null,
        ?int $with = null,
        string $contentType = self::contentTypes['restNewslettersListRecipientsGet'][0]
    ): PromiseInterface
    {
        return $this->restNewslettersListRecipientsGetAsyncWithHttpInfo($recipient_id, $columns, $page, $items_per_page, $folder_id, $is_confirmed, $with, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersListRecipientsGetAsyncWithHttpInfo
     *
     * List recipients
     *
     * @param  int $recipient_id The ID of the recipient (required)
     * @param  int|null $columns Filter that restricts the search result to specific columns (optional)
     * @param  int|null $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int|null $items_per_page The number of orders to be displayed per page. The default number of orders per page is 50. (optional)
     * @param  int|null $folder_id Filter that restricts the search result to a specific folderId. (optional)
     * @param  bool|null $is_confirmed Filter that restricts the search result to confirmed recipients. (optional)
     * @param  int|null $with Load additional relations for a Recipient. CURRENTLY NOT AVAILABLE (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersListRecipientsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restNewslettersListRecipientsGetAsyncWithHttpInfo(
        $recipient_id,
        $columns = null,
        $page = null,
        $items_per_page = null,
        $folder_id = null,
        $is_confirmed = null,
        $with = null,
        string $contentType = self::contentTypes['restNewslettersListRecipientsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response';
        $request = $this->restNewslettersListRecipientsGetRequest($recipient_id, $columns, $page, $items_per_page, $folder_id, $is_confirmed, $with, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersListRecipientsGet'
     *
     * @param  int $recipient_id The ID of the recipient (required)
     * @param  int|null $columns Filter that restricts the search result to specific columns (optional)
     * @param  int|null $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int|null $items_per_page The number of orders to be displayed per page. The default number of orders per page is 50. (optional)
     * @param  int|null $folder_id Filter that restricts the search result to a specific folderId. (optional)
     * @param  bool|null $is_confirmed Filter that restricts the search result to confirmed recipients. (optional)
     * @param  int|null $with Load additional relations for a Recipient. CURRENTLY NOT AVAILABLE (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersListRecipientsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restNewslettersListRecipientsGetRequest(
        $recipient_id,
        $columns = null,
        $page = null,
        $items_per_page = null,
        $folder_id = null,
        $is_confirmed = null,
        $with = null,
        string $contentType = self::contentTypes['restNewslettersListRecipientsGet'][0]
    ): Request
    {

        // verify the required parameter 'recipient_id' is set
        if ($recipient_id === null || (is_array($recipient_id) && count($recipient_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $recipient_id when calling restNewslettersListRecipientsGet'
            );
        }








        $resourcePath = '/rest/newsletters/list_recipients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $columns,
            'columns', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $items_per_page,
            'itemsPerPage', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $folder_id,
            'folderId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_confirmed,
            'isConfirmed', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recipient_id,
            'recipientId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersPost
     *
     * Create entry
     *
     * @param  string|null $subject The subject of the newsletter entry (optional)
     * @param  string|null $body The body of the newsletter entry (optional)
     * @param  string|null $kind The type of the entry. The content can be saved as plain text or in HTML format. Possible values: [&#39;plain&#39;, &#39;html&#39;]. (optional)
     * @param  \ck/plenty-client\Model\RestNewslettersPostRequest|null $_rest_newsletters _rest_newsletters (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\Entry
     */
    public function restNewslettersPost(
        ?string $subject = null,
        ?string $body = null,
        ?string $kind = null,
        ?\ck/plenty-client\Model\RestNewslettersPostRequest $_rest_newsletters = null,
        string $contentType = self::contentTypes['restNewslettersPost'][0]
    ): \ck/plenty-client\Model\Entry
    {
        list($response) = $this->restNewslettersPostWithHttpInfo($subject, $body, $kind, $_rest_newsletters, $contentType);
        return $response;
    }

    /**
     * Operation restNewslettersPostWithHttpInfo
     *
     * Create entry
     *
     * @param  string|null $subject The subject of the newsletter entry (optional)
     * @param  string|null $body The body of the newsletter entry (optional)
     * @param  string|null $kind The type of the entry. The content can be saved as plain text or in HTML format. Possible values: [&#39;plain&#39;, &#39;html&#39;]. (optional)
     * @param  \ck/plenty-client\Model\RestNewslettersPostRequest|null $_rest_newsletters (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\Entry, HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersPostWithHttpInfo(
        ?string $subject = null,
        ?string $body = null,
        ?string $kind = null,
        ?\ck/plenty-client\Model\RestNewslettersPostRequest $_rest_newsletters = null,
        string $contentType = self::contentTypes['restNewslettersPost'][0]
    ): array
    {
        $request = $this->restNewslettersPostRequest($subject, $body, $kind, $_rest_newsletters, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\Entry' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\Entry' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\Entry', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\Entry';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\Entry',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersPostAsync
     *
     * Create entry
     *
     * @param  string|null $subject The subject of the newsletter entry (optional)
     * @param  string|null $body The body of the newsletter entry (optional)
     * @param  string|null $kind The type of the entry. The content can be saved as plain text or in HTML format. Possible values: [&#39;plain&#39;, &#39;html&#39;]. (optional)
     * @param  \ck/plenty-client\Model\RestNewslettersPostRequest|null $_rest_newsletters (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restNewslettersPostAsync(
        ?string $subject = null,
        ?string $body = null,
        ?string $kind = null,
        ?\ck/plenty-client\Model\RestNewslettersPostRequest $_rest_newsletters = null,
        string $contentType = self::contentTypes['restNewslettersPost'][0]
    ): PromiseInterface
    {
        return $this->restNewslettersPostAsyncWithHttpInfo($subject, $body, $kind, $_rest_newsletters, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersPostAsyncWithHttpInfo
     *
     * Create entry
     *
     * @param  string|null $subject The subject of the newsletter entry (optional)
     * @param  string|null $body The body of the newsletter entry (optional)
     * @param  string|null $kind The type of the entry. The content can be saved as plain text or in HTML format. Possible values: [&#39;plain&#39;, &#39;html&#39;]. (optional)
     * @param  \ck/plenty-client\Model\RestNewslettersPostRequest|null $_rest_newsletters (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restNewslettersPostAsyncWithHttpInfo(
        $subject = null,
        $body = null,
        $kind = null,
        $_rest_newsletters = null,
        string $contentType = self::contentTypes['restNewslettersPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\Entry';
        $request = $this->restNewslettersPostRequest($subject, $body, $kind, $_rest_newsletters, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersPost'
     *
     * @param  string|null $subject The subject of the newsletter entry (optional)
     * @param  string|null $body The body of the newsletter entry (optional)
     * @param  string|null $kind The type of the entry. The content can be saved as plain text or in HTML format. Possible values: [&#39;plain&#39;, &#39;html&#39;]. (optional)
     * @param  \ck/plenty-client\Model\RestNewslettersPostRequest|null $_rest_newsletters (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restNewslettersPostRequest(
        $subject = null,
        $body = null,
        $kind = null,
        $_rest_newsletters = null,
        string $contentType = self::contentTypes['restNewslettersPost'][0]
    ): Request
    {






        $resourcePath = '/rest/newsletters';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $subject,
            'subject', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $body,
            'body', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $kind,
            'kind', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_newsletters)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_newsletters));
            } else {
                $httpBody = $_rest_newsletters;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersRecipientsDelete
     *
     * Delete recipients
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersRecipientsDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\Recipient[]
     */
    public function restNewslettersRecipientsDelete(
        string $contentType = self::contentTypes['restNewslettersRecipientsDelete'][0]
    ): array
    {
        list($response) = $this->restNewslettersRecipientsDeleteWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restNewslettersRecipientsDeleteWithHttpInfo
     *
     * Delete recipients
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersRecipientsDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\Recipient[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersRecipientsDeleteWithHttpInfo(
        string $contentType = self::contentTypes['restNewslettersRecipientsDelete'][0]
    ): array
    {
        $request = $this->restNewslettersRecipientsDeleteRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\Recipient[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\Recipient[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\Recipient[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\Recipient[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\Recipient[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersRecipientsDeleteAsync
     *
     * Delete recipients
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersRecipientsDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restNewslettersRecipientsDeleteAsync(
        string $contentType = self::contentTypes['restNewslettersRecipientsDelete'][0]
    ): PromiseInterface
    {
        return $this->restNewslettersRecipientsDeleteAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersRecipientsDeleteAsyncWithHttpInfo
     *
     * Delete recipients
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersRecipientsDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restNewslettersRecipientsDeleteAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restNewslettersRecipientsDelete'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\Recipient[]';
        $request = $this->restNewslettersRecipientsDeleteRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersRecipientsDelete'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersRecipientsDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restNewslettersRecipientsDeleteRequest(
        string $contentType = self::contentTypes['restNewslettersRecipientsDelete'][0]
    ): Request
    {


        $resourcePath = '/rest/newsletters/recipients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersRecipientsGet
     *
     * List recipients of folder
     *
     * @param  string|null $email Filter that restricts the search result to the email address of the recipient (optional)
     * @param  int|null $folder_id Filter that restricts the search result to the folder ID (optional)
     * @param  int|null $recipient_id Filter that restricts the search result to the recipient ID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersRecipientsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\Recipient[]
     */
    public function restNewslettersRecipientsGet(
        ?string $email = null,
        ?int $folder_id = null,
        ?int $recipient_id = null,
        string $contentType = self::contentTypes['restNewslettersRecipientsGet'][0]
    ): array
    {
        list($response) = $this->restNewslettersRecipientsGetWithHttpInfo($email, $folder_id, $recipient_id, $contentType);
        return $response;
    }

    /**
     * Operation restNewslettersRecipientsGetWithHttpInfo
     *
     * List recipients of folder
     *
     * @param  string|null $email Filter that restricts the search result to the email address of the recipient (optional)
     * @param  int|null $folder_id Filter that restricts the search result to the folder ID (optional)
     * @param  int|null $recipient_id Filter that restricts the search result to the recipient ID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersRecipientsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\Recipient[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersRecipientsGetWithHttpInfo(
        ?string $email = null,
        ?int $folder_id = null,
        ?int $recipient_id = null,
        string $contentType = self::contentTypes['restNewslettersRecipientsGet'][0]
    ): array
    {
        $request = $this->restNewslettersRecipientsGetRequest($email, $folder_id, $recipient_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\Recipient[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\Recipient[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\Recipient[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\Recipient[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\Recipient[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersRecipientsGetAsync
     *
     * List recipients of folder
     *
     * @param  string|null $email Filter that restricts the search result to the email address of the recipient (optional)
     * @param  int|null $folder_id Filter that restricts the search result to the folder ID (optional)
     * @param  int|null $recipient_id Filter that restricts the search result to the recipient ID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersRecipientsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restNewslettersRecipientsGetAsync(
        ?string $email = null,
        ?int $folder_id = null,
        ?int $recipient_id = null,
        string $contentType = self::contentTypes['restNewslettersRecipientsGet'][0]
    ): PromiseInterface
    {
        return $this->restNewslettersRecipientsGetAsyncWithHttpInfo($email, $folder_id, $recipient_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersRecipientsGetAsyncWithHttpInfo
     *
     * List recipients of folder
     *
     * @param  string|null $email Filter that restricts the search result to the email address of the recipient (optional)
     * @param  int|null $folder_id Filter that restricts the search result to the folder ID (optional)
     * @param  int|null $recipient_id Filter that restricts the search result to the recipient ID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersRecipientsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restNewslettersRecipientsGetAsyncWithHttpInfo(
        $email = null,
        $folder_id = null,
        $recipient_id = null,
        string $contentType = self::contentTypes['restNewslettersRecipientsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\Recipient[]';
        $request = $this->restNewslettersRecipientsGetRequest($email, $folder_id, $recipient_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersRecipientsGet'
     *
     * @param  string|null $email Filter that restricts the search result to the email address of the recipient (optional)
     * @param  int|null $folder_id Filter that restricts the search result to the folder ID (optional)
     * @param  int|null $recipient_id Filter that restricts the search result to the recipient ID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersRecipientsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restNewslettersRecipientsGetRequest(
        $email = null,
        $folder_id = null,
        $recipient_id = null,
        string $contentType = self::contentTypes['restNewslettersRecipientsGet'][0]
    ): Request
    {





        $resourcePath = '/rest/newsletters/recipients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $email,
            'email', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $folder_id,
            'folderId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recipient_id,
            'recipientId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersRecipientsPost
     *
     * Create recipient
     *
     * @param  string|null $email The email address of the recipient (optional)
     * @param  string|null $first_name The first name of the recipient (optional)
     * @param  string|null $last_name The last name of the recipient (optional)
     * @param  int|null $folder_ids The IDs of the newsletter folders. These folders were selected by the customer in the online store in order to receive newsletters included in these folders. (optional)
     * @param  bool|null $is_frontend Value that indicates if the REST call was retrieved from the front end. Possible values are: &#39;true&#39; or &#39;false&#39;. True &#x3D; The REST call was retrieved from the front end. False &#x3D; The REST call was not retrieved from the front end. (optional)
     * @param  bool|null $ignore_visibility Value that indicates if the REST call considers folders without visibility. Possible value: &#39;true&#39;. If the value &#39;true&#39; is set, the folder visibility will be ignored. This means that both visible and invisible folders will be listed depending on the folder IDs entered in the REST call. (optional)
     * @param  string|null $ip_address The IP address from where the customer has confirmed the newsletter (optional)
     * @param  \ck/plenty-client\Model\RestNewslettersRecipientsPostRequest|null $_rest_newsletters_recipients _rest_newsletters_recipients (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersRecipientsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\Recipient[]
     */
    public function restNewslettersRecipientsPost(
        ?string $email = null,
        ?string $first_name = null,
        ?string $last_name = null,
        ?int $folder_ids = null,
        ?bool $is_frontend = null,
        ?bool $ignore_visibility = null,
        ?string $ip_address = null,
        ?\ck/plenty-client\Model\RestNewslettersRecipientsPostRequest $_rest_newsletters_recipients = null,
        string $contentType = self::contentTypes['restNewslettersRecipientsPost'][0]
    ): array
    {
        list($response) = $this->restNewslettersRecipientsPostWithHttpInfo($email, $first_name, $last_name, $folder_ids, $is_frontend, $ignore_visibility, $ip_address, $_rest_newsletters_recipients, $contentType);
        return $response;
    }

    /**
     * Operation restNewslettersRecipientsPostWithHttpInfo
     *
     * Create recipient
     *
     * @param  string|null $email The email address of the recipient (optional)
     * @param  string|null $first_name The first name of the recipient (optional)
     * @param  string|null $last_name The last name of the recipient (optional)
     * @param  int|null $folder_ids The IDs of the newsletter folders. These folders were selected by the customer in the online store in order to receive newsletters included in these folders. (optional)
     * @param  bool|null $is_frontend Value that indicates if the REST call was retrieved from the front end. Possible values are: &#39;true&#39; or &#39;false&#39;. True &#x3D; The REST call was retrieved from the front end. False &#x3D; The REST call was not retrieved from the front end. (optional)
     * @param  bool|null $ignore_visibility Value that indicates if the REST call considers folders without visibility. Possible value: &#39;true&#39;. If the value &#39;true&#39; is set, the folder visibility will be ignored. This means that both visible and invisible folders will be listed depending on the folder IDs entered in the REST call. (optional)
     * @param  string|null $ip_address The IP address from where the customer has confirmed the newsletter (optional)
     * @param  \ck/plenty-client\Model\RestNewslettersRecipientsPostRequest|null $_rest_newsletters_recipients (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersRecipientsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\Recipient[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersRecipientsPostWithHttpInfo(
        ?string $email = null,
        ?string $first_name = null,
        ?string $last_name = null,
        ?int $folder_ids = null,
        ?bool $is_frontend = null,
        ?bool $ignore_visibility = null,
        ?string $ip_address = null,
        ?\ck/plenty-client\Model\RestNewslettersRecipientsPostRequest $_rest_newsletters_recipients = null,
        string $contentType = self::contentTypes['restNewslettersRecipientsPost'][0]
    ): array
    {
        $request = $this->restNewslettersRecipientsPostRequest($email, $first_name, $last_name, $folder_ids, $is_frontend, $ignore_visibility, $ip_address, $_rest_newsletters_recipients, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\Recipient[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\Recipient[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\Recipient[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\Recipient[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\Recipient[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersRecipientsPostAsync
     *
     * Create recipient
     *
     * @param  string|null $email The email address of the recipient (optional)
     * @param  string|null $first_name The first name of the recipient (optional)
     * @param  string|null $last_name The last name of the recipient (optional)
     * @param  int|null $folder_ids The IDs of the newsletter folders. These folders were selected by the customer in the online store in order to receive newsletters included in these folders. (optional)
     * @param  bool|null $is_frontend Value that indicates if the REST call was retrieved from the front end. Possible values are: &#39;true&#39; or &#39;false&#39;. True &#x3D; The REST call was retrieved from the front end. False &#x3D; The REST call was not retrieved from the front end. (optional)
     * @param  bool|null $ignore_visibility Value that indicates if the REST call considers folders without visibility. Possible value: &#39;true&#39;. If the value &#39;true&#39; is set, the folder visibility will be ignored. This means that both visible and invisible folders will be listed depending on the folder IDs entered in the REST call. (optional)
     * @param  string|null $ip_address The IP address from where the customer has confirmed the newsletter (optional)
     * @param  \ck/plenty-client\Model\RestNewslettersRecipientsPostRequest|null $_rest_newsletters_recipients (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersRecipientsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restNewslettersRecipientsPostAsync(
        ?string $email = null,
        ?string $first_name = null,
        ?string $last_name = null,
        ?int $folder_ids = null,
        ?bool $is_frontend = null,
        ?bool $ignore_visibility = null,
        ?string $ip_address = null,
        ?\ck/plenty-client\Model\RestNewslettersRecipientsPostRequest $_rest_newsletters_recipients = null,
        string $contentType = self::contentTypes['restNewslettersRecipientsPost'][0]
    ): PromiseInterface
    {
        return $this->restNewslettersRecipientsPostAsyncWithHttpInfo($email, $first_name, $last_name, $folder_ids, $is_frontend, $ignore_visibility, $ip_address, $_rest_newsletters_recipients, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersRecipientsPostAsyncWithHttpInfo
     *
     * Create recipient
     *
     * @param  string|null $email The email address of the recipient (optional)
     * @param  string|null $first_name The first name of the recipient (optional)
     * @param  string|null $last_name The last name of the recipient (optional)
     * @param  int|null $folder_ids The IDs of the newsletter folders. These folders were selected by the customer in the online store in order to receive newsletters included in these folders. (optional)
     * @param  bool|null $is_frontend Value that indicates if the REST call was retrieved from the front end. Possible values are: &#39;true&#39; or &#39;false&#39;. True &#x3D; The REST call was retrieved from the front end. False &#x3D; The REST call was not retrieved from the front end. (optional)
     * @param  bool|null $ignore_visibility Value that indicates if the REST call considers folders without visibility. Possible value: &#39;true&#39;. If the value &#39;true&#39; is set, the folder visibility will be ignored. This means that both visible and invisible folders will be listed depending on the folder IDs entered in the REST call. (optional)
     * @param  string|null $ip_address The IP address from where the customer has confirmed the newsletter (optional)
     * @param  \ck/plenty-client\Model\RestNewslettersRecipientsPostRequest|null $_rest_newsletters_recipients (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersRecipientsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restNewslettersRecipientsPostAsyncWithHttpInfo(
        $email = null,
        $first_name = null,
        $last_name = null,
        $folder_ids = null,
        $is_frontend = null,
        $ignore_visibility = null,
        $ip_address = null,
        $_rest_newsletters_recipients = null,
        string $contentType = self::contentTypes['restNewslettersRecipientsPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\Recipient[]';
        $request = $this->restNewslettersRecipientsPostRequest($email, $first_name, $last_name, $folder_ids, $is_frontend, $ignore_visibility, $ip_address, $_rest_newsletters_recipients, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersRecipientsPost'
     *
     * @param  string|null $email The email address of the recipient (optional)
     * @param  string|null $first_name The first name of the recipient (optional)
     * @param  string|null $last_name The last name of the recipient (optional)
     * @param  int|null $folder_ids The IDs of the newsletter folders. These folders were selected by the customer in the online store in order to receive newsletters included in these folders. (optional)
     * @param  bool|null $is_frontend Value that indicates if the REST call was retrieved from the front end. Possible values are: &#39;true&#39; or &#39;false&#39;. True &#x3D; The REST call was retrieved from the front end. False &#x3D; The REST call was not retrieved from the front end. (optional)
     * @param  bool|null $ignore_visibility Value that indicates if the REST call considers folders without visibility. Possible value: &#39;true&#39;. If the value &#39;true&#39; is set, the folder visibility will be ignored. This means that both visible and invisible folders will be listed depending on the folder IDs entered in the REST call. (optional)
     * @param  string|null $ip_address The IP address from where the customer has confirmed the newsletter (optional)
     * @param  \ck/plenty-client\Model\RestNewslettersRecipientsPostRequest|null $_rest_newsletters_recipients (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersRecipientsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restNewslettersRecipientsPostRequest(
        $email = null,
        $first_name = null,
        $last_name = null,
        $folder_ids = null,
        $is_frontend = null,
        $ignore_visibility = null,
        $ip_address = null,
        $_rest_newsletters_recipients = null,
        string $contentType = self::contentTypes['restNewslettersRecipientsPost'][0]
    ): Request
    {










        $resourcePath = '/rest/newsletters/recipients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $email,
            'email', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $first_name,
            'firstName', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_name,
            'lastName', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $folder_ids,
            'folderIds', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_frontend,
            'isFrontend', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ignore_visibility,
            'ignoreVisibility', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ip_address,
            'ipAddress', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_newsletters_recipients)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_newsletters_recipients));
            } else {
                $httpBody = $_rest_newsletters_recipients;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersRecipientsRecipientIdDelete
     *
     * Delete recipient
     *
     * @param  int $recipient_id The ID of the recipient (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersRecipientsRecipientIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\Recipient
     */
    public function restNewslettersRecipientsRecipientIdDelete(
        int $recipient_id,
        string $contentType = self::contentTypes['restNewslettersRecipientsRecipientIdDelete'][0]
    ): \ck/plenty-client\Model\Recipient
    {
        list($response) = $this->restNewslettersRecipientsRecipientIdDeleteWithHttpInfo($recipient_id, $contentType);
        return $response;
    }

    /**
     * Operation restNewslettersRecipientsRecipientIdDeleteWithHttpInfo
     *
     * Delete recipient
     *
     * @param  int $recipient_id The ID of the recipient (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersRecipientsRecipientIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\Recipient, HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersRecipientsRecipientIdDeleteWithHttpInfo(
        int $recipient_id,
        string $contentType = self::contentTypes['restNewslettersRecipientsRecipientIdDelete'][0]
    ): array
    {
        $request = $this->restNewslettersRecipientsRecipientIdDeleteRequest($recipient_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\Recipient' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\Recipient' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\Recipient', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\Recipient';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\Recipient',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersRecipientsRecipientIdDeleteAsync
     *
     * Delete recipient
     *
     * @param  int $recipient_id The ID of the recipient (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersRecipientsRecipientIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restNewslettersRecipientsRecipientIdDeleteAsync(
        int $recipient_id,
        string $contentType = self::contentTypes['restNewslettersRecipientsRecipientIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restNewslettersRecipientsRecipientIdDeleteAsyncWithHttpInfo($recipient_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersRecipientsRecipientIdDeleteAsyncWithHttpInfo
     *
     * Delete recipient
     *
     * @param  int $recipient_id The ID of the recipient (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersRecipientsRecipientIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restNewslettersRecipientsRecipientIdDeleteAsyncWithHttpInfo(
        $recipient_id,
        string $contentType = self::contentTypes['restNewslettersRecipientsRecipientIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\Recipient';
        $request = $this->restNewslettersRecipientsRecipientIdDeleteRequest($recipient_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersRecipientsRecipientIdDelete'
     *
     * @param  int $recipient_id The ID of the recipient (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersRecipientsRecipientIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restNewslettersRecipientsRecipientIdDeleteRequest(
        $recipient_id,
        string $contentType = self::contentTypes['restNewslettersRecipientsRecipientIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'recipient_id' is set
        if ($recipient_id === null || (is_array($recipient_id) && count($recipient_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $recipient_id when calling restNewslettersRecipientsRecipientIdDelete'
            );
        }


        $resourcePath = '/rest/newsletters/recipients/{recipientId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($recipient_id !== null) {
            $resourcePath = str_replace(
                '{' . 'recipientId' . '}',
                ObjectSerializer::toPathValue($recipient_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersRecipientsRecipientIdGet
     *
     * List recipient
     *
     * @param  int $recipient_id The ID of the newsletter folder. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersRecipientsRecipientIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\Recipient
     */
    public function restNewslettersRecipientsRecipientIdGet(
        int $recipient_id,
        string $contentType = self::contentTypes['restNewslettersRecipientsRecipientIdGet'][0]
    ): \ck/plenty-client\Model\Recipient
    {
        list($response) = $this->restNewslettersRecipientsRecipientIdGetWithHttpInfo($recipient_id, $contentType);
        return $response;
    }

    /**
     * Operation restNewslettersRecipientsRecipientIdGetWithHttpInfo
     *
     * List recipient
     *
     * @param  int $recipient_id The ID of the newsletter folder. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersRecipientsRecipientIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\Recipient, HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersRecipientsRecipientIdGetWithHttpInfo(
        int $recipient_id,
        string $contentType = self::contentTypes['restNewslettersRecipientsRecipientIdGet'][0]
    ): array
    {
        $request = $this->restNewslettersRecipientsRecipientIdGetRequest($recipient_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\Recipient' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\Recipient' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\Recipient', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\Recipient';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\Recipient',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersRecipientsRecipientIdGetAsync
     *
     * List recipient
     *
     * @param  int $recipient_id The ID of the newsletter folder. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersRecipientsRecipientIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restNewslettersRecipientsRecipientIdGetAsync(
        int $recipient_id,
        string $contentType = self::contentTypes['restNewslettersRecipientsRecipientIdGet'][0]
    ): PromiseInterface
    {
        return $this->restNewslettersRecipientsRecipientIdGetAsyncWithHttpInfo($recipient_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersRecipientsRecipientIdGetAsyncWithHttpInfo
     *
     * List recipient
     *
     * @param  int $recipient_id The ID of the newsletter folder. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersRecipientsRecipientIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restNewslettersRecipientsRecipientIdGetAsyncWithHttpInfo(
        $recipient_id,
        string $contentType = self::contentTypes['restNewslettersRecipientsRecipientIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\Recipient';
        $request = $this->restNewslettersRecipientsRecipientIdGetRequest($recipient_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersRecipientsRecipientIdGet'
     *
     * @param  int $recipient_id The ID of the newsletter folder. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersRecipientsRecipientIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restNewslettersRecipientsRecipientIdGetRequest(
        $recipient_id,
        string $contentType = self::contentTypes['restNewslettersRecipientsRecipientIdGet'][0]
    ): Request
    {

        // verify the required parameter 'recipient_id' is set
        if ($recipient_id === null || (is_array($recipient_id) && count($recipient_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $recipient_id when calling restNewslettersRecipientsRecipientIdGet'
            );
        }


        $resourcePath = '/rest/newsletters/recipients/{recipientId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($recipient_id !== null) {
            $resourcePath = str_replace(
                '{' . 'recipientId' . '}',
                ObjectSerializer::toPathValue($recipient_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersRecipientsRecipientIdPut
     *
     * Update recipient
     *
     * @param  int $recipient_id The ID of the recipient (required)
     * @param  string|null $email The email address of the newsletter recipient (optional)
     * @param  string|null $first_name The first name of the newsletter recipient (optional)
     * @param  string|null $last_name The last name of the newsletter recipient (optional)
     * @param  int|null $folder_ids DEPRECATED: The IDs of the newsletter folders. These folders were selected by the customer in the online store in order to receive newsletters included in these folders. (optional)
     * @param  int|null $folder_id The ID of the newsletter folder. (optional)
     * @param  string|null $ip_address The IP address from where the customer has confirmed the newsletter (optional)
     * @param  string|null $birthday The customer birthday as Date string (e.g. &#39;1982-11-24&#39;, &#39;1982/11/24&#39; or &#39;24.11.1982&#39;) (optional)
     * @param  string|null $gender The gender of the customer, one of the following values: &#39;m&#39;,&#39;f&#39;,&#39;d&#39;. (optional)
     * @param  \ck/plenty-client\Model\RestNewslettersRecipientsPostRequest|null $_rest_newsletters_recipients_recipient_id _rest_newsletters_recipients_recipient_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersRecipientsRecipientIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck/plenty-client\Model\Recipient
     */
    public function restNewslettersRecipientsRecipientIdPut(
        int $recipient_id,
        ?string $email = null,
        ?string $first_name = null,
        ?string $last_name = null,
        ?int $folder_ids = null,
        ?int $folder_id = null,
        ?string $ip_address = null,
        ?string $birthday = null,
        ?string $gender = null,
        ?\ck/plenty-client\Model\RestNewslettersRecipientsPostRequest $_rest_newsletters_recipients_recipient_id = null,
        string $contentType = self::contentTypes['restNewslettersRecipientsRecipientIdPut'][0]
    ): \ck/plenty-client\Model\Recipient
    {
        list($response) = $this->restNewslettersRecipientsRecipientIdPutWithHttpInfo($recipient_id, $email, $first_name, $last_name, $folder_ids, $folder_id, $ip_address, $birthday, $gender, $_rest_newsletters_recipients_recipient_id, $contentType);
        return $response;
    }

    /**
     * Operation restNewslettersRecipientsRecipientIdPutWithHttpInfo
     *
     * Update recipient
     *
     * @param  int $recipient_id The ID of the recipient (required)
     * @param  string|null $email The email address of the newsletter recipient (optional)
     * @param  string|null $first_name The first name of the newsletter recipient (optional)
     * @param  string|null $last_name The last name of the newsletter recipient (optional)
     * @param  int|null $folder_ids DEPRECATED: The IDs of the newsletter folders. These folders were selected by the customer in the online store in order to receive newsletters included in these folders. (optional)
     * @param  int|null $folder_id The ID of the newsletter folder. (optional)
     * @param  string|null $ip_address The IP address from where the customer has confirmed the newsletter (optional)
     * @param  string|null $birthday The customer birthday as Date string (e.g. &#39;1982-11-24&#39;, &#39;1982/11/24&#39; or &#39;24.11.1982&#39;) (optional)
     * @param  string|null $gender The gender of the customer, one of the following values: &#39;m&#39;,&#39;f&#39;,&#39;d&#39;. (optional)
     * @param  \ck/plenty-client\Model\RestNewslettersRecipientsPostRequest|null $_rest_newsletters_recipients_recipient_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersRecipientsRecipientIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck/plenty-client\Model\Recipient, HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersRecipientsRecipientIdPutWithHttpInfo(
        int $recipient_id,
        ?string $email = null,
        ?string $first_name = null,
        ?string $last_name = null,
        ?int $folder_ids = null,
        ?int $folder_id = null,
        ?string $ip_address = null,
        ?string $birthday = null,
        ?string $gender = null,
        ?\ck/plenty-client\Model\RestNewslettersRecipientsPostRequest $_rest_newsletters_recipients_recipient_id = null,
        string $contentType = self::contentTypes['restNewslettersRecipientsRecipientIdPut'][0]
    ): array
    {
        $request = $this->restNewslettersRecipientsRecipientIdPutRequest($recipient_id, $email, $first_name, $last_name, $folder_ids, $folder_id, $ip_address, $birthday, $gender, $_rest_newsletters_recipients_recipient_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck/plenty-client\Model\Recipient' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck/plenty-client\Model\Recipient' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck/plenty-client\Model\Recipient', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck/plenty-client\Model\Recipient';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck/plenty-client\Model\Recipient',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersRecipientsRecipientIdPutAsync
     *
     * Update recipient
     *
     * @param  int $recipient_id The ID of the recipient (required)
     * @param  string|null $email The email address of the newsletter recipient (optional)
     * @param  string|null $first_name The first name of the newsletter recipient (optional)
     * @param  string|null $last_name The last name of the newsletter recipient (optional)
     * @param  int|null $folder_ids DEPRECATED: The IDs of the newsletter folders. These folders were selected by the customer in the online store in order to receive newsletters included in these folders. (optional)
     * @param  int|null $folder_id The ID of the newsletter folder. (optional)
     * @param  string|null $ip_address The IP address from where the customer has confirmed the newsletter (optional)
     * @param  string|null $birthday The customer birthday as Date string (e.g. &#39;1982-11-24&#39;, &#39;1982/11/24&#39; or &#39;24.11.1982&#39;) (optional)
     * @param  string|null $gender The gender of the customer, one of the following values: &#39;m&#39;,&#39;f&#39;,&#39;d&#39;. (optional)
     * @param  \ck/plenty-client\Model\RestNewslettersRecipientsPostRequest|null $_rest_newsletters_recipients_recipient_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersRecipientsRecipientIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restNewslettersRecipientsRecipientIdPutAsync(
        int $recipient_id,
        ?string $email = null,
        ?string $first_name = null,
        ?string $last_name = null,
        ?int $folder_ids = null,
        ?int $folder_id = null,
        ?string $ip_address = null,
        ?string $birthday = null,
        ?string $gender = null,
        ?\ck/plenty-client\Model\RestNewslettersRecipientsPostRequest $_rest_newsletters_recipients_recipient_id = null,
        string $contentType = self::contentTypes['restNewslettersRecipientsRecipientIdPut'][0]
    ): PromiseInterface
    {
        return $this->restNewslettersRecipientsRecipientIdPutAsyncWithHttpInfo($recipient_id, $email, $first_name, $last_name, $folder_ids, $folder_id, $ip_address, $birthday, $gender, $_rest_newsletters_recipients_recipient_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersRecipientsRecipientIdPutAsyncWithHttpInfo
     *
     * Update recipient
     *
     * @param  int $recipient_id The ID of the recipient (required)
     * @param  string|null $email The email address of the newsletter recipient (optional)
     * @param  string|null $first_name The first name of the newsletter recipient (optional)
     * @param  string|null $last_name The last name of the newsletter recipient (optional)
     * @param  int|null $folder_ids DEPRECATED: The IDs of the newsletter folders. These folders were selected by the customer in the online store in order to receive newsletters included in these folders. (optional)
     * @param  int|null $folder_id The ID of the newsletter folder. (optional)
     * @param  string|null $ip_address The IP address from where the customer has confirmed the newsletter (optional)
     * @param  string|null $birthday The customer birthday as Date string (e.g. &#39;1982-11-24&#39;, &#39;1982/11/24&#39; or &#39;24.11.1982&#39;) (optional)
     * @param  string|null $gender The gender of the customer, one of the following values: &#39;m&#39;,&#39;f&#39;,&#39;d&#39;. (optional)
     * @param  \ck/plenty-client\Model\RestNewslettersRecipientsPostRequest|null $_rest_newsletters_recipients_recipient_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersRecipientsRecipientIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restNewslettersRecipientsRecipientIdPutAsyncWithHttpInfo(
        $recipient_id,
        $email = null,
        $first_name = null,
        $last_name = null,
        $folder_ids = null,
        $folder_id = null,
        $ip_address = null,
        $birthday = null,
        $gender = null,
        $_rest_newsletters_recipients_recipient_id = null,
        string $contentType = self::contentTypes['restNewslettersRecipientsRecipientIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck/plenty-client\Model\Recipient';
        $request = $this->restNewslettersRecipientsRecipientIdPutRequest($recipient_id, $email, $first_name, $last_name, $folder_ids, $folder_id, $ip_address, $birthday, $gender, $_rest_newsletters_recipients_recipient_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersRecipientsRecipientIdPut'
     *
     * @param  int $recipient_id The ID of the recipient (required)
     * @param  string|null $email The email address of the newsletter recipient (optional)
     * @param  string|null $first_name The first name of the newsletter recipient (optional)
     * @param  string|null $last_name The last name of the newsletter recipient (optional)
     * @param  int|null $folder_ids DEPRECATED: The IDs of the newsletter folders. These folders were selected by the customer in the online store in order to receive newsletters included in these folders. (optional)
     * @param  int|null $folder_id The ID of the newsletter folder. (optional)
     * @param  string|null $ip_address The IP address from where the customer has confirmed the newsletter (optional)
     * @param  string|null $birthday The customer birthday as Date string (e.g. &#39;1982-11-24&#39;, &#39;1982/11/24&#39; or &#39;24.11.1982&#39;) (optional)
     * @param  string|null $gender The gender of the customer, one of the following values: &#39;m&#39;,&#39;f&#39;,&#39;d&#39;. (optional)
     * @param  \ck/plenty-client\Model\RestNewslettersRecipientsPostRequest|null $_rest_newsletters_recipients_recipient_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restNewslettersRecipientsRecipientIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restNewslettersRecipientsRecipientIdPutRequest(
        $recipient_id,
        $email = null,
        $first_name = null,
        $last_name = null,
        $folder_ids = null,
        $folder_id = null,
        $ip_address = null,
        $birthday = null,
        $gender = null,
        $_rest_newsletters_recipients_recipient_id = null,
        string $contentType = self::contentTypes['restNewslettersRecipientsRecipientIdPut'][0]
    ): Request
    {

        // verify the required parameter 'recipient_id' is set
        if ($recipient_id === null || (is_array($recipient_id) && count($recipient_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $recipient_id when calling restNewslettersRecipientsRecipientIdPut'
            );
        }











        $resourcePath = '/rest/newsletters/recipients/{recipientId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $email,
            'email', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $first_name,
            'firstName', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_name,
            'lastName', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $folder_ids,
            'folderIds', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $folder_id,
            'folderId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ip_address,
            'ipAddress', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $birthday,
            'birthday', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $gender,
            'gender', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($recipient_id !== null) {
            $resourcePath = str_replace(
                '{' . 'recipientId' . '}',
                ObjectSerializer::toPathValue($recipient_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_newsletters_recipients_recipient_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_newsletters_recipients_recipient_id));
            } else {
                $httpBody = $_rest_newsletters_recipients_recipient_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption(): array
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
