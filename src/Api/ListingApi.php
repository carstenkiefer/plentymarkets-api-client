<?php
/**
 * ListingApi
 * PHP version 8.1
 *
 * @package  ck
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * plentymarkets REST-API
 *
 * The plentymarkets REST API expands the functionality of the plentymarkets CMS and allows access to resources, i.e. data records, via unique URI paths
 *
 * The version of the OpenAPI document: 1.0.0
 * @generated Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 7.1.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace ck\Api;

use InvalidArgumentException;
use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use GuzzleHttp\Promise\PromiseInterface;
use ck\ApiException;
use ck\Configuration;
use ck\HeaderSelector;
use ck\ObjectSerializer;

/**
 * ListingApi Class Doc Comment
 *
 * @package  ck
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class ListingApi
{
    /**
     * @var ClientInterface
     */
    protected ClientInterface $client;

    /**
     * @var Configuration
     */
    protected Configuration $config;

    /**
     * @var HeaderSelector
     */
    protected HeaderSelector $headerSelector;

    /**
     * @var int Host index
     */
    protected int $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'restListingsGet' => [
            'application/json',
        ],
        'restListingsIdDelete' => [
            'application/json',
        ],
        'restListingsIdGet' => [
            'application/json',
        ],
        'restListingsIdPut' => [
            'application/json',
        ],
        'restListingsLayoutTemplatesIdDelete' => [
            'application/json',
        ],
        'restListingsLayoutTemplatesIdGet' => [
            'application/json',
        ],
        'restListingsLayoutTemplatesPost' => [
            'application/json',
        ],
        'restListingsMarketsDirectoriesGet' => [
            'application/json',
        ],
        'restListingsMarketsDirectoriesIdDelete' => [
            'application/json',
        ],
        'restListingsMarketsDirectoriesIdGet' => [
            'application/json',
        ],
        'restListingsMarketsDirectoriesIdPut' => [
            'application/json',
        ],
        'restListingsMarketsDirectoriesPost' => [
            'application/json',
        ],
        'restListingsMarketsFindGet' => [
            'application/json',
        ],
        'restListingsMarketsGet' => [
            'application/json',
        ],
        'restListingsMarketsHistoriesGet' => [
            'application/json',
        ],
        'restListingsMarketsHistoriesIdGet' => [
            'application/json',
        ],
        'restListingsMarketsIdDelete' => [
            'application/json',
        ],
        'restListingsMarketsIdGet' => [
            'application/json',
        ],
        'restListingsMarketsIdPut' => [
            'application/json',
        ],
        'restListingsMarketsInfosGet' => [
            'application/json',
        ],
        'restListingsMarketsItemSpecificsFindGet' => [
            'application/json',
        ],
        'restListingsMarketsItemSpecificsGet' => [
            'application/json',
        ],
        'restListingsMarketsItemSpecificsIdDelete' => [
            'application/json',
        ],
        'restListingsMarketsItemSpecificsIdGet' => [
            'application/json',
        ],
        'restListingsMarketsItemSpecificsIdPut' => [
            'application/json',
        ],
        'restListingsMarketsPost' => [
            'application/json',
        ],
        'restListingsMarketsTextsGet' => [
            'application/json',
        ],
        'restListingsMarketsTextsIdDelete' => [
            'application/json',
        ],
        'restListingsMarketsTextsIdGet' => [
            'application/json',
        ],
        'restListingsMarketsTextsListingMarketIdLangPut' => [
            'application/json',
        ],
        'restListingsMarketsTextsPost' => [
            'application/json',
        ],
        'restListingsOptionTemplatesIdDelete' => [
            'application/json',
        ],
        'restListingsOptionTemplatesIdGet' => [
            'application/json',
        ],
        'restListingsOptionTemplatesIdPut' => [
            'application/json',
        ],
        'restListingsOptionTemplatesPost' => [
            'application/json',
        ],
        'restListingsOptionTemplatesPreviewGet' => [
            'application/json',
        ],
        'restListingsPost' => [
            'application/json',
        ],
        'restListingsShippingProfilesGet' => [
            'application/json',
        ],
        'restListingsShippingProfilesIdGet' => [
            'application/json',
        ],
        'restListingsStockDependenceTypesGet' => [
            'application/json',
        ],
        'restListingsStockDependenceTypesIdGet' => [
            'application/json',
        ],
        'restListingsTypesGet' => [
            'application/json',
        ],
        'restListingsTypesIdGet' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface|null $client
     * @param Configuration|null   $config
     * @param HeaderSelector|null  $selector
     * @param int                  $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex(int $hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex(): int
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig(): Configuration
    {
        return $this->config;
    }

    /**
     * Operation restListingsGet
     *
     * List listing
     *
     * @param  int|null $id Filter that restricts the search result to listings with specific listing ID. Several IDs can be entered as array. (optional)
     * @param  int|null $item_id Filter that restricts the search result to listings with specific item ID. Several IDs can be entered as array. (optional)
     * @param  int|null $type_id Filter that restricts the search result to listings with specific type ID. Several IDs can be entered as array. (optional)
     * @param  int|null $stock_dependence_type_id Filter that restricts the search result to listings with specific stock dependence type ID. Several IDs can be entered as array. (optional)
     * @param  int|null $unit_combination_id Filter that restricts the search result to listings with specific unit combination ID. Several IDs can be entered as array. (optional)
     * @param  int|null $page The page of results to search for. (optional)
     * @param  int|null $items_per_page The number of items to list per page. (optional)
     * @param  int|null $with An array with child instances to be loaded. One of &#39;stockDependenceType&#39;, &#39;type&#39;, &#39;markets&#39;, &#39;properties&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestListingsGet200Response
     */
    public function restListingsGet(
        ?int $id = null,
        ?int $item_id = null,
        ?int $type_id = null,
        ?int $stock_dependence_type_id = null,
        ?int $unit_combination_id = null,
        ?int $page = null,
        ?int $items_per_page = null,
        ?int $with = null,
        string $contentType = self::contentTypes['restListingsGet'][0]
    ): \ck\Model\RestListingsGet200Response
    {
        list($response) = $this->restListingsGetWithHttpInfo($id, $item_id, $type_id, $stock_dependence_type_id, $unit_combination_id, $page, $items_per_page, $with, $contentType);
        return $response;
    }

    /**
     * Operation restListingsGetWithHttpInfo
     *
     * List listing
     *
     * @param  int|null $id Filter that restricts the search result to listings with specific listing ID. Several IDs can be entered as array. (optional)
     * @param  int|null $item_id Filter that restricts the search result to listings with specific item ID. Several IDs can be entered as array. (optional)
     * @param  int|null $type_id Filter that restricts the search result to listings with specific type ID. Several IDs can be entered as array. (optional)
     * @param  int|null $stock_dependence_type_id Filter that restricts the search result to listings with specific stock dependence type ID. Several IDs can be entered as array. (optional)
     * @param  int|null $unit_combination_id Filter that restricts the search result to listings with specific unit combination ID. Several IDs can be entered as array. (optional)
     * @param  int|null $page The page of results to search for. (optional)
     * @param  int|null $items_per_page The number of items to list per page. (optional)
     * @param  int|null $with An array with child instances to be loaded. One of &#39;stockDependenceType&#39;, &#39;type&#39;, &#39;markets&#39;, &#39;properties&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestListingsGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsGetWithHttpInfo(
        ?int $id = null,
        ?int $item_id = null,
        ?int $type_id = null,
        ?int $stock_dependence_type_id = null,
        ?int $unit_combination_id = null,
        ?int $page = null,
        ?int $items_per_page = null,
        ?int $with = null,
        string $contentType = self::contentTypes['restListingsGet'][0]
    ): array
    {
        $request = $this->restListingsGetRequest($id, $item_id, $type_id, $stock_dependence_type_id, $unit_combination_id, $page, $items_per_page, $with, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestListingsGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestListingsGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestListingsGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestListingsGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestListingsGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsGetAsync
     *
     * List listing
     *
     * @param  int|null $id Filter that restricts the search result to listings with specific listing ID. Several IDs can be entered as array. (optional)
     * @param  int|null $item_id Filter that restricts the search result to listings with specific item ID. Several IDs can be entered as array. (optional)
     * @param  int|null $type_id Filter that restricts the search result to listings with specific type ID. Several IDs can be entered as array. (optional)
     * @param  int|null $stock_dependence_type_id Filter that restricts the search result to listings with specific stock dependence type ID. Several IDs can be entered as array. (optional)
     * @param  int|null $unit_combination_id Filter that restricts the search result to listings with specific unit combination ID. Several IDs can be entered as array. (optional)
     * @param  int|null $page The page of results to search for. (optional)
     * @param  int|null $items_per_page The number of items to list per page. (optional)
     * @param  int|null $with An array with child instances to be loaded. One of &#39;stockDependenceType&#39;, &#39;type&#39;, &#39;markets&#39;, &#39;properties&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsGetAsync(
        ?int $id = null,
        ?int $item_id = null,
        ?int $type_id = null,
        ?int $stock_dependence_type_id = null,
        ?int $unit_combination_id = null,
        ?int $page = null,
        ?int $items_per_page = null,
        ?int $with = null,
        string $contentType = self::contentTypes['restListingsGet'][0]
    ): PromiseInterface
    {
        return $this->restListingsGetAsyncWithHttpInfo($id, $item_id, $type_id, $stock_dependence_type_id, $unit_combination_id, $page, $items_per_page, $with, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsGetAsyncWithHttpInfo
     *
     * List listing
     *
     * @param  int|null $id Filter that restricts the search result to listings with specific listing ID. Several IDs can be entered as array. (optional)
     * @param  int|null $item_id Filter that restricts the search result to listings with specific item ID. Several IDs can be entered as array. (optional)
     * @param  int|null $type_id Filter that restricts the search result to listings with specific type ID. Several IDs can be entered as array. (optional)
     * @param  int|null $stock_dependence_type_id Filter that restricts the search result to listings with specific stock dependence type ID. Several IDs can be entered as array. (optional)
     * @param  int|null $unit_combination_id Filter that restricts the search result to listings with specific unit combination ID. Several IDs can be entered as array. (optional)
     * @param  int|null $page The page of results to search for. (optional)
     * @param  int|null $items_per_page The number of items to list per page. (optional)
     * @param  int|null $with An array with child instances to be loaded. One of &#39;stockDependenceType&#39;, &#39;type&#39;, &#39;markets&#39;, &#39;properties&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsGetAsyncWithHttpInfo(
        $id = null,
        $item_id = null,
        $type_id = null,
        $stock_dependence_type_id = null,
        $unit_combination_id = null,
        $page = null,
        $items_per_page = null,
        $with = null,
        string $contentType = self::contentTypes['restListingsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestListingsGet200Response';
        $request = $this->restListingsGetRequest($id, $item_id, $type_id, $stock_dependence_type_id, $unit_combination_id, $page, $items_per_page, $with, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsGet'
     *
     * @param  int|null $id Filter that restricts the search result to listings with specific listing ID. Several IDs can be entered as array. (optional)
     * @param  int|null $item_id Filter that restricts the search result to listings with specific item ID. Several IDs can be entered as array. (optional)
     * @param  int|null $type_id Filter that restricts the search result to listings with specific type ID. Several IDs can be entered as array. (optional)
     * @param  int|null $stock_dependence_type_id Filter that restricts the search result to listings with specific stock dependence type ID. Several IDs can be entered as array. (optional)
     * @param  int|null $unit_combination_id Filter that restricts the search result to listings with specific unit combination ID. Several IDs can be entered as array. (optional)
     * @param  int|null $page The page of results to search for. (optional)
     * @param  int|null $items_per_page The number of items to list per page. (optional)
     * @param  int|null $with An array with child instances to be loaded. One of &#39;stockDependenceType&#39;, &#39;type&#39;, &#39;markets&#39;, &#39;properties&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restListingsGetRequest(
        $id = null,
        $item_id = null,
        $type_id = null,
        $stock_dependence_type_id = null,
        $unit_combination_id = null,
        $page = null,
        $items_per_page = null,
        $with = null,
        string $contentType = self::contentTypes['restListingsGet'][0]
    ): Request
    {










        $resourcePath = '/rest/listings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $item_id,
            'itemId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type_id,
            'typeId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $stock_dependence_type_id,
            'stockDependenceTypeId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $unit_combination_id,
            'unitCombinationId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $items_per_page,
            'itemsPerPage', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsIdDelete
     *
     * Delete a listing
     *
     * @param  int $id The listing ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restListingsIdDelete(
        int $id,
        string $contentType = self::contentTypes['restListingsIdDelete'][0]
    ): object
    {
        list($response) = $this->restListingsIdDeleteWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation restListingsIdDeleteWithHttpInfo
     *
     * Delete a listing
     *
     * @param  int $id The listing ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsIdDeleteWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restListingsIdDelete'][0]
    ): array
    {
        $request = $this->restListingsIdDeleteRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsIdDeleteAsync
     *
     * Delete a listing
     *
     * @param  int $id The listing ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsIdDeleteAsync(
        int $id,
        string $contentType = self::contentTypes['restListingsIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restListingsIdDeleteAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsIdDeleteAsyncWithHttpInfo
     *
     * Delete a listing
     *
     * @param  int $id The listing ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsIdDeleteAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restListingsIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restListingsIdDeleteRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsIdDelete'
     *
     * @param  int $id The listing ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restListingsIdDeleteRequest(
        $id,
        string $contentType = self::contentTypes['restListingsIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsIdDelete'
            );
        }


        $resourcePath = '/rest/listings/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsIdGet
     *
     * Get a listing
     *
     * @param  int $id The ID of the listing entry. (required)
     * @param  int|null $with An array with child instances to be loaded. One of &#39;stockDependenceType&#39;, &#39;type&#39;, &#39;markets&#39;, &#39;properties&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Listing
     */
    public function restListingsIdGet(
        int $id,
        ?int $with = null,
        string $contentType = self::contentTypes['restListingsIdGet'][0]
    ): \ck\Model\Listing
    {
        list($response) = $this->restListingsIdGetWithHttpInfo($id, $with, $contentType);
        return $response;
    }

    /**
     * Operation restListingsIdGetWithHttpInfo
     *
     * Get a listing
     *
     * @param  int $id The ID of the listing entry. (required)
     * @param  int|null $with An array with child instances to be loaded. One of &#39;stockDependenceType&#39;, &#39;type&#39;, &#39;markets&#39;, &#39;properties&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Listing, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsIdGetWithHttpInfo(
        int $id,
        ?int $with = null,
        string $contentType = self::contentTypes['restListingsIdGet'][0]
    ): array
    {
        $request = $this->restListingsIdGetRequest($id, $with, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Listing' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Listing' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Listing', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Listing';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Listing',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsIdGetAsync
     *
     * Get a listing
     *
     * @param  int $id The ID of the listing entry. (required)
     * @param  int|null $with An array with child instances to be loaded. One of &#39;stockDependenceType&#39;, &#39;type&#39;, &#39;markets&#39;, &#39;properties&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsIdGetAsync(
        int $id,
        ?int $with = null,
        string $contentType = self::contentTypes['restListingsIdGet'][0]
    ): PromiseInterface
    {
        return $this->restListingsIdGetAsyncWithHttpInfo($id, $with, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsIdGetAsyncWithHttpInfo
     *
     * Get a listing
     *
     * @param  int $id The ID of the listing entry. (required)
     * @param  int|null $with An array with child instances to be loaded. One of &#39;stockDependenceType&#39;, &#39;type&#39;, &#39;markets&#39;, &#39;properties&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsIdGetAsyncWithHttpInfo(
        $id,
        $with = null,
        string $contentType = self::contentTypes['restListingsIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Listing';
        $request = $this->restListingsIdGetRequest($id, $with, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsIdGet'
     *
     * @param  int $id The ID of the listing entry. (required)
     * @param  int|null $with An array with child instances to be loaded. One of &#39;stockDependenceType&#39;, &#39;type&#39;, &#39;markets&#39;, &#39;properties&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restListingsIdGetRequest(
        $id,
        $with = null,
        string $contentType = self::contentTypes['restListingsIdGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsIdGet'
            );
        }



        $resourcePath = '/rest/listings/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsIdPut
     *
     * Update a listing
     *
     * @param  int $id The ID of the listing. (required)
     * @param  \ck\Model\RestListingsIdPutRequest|null $_rest_listings_id _rest_listings_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Listing
     */
    public function restListingsIdPut(
        int $id,
        ?\ck\Model\RestListingsIdPutRequest $_rest_listings_id = null,
        string $contentType = self::contentTypes['restListingsIdPut'][0]
    ): \ck\Model\Listing
    {
        list($response) = $this->restListingsIdPutWithHttpInfo($id, $_rest_listings_id, $contentType);
        return $response;
    }

    /**
     * Operation restListingsIdPutWithHttpInfo
     *
     * Update a listing
     *
     * @param  int $id The ID of the listing. (required)
     * @param  \ck\Model\RestListingsIdPutRequest|null $_rest_listings_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Listing, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsIdPutWithHttpInfo(
        int $id,
        ?\ck\Model\RestListingsIdPutRequest $_rest_listings_id = null,
        string $contentType = self::contentTypes['restListingsIdPut'][0]
    ): array
    {
        $request = $this->restListingsIdPutRequest($id, $_rest_listings_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Listing' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Listing' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Listing', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Listing';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Listing',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsIdPutAsync
     *
     * Update a listing
     *
     * @param  int $id The ID of the listing. (required)
     * @param  \ck\Model\RestListingsIdPutRequest|null $_rest_listings_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsIdPutAsync(
        int $id,
        ?\ck\Model\RestListingsIdPutRequest $_rest_listings_id = null,
        string $contentType = self::contentTypes['restListingsIdPut'][0]
    ): PromiseInterface
    {
        return $this->restListingsIdPutAsyncWithHttpInfo($id, $_rest_listings_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsIdPutAsyncWithHttpInfo
     *
     * Update a listing
     *
     * @param  int $id The ID of the listing. (required)
     * @param  \ck\Model\RestListingsIdPutRequest|null $_rest_listings_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsIdPutAsyncWithHttpInfo(
        $id,
        $_rest_listings_id = null,
        string $contentType = self::contentTypes['restListingsIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Listing';
        $request = $this->restListingsIdPutRequest($id, $_rest_listings_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsIdPut'
     *
     * @param  int $id The ID of the listing. (required)
     * @param  \ck\Model\RestListingsIdPutRequest|null $_rest_listings_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restListingsIdPutRequest(
        $id,
        $_rest_listings_id = null,
        string $contentType = self::contentTypes['restListingsIdPut'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsIdPut'
            );
        }



        $resourcePath = '/rest/listings/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_listings_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_listings_id));
            } else {
                $httpBody = $_rest_listings_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsLayoutTemplatesIdDelete
     *
     * Delete a layout template
     *
     * @param  int $id The layout template ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsLayoutTemplatesIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restListingsLayoutTemplatesIdDelete(
        int $id,
        string $contentType = self::contentTypes['restListingsLayoutTemplatesIdDelete'][0]
    ): object
    {
        list($response) = $this->restListingsLayoutTemplatesIdDeleteWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation restListingsLayoutTemplatesIdDeleteWithHttpInfo
     *
     * Delete a layout template
     *
     * @param  int $id The layout template ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsLayoutTemplatesIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsLayoutTemplatesIdDeleteWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restListingsLayoutTemplatesIdDelete'][0]
    ): array
    {
        $request = $this->restListingsLayoutTemplatesIdDeleteRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsLayoutTemplatesIdDeleteAsync
     *
     * Delete a layout template
     *
     * @param  int $id The layout template ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsLayoutTemplatesIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsLayoutTemplatesIdDeleteAsync(
        int $id,
        string $contentType = self::contentTypes['restListingsLayoutTemplatesIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restListingsLayoutTemplatesIdDeleteAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsLayoutTemplatesIdDeleteAsyncWithHttpInfo
     *
     * Delete a layout template
     *
     * @param  int $id The layout template ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsLayoutTemplatesIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsLayoutTemplatesIdDeleteAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restListingsLayoutTemplatesIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restListingsLayoutTemplatesIdDeleteRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsLayoutTemplatesIdDelete'
     *
     * @param  int $id The layout template ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsLayoutTemplatesIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restListingsLayoutTemplatesIdDeleteRequest(
        $id,
        string $contentType = self::contentTypes['restListingsLayoutTemplatesIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsLayoutTemplatesIdDelete'
            );
        }


        $resourcePath = '/rest/listings/layout_templates/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsLayoutTemplatesIdGet
     *
     * Get a layout template
     *
     * @param  int $id The ID of the layout template entry. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsLayoutTemplatesIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\LayoutTemplate
     */
    public function restListingsLayoutTemplatesIdGet(
        int $id,
        string $contentType = self::contentTypes['restListingsLayoutTemplatesIdGet'][0]
    ): \ck\Model\LayoutTemplate
    {
        list($response) = $this->restListingsLayoutTemplatesIdGetWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation restListingsLayoutTemplatesIdGetWithHttpInfo
     *
     * Get a layout template
     *
     * @param  int $id The ID of the layout template entry. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsLayoutTemplatesIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\LayoutTemplate, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsLayoutTemplatesIdGetWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restListingsLayoutTemplatesIdGet'][0]
    ): array
    {
        $request = $this->restListingsLayoutTemplatesIdGetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\LayoutTemplate' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\LayoutTemplate' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\LayoutTemplate', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\LayoutTemplate';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\LayoutTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsLayoutTemplatesIdGetAsync
     *
     * Get a layout template
     *
     * @param  int $id The ID of the layout template entry. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsLayoutTemplatesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsLayoutTemplatesIdGetAsync(
        int $id,
        string $contentType = self::contentTypes['restListingsLayoutTemplatesIdGet'][0]
    ): PromiseInterface
    {
        return $this->restListingsLayoutTemplatesIdGetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsLayoutTemplatesIdGetAsyncWithHttpInfo
     *
     * Get a layout template
     *
     * @param  int $id The ID of the layout template entry. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsLayoutTemplatesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsLayoutTemplatesIdGetAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restListingsLayoutTemplatesIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\LayoutTemplate';
        $request = $this->restListingsLayoutTemplatesIdGetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsLayoutTemplatesIdGet'
     *
     * @param  int $id The ID of the layout template entry. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsLayoutTemplatesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restListingsLayoutTemplatesIdGetRequest(
        $id,
        string $contentType = self::contentTypes['restListingsLayoutTemplatesIdGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsLayoutTemplatesIdGet'
            );
        }


        $resourcePath = '/rest/listings/layout_templates/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsLayoutTemplatesPost
     *
     * Create new layout template
     *
     * @param  \ck\Model\RestListingsLayoutTemplatesPostRequest|null $_rest_listings_layout_templates _rest_listings_layout_templates (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsLayoutTemplatesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\LayoutTemplate
     */
    public function restListingsLayoutTemplatesPost(
        ?\ck\Model\RestListingsLayoutTemplatesPostRequest $_rest_listings_layout_templates = null,
        string $contentType = self::contentTypes['restListingsLayoutTemplatesPost'][0]
    ): \ck\Model\LayoutTemplate
    {
        list($response) = $this->restListingsLayoutTemplatesPostWithHttpInfo($_rest_listings_layout_templates, $contentType);
        return $response;
    }

    /**
     * Operation restListingsLayoutTemplatesPostWithHttpInfo
     *
     * Create new layout template
     *
     * @param  \ck\Model\RestListingsLayoutTemplatesPostRequest|null $_rest_listings_layout_templates (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsLayoutTemplatesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\LayoutTemplate, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsLayoutTemplatesPostWithHttpInfo(
        ?\ck\Model\RestListingsLayoutTemplatesPostRequest $_rest_listings_layout_templates = null,
        string $contentType = self::contentTypes['restListingsLayoutTemplatesPost'][0]
    ): array
    {
        $request = $this->restListingsLayoutTemplatesPostRequest($_rest_listings_layout_templates, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\LayoutTemplate' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\LayoutTemplate' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\LayoutTemplate', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\LayoutTemplate';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\LayoutTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsLayoutTemplatesPostAsync
     *
     * Create new layout template
     *
     * @param  \ck\Model\RestListingsLayoutTemplatesPostRequest|null $_rest_listings_layout_templates (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsLayoutTemplatesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsLayoutTemplatesPostAsync(
        ?\ck\Model\RestListingsLayoutTemplatesPostRequest $_rest_listings_layout_templates = null,
        string $contentType = self::contentTypes['restListingsLayoutTemplatesPost'][0]
    ): PromiseInterface
    {
        return $this->restListingsLayoutTemplatesPostAsyncWithHttpInfo($_rest_listings_layout_templates, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsLayoutTemplatesPostAsyncWithHttpInfo
     *
     * Create new layout template
     *
     * @param  \ck\Model\RestListingsLayoutTemplatesPostRequest|null $_rest_listings_layout_templates (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsLayoutTemplatesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsLayoutTemplatesPostAsyncWithHttpInfo(
        $_rest_listings_layout_templates = null,
        string $contentType = self::contentTypes['restListingsLayoutTemplatesPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\LayoutTemplate';
        $request = $this->restListingsLayoutTemplatesPostRequest($_rest_listings_layout_templates, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsLayoutTemplatesPost'
     *
     * @param  \ck\Model\RestListingsLayoutTemplatesPostRequest|null $_rest_listings_layout_templates (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsLayoutTemplatesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restListingsLayoutTemplatesPostRequest(
        $_rest_listings_layout_templates = null,
        string $contentType = self::contentTypes['restListingsLayoutTemplatesPost'][0]
    ): Request
    {



        $resourcePath = '/rest/listings/layout_templates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_listings_layout_templates)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_listings_layout_templates));
            } else {
                $httpBody = $_rest_listings_layout_templates;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsDirectoriesGet
     *
     * Get all listing market directories
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsDirectoriesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ListingMarketDirectory[]
     */
    public function restListingsMarketsDirectoriesGet(
        string $contentType = self::contentTypes['restListingsMarketsDirectoriesGet'][0]
    ): array
    {
        list($response) = $this->restListingsMarketsDirectoriesGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restListingsMarketsDirectoriesGetWithHttpInfo
     *
     * Get all listing market directories
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsDirectoriesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ListingMarketDirectory[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsDirectoriesGetWithHttpInfo(
        string $contentType = self::contentTypes['restListingsMarketsDirectoriesGet'][0]
    ): array
    {
        $request = $this->restListingsMarketsDirectoriesGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ListingMarketDirectory[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ListingMarketDirectory[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ListingMarketDirectory[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ListingMarketDirectory[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ListingMarketDirectory[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsDirectoriesGetAsync
     *
     * Get all listing market directories
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsDirectoriesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsMarketsDirectoriesGetAsync(
        string $contentType = self::contentTypes['restListingsMarketsDirectoriesGet'][0]
    ): PromiseInterface
    {
        return $this->restListingsMarketsDirectoriesGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsDirectoriesGetAsyncWithHttpInfo
     *
     * Get all listing market directories
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsDirectoriesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsMarketsDirectoriesGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restListingsMarketsDirectoriesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ListingMarketDirectory[]';
        $request = $this->restListingsMarketsDirectoriesGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsDirectoriesGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsDirectoriesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restListingsMarketsDirectoriesGetRequest(
        string $contentType = self::contentTypes['restListingsMarketsDirectoriesGet'][0]
    ): Request
    {


        $resourcePath = '/rest/listings/markets/directories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsDirectoriesIdDelete
     *
     * Delete listing market directory
     *
     * @param  int $id The listing market directory ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsDirectoriesIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restListingsMarketsDirectoriesIdDelete(
        int $id,
        string $contentType = self::contentTypes['restListingsMarketsDirectoriesIdDelete'][0]
    ): object
    {
        list($response) = $this->restListingsMarketsDirectoriesIdDeleteWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation restListingsMarketsDirectoriesIdDeleteWithHttpInfo
     *
     * Delete listing market directory
     *
     * @param  int $id The listing market directory ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsDirectoriesIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsDirectoriesIdDeleteWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restListingsMarketsDirectoriesIdDelete'][0]
    ): array
    {
        $request = $this->restListingsMarketsDirectoriesIdDeleteRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsDirectoriesIdDeleteAsync
     *
     * Delete listing market directory
     *
     * @param  int $id The listing market directory ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsDirectoriesIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsMarketsDirectoriesIdDeleteAsync(
        int $id,
        string $contentType = self::contentTypes['restListingsMarketsDirectoriesIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restListingsMarketsDirectoriesIdDeleteAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsDirectoriesIdDeleteAsyncWithHttpInfo
     *
     * Delete listing market directory
     *
     * @param  int $id The listing market directory ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsDirectoriesIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsMarketsDirectoriesIdDeleteAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restListingsMarketsDirectoriesIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restListingsMarketsDirectoriesIdDeleteRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsDirectoriesIdDelete'
     *
     * @param  int $id The listing market directory ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsDirectoriesIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restListingsMarketsDirectoriesIdDeleteRequest(
        $id,
        string $contentType = self::contentTypes['restListingsMarketsDirectoriesIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsMarketsDirectoriesIdDelete'
            );
        }


        $resourcePath = '/rest/listings/markets/directories/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsDirectoriesIdGet
     *
     * Get a listing market directory
     *
     * @param  int $id The ID of the listing market directory entry. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsDirectoriesIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ListingMarketDirectory
     */
    public function restListingsMarketsDirectoriesIdGet(
        int $id,
        string $contentType = self::contentTypes['restListingsMarketsDirectoriesIdGet'][0]
    ): \ck\Model\ListingMarketDirectory
    {
        list($response) = $this->restListingsMarketsDirectoriesIdGetWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation restListingsMarketsDirectoriesIdGetWithHttpInfo
     *
     * Get a listing market directory
     *
     * @param  int $id The ID of the listing market directory entry. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsDirectoriesIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ListingMarketDirectory, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsDirectoriesIdGetWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restListingsMarketsDirectoriesIdGet'][0]
    ): array
    {
        $request = $this->restListingsMarketsDirectoriesIdGetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ListingMarketDirectory' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ListingMarketDirectory' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ListingMarketDirectory', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ListingMarketDirectory';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ListingMarketDirectory',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsDirectoriesIdGetAsync
     *
     * Get a listing market directory
     *
     * @param  int $id The ID of the listing market directory entry. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsDirectoriesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsMarketsDirectoriesIdGetAsync(
        int $id,
        string $contentType = self::contentTypes['restListingsMarketsDirectoriesIdGet'][0]
    ): PromiseInterface
    {
        return $this->restListingsMarketsDirectoriesIdGetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsDirectoriesIdGetAsyncWithHttpInfo
     *
     * Get a listing market directory
     *
     * @param  int $id The ID of the listing market directory entry. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsDirectoriesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsMarketsDirectoriesIdGetAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restListingsMarketsDirectoriesIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ListingMarketDirectory';
        $request = $this->restListingsMarketsDirectoriesIdGetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsDirectoriesIdGet'
     *
     * @param  int $id The ID of the listing market directory entry. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsDirectoriesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restListingsMarketsDirectoriesIdGetRequest(
        $id,
        string $contentType = self::contentTypes['restListingsMarketsDirectoriesIdGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsMarketsDirectoriesIdGet'
            );
        }


        $resourcePath = '/rest/listings/markets/directories/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsDirectoriesIdPut
     *
     * Update listing market directory
     *
     * @param  int $id The listing market directory ID. (required)
     * @param  \ck\Model\RestListingsMarketsDirectoriesIdPutRequest|null $_rest_listings_markets_directories_id _rest_listings_markets_directories_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsDirectoriesIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ListingMarketDirectory
     */
    public function restListingsMarketsDirectoriesIdPut(
        int $id,
        ?\ck\Model\RestListingsMarketsDirectoriesIdPutRequest $_rest_listings_markets_directories_id = null,
        string $contentType = self::contentTypes['restListingsMarketsDirectoriesIdPut'][0]
    ): \ck\Model\ListingMarketDirectory
    {
        list($response) = $this->restListingsMarketsDirectoriesIdPutWithHttpInfo($id, $_rest_listings_markets_directories_id, $contentType);
        return $response;
    }

    /**
     * Operation restListingsMarketsDirectoriesIdPutWithHttpInfo
     *
     * Update listing market directory
     *
     * @param  int $id The listing market directory ID. (required)
     * @param  \ck\Model\RestListingsMarketsDirectoriesIdPutRequest|null $_rest_listings_markets_directories_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsDirectoriesIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ListingMarketDirectory, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsDirectoriesIdPutWithHttpInfo(
        int $id,
        ?\ck\Model\RestListingsMarketsDirectoriesIdPutRequest $_rest_listings_markets_directories_id = null,
        string $contentType = self::contentTypes['restListingsMarketsDirectoriesIdPut'][0]
    ): array
    {
        $request = $this->restListingsMarketsDirectoriesIdPutRequest($id, $_rest_listings_markets_directories_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ListingMarketDirectory' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ListingMarketDirectory' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ListingMarketDirectory', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ListingMarketDirectory';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ListingMarketDirectory',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsDirectoriesIdPutAsync
     *
     * Update listing market directory
     *
     * @param  int $id The listing market directory ID. (required)
     * @param  \ck\Model\RestListingsMarketsDirectoriesIdPutRequest|null $_rest_listings_markets_directories_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsDirectoriesIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsMarketsDirectoriesIdPutAsync(
        int $id,
        ?\ck\Model\RestListingsMarketsDirectoriesIdPutRequest $_rest_listings_markets_directories_id = null,
        string $contentType = self::contentTypes['restListingsMarketsDirectoriesIdPut'][0]
    ): PromiseInterface
    {
        return $this->restListingsMarketsDirectoriesIdPutAsyncWithHttpInfo($id, $_rest_listings_markets_directories_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsDirectoriesIdPutAsyncWithHttpInfo
     *
     * Update listing market directory
     *
     * @param  int $id The listing market directory ID. (required)
     * @param  \ck\Model\RestListingsMarketsDirectoriesIdPutRequest|null $_rest_listings_markets_directories_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsDirectoriesIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsMarketsDirectoriesIdPutAsyncWithHttpInfo(
        $id,
        $_rest_listings_markets_directories_id = null,
        string $contentType = self::contentTypes['restListingsMarketsDirectoriesIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ListingMarketDirectory';
        $request = $this->restListingsMarketsDirectoriesIdPutRequest($id, $_rest_listings_markets_directories_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsDirectoriesIdPut'
     *
     * @param  int $id The listing market directory ID. (required)
     * @param  \ck\Model\RestListingsMarketsDirectoriesIdPutRequest|null $_rest_listings_markets_directories_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsDirectoriesIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restListingsMarketsDirectoriesIdPutRequest(
        $id,
        $_rest_listings_markets_directories_id = null,
        string $contentType = self::contentTypes['restListingsMarketsDirectoriesIdPut'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsMarketsDirectoriesIdPut'
            );
        }



        $resourcePath = '/rest/listings/markets/directories/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_listings_markets_directories_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_listings_markets_directories_id));
            } else {
                $httpBody = $_rest_listings_markets_directories_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsDirectoriesPost
     *
     * Create listing market directory
     *
     * @param  \ck\Model\RestListingsMarketsDirectoriesPostRequest|null $_rest_listings_markets_directories _rest_listings_markets_directories (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsDirectoriesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ListingMarketDirectory
     */
    public function restListingsMarketsDirectoriesPost(
        ?\ck\Model\RestListingsMarketsDirectoriesPostRequest $_rest_listings_markets_directories = null,
        string $contentType = self::contentTypes['restListingsMarketsDirectoriesPost'][0]
    ): \ck\Model\ListingMarketDirectory
    {
        list($response) = $this->restListingsMarketsDirectoriesPostWithHttpInfo($_rest_listings_markets_directories, $contentType);
        return $response;
    }

    /**
     * Operation restListingsMarketsDirectoriesPostWithHttpInfo
     *
     * Create listing market directory
     *
     * @param  \ck\Model\RestListingsMarketsDirectoriesPostRequest|null $_rest_listings_markets_directories (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsDirectoriesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ListingMarketDirectory, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsDirectoriesPostWithHttpInfo(
        ?\ck\Model\RestListingsMarketsDirectoriesPostRequest $_rest_listings_markets_directories = null,
        string $contentType = self::contentTypes['restListingsMarketsDirectoriesPost'][0]
    ): array
    {
        $request = $this->restListingsMarketsDirectoriesPostRequest($_rest_listings_markets_directories, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ListingMarketDirectory' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ListingMarketDirectory' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ListingMarketDirectory', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ListingMarketDirectory';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ListingMarketDirectory',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsDirectoriesPostAsync
     *
     * Create listing market directory
     *
     * @param  \ck\Model\RestListingsMarketsDirectoriesPostRequest|null $_rest_listings_markets_directories (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsDirectoriesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsMarketsDirectoriesPostAsync(
        ?\ck\Model\RestListingsMarketsDirectoriesPostRequest $_rest_listings_markets_directories = null,
        string $contentType = self::contentTypes['restListingsMarketsDirectoriesPost'][0]
    ): PromiseInterface
    {
        return $this->restListingsMarketsDirectoriesPostAsyncWithHttpInfo($_rest_listings_markets_directories, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsDirectoriesPostAsyncWithHttpInfo
     *
     * Create listing market directory
     *
     * @param  \ck\Model\RestListingsMarketsDirectoriesPostRequest|null $_rest_listings_markets_directories (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsDirectoriesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsMarketsDirectoriesPostAsyncWithHttpInfo(
        $_rest_listings_markets_directories = null,
        string $contentType = self::contentTypes['restListingsMarketsDirectoriesPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ListingMarketDirectory';
        $request = $this->restListingsMarketsDirectoriesPostRequest($_rest_listings_markets_directories, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsDirectoriesPost'
     *
     * @param  \ck\Model\RestListingsMarketsDirectoriesPostRequest|null $_rest_listings_markets_directories (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsDirectoriesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restListingsMarketsDirectoriesPostRequest(
        $_rest_listings_markets_directories = null,
        string $contentType = self::contentTypes['restListingsMarketsDirectoriesPost'][0]
    ): Request
    {



        $resourcePath = '/rest/listings/markets/directories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_listings_markets_directories)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_listings_markets_directories));
            } else {
                $httpBody = $_rest_listings_markets_directories;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsFindGet
     *
     * Find listing markets
     *
     * @param  int|null $page The page of results to search for. (optional)
     * @param  int|null $items_per_page The number of items to list per page. (optional)
     * @param  int|null $id Filter that restricts the search result to listing markets that match the given ID(s). (optional)
     * @param  string|null $variations Filter that restricts the search result to listing markets with a custom variation condition. Available values are &#39;all&#39;, &#39;fixed&#39;. (optional)
     * @param  int|null $referrer_id Filter that restricts the search result to listing markets with given referrer ID. (optional)
     * @param  int|null $credentials_id Filter that restricts the search result to listing markets with given credential ID. (optional)
     * @param  int|null $directory_id Filter that restricts the search result to listing markets with a given directory ID. (optional)
     * @param  int|null $item_id Filter that restricts the search result to listing markets that belong to a given item ID. (optional)
     * @param  int|null $shipping_profile_id Filter that restricts the search result to listing markets that belong to a given shipping profile ID (optional)
     * @param  int|null $with An array with child instances to be loaded. Valid instances are &#39;listing&#39;, &#39;texts&#39;, &#39;properties&#39;, &#39;prices&#39;, &#39;dates&#39;, &#39;infos&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsFindGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestListingsMarketsGet200Response
     */
    public function restListingsMarketsFindGet(
        ?int $page = null,
        ?int $items_per_page = null,
        ?int $id = null,
        ?string $variations = null,
        ?int $referrer_id = null,
        ?int $credentials_id = null,
        ?int $directory_id = null,
        ?int $item_id = null,
        ?int $shipping_profile_id = null,
        ?int $with = null,
        string $contentType = self::contentTypes['restListingsMarketsFindGet'][0]
    ): \ck\Model\RestListingsMarketsGet200Response
    {
        list($response) = $this->restListingsMarketsFindGetWithHttpInfo($page, $items_per_page, $id, $variations, $referrer_id, $credentials_id, $directory_id, $item_id, $shipping_profile_id, $with, $contentType);
        return $response;
    }

    /**
     * Operation restListingsMarketsFindGetWithHttpInfo
     *
     * Find listing markets
     *
     * @param  int|null $page The page of results to search for. (optional)
     * @param  int|null $items_per_page The number of items to list per page. (optional)
     * @param  int|null $id Filter that restricts the search result to listing markets that match the given ID(s). (optional)
     * @param  string|null $variations Filter that restricts the search result to listing markets with a custom variation condition. Available values are &#39;all&#39;, &#39;fixed&#39;. (optional)
     * @param  int|null $referrer_id Filter that restricts the search result to listing markets with given referrer ID. (optional)
     * @param  int|null $credentials_id Filter that restricts the search result to listing markets with given credential ID. (optional)
     * @param  int|null $directory_id Filter that restricts the search result to listing markets with a given directory ID. (optional)
     * @param  int|null $item_id Filter that restricts the search result to listing markets that belong to a given item ID. (optional)
     * @param  int|null $shipping_profile_id Filter that restricts the search result to listing markets that belong to a given shipping profile ID (optional)
     * @param  int|null $with An array with child instances to be loaded. Valid instances are &#39;listing&#39;, &#39;texts&#39;, &#39;properties&#39;, &#39;prices&#39;, &#39;dates&#39;, &#39;infos&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsFindGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestListingsMarketsGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsFindGetWithHttpInfo(
        ?int $page = null,
        ?int $items_per_page = null,
        ?int $id = null,
        ?string $variations = null,
        ?int $referrer_id = null,
        ?int $credentials_id = null,
        ?int $directory_id = null,
        ?int $item_id = null,
        ?int $shipping_profile_id = null,
        ?int $with = null,
        string $contentType = self::contentTypes['restListingsMarketsFindGet'][0]
    ): array
    {
        $request = $this->restListingsMarketsFindGetRequest($page, $items_per_page, $id, $variations, $referrer_id, $credentials_id, $directory_id, $item_id, $shipping_profile_id, $with, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestListingsMarketsGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestListingsMarketsGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestListingsMarketsGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestListingsMarketsGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestListingsMarketsGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsFindGetAsync
     *
     * Find listing markets
     *
     * @param  int|null $page The page of results to search for. (optional)
     * @param  int|null $items_per_page The number of items to list per page. (optional)
     * @param  int|null $id Filter that restricts the search result to listing markets that match the given ID(s). (optional)
     * @param  string|null $variations Filter that restricts the search result to listing markets with a custom variation condition. Available values are &#39;all&#39;, &#39;fixed&#39;. (optional)
     * @param  int|null $referrer_id Filter that restricts the search result to listing markets with given referrer ID. (optional)
     * @param  int|null $credentials_id Filter that restricts the search result to listing markets with given credential ID. (optional)
     * @param  int|null $directory_id Filter that restricts the search result to listing markets with a given directory ID. (optional)
     * @param  int|null $item_id Filter that restricts the search result to listing markets that belong to a given item ID. (optional)
     * @param  int|null $shipping_profile_id Filter that restricts the search result to listing markets that belong to a given shipping profile ID (optional)
     * @param  int|null $with An array with child instances to be loaded. Valid instances are &#39;listing&#39;, &#39;texts&#39;, &#39;properties&#39;, &#39;prices&#39;, &#39;dates&#39;, &#39;infos&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsFindGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsMarketsFindGetAsync(
        ?int $page = null,
        ?int $items_per_page = null,
        ?int $id = null,
        ?string $variations = null,
        ?int $referrer_id = null,
        ?int $credentials_id = null,
        ?int $directory_id = null,
        ?int $item_id = null,
        ?int $shipping_profile_id = null,
        ?int $with = null,
        string $contentType = self::contentTypes['restListingsMarketsFindGet'][0]
    ): PromiseInterface
    {
        return $this->restListingsMarketsFindGetAsyncWithHttpInfo($page, $items_per_page, $id, $variations, $referrer_id, $credentials_id, $directory_id, $item_id, $shipping_profile_id, $with, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsFindGetAsyncWithHttpInfo
     *
     * Find listing markets
     *
     * @param  int|null $page The page of results to search for. (optional)
     * @param  int|null $items_per_page The number of items to list per page. (optional)
     * @param  int|null $id Filter that restricts the search result to listing markets that match the given ID(s). (optional)
     * @param  string|null $variations Filter that restricts the search result to listing markets with a custom variation condition. Available values are &#39;all&#39;, &#39;fixed&#39;. (optional)
     * @param  int|null $referrer_id Filter that restricts the search result to listing markets with given referrer ID. (optional)
     * @param  int|null $credentials_id Filter that restricts the search result to listing markets with given credential ID. (optional)
     * @param  int|null $directory_id Filter that restricts the search result to listing markets with a given directory ID. (optional)
     * @param  int|null $item_id Filter that restricts the search result to listing markets that belong to a given item ID. (optional)
     * @param  int|null $shipping_profile_id Filter that restricts the search result to listing markets that belong to a given shipping profile ID (optional)
     * @param  int|null $with An array with child instances to be loaded. Valid instances are &#39;listing&#39;, &#39;texts&#39;, &#39;properties&#39;, &#39;prices&#39;, &#39;dates&#39;, &#39;infos&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsFindGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsMarketsFindGetAsyncWithHttpInfo(
        $page = null,
        $items_per_page = null,
        $id = null,
        $variations = null,
        $referrer_id = null,
        $credentials_id = null,
        $directory_id = null,
        $item_id = null,
        $shipping_profile_id = null,
        $with = null,
        string $contentType = self::contentTypes['restListingsMarketsFindGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestListingsMarketsGet200Response';
        $request = $this->restListingsMarketsFindGetRequest($page, $items_per_page, $id, $variations, $referrer_id, $credentials_id, $directory_id, $item_id, $shipping_profile_id, $with, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsFindGet'
     *
     * @param  int|null $page The page of results to search for. (optional)
     * @param  int|null $items_per_page The number of items to list per page. (optional)
     * @param  int|null $id Filter that restricts the search result to listing markets that match the given ID(s). (optional)
     * @param  string|null $variations Filter that restricts the search result to listing markets with a custom variation condition. Available values are &#39;all&#39;, &#39;fixed&#39;. (optional)
     * @param  int|null $referrer_id Filter that restricts the search result to listing markets with given referrer ID. (optional)
     * @param  int|null $credentials_id Filter that restricts the search result to listing markets with given credential ID. (optional)
     * @param  int|null $directory_id Filter that restricts the search result to listing markets with a given directory ID. (optional)
     * @param  int|null $item_id Filter that restricts the search result to listing markets that belong to a given item ID. (optional)
     * @param  int|null $shipping_profile_id Filter that restricts the search result to listing markets that belong to a given shipping profile ID (optional)
     * @param  int|null $with An array with child instances to be loaded. Valid instances are &#39;listing&#39;, &#39;texts&#39;, &#39;properties&#39;, &#39;prices&#39;, &#39;dates&#39;, &#39;infos&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsFindGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restListingsMarketsFindGetRequest(
        $page = null,
        $items_per_page = null,
        $id = null,
        $variations = null,
        $referrer_id = null,
        $credentials_id = null,
        $directory_id = null,
        $item_id = null,
        $shipping_profile_id = null,
        $with = null,
        string $contentType = self::contentTypes['restListingsMarketsFindGet'][0]
    ): Request
    {












        $resourcePath = '/rest/listings/markets/find';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $items_per_page,
            'itemsPerPage', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $variations,
            'variations', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $referrer_id,
            'referrerId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $credentials_id,
            'credentialsId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $directory_id,
            'directoryId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $item_id,
            'itemId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $shipping_profile_id,
            'shippingProfileId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsGet
     *
     * List listing markets
     *
     * @param  int|null $page The page of results to search for. (optional)
     * @param  int|null $items_per_page The number of items to list per page. (optional)
     * @param  int|null $id Filter that restricts the search result to listing markets that match the given ID(s). (optional)
     * @param  int|null $variation_id Filter that restricts the search result to listing markets that match the given variation ID(s). (optional)
     * @param  string|null $variations Filter that restricts the search result to listing markets with a custom variation condition. Available values are &#39;all&#39;, &#39;fixed&#39;. (optional)
     * @param  int|null $referrer_id Filter that restricts the search result to listing markets with given referrer ID. (optional)
     * @param  int|null $credentials_id Filter that restricts the search result to listing markets with given credential ID. (optional)
     * @param  int|null $directory_id Filter that restricts the search result to listing markets with a given directory ID. (optional)
     * @param  string|null $verified Filter that restricts the search result to listing markets that are verified. Available values are &#39;succeeded&#39;,&#39;unknown&#39; or &#39;failed&#39;. (optional)
     * @param  string|null $duration Filter that restricts the search result to listing markets with given duration. (optional)
     * @param  int|null $listing_id Filter that restricts the search result to listing markets that belong to a given listing ID. (optional)
     * @param  int|null $item_id Filter that restricts the search result to listing markets that belong to a given item ID. (optional)
     * @param  int|null $listing_type_id Filter that restricts the search result to listing markets that belong to a listing of a custom type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Auction&lt;/li&gt;     &lt;li&gt;2 - Fixed price&lt;/li&gt;     &lt;li&gt;3 - Shop (only for Hood listings)&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  int|null $stock_dependence_type_id Filter that restricts the search result to listing markets that belong to a listing with a custom stock dependence type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Unlimited stock with automatic synchronisation&lt;/li&gt;     &lt;li&gt;2 - Limited and reserved stock&lt;/li&gt;     &lt;li&gt;3 - Limited and unreserved stock&lt;/li&gt;     &lt;li&gt;4 - Unlimited stock without automatich synchronisation&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  string|null $status Filter that restricts the search result to listing markets with a custom status condition. Available values are &#39;enabled&#39;, &#39;disabled&#39;, &#39;online&#39;, &#39;offline&#39; (optional)
     * @param  string|null $stock_condition Filter that restricts the search result to listing markets with a custom stock condition. Available values are &#39;stockNetLessEqualZero&#39;, &#39;stockNetLessZero&#39;, &#39;stockNetGreaterZero&#39;, &#39;stockGrossLessEqualZero&#39;, &#39;stockGrossLessZero&#39;, &#39;stockGrossGreaterZero&#39;, &#39;stockNetTotalLessEqualZero&#39;, &#39;stockNetTotalLessZero&#39;, &#39;stockNetTotalGreaterZero&#39; (optional)
     * @param  int|null $shipping_profile_id Filter that restricts the search result to listing markets that belong to a given shipping profile ID (optional)
     * @param  string|null $updated_at_from Filter that restricts the search result to listing markets that were last updated on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $updated_at_to Filter that restricts the search result to listing markets that were last updated within a specified period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  int|null $with An array with child instances to be loaded. Valid instances are &#39;listing&#39;, &#39;texts&#39;, &#39;properties&#39;, &#39;prices&#39;, &#39;dates&#39;, &#39;infos&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestListingsMarketsGet200Response
     */
    public function restListingsMarketsGet(
        ?int $page = null,
        ?int $items_per_page = null,
        ?int $id = null,
        ?int $variation_id = null,
        ?string $variations = null,
        ?int $referrer_id = null,
        ?int $credentials_id = null,
        ?int $directory_id = null,
        ?string $verified = null,
        ?string $duration = null,
        ?int $listing_id = null,
        ?int $item_id = null,
        ?int $listing_type_id = null,
        ?int $stock_dependence_type_id = null,
        ?string $status = null,
        ?string $stock_condition = null,
        ?int $shipping_profile_id = null,
        ?string $updated_at_from = null,
        ?string $updated_at_to = null,
        ?int $with = null,
        string $contentType = self::contentTypes['restListingsMarketsGet'][0]
    ): \ck\Model\RestListingsMarketsGet200Response
    {
        list($response) = $this->restListingsMarketsGetWithHttpInfo($page, $items_per_page, $id, $variation_id, $variations, $referrer_id, $credentials_id, $directory_id, $verified, $duration, $listing_id, $item_id, $listing_type_id, $stock_dependence_type_id, $status, $stock_condition, $shipping_profile_id, $updated_at_from, $updated_at_to, $with, $contentType);
        return $response;
    }

    /**
     * Operation restListingsMarketsGetWithHttpInfo
     *
     * List listing markets
     *
     * @param  int|null $page The page of results to search for. (optional)
     * @param  int|null $items_per_page The number of items to list per page. (optional)
     * @param  int|null $id Filter that restricts the search result to listing markets that match the given ID(s). (optional)
     * @param  int|null $variation_id Filter that restricts the search result to listing markets that match the given variation ID(s). (optional)
     * @param  string|null $variations Filter that restricts the search result to listing markets with a custom variation condition. Available values are &#39;all&#39;, &#39;fixed&#39;. (optional)
     * @param  int|null $referrer_id Filter that restricts the search result to listing markets with given referrer ID. (optional)
     * @param  int|null $credentials_id Filter that restricts the search result to listing markets with given credential ID. (optional)
     * @param  int|null $directory_id Filter that restricts the search result to listing markets with a given directory ID. (optional)
     * @param  string|null $verified Filter that restricts the search result to listing markets that are verified. Available values are &#39;succeeded&#39;,&#39;unknown&#39; or &#39;failed&#39;. (optional)
     * @param  string|null $duration Filter that restricts the search result to listing markets with given duration. (optional)
     * @param  int|null $listing_id Filter that restricts the search result to listing markets that belong to a given listing ID. (optional)
     * @param  int|null $item_id Filter that restricts the search result to listing markets that belong to a given item ID. (optional)
     * @param  int|null $listing_type_id Filter that restricts the search result to listing markets that belong to a listing of a custom type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Auction&lt;/li&gt;     &lt;li&gt;2 - Fixed price&lt;/li&gt;     &lt;li&gt;3 - Shop (only for Hood listings)&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  int|null $stock_dependence_type_id Filter that restricts the search result to listing markets that belong to a listing with a custom stock dependence type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Unlimited stock with automatic synchronisation&lt;/li&gt;     &lt;li&gt;2 - Limited and reserved stock&lt;/li&gt;     &lt;li&gt;3 - Limited and unreserved stock&lt;/li&gt;     &lt;li&gt;4 - Unlimited stock without automatich synchronisation&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  string|null $status Filter that restricts the search result to listing markets with a custom status condition. Available values are &#39;enabled&#39;, &#39;disabled&#39;, &#39;online&#39;, &#39;offline&#39; (optional)
     * @param  string|null $stock_condition Filter that restricts the search result to listing markets with a custom stock condition. Available values are &#39;stockNetLessEqualZero&#39;, &#39;stockNetLessZero&#39;, &#39;stockNetGreaterZero&#39;, &#39;stockGrossLessEqualZero&#39;, &#39;stockGrossLessZero&#39;, &#39;stockGrossGreaterZero&#39;, &#39;stockNetTotalLessEqualZero&#39;, &#39;stockNetTotalLessZero&#39;, &#39;stockNetTotalGreaterZero&#39; (optional)
     * @param  int|null $shipping_profile_id Filter that restricts the search result to listing markets that belong to a given shipping profile ID (optional)
     * @param  string|null $updated_at_from Filter that restricts the search result to listing markets that were last updated on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $updated_at_to Filter that restricts the search result to listing markets that were last updated within a specified period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  int|null $with An array with child instances to be loaded. Valid instances are &#39;listing&#39;, &#39;texts&#39;, &#39;properties&#39;, &#39;prices&#39;, &#39;dates&#39;, &#39;infos&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestListingsMarketsGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsGetWithHttpInfo(
        ?int $page = null,
        ?int $items_per_page = null,
        ?int $id = null,
        ?int $variation_id = null,
        ?string $variations = null,
        ?int $referrer_id = null,
        ?int $credentials_id = null,
        ?int $directory_id = null,
        ?string $verified = null,
        ?string $duration = null,
        ?int $listing_id = null,
        ?int $item_id = null,
        ?int $listing_type_id = null,
        ?int $stock_dependence_type_id = null,
        ?string $status = null,
        ?string $stock_condition = null,
        ?int $shipping_profile_id = null,
        ?string $updated_at_from = null,
        ?string $updated_at_to = null,
        ?int $with = null,
        string $contentType = self::contentTypes['restListingsMarketsGet'][0]
    ): array
    {
        $request = $this->restListingsMarketsGetRequest($page, $items_per_page, $id, $variation_id, $variations, $referrer_id, $credentials_id, $directory_id, $verified, $duration, $listing_id, $item_id, $listing_type_id, $stock_dependence_type_id, $status, $stock_condition, $shipping_profile_id, $updated_at_from, $updated_at_to, $with, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestListingsMarketsGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestListingsMarketsGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestListingsMarketsGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestListingsMarketsGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestListingsMarketsGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsGetAsync
     *
     * List listing markets
     *
     * @param  int|null $page The page of results to search for. (optional)
     * @param  int|null $items_per_page The number of items to list per page. (optional)
     * @param  int|null $id Filter that restricts the search result to listing markets that match the given ID(s). (optional)
     * @param  int|null $variation_id Filter that restricts the search result to listing markets that match the given variation ID(s). (optional)
     * @param  string|null $variations Filter that restricts the search result to listing markets with a custom variation condition. Available values are &#39;all&#39;, &#39;fixed&#39;. (optional)
     * @param  int|null $referrer_id Filter that restricts the search result to listing markets with given referrer ID. (optional)
     * @param  int|null $credentials_id Filter that restricts the search result to listing markets with given credential ID. (optional)
     * @param  int|null $directory_id Filter that restricts the search result to listing markets with a given directory ID. (optional)
     * @param  string|null $verified Filter that restricts the search result to listing markets that are verified. Available values are &#39;succeeded&#39;,&#39;unknown&#39; or &#39;failed&#39;. (optional)
     * @param  string|null $duration Filter that restricts the search result to listing markets with given duration. (optional)
     * @param  int|null $listing_id Filter that restricts the search result to listing markets that belong to a given listing ID. (optional)
     * @param  int|null $item_id Filter that restricts the search result to listing markets that belong to a given item ID. (optional)
     * @param  int|null $listing_type_id Filter that restricts the search result to listing markets that belong to a listing of a custom type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Auction&lt;/li&gt;     &lt;li&gt;2 - Fixed price&lt;/li&gt;     &lt;li&gt;3 - Shop (only for Hood listings)&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  int|null $stock_dependence_type_id Filter that restricts the search result to listing markets that belong to a listing with a custom stock dependence type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Unlimited stock with automatic synchronisation&lt;/li&gt;     &lt;li&gt;2 - Limited and reserved stock&lt;/li&gt;     &lt;li&gt;3 - Limited and unreserved stock&lt;/li&gt;     &lt;li&gt;4 - Unlimited stock without automatich synchronisation&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  string|null $status Filter that restricts the search result to listing markets with a custom status condition. Available values are &#39;enabled&#39;, &#39;disabled&#39;, &#39;online&#39;, &#39;offline&#39; (optional)
     * @param  string|null $stock_condition Filter that restricts the search result to listing markets with a custom stock condition. Available values are &#39;stockNetLessEqualZero&#39;, &#39;stockNetLessZero&#39;, &#39;stockNetGreaterZero&#39;, &#39;stockGrossLessEqualZero&#39;, &#39;stockGrossLessZero&#39;, &#39;stockGrossGreaterZero&#39;, &#39;stockNetTotalLessEqualZero&#39;, &#39;stockNetTotalLessZero&#39;, &#39;stockNetTotalGreaterZero&#39; (optional)
     * @param  int|null $shipping_profile_id Filter that restricts the search result to listing markets that belong to a given shipping profile ID (optional)
     * @param  string|null $updated_at_from Filter that restricts the search result to listing markets that were last updated on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $updated_at_to Filter that restricts the search result to listing markets that were last updated within a specified period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  int|null $with An array with child instances to be loaded. Valid instances are &#39;listing&#39;, &#39;texts&#39;, &#39;properties&#39;, &#39;prices&#39;, &#39;dates&#39;, &#39;infos&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsMarketsGetAsync(
        ?int $page = null,
        ?int $items_per_page = null,
        ?int $id = null,
        ?int $variation_id = null,
        ?string $variations = null,
        ?int $referrer_id = null,
        ?int $credentials_id = null,
        ?int $directory_id = null,
        ?string $verified = null,
        ?string $duration = null,
        ?int $listing_id = null,
        ?int $item_id = null,
        ?int $listing_type_id = null,
        ?int $stock_dependence_type_id = null,
        ?string $status = null,
        ?string $stock_condition = null,
        ?int $shipping_profile_id = null,
        ?string $updated_at_from = null,
        ?string $updated_at_to = null,
        ?int $with = null,
        string $contentType = self::contentTypes['restListingsMarketsGet'][0]
    ): PromiseInterface
    {
        return $this->restListingsMarketsGetAsyncWithHttpInfo($page, $items_per_page, $id, $variation_id, $variations, $referrer_id, $credentials_id, $directory_id, $verified, $duration, $listing_id, $item_id, $listing_type_id, $stock_dependence_type_id, $status, $stock_condition, $shipping_profile_id, $updated_at_from, $updated_at_to, $with, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsGetAsyncWithHttpInfo
     *
     * List listing markets
     *
     * @param  int|null $page The page of results to search for. (optional)
     * @param  int|null $items_per_page The number of items to list per page. (optional)
     * @param  int|null $id Filter that restricts the search result to listing markets that match the given ID(s). (optional)
     * @param  int|null $variation_id Filter that restricts the search result to listing markets that match the given variation ID(s). (optional)
     * @param  string|null $variations Filter that restricts the search result to listing markets with a custom variation condition. Available values are &#39;all&#39;, &#39;fixed&#39;. (optional)
     * @param  int|null $referrer_id Filter that restricts the search result to listing markets with given referrer ID. (optional)
     * @param  int|null $credentials_id Filter that restricts the search result to listing markets with given credential ID. (optional)
     * @param  int|null $directory_id Filter that restricts the search result to listing markets with a given directory ID. (optional)
     * @param  string|null $verified Filter that restricts the search result to listing markets that are verified. Available values are &#39;succeeded&#39;,&#39;unknown&#39; or &#39;failed&#39;. (optional)
     * @param  string|null $duration Filter that restricts the search result to listing markets with given duration. (optional)
     * @param  int|null $listing_id Filter that restricts the search result to listing markets that belong to a given listing ID. (optional)
     * @param  int|null $item_id Filter that restricts the search result to listing markets that belong to a given item ID. (optional)
     * @param  int|null $listing_type_id Filter that restricts the search result to listing markets that belong to a listing of a custom type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Auction&lt;/li&gt;     &lt;li&gt;2 - Fixed price&lt;/li&gt;     &lt;li&gt;3 - Shop (only for Hood listings)&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  int|null $stock_dependence_type_id Filter that restricts the search result to listing markets that belong to a listing with a custom stock dependence type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Unlimited stock with automatic synchronisation&lt;/li&gt;     &lt;li&gt;2 - Limited and reserved stock&lt;/li&gt;     &lt;li&gt;3 - Limited and unreserved stock&lt;/li&gt;     &lt;li&gt;4 - Unlimited stock without automatich synchronisation&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  string|null $status Filter that restricts the search result to listing markets with a custom status condition. Available values are &#39;enabled&#39;, &#39;disabled&#39;, &#39;online&#39;, &#39;offline&#39; (optional)
     * @param  string|null $stock_condition Filter that restricts the search result to listing markets with a custom stock condition. Available values are &#39;stockNetLessEqualZero&#39;, &#39;stockNetLessZero&#39;, &#39;stockNetGreaterZero&#39;, &#39;stockGrossLessEqualZero&#39;, &#39;stockGrossLessZero&#39;, &#39;stockGrossGreaterZero&#39;, &#39;stockNetTotalLessEqualZero&#39;, &#39;stockNetTotalLessZero&#39;, &#39;stockNetTotalGreaterZero&#39; (optional)
     * @param  int|null $shipping_profile_id Filter that restricts the search result to listing markets that belong to a given shipping profile ID (optional)
     * @param  string|null $updated_at_from Filter that restricts the search result to listing markets that were last updated on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $updated_at_to Filter that restricts the search result to listing markets that were last updated within a specified period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  int|null $with An array with child instances to be loaded. Valid instances are &#39;listing&#39;, &#39;texts&#39;, &#39;properties&#39;, &#39;prices&#39;, &#39;dates&#39;, &#39;infos&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsMarketsGetAsyncWithHttpInfo(
        $page = null,
        $items_per_page = null,
        $id = null,
        $variation_id = null,
        $variations = null,
        $referrer_id = null,
        $credentials_id = null,
        $directory_id = null,
        $verified = null,
        $duration = null,
        $listing_id = null,
        $item_id = null,
        $listing_type_id = null,
        $stock_dependence_type_id = null,
        $status = null,
        $stock_condition = null,
        $shipping_profile_id = null,
        $updated_at_from = null,
        $updated_at_to = null,
        $with = null,
        string $contentType = self::contentTypes['restListingsMarketsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestListingsMarketsGet200Response';
        $request = $this->restListingsMarketsGetRequest($page, $items_per_page, $id, $variation_id, $variations, $referrer_id, $credentials_id, $directory_id, $verified, $duration, $listing_id, $item_id, $listing_type_id, $stock_dependence_type_id, $status, $stock_condition, $shipping_profile_id, $updated_at_from, $updated_at_to, $with, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsGet'
     *
     * @param  int|null $page The page of results to search for. (optional)
     * @param  int|null $items_per_page The number of items to list per page. (optional)
     * @param  int|null $id Filter that restricts the search result to listing markets that match the given ID(s). (optional)
     * @param  int|null $variation_id Filter that restricts the search result to listing markets that match the given variation ID(s). (optional)
     * @param  string|null $variations Filter that restricts the search result to listing markets with a custom variation condition. Available values are &#39;all&#39;, &#39;fixed&#39;. (optional)
     * @param  int|null $referrer_id Filter that restricts the search result to listing markets with given referrer ID. (optional)
     * @param  int|null $credentials_id Filter that restricts the search result to listing markets with given credential ID. (optional)
     * @param  int|null $directory_id Filter that restricts the search result to listing markets with a given directory ID. (optional)
     * @param  string|null $verified Filter that restricts the search result to listing markets that are verified. Available values are &#39;succeeded&#39;,&#39;unknown&#39; or &#39;failed&#39;. (optional)
     * @param  string|null $duration Filter that restricts the search result to listing markets with given duration. (optional)
     * @param  int|null $listing_id Filter that restricts the search result to listing markets that belong to a given listing ID. (optional)
     * @param  int|null $item_id Filter that restricts the search result to listing markets that belong to a given item ID. (optional)
     * @param  int|null $listing_type_id Filter that restricts the search result to listing markets that belong to a listing of a custom type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Auction&lt;/li&gt;     &lt;li&gt;2 - Fixed price&lt;/li&gt;     &lt;li&gt;3 - Shop (only for Hood listings)&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  int|null $stock_dependence_type_id Filter that restricts the search result to listing markets that belong to a listing with a custom stock dependence type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Unlimited stock with automatic synchronisation&lt;/li&gt;     &lt;li&gt;2 - Limited and reserved stock&lt;/li&gt;     &lt;li&gt;3 - Limited and unreserved stock&lt;/li&gt;     &lt;li&gt;4 - Unlimited stock without automatich synchronisation&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  string|null $status Filter that restricts the search result to listing markets with a custom status condition. Available values are &#39;enabled&#39;, &#39;disabled&#39;, &#39;online&#39;, &#39;offline&#39; (optional)
     * @param  string|null $stock_condition Filter that restricts the search result to listing markets with a custom stock condition. Available values are &#39;stockNetLessEqualZero&#39;, &#39;stockNetLessZero&#39;, &#39;stockNetGreaterZero&#39;, &#39;stockGrossLessEqualZero&#39;, &#39;stockGrossLessZero&#39;, &#39;stockGrossGreaterZero&#39;, &#39;stockNetTotalLessEqualZero&#39;, &#39;stockNetTotalLessZero&#39;, &#39;stockNetTotalGreaterZero&#39; (optional)
     * @param  int|null $shipping_profile_id Filter that restricts the search result to listing markets that belong to a given shipping profile ID (optional)
     * @param  string|null $updated_at_from Filter that restricts the search result to listing markets that were last updated on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $updated_at_to Filter that restricts the search result to listing markets that were last updated within a specified period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  int|null $with An array with child instances to be loaded. Valid instances are &#39;listing&#39;, &#39;texts&#39;, &#39;properties&#39;, &#39;prices&#39;, &#39;dates&#39;, &#39;infos&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restListingsMarketsGetRequest(
        $page = null,
        $items_per_page = null,
        $id = null,
        $variation_id = null,
        $variations = null,
        $referrer_id = null,
        $credentials_id = null,
        $directory_id = null,
        $verified = null,
        $duration = null,
        $listing_id = null,
        $item_id = null,
        $listing_type_id = null,
        $stock_dependence_type_id = null,
        $status = null,
        $stock_condition = null,
        $shipping_profile_id = null,
        $updated_at_from = null,
        $updated_at_to = null,
        $with = null,
        string $contentType = self::contentTypes['restListingsMarketsGet'][0]
    ): Request
    {






















        $resourcePath = '/rest/listings/markets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $items_per_page,
            'itemsPerPage', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $variation_id,
            'variationId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $variations,
            'variations', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $referrer_id,
            'referrerId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $credentials_id,
            'credentialsId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $directory_id,
            'directoryId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $verified,
            'verified', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $duration,
            'duration', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $listing_id,
            'listingId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $item_id,
            'itemId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $listing_type_id,
            'listingTypeId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $stock_dependence_type_id,
            'stockDependenceTypeId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $stock_condition,
            'stockCondition', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $shipping_profile_id,
            'shippingProfileId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_at_from,
            'updatedAtFrom', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_at_to,
            'updatedAtTo', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsHistoriesGet
     *
     * List listing market history
     *
     * @param  int|null $page The page of results to search for. (optional)
     * @param  int|null $items_per_page The number of items to list per page. (optional)
     * @param  int|null $listing_market_id Filter that restricts the search result to listing market histories that match the given listing market ID(s). (optional)
     * @param  int|null $variation_id Filter that restricts the search result to listing market histories that match the given variation ID(s). (optional)
     * @param  string|null $variations Filter that restricts the search result to listing market histories with a custom variation condition. Available values are &#39;all&#39;, &#39;fixed&#39;. (optional)
     * @param  int|null $referrer_id Filter that restricts the search result to listing market histories with given referrer ID. (optional)
     * @param  int|null $credentials_id Filter that restricts the search result to listing market histories with given credential ID. (optional)
     * @param  int|null $directory_id Filter that restricts the search result to listing market histories with a given directory ID. (optional)
     * @param  string|null $verified Filter that restricts the search result to listing market histories that are verified. Available values are &#39;succeeded&#39;,&#39;unknown&#39; or &#39;failed&#39;. (optional)
     * @param  string|null $duration Filter that restricts the search result to listing market histories with given duration. (optional)
     * @param  string|null $external_id Filter that restricts the search result to listing market histories with given external id. (optional)
     * @param  int|null $listing_id Filter that restricts the search result to listing market histories that belong to a given listing ID. (optional)
     * @param  int|null $item_id Filter that restricts the search result to listing market histories that belong to a given item ID. (optional)
     * @param  int|null $listing_type_id Filter that restricts the search result to listing market histories that belong to a listing of a custom type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Auction&lt;/li&gt;     &lt;li&gt;2 - Fixed price&lt;/li&gt;     &lt;li&gt;3 - Shop (only for Hood listings)&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  int|null $stock_dependence_type_id Filter that restricts the search result to listing market histories that belong to a listing with a custom stock dependence type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Unlimited stock with automatic synchronisation&lt;/li&gt;     &lt;li&gt;2 - Limited and reserved stock&lt;/li&gt;     &lt;li&gt;3 - Limited and unreserved stock&lt;/li&gt;     &lt;li&gt;4 - Unlimited stock without automatich synchronisation&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  int|null $status_id Filter that restricts the search result to listing market histories with a custom status status ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Active listing market histories&lt;/li&gt;     &lt;li&gt;2 - Ended listing market histories&lt;/li&gt;     &lt;li&gt;3 - Relisted listing market histories&lt;/li&gt;     &lt;li&gt;4 - Hidden listing market histories&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  string|null $stock_condition Filter that restricts the search result to listing market histories with a custom stock condition. Available values are &#39;stockNetLessEqualZero&#39;, &#39;stockNetLessZero&#39;, &#39;stockNetGreaterZero&#39;, &#39;stockGrossLessEqualZero&#39;, &#39;stockGrossLessZero&#39;, &#39;stockGrossGreaterZero&#39;, &#39;stockNetTotalLessEqualZero&#39;, &#39;stockNetTotalLessZero&#39;, &#39;stockNetTotalGreaterZero&#39; (optional)
     * @param  string|null $updated_at_from Filter that restricts the search result to listing market histories that were last updated on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $updated_at_to Filter that restricts the search result to listing market histories that were last updated within a specified period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $text_data Filter that restricts the search result to listing market histories that match given text in listing title or description. (optional)
     * @param  string|null $first_platform_category_id Filter that restricts the search result to listing market histories with first platform category ID equal to the given ID. (optional)
     * @param  string|null $second_platform_category_id Filter that restricts the search result to listing market histories with second platform category ID equal to the given ID. (optional)
     * @param  string|null $first_shop_category_id Filter that restricts the search result to listing market histories with first shop category ID equal to the given ID. (optional)
     * @param  string|null $second_shop_category_id Filter that restricts the search result to listing market histories with second shop category ID equal to the given ID. (optional)
     * @param  string|null $third_shop_category_id Filter that restricts the search result to listing market histories with third shop category ID equal to the given ID. (optional)
     * @param  string|null $shipping_profile_id Filter that restricts the search result to listing market histories that belong to a given shipping profile. (optional)
     * @param  string|null $last_sale Filter that restricts the search result to listing market histories with last sale before given date.The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $is_ebay_plus Filter that restricts the search result to listing market histories that belong to eBay Plus. (optional)
     * @param  string|null $is_click_and_collect Filter that restricts the search result to listing market histories that belong to eBay Click &amp; Collect. (optional)
     * @param  int|null $with An array with child instances to be loaded. Valid instances are &#39;listingMarket&#39;, &#39;texts&#39;, &#39;properties&#39;, &#39;prices&#39;, &#39;dates&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsHistoriesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestListingsMarketsHistoriesGet200Response
     */
    public function restListingsMarketsHistoriesGet(
        ?int $page = null,
        ?int $items_per_page = null,
        ?int $listing_market_id = null,
        ?int $variation_id = null,
        ?string $variations = null,
        ?int $referrer_id = null,
        ?int $credentials_id = null,
        ?int $directory_id = null,
        ?string $verified = null,
        ?string $duration = null,
        ?string $external_id = null,
        ?int $listing_id = null,
        ?int $item_id = null,
        ?int $listing_type_id = null,
        ?int $stock_dependence_type_id = null,
        ?int $status_id = null,
        ?string $stock_condition = null,
        ?string $updated_at_from = null,
        ?string $updated_at_to = null,
        ?string $text_data = null,
        ?string $first_platform_category_id = null,
        ?string $second_platform_category_id = null,
        ?string $first_shop_category_id = null,
        ?string $second_shop_category_id = null,
        ?string $third_shop_category_id = null,
        ?string $shipping_profile_id = null,
        ?string $last_sale = null,
        ?string $is_ebay_plus = null,
        ?string $is_click_and_collect = null,
        ?int $with = null,
        string $contentType = self::contentTypes['restListingsMarketsHistoriesGet'][0]
    ): \ck\Model\RestListingsMarketsHistoriesGet200Response
    {
        list($response) = $this->restListingsMarketsHistoriesGetWithHttpInfo($page, $items_per_page, $listing_market_id, $variation_id, $variations, $referrer_id, $credentials_id, $directory_id, $verified, $duration, $external_id, $listing_id, $item_id, $listing_type_id, $stock_dependence_type_id, $status_id, $stock_condition, $updated_at_from, $updated_at_to, $text_data, $first_platform_category_id, $second_platform_category_id, $first_shop_category_id, $second_shop_category_id, $third_shop_category_id, $shipping_profile_id, $last_sale, $is_ebay_plus, $is_click_and_collect, $with, $contentType);
        return $response;
    }

    /**
     * Operation restListingsMarketsHistoriesGetWithHttpInfo
     *
     * List listing market history
     *
     * @param  int|null $page The page of results to search for. (optional)
     * @param  int|null $items_per_page The number of items to list per page. (optional)
     * @param  int|null $listing_market_id Filter that restricts the search result to listing market histories that match the given listing market ID(s). (optional)
     * @param  int|null $variation_id Filter that restricts the search result to listing market histories that match the given variation ID(s). (optional)
     * @param  string|null $variations Filter that restricts the search result to listing market histories with a custom variation condition. Available values are &#39;all&#39;, &#39;fixed&#39;. (optional)
     * @param  int|null $referrer_id Filter that restricts the search result to listing market histories with given referrer ID. (optional)
     * @param  int|null $credentials_id Filter that restricts the search result to listing market histories with given credential ID. (optional)
     * @param  int|null $directory_id Filter that restricts the search result to listing market histories with a given directory ID. (optional)
     * @param  string|null $verified Filter that restricts the search result to listing market histories that are verified. Available values are &#39;succeeded&#39;,&#39;unknown&#39; or &#39;failed&#39;. (optional)
     * @param  string|null $duration Filter that restricts the search result to listing market histories with given duration. (optional)
     * @param  string|null $external_id Filter that restricts the search result to listing market histories with given external id. (optional)
     * @param  int|null $listing_id Filter that restricts the search result to listing market histories that belong to a given listing ID. (optional)
     * @param  int|null $item_id Filter that restricts the search result to listing market histories that belong to a given item ID. (optional)
     * @param  int|null $listing_type_id Filter that restricts the search result to listing market histories that belong to a listing of a custom type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Auction&lt;/li&gt;     &lt;li&gt;2 - Fixed price&lt;/li&gt;     &lt;li&gt;3 - Shop (only for Hood listings)&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  int|null $stock_dependence_type_id Filter that restricts the search result to listing market histories that belong to a listing with a custom stock dependence type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Unlimited stock with automatic synchronisation&lt;/li&gt;     &lt;li&gt;2 - Limited and reserved stock&lt;/li&gt;     &lt;li&gt;3 - Limited and unreserved stock&lt;/li&gt;     &lt;li&gt;4 - Unlimited stock without automatich synchronisation&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  int|null $status_id Filter that restricts the search result to listing market histories with a custom status status ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Active listing market histories&lt;/li&gt;     &lt;li&gt;2 - Ended listing market histories&lt;/li&gt;     &lt;li&gt;3 - Relisted listing market histories&lt;/li&gt;     &lt;li&gt;4 - Hidden listing market histories&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  string|null $stock_condition Filter that restricts the search result to listing market histories with a custom stock condition. Available values are &#39;stockNetLessEqualZero&#39;, &#39;stockNetLessZero&#39;, &#39;stockNetGreaterZero&#39;, &#39;stockGrossLessEqualZero&#39;, &#39;stockGrossLessZero&#39;, &#39;stockGrossGreaterZero&#39;, &#39;stockNetTotalLessEqualZero&#39;, &#39;stockNetTotalLessZero&#39;, &#39;stockNetTotalGreaterZero&#39; (optional)
     * @param  string|null $updated_at_from Filter that restricts the search result to listing market histories that were last updated on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $updated_at_to Filter that restricts the search result to listing market histories that were last updated within a specified period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $text_data Filter that restricts the search result to listing market histories that match given text in listing title or description. (optional)
     * @param  string|null $first_platform_category_id Filter that restricts the search result to listing market histories with first platform category ID equal to the given ID. (optional)
     * @param  string|null $second_platform_category_id Filter that restricts the search result to listing market histories with second platform category ID equal to the given ID. (optional)
     * @param  string|null $first_shop_category_id Filter that restricts the search result to listing market histories with first shop category ID equal to the given ID. (optional)
     * @param  string|null $second_shop_category_id Filter that restricts the search result to listing market histories with second shop category ID equal to the given ID. (optional)
     * @param  string|null $third_shop_category_id Filter that restricts the search result to listing market histories with third shop category ID equal to the given ID. (optional)
     * @param  string|null $shipping_profile_id Filter that restricts the search result to listing market histories that belong to a given shipping profile. (optional)
     * @param  string|null $last_sale Filter that restricts the search result to listing market histories with last sale before given date.The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $is_ebay_plus Filter that restricts the search result to listing market histories that belong to eBay Plus. (optional)
     * @param  string|null $is_click_and_collect Filter that restricts the search result to listing market histories that belong to eBay Click &amp; Collect. (optional)
     * @param  int|null $with An array with child instances to be loaded. Valid instances are &#39;listingMarket&#39;, &#39;texts&#39;, &#39;properties&#39;, &#39;prices&#39;, &#39;dates&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsHistoriesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestListingsMarketsHistoriesGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsHistoriesGetWithHttpInfo(
        ?int $page = null,
        ?int $items_per_page = null,
        ?int $listing_market_id = null,
        ?int $variation_id = null,
        ?string $variations = null,
        ?int $referrer_id = null,
        ?int $credentials_id = null,
        ?int $directory_id = null,
        ?string $verified = null,
        ?string $duration = null,
        ?string $external_id = null,
        ?int $listing_id = null,
        ?int $item_id = null,
        ?int $listing_type_id = null,
        ?int $stock_dependence_type_id = null,
        ?int $status_id = null,
        ?string $stock_condition = null,
        ?string $updated_at_from = null,
        ?string $updated_at_to = null,
        ?string $text_data = null,
        ?string $first_platform_category_id = null,
        ?string $second_platform_category_id = null,
        ?string $first_shop_category_id = null,
        ?string $second_shop_category_id = null,
        ?string $third_shop_category_id = null,
        ?string $shipping_profile_id = null,
        ?string $last_sale = null,
        ?string $is_ebay_plus = null,
        ?string $is_click_and_collect = null,
        ?int $with = null,
        string $contentType = self::contentTypes['restListingsMarketsHistoriesGet'][0]
    ): array
    {
        $request = $this->restListingsMarketsHistoriesGetRequest($page, $items_per_page, $listing_market_id, $variation_id, $variations, $referrer_id, $credentials_id, $directory_id, $verified, $duration, $external_id, $listing_id, $item_id, $listing_type_id, $stock_dependence_type_id, $status_id, $stock_condition, $updated_at_from, $updated_at_to, $text_data, $first_platform_category_id, $second_platform_category_id, $first_shop_category_id, $second_shop_category_id, $third_shop_category_id, $shipping_profile_id, $last_sale, $is_ebay_plus, $is_click_and_collect, $with, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestListingsMarketsHistoriesGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestListingsMarketsHistoriesGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestListingsMarketsHistoriesGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestListingsMarketsHistoriesGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestListingsMarketsHistoriesGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsHistoriesGetAsync
     *
     * List listing market history
     *
     * @param  int|null $page The page of results to search for. (optional)
     * @param  int|null $items_per_page The number of items to list per page. (optional)
     * @param  int|null $listing_market_id Filter that restricts the search result to listing market histories that match the given listing market ID(s). (optional)
     * @param  int|null $variation_id Filter that restricts the search result to listing market histories that match the given variation ID(s). (optional)
     * @param  string|null $variations Filter that restricts the search result to listing market histories with a custom variation condition. Available values are &#39;all&#39;, &#39;fixed&#39;. (optional)
     * @param  int|null $referrer_id Filter that restricts the search result to listing market histories with given referrer ID. (optional)
     * @param  int|null $credentials_id Filter that restricts the search result to listing market histories with given credential ID. (optional)
     * @param  int|null $directory_id Filter that restricts the search result to listing market histories with a given directory ID. (optional)
     * @param  string|null $verified Filter that restricts the search result to listing market histories that are verified. Available values are &#39;succeeded&#39;,&#39;unknown&#39; or &#39;failed&#39;. (optional)
     * @param  string|null $duration Filter that restricts the search result to listing market histories with given duration. (optional)
     * @param  string|null $external_id Filter that restricts the search result to listing market histories with given external id. (optional)
     * @param  int|null $listing_id Filter that restricts the search result to listing market histories that belong to a given listing ID. (optional)
     * @param  int|null $item_id Filter that restricts the search result to listing market histories that belong to a given item ID. (optional)
     * @param  int|null $listing_type_id Filter that restricts the search result to listing market histories that belong to a listing of a custom type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Auction&lt;/li&gt;     &lt;li&gt;2 - Fixed price&lt;/li&gt;     &lt;li&gt;3 - Shop (only for Hood listings)&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  int|null $stock_dependence_type_id Filter that restricts the search result to listing market histories that belong to a listing with a custom stock dependence type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Unlimited stock with automatic synchronisation&lt;/li&gt;     &lt;li&gt;2 - Limited and reserved stock&lt;/li&gt;     &lt;li&gt;3 - Limited and unreserved stock&lt;/li&gt;     &lt;li&gt;4 - Unlimited stock without automatich synchronisation&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  int|null $status_id Filter that restricts the search result to listing market histories with a custom status status ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Active listing market histories&lt;/li&gt;     &lt;li&gt;2 - Ended listing market histories&lt;/li&gt;     &lt;li&gt;3 - Relisted listing market histories&lt;/li&gt;     &lt;li&gt;4 - Hidden listing market histories&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  string|null $stock_condition Filter that restricts the search result to listing market histories with a custom stock condition. Available values are &#39;stockNetLessEqualZero&#39;, &#39;stockNetLessZero&#39;, &#39;stockNetGreaterZero&#39;, &#39;stockGrossLessEqualZero&#39;, &#39;stockGrossLessZero&#39;, &#39;stockGrossGreaterZero&#39;, &#39;stockNetTotalLessEqualZero&#39;, &#39;stockNetTotalLessZero&#39;, &#39;stockNetTotalGreaterZero&#39; (optional)
     * @param  string|null $updated_at_from Filter that restricts the search result to listing market histories that were last updated on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $updated_at_to Filter that restricts the search result to listing market histories that were last updated within a specified period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $text_data Filter that restricts the search result to listing market histories that match given text in listing title or description. (optional)
     * @param  string|null $first_platform_category_id Filter that restricts the search result to listing market histories with first platform category ID equal to the given ID. (optional)
     * @param  string|null $second_platform_category_id Filter that restricts the search result to listing market histories with second platform category ID equal to the given ID. (optional)
     * @param  string|null $first_shop_category_id Filter that restricts the search result to listing market histories with first shop category ID equal to the given ID. (optional)
     * @param  string|null $second_shop_category_id Filter that restricts the search result to listing market histories with second shop category ID equal to the given ID. (optional)
     * @param  string|null $third_shop_category_id Filter that restricts the search result to listing market histories with third shop category ID equal to the given ID. (optional)
     * @param  string|null $shipping_profile_id Filter that restricts the search result to listing market histories that belong to a given shipping profile. (optional)
     * @param  string|null $last_sale Filter that restricts the search result to listing market histories with last sale before given date.The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $is_ebay_plus Filter that restricts the search result to listing market histories that belong to eBay Plus. (optional)
     * @param  string|null $is_click_and_collect Filter that restricts the search result to listing market histories that belong to eBay Click &amp; Collect. (optional)
     * @param  int|null $with An array with child instances to be loaded. Valid instances are &#39;listingMarket&#39;, &#39;texts&#39;, &#39;properties&#39;, &#39;prices&#39;, &#39;dates&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsHistoriesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsMarketsHistoriesGetAsync(
        ?int $page = null,
        ?int $items_per_page = null,
        ?int $listing_market_id = null,
        ?int $variation_id = null,
        ?string $variations = null,
        ?int $referrer_id = null,
        ?int $credentials_id = null,
        ?int $directory_id = null,
        ?string $verified = null,
        ?string $duration = null,
        ?string $external_id = null,
        ?int $listing_id = null,
        ?int $item_id = null,
        ?int $listing_type_id = null,
        ?int $stock_dependence_type_id = null,
        ?int $status_id = null,
        ?string $stock_condition = null,
        ?string $updated_at_from = null,
        ?string $updated_at_to = null,
        ?string $text_data = null,
        ?string $first_platform_category_id = null,
        ?string $second_platform_category_id = null,
        ?string $first_shop_category_id = null,
        ?string $second_shop_category_id = null,
        ?string $third_shop_category_id = null,
        ?string $shipping_profile_id = null,
        ?string $last_sale = null,
        ?string $is_ebay_plus = null,
        ?string $is_click_and_collect = null,
        ?int $with = null,
        string $contentType = self::contentTypes['restListingsMarketsHistoriesGet'][0]
    ): PromiseInterface
    {
        return $this->restListingsMarketsHistoriesGetAsyncWithHttpInfo($page, $items_per_page, $listing_market_id, $variation_id, $variations, $referrer_id, $credentials_id, $directory_id, $verified, $duration, $external_id, $listing_id, $item_id, $listing_type_id, $stock_dependence_type_id, $status_id, $stock_condition, $updated_at_from, $updated_at_to, $text_data, $first_platform_category_id, $second_platform_category_id, $first_shop_category_id, $second_shop_category_id, $third_shop_category_id, $shipping_profile_id, $last_sale, $is_ebay_plus, $is_click_and_collect, $with, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsHistoriesGetAsyncWithHttpInfo
     *
     * List listing market history
     *
     * @param  int|null $page The page of results to search for. (optional)
     * @param  int|null $items_per_page The number of items to list per page. (optional)
     * @param  int|null $listing_market_id Filter that restricts the search result to listing market histories that match the given listing market ID(s). (optional)
     * @param  int|null $variation_id Filter that restricts the search result to listing market histories that match the given variation ID(s). (optional)
     * @param  string|null $variations Filter that restricts the search result to listing market histories with a custom variation condition. Available values are &#39;all&#39;, &#39;fixed&#39;. (optional)
     * @param  int|null $referrer_id Filter that restricts the search result to listing market histories with given referrer ID. (optional)
     * @param  int|null $credentials_id Filter that restricts the search result to listing market histories with given credential ID. (optional)
     * @param  int|null $directory_id Filter that restricts the search result to listing market histories with a given directory ID. (optional)
     * @param  string|null $verified Filter that restricts the search result to listing market histories that are verified. Available values are &#39;succeeded&#39;,&#39;unknown&#39; or &#39;failed&#39;. (optional)
     * @param  string|null $duration Filter that restricts the search result to listing market histories with given duration. (optional)
     * @param  string|null $external_id Filter that restricts the search result to listing market histories with given external id. (optional)
     * @param  int|null $listing_id Filter that restricts the search result to listing market histories that belong to a given listing ID. (optional)
     * @param  int|null $item_id Filter that restricts the search result to listing market histories that belong to a given item ID. (optional)
     * @param  int|null $listing_type_id Filter that restricts the search result to listing market histories that belong to a listing of a custom type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Auction&lt;/li&gt;     &lt;li&gt;2 - Fixed price&lt;/li&gt;     &lt;li&gt;3 - Shop (only for Hood listings)&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  int|null $stock_dependence_type_id Filter that restricts the search result to listing market histories that belong to a listing with a custom stock dependence type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Unlimited stock with automatic synchronisation&lt;/li&gt;     &lt;li&gt;2 - Limited and reserved stock&lt;/li&gt;     &lt;li&gt;3 - Limited and unreserved stock&lt;/li&gt;     &lt;li&gt;4 - Unlimited stock without automatich synchronisation&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  int|null $status_id Filter that restricts the search result to listing market histories with a custom status status ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Active listing market histories&lt;/li&gt;     &lt;li&gt;2 - Ended listing market histories&lt;/li&gt;     &lt;li&gt;3 - Relisted listing market histories&lt;/li&gt;     &lt;li&gt;4 - Hidden listing market histories&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  string|null $stock_condition Filter that restricts the search result to listing market histories with a custom stock condition. Available values are &#39;stockNetLessEqualZero&#39;, &#39;stockNetLessZero&#39;, &#39;stockNetGreaterZero&#39;, &#39;stockGrossLessEqualZero&#39;, &#39;stockGrossLessZero&#39;, &#39;stockGrossGreaterZero&#39;, &#39;stockNetTotalLessEqualZero&#39;, &#39;stockNetTotalLessZero&#39;, &#39;stockNetTotalGreaterZero&#39; (optional)
     * @param  string|null $updated_at_from Filter that restricts the search result to listing market histories that were last updated on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $updated_at_to Filter that restricts the search result to listing market histories that were last updated within a specified period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $text_data Filter that restricts the search result to listing market histories that match given text in listing title or description. (optional)
     * @param  string|null $first_platform_category_id Filter that restricts the search result to listing market histories with first platform category ID equal to the given ID. (optional)
     * @param  string|null $second_platform_category_id Filter that restricts the search result to listing market histories with second platform category ID equal to the given ID. (optional)
     * @param  string|null $first_shop_category_id Filter that restricts the search result to listing market histories with first shop category ID equal to the given ID. (optional)
     * @param  string|null $second_shop_category_id Filter that restricts the search result to listing market histories with second shop category ID equal to the given ID. (optional)
     * @param  string|null $third_shop_category_id Filter that restricts the search result to listing market histories with third shop category ID equal to the given ID. (optional)
     * @param  string|null $shipping_profile_id Filter that restricts the search result to listing market histories that belong to a given shipping profile. (optional)
     * @param  string|null $last_sale Filter that restricts the search result to listing market histories with last sale before given date.The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $is_ebay_plus Filter that restricts the search result to listing market histories that belong to eBay Plus. (optional)
     * @param  string|null $is_click_and_collect Filter that restricts the search result to listing market histories that belong to eBay Click &amp; Collect. (optional)
     * @param  int|null $with An array with child instances to be loaded. Valid instances are &#39;listingMarket&#39;, &#39;texts&#39;, &#39;properties&#39;, &#39;prices&#39;, &#39;dates&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsHistoriesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsMarketsHistoriesGetAsyncWithHttpInfo(
        $page = null,
        $items_per_page = null,
        $listing_market_id = null,
        $variation_id = null,
        $variations = null,
        $referrer_id = null,
        $credentials_id = null,
        $directory_id = null,
        $verified = null,
        $duration = null,
        $external_id = null,
        $listing_id = null,
        $item_id = null,
        $listing_type_id = null,
        $stock_dependence_type_id = null,
        $status_id = null,
        $stock_condition = null,
        $updated_at_from = null,
        $updated_at_to = null,
        $text_data = null,
        $first_platform_category_id = null,
        $second_platform_category_id = null,
        $first_shop_category_id = null,
        $second_shop_category_id = null,
        $third_shop_category_id = null,
        $shipping_profile_id = null,
        $last_sale = null,
        $is_ebay_plus = null,
        $is_click_and_collect = null,
        $with = null,
        string $contentType = self::contentTypes['restListingsMarketsHistoriesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestListingsMarketsHistoriesGet200Response';
        $request = $this->restListingsMarketsHistoriesGetRequest($page, $items_per_page, $listing_market_id, $variation_id, $variations, $referrer_id, $credentials_id, $directory_id, $verified, $duration, $external_id, $listing_id, $item_id, $listing_type_id, $stock_dependence_type_id, $status_id, $stock_condition, $updated_at_from, $updated_at_to, $text_data, $first_platform_category_id, $second_platform_category_id, $first_shop_category_id, $second_shop_category_id, $third_shop_category_id, $shipping_profile_id, $last_sale, $is_ebay_plus, $is_click_and_collect, $with, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsHistoriesGet'
     *
     * @param  int|null $page The page of results to search for. (optional)
     * @param  int|null $items_per_page The number of items to list per page. (optional)
     * @param  int|null $listing_market_id Filter that restricts the search result to listing market histories that match the given listing market ID(s). (optional)
     * @param  int|null $variation_id Filter that restricts the search result to listing market histories that match the given variation ID(s). (optional)
     * @param  string|null $variations Filter that restricts the search result to listing market histories with a custom variation condition. Available values are &#39;all&#39;, &#39;fixed&#39;. (optional)
     * @param  int|null $referrer_id Filter that restricts the search result to listing market histories with given referrer ID. (optional)
     * @param  int|null $credentials_id Filter that restricts the search result to listing market histories with given credential ID. (optional)
     * @param  int|null $directory_id Filter that restricts the search result to listing market histories with a given directory ID. (optional)
     * @param  string|null $verified Filter that restricts the search result to listing market histories that are verified. Available values are &#39;succeeded&#39;,&#39;unknown&#39; or &#39;failed&#39;. (optional)
     * @param  string|null $duration Filter that restricts the search result to listing market histories with given duration. (optional)
     * @param  string|null $external_id Filter that restricts the search result to listing market histories with given external id. (optional)
     * @param  int|null $listing_id Filter that restricts the search result to listing market histories that belong to a given listing ID. (optional)
     * @param  int|null $item_id Filter that restricts the search result to listing market histories that belong to a given item ID. (optional)
     * @param  int|null $listing_type_id Filter that restricts the search result to listing market histories that belong to a listing of a custom type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Auction&lt;/li&gt;     &lt;li&gt;2 - Fixed price&lt;/li&gt;     &lt;li&gt;3 - Shop (only for Hood listings)&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  int|null $stock_dependence_type_id Filter that restricts the search result to listing market histories that belong to a listing with a custom stock dependence type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Unlimited stock with automatic synchronisation&lt;/li&gt;     &lt;li&gt;2 - Limited and reserved stock&lt;/li&gt;     &lt;li&gt;3 - Limited and unreserved stock&lt;/li&gt;     &lt;li&gt;4 - Unlimited stock without automatich synchronisation&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  int|null $status_id Filter that restricts the search result to listing market histories with a custom status status ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Active listing market histories&lt;/li&gt;     &lt;li&gt;2 - Ended listing market histories&lt;/li&gt;     &lt;li&gt;3 - Relisted listing market histories&lt;/li&gt;     &lt;li&gt;4 - Hidden listing market histories&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  string|null $stock_condition Filter that restricts the search result to listing market histories with a custom stock condition. Available values are &#39;stockNetLessEqualZero&#39;, &#39;stockNetLessZero&#39;, &#39;stockNetGreaterZero&#39;, &#39;stockGrossLessEqualZero&#39;, &#39;stockGrossLessZero&#39;, &#39;stockGrossGreaterZero&#39;, &#39;stockNetTotalLessEqualZero&#39;, &#39;stockNetTotalLessZero&#39;, &#39;stockNetTotalGreaterZero&#39; (optional)
     * @param  string|null $updated_at_from Filter that restricts the search result to listing market histories that were last updated on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $updated_at_to Filter that restricts the search result to listing market histories that were last updated within a specified period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $text_data Filter that restricts the search result to listing market histories that match given text in listing title or description. (optional)
     * @param  string|null $first_platform_category_id Filter that restricts the search result to listing market histories with first platform category ID equal to the given ID. (optional)
     * @param  string|null $second_platform_category_id Filter that restricts the search result to listing market histories with second platform category ID equal to the given ID. (optional)
     * @param  string|null $first_shop_category_id Filter that restricts the search result to listing market histories with first shop category ID equal to the given ID. (optional)
     * @param  string|null $second_shop_category_id Filter that restricts the search result to listing market histories with second shop category ID equal to the given ID. (optional)
     * @param  string|null $third_shop_category_id Filter that restricts the search result to listing market histories with third shop category ID equal to the given ID. (optional)
     * @param  string|null $shipping_profile_id Filter that restricts the search result to listing market histories that belong to a given shipping profile. (optional)
     * @param  string|null $last_sale Filter that restricts the search result to listing market histories with last sale before given date.The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $is_ebay_plus Filter that restricts the search result to listing market histories that belong to eBay Plus. (optional)
     * @param  string|null $is_click_and_collect Filter that restricts the search result to listing market histories that belong to eBay Click &amp; Collect. (optional)
     * @param  int|null $with An array with child instances to be loaded. Valid instances are &#39;listingMarket&#39;, &#39;texts&#39;, &#39;properties&#39;, &#39;prices&#39;, &#39;dates&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsHistoriesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restListingsMarketsHistoriesGetRequest(
        $page = null,
        $items_per_page = null,
        $listing_market_id = null,
        $variation_id = null,
        $variations = null,
        $referrer_id = null,
        $credentials_id = null,
        $directory_id = null,
        $verified = null,
        $duration = null,
        $external_id = null,
        $listing_id = null,
        $item_id = null,
        $listing_type_id = null,
        $stock_dependence_type_id = null,
        $status_id = null,
        $stock_condition = null,
        $updated_at_from = null,
        $updated_at_to = null,
        $text_data = null,
        $first_platform_category_id = null,
        $second_platform_category_id = null,
        $first_shop_category_id = null,
        $second_shop_category_id = null,
        $third_shop_category_id = null,
        $shipping_profile_id = null,
        $last_sale = null,
        $is_ebay_plus = null,
        $is_click_and_collect = null,
        $with = null,
        string $contentType = self::contentTypes['restListingsMarketsHistoriesGet'][0]
    ): Request
    {
































        $resourcePath = '/rest/listings/markets/histories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $items_per_page,
            'itemsPerPage', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $listing_market_id,
            'listingMarketId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $variation_id,
            'variationId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $variations,
            'variations', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $referrer_id,
            'referrerId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $credentials_id,
            'credentialsId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $directory_id,
            'directoryId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $verified,
            'verified', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $duration,
            'duration', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $external_id,
            'externalId', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $listing_id,
            'listingId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $item_id,
            'itemId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $listing_type_id,
            'listingTypeId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $stock_dependence_type_id,
            'stockDependenceTypeId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status_id,
            'statusId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $stock_condition,
            'stockCondition', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_at_from,
            'updatedAtFrom', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_at_to,
            'updatedAtTo', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $text_data,
            'textData', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $first_platform_category_id,
            'firstPlatformCategoryId', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $second_platform_category_id,
            'secondPlatformCategoryId', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $first_shop_category_id,
            'firstShopCategoryId', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $second_shop_category_id,
            'secondShopCategoryId', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $third_shop_category_id,
            'thirdShopCategoryId', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $shipping_profile_id,
            'shippingProfileId', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_sale,
            'lastSale', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_ebay_plus,
            'isEbayPlus', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_click_and_collect,
            'isClickAndCollect', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsHistoriesIdGet
     *
     * Get a listing market history
     *
     * @param  int $id The ID of the listing market history entry. (required)
     * @param  int|null $with An array with child instances to be loaded. One of &#39;listingMarket&#39;, &#39;texts&#39;, &#39;properties&#39;, &#39;dates&#39;, &#39;variations&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsHistoriesIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ListingMarketHistory
     */
    public function restListingsMarketsHistoriesIdGet(
        int $id,
        ?int $with = null,
        string $contentType = self::contentTypes['restListingsMarketsHistoriesIdGet'][0]
    ): \ck\Model\ListingMarketHistory
    {
        list($response) = $this->restListingsMarketsHistoriesIdGetWithHttpInfo($id, $with, $contentType);
        return $response;
    }

    /**
     * Operation restListingsMarketsHistoriesIdGetWithHttpInfo
     *
     * Get a listing market history
     *
     * @param  int $id The ID of the listing market history entry. (required)
     * @param  int|null $with An array with child instances to be loaded. One of &#39;listingMarket&#39;, &#39;texts&#39;, &#39;properties&#39;, &#39;dates&#39;, &#39;variations&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsHistoriesIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ListingMarketHistory, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsHistoriesIdGetWithHttpInfo(
        int $id,
        ?int $with = null,
        string $contentType = self::contentTypes['restListingsMarketsHistoriesIdGet'][0]
    ): array
    {
        $request = $this->restListingsMarketsHistoriesIdGetRequest($id, $with, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ListingMarketHistory' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ListingMarketHistory' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ListingMarketHistory', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ListingMarketHistory';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ListingMarketHistory',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsHistoriesIdGetAsync
     *
     * Get a listing market history
     *
     * @param  int $id The ID of the listing market history entry. (required)
     * @param  int|null $with An array with child instances to be loaded. One of &#39;listingMarket&#39;, &#39;texts&#39;, &#39;properties&#39;, &#39;dates&#39;, &#39;variations&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsHistoriesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsMarketsHistoriesIdGetAsync(
        int $id,
        ?int $with = null,
        string $contentType = self::contentTypes['restListingsMarketsHistoriesIdGet'][0]
    ): PromiseInterface
    {
        return $this->restListingsMarketsHistoriesIdGetAsyncWithHttpInfo($id, $with, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsHistoriesIdGetAsyncWithHttpInfo
     *
     * Get a listing market history
     *
     * @param  int $id The ID of the listing market history entry. (required)
     * @param  int|null $with An array with child instances to be loaded. One of &#39;listingMarket&#39;, &#39;texts&#39;, &#39;properties&#39;, &#39;dates&#39;, &#39;variations&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsHistoriesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsMarketsHistoriesIdGetAsyncWithHttpInfo(
        $id,
        $with = null,
        string $contentType = self::contentTypes['restListingsMarketsHistoriesIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ListingMarketHistory';
        $request = $this->restListingsMarketsHistoriesIdGetRequest($id, $with, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsHistoriesIdGet'
     *
     * @param  int $id The ID of the listing market history entry. (required)
     * @param  int|null $with An array with child instances to be loaded. One of &#39;listingMarket&#39;, &#39;texts&#39;, &#39;properties&#39;, &#39;dates&#39;, &#39;variations&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsHistoriesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restListingsMarketsHistoriesIdGetRequest(
        $id,
        $with = null,
        string $contentType = self::contentTypes['restListingsMarketsHistoriesIdGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsMarketsHistoriesIdGet'
            );
        }



        $resourcePath = '/rest/listings/markets/histories/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsIdDelete
     *
     * Delete listing market
     *
     * @param  int $id The listing market ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restListingsMarketsIdDelete(
        int $id,
        string $contentType = self::contentTypes['restListingsMarketsIdDelete'][0]
    ): object
    {
        list($response) = $this->restListingsMarketsIdDeleteWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation restListingsMarketsIdDeleteWithHttpInfo
     *
     * Delete listing market
     *
     * @param  int $id The listing market ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsIdDeleteWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restListingsMarketsIdDelete'][0]
    ): array
    {
        $request = $this->restListingsMarketsIdDeleteRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsIdDeleteAsync
     *
     * Delete listing market
     *
     * @param  int $id The listing market ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsMarketsIdDeleteAsync(
        int $id,
        string $contentType = self::contentTypes['restListingsMarketsIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restListingsMarketsIdDeleteAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsIdDeleteAsyncWithHttpInfo
     *
     * Delete listing market
     *
     * @param  int $id The listing market ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsMarketsIdDeleteAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restListingsMarketsIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restListingsMarketsIdDeleteRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsIdDelete'
     *
     * @param  int $id The listing market ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restListingsMarketsIdDeleteRequest(
        $id,
        string $contentType = self::contentTypes['restListingsMarketsIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsMarketsIdDelete'
            );
        }


        $resourcePath = '/rest/listings/markets/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsIdGet
     *
     * Get a listing market
     *
     * @param  int $id The ID of the listing market entry. (required)
     * @param  int|null $with An array with child instances to be loaded. One of &#39;listing&#39;, &#39;texts&#39;, &#39;properties&#39;, &#39;itemSpecifics&#39;, &#39;prices&#39;, &#39;dates&#39;, &#39;infos&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ListingMarket
     */
    public function restListingsMarketsIdGet(
        int $id,
        ?int $with = null,
        string $contentType = self::contentTypes['restListingsMarketsIdGet'][0]
    ): \ck\Model\ListingMarket
    {
        list($response) = $this->restListingsMarketsIdGetWithHttpInfo($id, $with, $contentType);
        return $response;
    }

    /**
     * Operation restListingsMarketsIdGetWithHttpInfo
     *
     * Get a listing market
     *
     * @param  int $id The ID of the listing market entry. (required)
     * @param  int|null $with An array with child instances to be loaded. One of &#39;listing&#39;, &#39;texts&#39;, &#39;properties&#39;, &#39;itemSpecifics&#39;, &#39;prices&#39;, &#39;dates&#39;, &#39;infos&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ListingMarket, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsIdGetWithHttpInfo(
        int $id,
        ?int $with = null,
        string $contentType = self::contentTypes['restListingsMarketsIdGet'][0]
    ): array
    {
        $request = $this->restListingsMarketsIdGetRequest($id, $with, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ListingMarket' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ListingMarket' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ListingMarket', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ListingMarket';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ListingMarket',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsIdGetAsync
     *
     * Get a listing market
     *
     * @param  int $id The ID of the listing market entry. (required)
     * @param  int|null $with An array with child instances to be loaded. One of &#39;listing&#39;, &#39;texts&#39;, &#39;properties&#39;, &#39;itemSpecifics&#39;, &#39;prices&#39;, &#39;dates&#39;, &#39;infos&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsMarketsIdGetAsync(
        int $id,
        ?int $with = null,
        string $contentType = self::contentTypes['restListingsMarketsIdGet'][0]
    ): PromiseInterface
    {
        return $this->restListingsMarketsIdGetAsyncWithHttpInfo($id, $with, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsIdGetAsyncWithHttpInfo
     *
     * Get a listing market
     *
     * @param  int $id The ID of the listing market entry. (required)
     * @param  int|null $with An array with child instances to be loaded. One of &#39;listing&#39;, &#39;texts&#39;, &#39;properties&#39;, &#39;itemSpecifics&#39;, &#39;prices&#39;, &#39;dates&#39;, &#39;infos&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsMarketsIdGetAsyncWithHttpInfo(
        $id,
        $with = null,
        string $contentType = self::contentTypes['restListingsMarketsIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ListingMarket';
        $request = $this->restListingsMarketsIdGetRequest($id, $with, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsIdGet'
     *
     * @param  int $id The ID of the listing market entry. (required)
     * @param  int|null $with An array with child instances to be loaded. One of &#39;listing&#39;, &#39;texts&#39;, &#39;properties&#39;, &#39;itemSpecifics&#39;, &#39;prices&#39;, &#39;dates&#39;, &#39;infos&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restListingsMarketsIdGetRequest(
        $id,
        $with = null,
        string $contentType = self::contentTypes['restListingsMarketsIdGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsMarketsIdGet'
            );
        }



        $resourcePath = '/rest/listings/markets/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsIdPut
     *
     * Update a listing market
     *
     * @param  int $id The listing market ID. (required)
     * @param  int $referrer_id The referrer ID. (required)
     * @param  \ck\Model\RestListingsMarketsIdPutRequest|null $_rest_listings_markets_id _rest_listings_markets_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ListingMarket
     */
    public function restListingsMarketsIdPut(
        int $id,
        int $referrer_id,
        ?\ck\Model\RestListingsMarketsIdPutRequest $_rest_listings_markets_id = null,
        string $contentType = self::contentTypes['restListingsMarketsIdPut'][0]
    ): \ck\Model\ListingMarket
    {
        list($response) = $this->restListingsMarketsIdPutWithHttpInfo($id, $referrer_id, $_rest_listings_markets_id, $contentType);
        return $response;
    }

    /**
     * Operation restListingsMarketsIdPutWithHttpInfo
     *
     * Update a listing market
     *
     * @param  int $id The listing market ID. (required)
     * @param  int $referrer_id The referrer ID. (required)
     * @param  \ck\Model\RestListingsMarketsIdPutRequest|null $_rest_listings_markets_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ListingMarket, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsIdPutWithHttpInfo(
        int $id,
        int $referrer_id,
        ?\ck\Model\RestListingsMarketsIdPutRequest $_rest_listings_markets_id = null,
        string $contentType = self::contentTypes['restListingsMarketsIdPut'][0]
    ): array
    {
        $request = $this->restListingsMarketsIdPutRequest($id, $referrer_id, $_rest_listings_markets_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ListingMarket' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ListingMarket' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ListingMarket', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ListingMarket';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ListingMarket',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsIdPutAsync
     *
     * Update a listing market
     *
     * @param  int $id The listing market ID. (required)
     * @param  int $referrer_id The referrer ID. (required)
     * @param  \ck\Model\RestListingsMarketsIdPutRequest|null $_rest_listings_markets_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsMarketsIdPutAsync(
        int $id,
        int $referrer_id,
        ?\ck\Model\RestListingsMarketsIdPutRequest $_rest_listings_markets_id = null,
        string $contentType = self::contentTypes['restListingsMarketsIdPut'][0]
    ): PromiseInterface
    {
        return $this->restListingsMarketsIdPutAsyncWithHttpInfo($id, $referrer_id, $_rest_listings_markets_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsIdPutAsyncWithHttpInfo
     *
     * Update a listing market
     *
     * @param  int $id The listing market ID. (required)
     * @param  int $referrer_id The referrer ID. (required)
     * @param  \ck\Model\RestListingsMarketsIdPutRequest|null $_rest_listings_markets_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsMarketsIdPutAsyncWithHttpInfo(
        $id,
        $referrer_id,
        $_rest_listings_markets_id = null,
        string $contentType = self::contentTypes['restListingsMarketsIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ListingMarket';
        $request = $this->restListingsMarketsIdPutRequest($id, $referrer_id, $_rest_listings_markets_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsIdPut'
     *
     * @param  int $id The listing market ID. (required)
     * @param  int $referrer_id The referrer ID. (required)
     * @param  \ck\Model\RestListingsMarketsIdPutRequest|null $_rest_listings_markets_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restListingsMarketsIdPutRequest(
        $id,
        $referrer_id,
        $_rest_listings_markets_id = null,
        string $contentType = self::contentTypes['restListingsMarketsIdPut'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsMarketsIdPut'
            );
        }

        // verify the required parameter 'referrer_id' is set
        if ($referrer_id === null || (is_array($referrer_id) && count($referrer_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $referrer_id when calling restListingsMarketsIdPut'
            );
        }



        $resourcePath = '/rest/listings/markets/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $referrer_id,
            'referrerId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_listings_markets_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_listings_markets_id));
            } else {
                $httpBody = $_rest_listings_markets_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsInfosGet
     *
     * Search listing market info
     *
     * @param  int|null $page The page of results to search for. (optional)
     * @param  int|null $items_per_page The number of items to list per page. (optional)
     * @param  int|null $id Filter that restricts the search result to listing market info that match the given ID(s). (optional)
     * @param  int|null $listing_market_id Filter that restricts the search result to listing market info that match the given listing market ID(s). (optional)
     * @param  string|null $type Filter that restricts the search result to listing market info with a custom type. Available values are &#39;warning&#39;, &#39;error&#39;, &#39;info&#39;. (optional)
     * @param  int|null $code Filter that restricts the search result to listing market info with given codes. (optional)
     * @param  string|null $created_at_from Filter that restricts the search result to listing markets that were last updated on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $created_at_to Filter that restricts the search result to listing markets that were last updated within a specified period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  int|null $with An array with child instances to be loaded. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsInfosGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestListingsMarketsInfosGet200Response
     */
    public function restListingsMarketsInfosGet(
        ?int $page = null,
        ?int $items_per_page = null,
        ?int $id = null,
        ?int $listing_market_id = null,
        ?string $type = null,
        ?int $code = null,
        ?string $created_at_from = null,
        ?string $created_at_to = null,
        ?int $with = null,
        string $contentType = self::contentTypes['restListingsMarketsInfosGet'][0]
    ): \ck\Model\RestListingsMarketsInfosGet200Response
    {
        list($response) = $this->restListingsMarketsInfosGetWithHttpInfo($page, $items_per_page, $id, $listing_market_id, $type, $code, $created_at_from, $created_at_to, $with, $contentType);
        return $response;
    }

    /**
     * Operation restListingsMarketsInfosGetWithHttpInfo
     *
     * Search listing market info
     *
     * @param  int|null $page The page of results to search for. (optional)
     * @param  int|null $items_per_page The number of items to list per page. (optional)
     * @param  int|null $id Filter that restricts the search result to listing market info that match the given ID(s). (optional)
     * @param  int|null $listing_market_id Filter that restricts the search result to listing market info that match the given listing market ID(s). (optional)
     * @param  string|null $type Filter that restricts the search result to listing market info with a custom type. Available values are &#39;warning&#39;, &#39;error&#39;, &#39;info&#39;. (optional)
     * @param  int|null $code Filter that restricts the search result to listing market info with given codes. (optional)
     * @param  string|null $created_at_from Filter that restricts the search result to listing markets that were last updated on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $created_at_to Filter that restricts the search result to listing markets that were last updated within a specified period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  int|null $with An array with child instances to be loaded. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsInfosGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestListingsMarketsInfosGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsInfosGetWithHttpInfo(
        ?int $page = null,
        ?int $items_per_page = null,
        ?int $id = null,
        ?int $listing_market_id = null,
        ?string $type = null,
        ?int $code = null,
        ?string $created_at_from = null,
        ?string $created_at_to = null,
        ?int $with = null,
        string $contentType = self::contentTypes['restListingsMarketsInfosGet'][0]
    ): array
    {
        $request = $this->restListingsMarketsInfosGetRequest($page, $items_per_page, $id, $listing_market_id, $type, $code, $created_at_from, $created_at_to, $with, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestListingsMarketsInfosGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestListingsMarketsInfosGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestListingsMarketsInfosGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestListingsMarketsInfosGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestListingsMarketsInfosGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsInfosGetAsync
     *
     * Search listing market info
     *
     * @param  int|null $page The page of results to search for. (optional)
     * @param  int|null $items_per_page The number of items to list per page. (optional)
     * @param  int|null $id Filter that restricts the search result to listing market info that match the given ID(s). (optional)
     * @param  int|null $listing_market_id Filter that restricts the search result to listing market info that match the given listing market ID(s). (optional)
     * @param  string|null $type Filter that restricts the search result to listing market info with a custom type. Available values are &#39;warning&#39;, &#39;error&#39;, &#39;info&#39;. (optional)
     * @param  int|null $code Filter that restricts the search result to listing market info with given codes. (optional)
     * @param  string|null $created_at_from Filter that restricts the search result to listing markets that were last updated on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $created_at_to Filter that restricts the search result to listing markets that were last updated within a specified period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  int|null $with An array with child instances to be loaded. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsInfosGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsMarketsInfosGetAsync(
        ?int $page = null,
        ?int $items_per_page = null,
        ?int $id = null,
        ?int $listing_market_id = null,
        ?string $type = null,
        ?int $code = null,
        ?string $created_at_from = null,
        ?string $created_at_to = null,
        ?int $with = null,
        string $contentType = self::contentTypes['restListingsMarketsInfosGet'][0]
    ): PromiseInterface
    {
        return $this->restListingsMarketsInfosGetAsyncWithHttpInfo($page, $items_per_page, $id, $listing_market_id, $type, $code, $created_at_from, $created_at_to, $with, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsInfosGetAsyncWithHttpInfo
     *
     * Search listing market info
     *
     * @param  int|null $page The page of results to search for. (optional)
     * @param  int|null $items_per_page The number of items to list per page. (optional)
     * @param  int|null $id Filter that restricts the search result to listing market info that match the given ID(s). (optional)
     * @param  int|null $listing_market_id Filter that restricts the search result to listing market info that match the given listing market ID(s). (optional)
     * @param  string|null $type Filter that restricts the search result to listing market info with a custom type. Available values are &#39;warning&#39;, &#39;error&#39;, &#39;info&#39;. (optional)
     * @param  int|null $code Filter that restricts the search result to listing market info with given codes. (optional)
     * @param  string|null $created_at_from Filter that restricts the search result to listing markets that were last updated on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $created_at_to Filter that restricts the search result to listing markets that were last updated within a specified period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  int|null $with An array with child instances to be loaded. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsInfosGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsMarketsInfosGetAsyncWithHttpInfo(
        $page = null,
        $items_per_page = null,
        $id = null,
        $listing_market_id = null,
        $type = null,
        $code = null,
        $created_at_from = null,
        $created_at_to = null,
        $with = null,
        string $contentType = self::contentTypes['restListingsMarketsInfosGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestListingsMarketsInfosGet200Response';
        $request = $this->restListingsMarketsInfosGetRequest($page, $items_per_page, $id, $listing_market_id, $type, $code, $created_at_from, $created_at_to, $with, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsInfosGet'
     *
     * @param  int|null $page The page of results to search for. (optional)
     * @param  int|null $items_per_page The number of items to list per page. (optional)
     * @param  int|null $id Filter that restricts the search result to listing market info that match the given ID(s). (optional)
     * @param  int|null $listing_market_id Filter that restricts the search result to listing market info that match the given listing market ID(s). (optional)
     * @param  string|null $type Filter that restricts the search result to listing market info with a custom type. Available values are &#39;warning&#39;, &#39;error&#39;, &#39;info&#39;. (optional)
     * @param  int|null $code Filter that restricts the search result to listing market info with given codes. (optional)
     * @param  string|null $created_at_from Filter that restricts the search result to listing markets that were last updated on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $created_at_to Filter that restricts the search result to listing markets that were last updated within a specified period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  int|null $with An array with child instances to be loaded. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsInfosGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restListingsMarketsInfosGetRequest(
        $page = null,
        $items_per_page = null,
        $id = null,
        $listing_market_id = null,
        $type = null,
        $code = null,
        $created_at_from = null,
        $created_at_to = null,
        $with = null,
        string $contentType = self::contentTypes['restListingsMarketsInfosGet'][0]
    ): Request
    {











        $resourcePath = '/rest/listings/markets/infos';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $items_per_page,
            'itemsPerPage', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $listing_market_id,
            'listingMarketId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $code,
            'code', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_at_from,
            'createdAtFrom', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_at_to,
            'createdAtTo', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsItemSpecificsFindGet
     *
     * Gets all ListingMarketItemSpecifics.
     *
     * @param  \ck\Model\RestListingsMarketsItemSpecificsGetRequest|null $_rest_listings_markets_item_specifics_find _rest_listings_markets_item_specifics_find (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsItemSpecificsFindGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestListingsMarketsItemSpecificsFindGet200Response
     */
    public function restListingsMarketsItemSpecificsFindGet(
        ?\ck\Model\RestListingsMarketsItemSpecificsGetRequest $_rest_listings_markets_item_specifics_find = null,
        string $contentType = self::contentTypes['restListingsMarketsItemSpecificsFindGet'][0]
    ): \ck\Model\RestListingsMarketsItemSpecificsFindGet200Response
    {
        list($response) = $this->restListingsMarketsItemSpecificsFindGetWithHttpInfo($_rest_listings_markets_item_specifics_find, $contentType);
        return $response;
    }

    /**
     * Operation restListingsMarketsItemSpecificsFindGetWithHttpInfo
     *
     * Gets all ListingMarketItemSpecifics.
     *
     * @param  \ck\Model\RestListingsMarketsItemSpecificsGetRequest|null $_rest_listings_markets_item_specifics_find (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsItemSpecificsFindGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestListingsMarketsItemSpecificsFindGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsItemSpecificsFindGetWithHttpInfo(
        ?\ck\Model\RestListingsMarketsItemSpecificsGetRequest $_rest_listings_markets_item_specifics_find = null,
        string $contentType = self::contentTypes['restListingsMarketsItemSpecificsFindGet'][0]
    ): array
    {
        $request = $this->restListingsMarketsItemSpecificsFindGetRequest($_rest_listings_markets_item_specifics_find, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestListingsMarketsItemSpecificsFindGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestListingsMarketsItemSpecificsFindGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestListingsMarketsItemSpecificsFindGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestListingsMarketsItemSpecificsFindGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestListingsMarketsItemSpecificsFindGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsItemSpecificsFindGetAsync
     *
     * Gets all ListingMarketItemSpecifics.
     *
     * @param  \ck\Model\RestListingsMarketsItemSpecificsGetRequest|null $_rest_listings_markets_item_specifics_find (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsItemSpecificsFindGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsMarketsItemSpecificsFindGetAsync(
        ?\ck\Model\RestListingsMarketsItemSpecificsGetRequest $_rest_listings_markets_item_specifics_find = null,
        string $contentType = self::contentTypes['restListingsMarketsItemSpecificsFindGet'][0]
    ): PromiseInterface
    {
        return $this->restListingsMarketsItemSpecificsFindGetAsyncWithHttpInfo($_rest_listings_markets_item_specifics_find, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsItemSpecificsFindGetAsyncWithHttpInfo
     *
     * Gets all ListingMarketItemSpecifics.
     *
     * @param  \ck\Model\RestListingsMarketsItemSpecificsGetRequest|null $_rest_listings_markets_item_specifics_find (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsItemSpecificsFindGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsMarketsItemSpecificsFindGetAsyncWithHttpInfo(
        $_rest_listings_markets_item_specifics_find = null,
        string $contentType = self::contentTypes['restListingsMarketsItemSpecificsFindGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestListingsMarketsItemSpecificsFindGet200Response';
        $request = $this->restListingsMarketsItemSpecificsFindGetRequest($_rest_listings_markets_item_specifics_find, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsItemSpecificsFindGet'
     *
     * @param  \ck\Model\RestListingsMarketsItemSpecificsGetRequest|null $_rest_listings_markets_item_specifics_find (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsItemSpecificsFindGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restListingsMarketsItemSpecificsFindGetRequest(
        $_rest_listings_markets_item_specifics_find = null,
        string $contentType = self::contentTypes['restListingsMarketsItemSpecificsFindGet'][0]
    ): Request
    {



        $resourcePath = '/rest/listings/markets/item_specifics/find';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_listings_markets_item_specifics_find)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_listings_markets_item_specifics_find));
            } else {
                $httpBody = $_rest_listings_markets_item_specifics_find;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsItemSpecificsGet
     *
     * Gets all ListingMarketItemSpecifics.
     *
     * @param  \ck\Model\RestListingsMarketsItemSpecificsGetRequest|null $_rest_listings_markets_item_specifics _rest_listings_markets_item_specifics (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsItemSpecificsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ListingMarketItemSpecific
     */
    public function restListingsMarketsItemSpecificsGet(
        ?\ck\Model\RestListingsMarketsItemSpecificsGetRequest $_rest_listings_markets_item_specifics = null,
        string $contentType = self::contentTypes['restListingsMarketsItemSpecificsGet'][0]
    ): \ck\Model\ListingMarketItemSpecific
    {
        list($response) = $this->restListingsMarketsItemSpecificsGetWithHttpInfo($_rest_listings_markets_item_specifics, $contentType);
        return $response;
    }

    /**
     * Operation restListingsMarketsItemSpecificsGetWithHttpInfo
     *
     * Gets all ListingMarketItemSpecifics.
     *
     * @param  \ck\Model\RestListingsMarketsItemSpecificsGetRequest|null $_rest_listings_markets_item_specifics (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsItemSpecificsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ListingMarketItemSpecific, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsItemSpecificsGetWithHttpInfo(
        ?\ck\Model\RestListingsMarketsItemSpecificsGetRequest $_rest_listings_markets_item_specifics = null,
        string $contentType = self::contentTypes['restListingsMarketsItemSpecificsGet'][0]
    ): array
    {
        $request = $this->restListingsMarketsItemSpecificsGetRequest($_rest_listings_markets_item_specifics, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ListingMarketItemSpecific' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ListingMarketItemSpecific' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ListingMarketItemSpecific', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ListingMarketItemSpecific';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ListingMarketItemSpecific',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsItemSpecificsGetAsync
     *
     * Gets all ListingMarketItemSpecifics.
     *
     * @param  \ck\Model\RestListingsMarketsItemSpecificsGetRequest|null $_rest_listings_markets_item_specifics (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsItemSpecificsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsMarketsItemSpecificsGetAsync(
        ?\ck\Model\RestListingsMarketsItemSpecificsGetRequest $_rest_listings_markets_item_specifics = null,
        string $contentType = self::contentTypes['restListingsMarketsItemSpecificsGet'][0]
    ): PromiseInterface
    {
        return $this->restListingsMarketsItemSpecificsGetAsyncWithHttpInfo($_rest_listings_markets_item_specifics, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsItemSpecificsGetAsyncWithHttpInfo
     *
     * Gets all ListingMarketItemSpecifics.
     *
     * @param  \ck\Model\RestListingsMarketsItemSpecificsGetRequest|null $_rest_listings_markets_item_specifics (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsItemSpecificsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsMarketsItemSpecificsGetAsyncWithHttpInfo(
        $_rest_listings_markets_item_specifics = null,
        string $contentType = self::contentTypes['restListingsMarketsItemSpecificsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ListingMarketItemSpecific';
        $request = $this->restListingsMarketsItemSpecificsGetRequest($_rest_listings_markets_item_specifics, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsItemSpecificsGet'
     *
     * @param  \ck\Model\RestListingsMarketsItemSpecificsGetRequest|null $_rest_listings_markets_item_specifics (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsItemSpecificsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restListingsMarketsItemSpecificsGetRequest(
        $_rest_listings_markets_item_specifics = null,
        string $contentType = self::contentTypes['restListingsMarketsItemSpecificsGet'][0]
    ): Request
    {



        $resourcePath = '/rest/listings/markets/item_specifics';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_listings_markets_item_specifics)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_listings_markets_item_specifics));
            } else {
                $httpBody = $_rest_listings_markets_item_specifics;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsItemSpecificsIdDelete
     *
     * Deletes a ListingMarketItemSpecific.
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsItemSpecificsIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restListingsMarketsItemSpecificsIdDelete(
        int $id,
        string $contentType = self::contentTypes['restListingsMarketsItemSpecificsIdDelete'][0]
    ): object
    {
        list($response) = $this->restListingsMarketsItemSpecificsIdDeleteWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation restListingsMarketsItemSpecificsIdDeleteWithHttpInfo
     *
     * Deletes a ListingMarketItemSpecific.
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsItemSpecificsIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsItemSpecificsIdDeleteWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restListingsMarketsItemSpecificsIdDelete'][0]
    ): array
    {
        $request = $this->restListingsMarketsItemSpecificsIdDeleteRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsItemSpecificsIdDeleteAsync
     *
     * Deletes a ListingMarketItemSpecific.
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsItemSpecificsIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsMarketsItemSpecificsIdDeleteAsync(
        int $id,
        string $contentType = self::contentTypes['restListingsMarketsItemSpecificsIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restListingsMarketsItemSpecificsIdDeleteAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsItemSpecificsIdDeleteAsyncWithHttpInfo
     *
     * Deletes a ListingMarketItemSpecific.
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsItemSpecificsIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsMarketsItemSpecificsIdDeleteAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restListingsMarketsItemSpecificsIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restListingsMarketsItemSpecificsIdDeleteRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsItemSpecificsIdDelete'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsItemSpecificsIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restListingsMarketsItemSpecificsIdDeleteRequest(
        $id,
        string $contentType = self::contentTypes['restListingsMarketsItemSpecificsIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsMarketsItemSpecificsIdDelete'
            );
        }


        $resourcePath = '/rest/listings/markets/item_specifics/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsItemSpecificsIdGet
     *
     * Gets a ListingMarketItemSpecific.
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsItemSpecificsIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ListingMarketItemSpecific
     */
    public function restListingsMarketsItemSpecificsIdGet(
        int $id,
        string $contentType = self::contentTypes['restListingsMarketsItemSpecificsIdGet'][0]
    ): \ck\Model\ListingMarketItemSpecific
    {
        list($response) = $this->restListingsMarketsItemSpecificsIdGetWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation restListingsMarketsItemSpecificsIdGetWithHttpInfo
     *
     * Gets a ListingMarketItemSpecific.
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsItemSpecificsIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ListingMarketItemSpecific, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsItemSpecificsIdGetWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restListingsMarketsItemSpecificsIdGet'][0]
    ): array
    {
        $request = $this->restListingsMarketsItemSpecificsIdGetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ListingMarketItemSpecific' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ListingMarketItemSpecific' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ListingMarketItemSpecific', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ListingMarketItemSpecific';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ListingMarketItemSpecific',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsItemSpecificsIdGetAsync
     *
     * Gets a ListingMarketItemSpecific.
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsItemSpecificsIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsMarketsItemSpecificsIdGetAsync(
        int $id,
        string $contentType = self::contentTypes['restListingsMarketsItemSpecificsIdGet'][0]
    ): PromiseInterface
    {
        return $this->restListingsMarketsItemSpecificsIdGetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsItemSpecificsIdGetAsyncWithHttpInfo
     *
     * Gets a ListingMarketItemSpecific.
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsItemSpecificsIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsMarketsItemSpecificsIdGetAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restListingsMarketsItemSpecificsIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ListingMarketItemSpecific';
        $request = $this->restListingsMarketsItemSpecificsIdGetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsItemSpecificsIdGet'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsItemSpecificsIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restListingsMarketsItemSpecificsIdGetRequest(
        $id,
        string $contentType = self::contentTypes['restListingsMarketsItemSpecificsIdGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsMarketsItemSpecificsIdGet'
            );
        }


        $resourcePath = '/rest/listings/markets/item_specifics/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsItemSpecificsIdPut
     *
     * Updates a ListingMarketItemSpecific.
     *
     * @param  int $id id (required)
     * @param  \ck\Model\RestListingsMarketsItemSpecificsIdPutRequest|null $_rest_listings_markets_item_specifics_id _rest_listings_markets_item_specifics_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsItemSpecificsIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ListingMarketItemSpecific
     */
    public function restListingsMarketsItemSpecificsIdPut(
        int $id,
        ?\ck\Model\RestListingsMarketsItemSpecificsIdPutRequest $_rest_listings_markets_item_specifics_id = null,
        string $contentType = self::contentTypes['restListingsMarketsItemSpecificsIdPut'][0]
    ): \ck\Model\ListingMarketItemSpecific
    {
        list($response) = $this->restListingsMarketsItemSpecificsIdPutWithHttpInfo($id, $_rest_listings_markets_item_specifics_id, $contentType);
        return $response;
    }

    /**
     * Operation restListingsMarketsItemSpecificsIdPutWithHttpInfo
     *
     * Updates a ListingMarketItemSpecific.
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestListingsMarketsItemSpecificsIdPutRequest|null $_rest_listings_markets_item_specifics_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsItemSpecificsIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ListingMarketItemSpecific, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsItemSpecificsIdPutWithHttpInfo(
        int $id,
        ?\ck\Model\RestListingsMarketsItemSpecificsIdPutRequest $_rest_listings_markets_item_specifics_id = null,
        string $contentType = self::contentTypes['restListingsMarketsItemSpecificsIdPut'][0]
    ): array
    {
        $request = $this->restListingsMarketsItemSpecificsIdPutRequest($id, $_rest_listings_markets_item_specifics_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ListingMarketItemSpecific' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ListingMarketItemSpecific' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ListingMarketItemSpecific', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ListingMarketItemSpecific';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ListingMarketItemSpecific',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsItemSpecificsIdPutAsync
     *
     * Updates a ListingMarketItemSpecific.
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestListingsMarketsItemSpecificsIdPutRequest|null $_rest_listings_markets_item_specifics_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsItemSpecificsIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsMarketsItemSpecificsIdPutAsync(
        int $id,
        ?\ck\Model\RestListingsMarketsItemSpecificsIdPutRequest $_rest_listings_markets_item_specifics_id = null,
        string $contentType = self::contentTypes['restListingsMarketsItemSpecificsIdPut'][0]
    ): PromiseInterface
    {
        return $this->restListingsMarketsItemSpecificsIdPutAsyncWithHttpInfo($id, $_rest_listings_markets_item_specifics_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsItemSpecificsIdPutAsyncWithHttpInfo
     *
     * Updates a ListingMarketItemSpecific.
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestListingsMarketsItemSpecificsIdPutRequest|null $_rest_listings_markets_item_specifics_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsItemSpecificsIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsMarketsItemSpecificsIdPutAsyncWithHttpInfo(
        $id,
        $_rest_listings_markets_item_specifics_id = null,
        string $contentType = self::contentTypes['restListingsMarketsItemSpecificsIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ListingMarketItemSpecific';
        $request = $this->restListingsMarketsItemSpecificsIdPutRequest($id, $_rest_listings_markets_item_specifics_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsItemSpecificsIdPut'
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestListingsMarketsItemSpecificsIdPutRequest|null $_rest_listings_markets_item_specifics_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsItemSpecificsIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restListingsMarketsItemSpecificsIdPutRequest(
        $id,
        $_rest_listings_markets_item_specifics_id = null,
        string $contentType = self::contentTypes['restListingsMarketsItemSpecificsIdPut'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsMarketsItemSpecificsIdPut'
            );
        }



        $resourcePath = '/rest/listings/markets/item_specifics/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_listings_markets_item_specifics_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_listings_markets_item_specifics_id));
            } else {
                $httpBody = $_rest_listings_markets_item_specifics_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsPost
     *
     * Create new listing market
     *
     * @param  \ck\Model\RestListingsMarketsPostRequest|null $_rest_listings_markets _rest_listings_markets (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ListingMarket[]
     */
    public function restListingsMarketsPost(
        ?\ck\Model\RestListingsMarketsPostRequest $_rest_listings_markets = null,
        string $contentType = self::contentTypes['restListingsMarketsPost'][0]
    ): array
    {
        list($response) = $this->restListingsMarketsPostWithHttpInfo($_rest_listings_markets, $contentType);
        return $response;
    }

    /**
     * Operation restListingsMarketsPostWithHttpInfo
     *
     * Create new listing market
     *
     * @param  \ck\Model\RestListingsMarketsPostRequest|null $_rest_listings_markets (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ListingMarket[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsPostWithHttpInfo(
        ?\ck\Model\RestListingsMarketsPostRequest $_rest_listings_markets = null,
        string $contentType = self::contentTypes['restListingsMarketsPost'][0]
    ): array
    {
        $request = $this->restListingsMarketsPostRequest($_rest_listings_markets, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ListingMarket[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ListingMarket[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ListingMarket[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ListingMarket[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ListingMarket[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsPostAsync
     *
     * Create new listing market
     *
     * @param  \ck\Model\RestListingsMarketsPostRequest|null $_rest_listings_markets (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsMarketsPostAsync(
        ?\ck\Model\RestListingsMarketsPostRequest $_rest_listings_markets = null,
        string $contentType = self::contentTypes['restListingsMarketsPost'][0]
    ): PromiseInterface
    {
        return $this->restListingsMarketsPostAsyncWithHttpInfo($_rest_listings_markets, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsPostAsyncWithHttpInfo
     *
     * Create new listing market
     *
     * @param  \ck\Model\RestListingsMarketsPostRequest|null $_rest_listings_markets (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsMarketsPostAsyncWithHttpInfo(
        $_rest_listings_markets = null,
        string $contentType = self::contentTypes['restListingsMarketsPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ListingMarket[]';
        $request = $this->restListingsMarketsPostRequest($_rest_listings_markets, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsPost'
     *
     * @param  \ck\Model\RestListingsMarketsPostRequest|null $_rest_listings_markets (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restListingsMarketsPostRequest(
        $_rest_listings_markets = null,
        string $contentType = self::contentTypes['restListingsMarketsPost'][0]
    ): Request
    {



        $resourcePath = '/rest/listings/markets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_listings_markets)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_listings_markets));
            } else {
                $httpBody = $_rest_listings_markets;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsTextsGet
     *
     * List listing market texts
     *
     * @param  int|null $id Filter that restricts the search result to listing market texts with specific ID. Several IDs can be entered as array. (optional)
     * @param  int|null $listing_market_id Filter that restricts the search result to listing market texts with specific listing market IDs. Several IDs can be entered as array. (optional)
     * @param  string|null $language Filter that restricts the search result to listing market texts for a specific language. @see listing market text model language for the complete available list of language types. (optional)
     * @param  string|null $contains Filter that restricts the search result to listing market texts which title, subtitle or description contain the given value. (optional)
     * @param  int|null $page The page of results to search for. (optional)
     * @param  int|null $items_per_page The number of items to list per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsTextsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestListingsMarketsTextsGet200Response
     */
    public function restListingsMarketsTextsGet(
        ?int $id = null,
        ?int $listing_market_id = null,
        ?string $language = null,
        ?string $contains = null,
        ?int $page = null,
        ?int $items_per_page = null,
        string $contentType = self::contentTypes['restListingsMarketsTextsGet'][0]
    ): \ck\Model\RestListingsMarketsTextsGet200Response
    {
        list($response) = $this->restListingsMarketsTextsGetWithHttpInfo($id, $listing_market_id, $language, $contains, $page, $items_per_page, $contentType);
        return $response;
    }

    /**
     * Operation restListingsMarketsTextsGetWithHttpInfo
     *
     * List listing market texts
     *
     * @param  int|null $id Filter that restricts the search result to listing market texts with specific ID. Several IDs can be entered as array. (optional)
     * @param  int|null $listing_market_id Filter that restricts the search result to listing market texts with specific listing market IDs. Several IDs can be entered as array. (optional)
     * @param  string|null $language Filter that restricts the search result to listing market texts for a specific language. @see listing market text model language for the complete available list of language types. (optional)
     * @param  string|null $contains Filter that restricts the search result to listing market texts which title, subtitle or description contain the given value. (optional)
     * @param  int|null $page The page of results to search for. (optional)
     * @param  int|null $items_per_page The number of items to list per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsTextsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestListingsMarketsTextsGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsTextsGetWithHttpInfo(
        ?int $id = null,
        ?int $listing_market_id = null,
        ?string $language = null,
        ?string $contains = null,
        ?int $page = null,
        ?int $items_per_page = null,
        string $contentType = self::contentTypes['restListingsMarketsTextsGet'][0]
    ): array
    {
        $request = $this->restListingsMarketsTextsGetRequest($id, $listing_market_id, $language, $contains, $page, $items_per_page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestListingsMarketsTextsGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestListingsMarketsTextsGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestListingsMarketsTextsGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestListingsMarketsTextsGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestListingsMarketsTextsGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsTextsGetAsync
     *
     * List listing market texts
     *
     * @param  int|null $id Filter that restricts the search result to listing market texts with specific ID. Several IDs can be entered as array. (optional)
     * @param  int|null $listing_market_id Filter that restricts the search result to listing market texts with specific listing market IDs. Several IDs can be entered as array. (optional)
     * @param  string|null $language Filter that restricts the search result to listing market texts for a specific language. @see listing market text model language for the complete available list of language types. (optional)
     * @param  string|null $contains Filter that restricts the search result to listing market texts which title, subtitle or description contain the given value. (optional)
     * @param  int|null $page The page of results to search for. (optional)
     * @param  int|null $items_per_page The number of items to list per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsTextsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsMarketsTextsGetAsync(
        ?int $id = null,
        ?int $listing_market_id = null,
        ?string $language = null,
        ?string $contains = null,
        ?int $page = null,
        ?int $items_per_page = null,
        string $contentType = self::contentTypes['restListingsMarketsTextsGet'][0]
    ): PromiseInterface
    {
        return $this->restListingsMarketsTextsGetAsyncWithHttpInfo($id, $listing_market_id, $language, $contains, $page, $items_per_page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsTextsGetAsyncWithHttpInfo
     *
     * List listing market texts
     *
     * @param  int|null $id Filter that restricts the search result to listing market texts with specific ID. Several IDs can be entered as array. (optional)
     * @param  int|null $listing_market_id Filter that restricts the search result to listing market texts with specific listing market IDs. Several IDs can be entered as array. (optional)
     * @param  string|null $language Filter that restricts the search result to listing market texts for a specific language. @see listing market text model language for the complete available list of language types. (optional)
     * @param  string|null $contains Filter that restricts the search result to listing market texts which title, subtitle or description contain the given value. (optional)
     * @param  int|null $page The page of results to search for. (optional)
     * @param  int|null $items_per_page The number of items to list per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsTextsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsMarketsTextsGetAsyncWithHttpInfo(
        $id = null,
        $listing_market_id = null,
        $language = null,
        $contains = null,
        $page = null,
        $items_per_page = null,
        string $contentType = self::contentTypes['restListingsMarketsTextsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestListingsMarketsTextsGet200Response';
        $request = $this->restListingsMarketsTextsGetRequest($id, $listing_market_id, $language, $contains, $page, $items_per_page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsTextsGet'
     *
     * @param  int|null $id Filter that restricts the search result to listing market texts with specific ID. Several IDs can be entered as array. (optional)
     * @param  int|null $listing_market_id Filter that restricts the search result to listing market texts with specific listing market IDs. Several IDs can be entered as array. (optional)
     * @param  string|null $language Filter that restricts the search result to listing market texts for a specific language. @see listing market text model language for the complete available list of language types. (optional)
     * @param  string|null $contains Filter that restricts the search result to listing market texts which title, subtitle or description contain the given value. (optional)
     * @param  int|null $page The page of results to search for. (optional)
     * @param  int|null $items_per_page The number of items to list per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsTextsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restListingsMarketsTextsGetRequest(
        $id = null,
        $listing_market_id = null,
        $language = null,
        $contains = null,
        $page = null,
        $items_per_page = null,
        string $contentType = self::contentTypes['restListingsMarketsTextsGet'][0]
    ): Request
    {








        $resourcePath = '/rest/listings/markets/texts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $listing_market_id,
            'listingMarketId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $language,
            'language', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $contains,
            'contains', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $items_per_page,
            'itemsPerPage', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsTextsIdDelete
     *
     * Delete a listing market text
     *
     * @param  string $lang The listing market text language that should be updated. (required)
     * @param  int $listing_market_id The listing market ID this text belongs to. (required)
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsTextsIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restListingsMarketsTextsIdDelete(
        string $lang,
        int $listing_market_id,
        int $id,
        string $contentType = self::contentTypes['restListingsMarketsTextsIdDelete'][0]
    ): object
    {
        list($response) = $this->restListingsMarketsTextsIdDeleteWithHttpInfo($lang, $listing_market_id, $id, $contentType);
        return $response;
    }

    /**
     * Operation restListingsMarketsTextsIdDeleteWithHttpInfo
     *
     * Delete a listing market text
     *
     * @param  string $lang The listing market text language that should be updated. (required)
     * @param  int $listing_market_id The listing market ID this text belongs to. (required)
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsTextsIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsTextsIdDeleteWithHttpInfo(
        string $lang,
        int $listing_market_id,
        int $id,
        string $contentType = self::contentTypes['restListingsMarketsTextsIdDelete'][0]
    ): array
    {
        $request = $this->restListingsMarketsTextsIdDeleteRequest($lang, $listing_market_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsTextsIdDeleteAsync
     *
     * Delete a listing market text
     *
     * @param  string $lang The listing market text language that should be updated. (required)
     * @param  int $listing_market_id The listing market ID this text belongs to. (required)
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsTextsIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsMarketsTextsIdDeleteAsync(
        string $lang,
        int $listing_market_id,
        int $id,
        string $contentType = self::contentTypes['restListingsMarketsTextsIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restListingsMarketsTextsIdDeleteAsyncWithHttpInfo($lang, $listing_market_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsTextsIdDeleteAsyncWithHttpInfo
     *
     * Delete a listing market text
     *
     * @param  string $lang The listing market text language that should be updated. (required)
     * @param  int $listing_market_id The listing market ID this text belongs to. (required)
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsTextsIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsMarketsTextsIdDeleteAsyncWithHttpInfo(
        $lang,
        $listing_market_id,
        $id,
        string $contentType = self::contentTypes['restListingsMarketsTextsIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restListingsMarketsTextsIdDeleteRequest($lang, $listing_market_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsTextsIdDelete'
     *
     * @param  string $lang The listing market text language that should be updated. (required)
     * @param  int $listing_market_id The listing market ID this text belongs to. (required)
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsTextsIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restListingsMarketsTextsIdDeleteRequest(
        $lang,
        $listing_market_id,
        $id,
        string $contentType = self::contentTypes['restListingsMarketsTextsIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $lang when calling restListingsMarketsTextsIdDelete'
            );
        }

        // verify the required parameter 'listing_market_id' is set
        if ($listing_market_id === null || (is_array($listing_market_id) && count($listing_market_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $listing_market_id when calling restListingsMarketsTextsIdDelete'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsMarketsTextsIdDelete'
            );
        }


        $resourcePath = '/rest/listings/markets/texts/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $lang,
            'lang', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $listing_market_id,
            'listingMarketId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsTextsIdGet
     *
     * Get a listing market text
     *
     * @param  int $id The ID of the listing market text entry. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsTextsIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ListingMarketText
     */
    public function restListingsMarketsTextsIdGet(
        int $id,
        string $contentType = self::contentTypes['restListingsMarketsTextsIdGet'][0]
    ): \ck\Model\ListingMarketText
    {
        list($response) = $this->restListingsMarketsTextsIdGetWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation restListingsMarketsTextsIdGetWithHttpInfo
     *
     * Get a listing market text
     *
     * @param  int $id The ID of the listing market text entry. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsTextsIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ListingMarketText, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsTextsIdGetWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restListingsMarketsTextsIdGet'][0]
    ): array
    {
        $request = $this->restListingsMarketsTextsIdGetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ListingMarketText' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ListingMarketText' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ListingMarketText', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ListingMarketText';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ListingMarketText',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsTextsIdGetAsync
     *
     * Get a listing market text
     *
     * @param  int $id The ID of the listing market text entry. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsTextsIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsMarketsTextsIdGetAsync(
        int $id,
        string $contentType = self::contentTypes['restListingsMarketsTextsIdGet'][0]
    ): PromiseInterface
    {
        return $this->restListingsMarketsTextsIdGetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsTextsIdGetAsyncWithHttpInfo
     *
     * Get a listing market text
     *
     * @param  int $id The ID of the listing market text entry. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsTextsIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsMarketsTextsIdGetAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restListingsMarketsTextsIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ListingMarketText';
        $request = $this->restListingsMarketsTextsIdGetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsTextsIdGet'
     *
     * @param  int $id The ID of the listing market text entry. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsTextsIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restListingsMarketsTextsIdGetRequest(
        $id,
        string $contentType = self::contentTypes['restListingsMarketsTextsIdGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsMarketsTextsIdGet'
            );
        }


        $resourcePath = '/rest/listings/markets/texts/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsTextsListingMarketIdLangPut
     *
     * Update a listing market text
     *
     * @param  int $listing_market_id The listing market ID this text belongs to. (required)
     * @param  string $lang The listing market text language that should be updated. (required)
     * @param  \ck\Model\RestListingsMarketsTextsListingMarketIdLangPutRequest|null $_rest_listings_markets_texts_listing_market_id_lang _rest_listings_markets_texts_listing_market_id_lang (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsTextsListingMarketIdLangPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ListingMarketText
     */
    public function restListingsMarketsTextsListingMarketIdLangPut(
        int $listing_market_id,
        string $lang,
        ?\ck\Model\RestListingsMarketsTextsListingMarketIdLangPutRequest $_rest_listings_markets_texts_listing_market_id_lang = null,
        string $contentType = self::contentTypes['restListingsMarketsTextsListingMarketIdLangPut'][0]
    ): \ck\Model\ListingMarketText
    {
        list($response) = $this->restListingsMarketsTextsListingMarketIdLangPutWithHttpInfo($listing_market_id, $lang, $_rest_listings_markets_texts_listing_market_id_lang, $contentType);
        return $response;
    }

    /**
     * Operation restListingsMarketsTextsListingMarketIdLangPutWithHttpInfo
     *
     * Update a listing market text
     *
     * @param  int $listing_market_id The listing market ID this text belongs to. (required)
     * @param  string $lang The listing market text language that should be updated. (required)
     * @param  \ck\Model\RestListingsMarketsTextsListingMarketIdLangPutRequest|null $_rest_listings_markets_texts_listing_market_id_lang (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsTextsListingMarketIdLangPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ListingMarketText, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsTextsListingMarketIdLangPutWithHttpInfo(
        int $listing_market_id,
        string $lang,
        ?\ck\Model\RestListingsMarketsTextsListingMarketIdLangPutRequest $_rest_listings_markets_texts_listing_market_id_lang = null,
        string $contentType = self::contentTypes['restListingsMarketsTextsListingMarketIdLangPut'][0]
    ): array
    {
        $request = $this->restListingsMarketsTextsListingMarketIdLangPutRequest($listing_market_id, $lang, $_rest_listings_markets_texts_listing_market_id_lang, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ListingMarketText' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ListingMarketText' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ListingMarketText', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ListingMarketText';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ListingMarketText',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsTextsListingMarketIdLangPutAsync
     *
     * Update a listing market text
     *
     * @param  int $listing_market_id The listing market ID this text belongs to. (required)
     * @param  string $lang The listing market text language that should be updated. (required)
     * @param  \ck\Model\RestListingsMarketsTextsListingMarketIdLangPutRequest|null $_rest_listings_markets_texts_listing_market_id_lang (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsTextsListingMarketIdLangPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsMarketsTextsListingMarketIdLangPutAsync(
        int $listing_market_id,
        string $lang,
        ?\ck\Model\RestListingsMarketsTextsListingMarketIdLangPutRequest $_rest_listings_markets_texts_listing_market_id_lang = null,
        string $contentType = self::contentTypes['restListingsMarketsTextsListingMarketIdLangPut'][0]
    ): PromiseInterface
    {
        return $this->restListingsMarketsTextsListingMarketIdLangPutAsyncWithHttpInfo($listing_market_id, $lang, $_rest_listings_markets_texts_listing_market_id_lang, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsTextsListingMarketIdLangPutAsyncWithHttpInfo
     *
     * Update a listing market text
     *
     * @param  int $listing_market_id The listing market ID this text belongs to. (required)
     * @param  string $lang The listing market text language that should be updated. (required)
     * @param  \ck\Model\RestListingsMarketsTextsListingMarketIdLangPutRequest|null $_rest_listings_markets_texts_listing_market_id_lang (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsTextsListingMarketIdLangPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsMarketsTextsListingMarketIdLangPutAsyncWithHttpInfo(
        $listing_market_id,
        $lang,
        $_rest_listings_markets_texts_listing_market_id_lang = null,
        string $contentType = self::contentTypes['restListingsMarketsTextsListingMarketIdLangPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ListingMarketText';
        $request = $this->restListingsMarketsTextsListingMarketIdLangPutRequest($listing_market_id, $lang, $_rest_listings_markets_texts_listing_market_id_lang, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsTextsListingMarketIdLangPut'
     *
     * @param  int $listing_market_id The listing market ID this text belongs to. (required)
     * @param  string $lang The listing market text language that should be updated. (required)
     * @param  \ck\Model\RestListingsMarketsTextsListingMarketIdLangPutRequest|null $_rest_listings_markets_texts_listing_market_id_lang (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsTextsListingMarketIdLangPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restListingsMarketsTextsListingMarketIdLangPutRequest(
        $listing_market_id,
        $lang,
        $_rest_listings_markets_texts_listing_market_id_lang = null,
        string $contentType = self::contentTypes['restListingsMarketsTextsListingMarketIdLangPut'][0]
    ): Request
    {

        // verify the required parameter 'listing_market_id' is set
        if ($listing_market_id === null || (is_array($listing_market_id) && count($listing_market_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $listing_market_id when calling restListingsMarketsTextsListingMarketIdLangPut'
            );
        }

        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $lang when calling restListingsMarketsTextsListingMarketIdLangPut'
            );
        }



        $resourcePath = '/rest/listings/markets/texts/{listingMarketId}/{lang}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($listing_market_id !== null) {
            $resourcePath = str_replace(
                '{' . 'listingMarketId' . '}',
                ObjectSerializer::toPathValue($listing_market_id),
                $resourcePath
            );
        }
        // path params
        if ($lang !== null) {
            $resourcePath = str_replace(
                '{' . 'lang' . '}',
                ObjectSerializer::toPathValue($lang),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_listings_markets_texts_listing_market_id_lang)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_listings_markets_texts_listing_market_id_lang));
            } else {
                $httpBody = $_rest_listings_markets_texts_listing_market_id_lang;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsTextsPost
     *
     * Create a listing market text
     *
     * @param  int $listing_market_id The listing market ID this text belongs to. (required)
     * @param  \ck\Model\RestListingsMarketsTextsPostRequest|null $_rest_listings_markets_texts _rest_listings_markets_texts (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsTextsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ListingMarketText
     */
    public function restListingsMarketsTextsPost(
        int $listing_market_id,
        ?\ck\Model\RestListingsMarketsTextsPostRequest $_rest_listings_markets_texts = null,
        string $contentType = self::contentTypes['restListingsMarketsTextsPost'][0]
    ): \ck\Model\ListingMarketText
    {
        list($response) = $this->restListingsMarketsTextsPostWithHttpInfo($listing_market_id, $_rest_listings_markets_texts, $contentType);
        return $response;
    }

    /**
     * Operation restListingsMarketsTextsPostWithHttpInfo
     *
     * Create a listing market text
     *
     * @param  int $listing_market_id The listing market ID this text belongs to. (required)
     * @param  \ck\Model\RestListingsMarketsTextsPostRequest|null $_rest_listings_markets_texts (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsTextsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ListingMarketText, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsTextsPostWithHttpInfo(
        int $listing_market_id,
        ?\ck\Model\RestListingsMarketsTextsPostRequest $_rest_listings_markets_texts = null,
        string $contentType = self::contentTypes['restListingsMarketsTextsPost'][0]
    ): array
    {
        $request = $this->restListingsMarketsTextsPostRequest($listing_market_id, $_rest_listings_markets_texts, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ListingMarketText' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ListingMarketText' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ListingMarketText', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ListingMarketText';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ListingMarketText',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsTextsPostAsync
     *
     * Create a listing market text
     *
     * @param  int $listing_market_id The listing market ID this text belongs to. (required)
     * @param  \ck\Model\RestListingsMarketsTextsPostRequest|null $_rest_listings_markets_texts (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsTextsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsMarketsTextsPostAsync(
        int $listing_market_id,
        ?\ck\Model\RestListingsMarketsTextsPostRequest $_rest_listings_markets_texts = null,
        string $contentType = self::contentTypes['restListingsMarketsTextsPost'][0]
    ): PromiseInterface
    {
        return $this->restListingsMarketsTextsPostAsyncWithHttpInfo($listing_market_id, $_rest_listings_markets_texts, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsTextsPostAsyncWithHttpInfo
     *
     * Create a listing market text
     *
     * @param  int $listing_market_id The listing market ID this text belongs to. (required)
     * @param  \ck\Model\RestListingsMarketsTextsPostRequest|null $_rest_listings_markets_texts (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsTextsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsMarketsTextsPostAsyncWithHttpInfo(
        $listing_market_id,
        $_rest_listings_markets_texts = null,
        string $contentType = self::contentTypes['restListingsMarketsTextsPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ListingMarketText';
        $request = $this->restListingsMarketsTextsPostRequest($listing_market_id, $_rest_listings_markets_texts, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsTextsPost'
     *
     * @param  int $listing_market_id The listing market ID this text belongs to. (required)
     * @param  \ck\Model\RestListingsMarketsTextsPostRequest|null $_rest_listings_markets_texts (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsMarketsTextsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restListingsMarketsTextsPostRequest(
        $listing_market_id,
        $_rest_listings_markets_texts = null,
        string $contentType = self::contentTypes['restListingsMarketsTextsPost'][0]
    ): Request
    {

        // verify the required parameter 'listing_market_id' is set
        if ($listing_market_id === null || (is_array($listing_market_id) && count($listing_market_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $listing_market_id when calling restListingsMarketsTextsPost'
            );
        }



        $resourcePath = '/rest/listings/markets/texts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $listing_market_id,
            'listingMarketId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_listings_markets_texts)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_listings_markets_texts));
            } else {
                $httpBody = $_rest_listings_markets_texts;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsOptionTemplatesIdDelete
     *
     * Delete option template
     *
     * @param  int $id The option template ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsOptionTemplatesIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restListingsOptionTemplatesIdDelete(
        int $id,
        string $contentType = self::contentTypes['restListingsOptionTemplatesIdDelete'][0]
    ): object
    {
        list($response) = $this->restListingsOptionTemplatesIdDeleteWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation restListingsOptionTemplatesIdDeleteWithHttpInfo
     *
     * Delete option template
     *
     * @param  int $id The option template ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsOptionTemplatesIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsOptionTemplatesIdDeleteWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restListingsOptionTemplatesIdDelete'][0]
    ): array
    {
        $request = $this->restListingsOptionTemplatesIdDeleteRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsOptionTemplatesIdDeleteAsync
     *
     * Delete option template
     *
     * @param  int $id The option template ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsOptionTemplatesIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsOptionTemplatesIdDeleteAsync(
        int $id,
        string $contentType = self::contentTypes['restListingsOptionTemplatesIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restListingsOptionTemplatesIdDeleteAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsOptionTemplatesIdDeleteAsyncWithHttpInfo
     *
     * Delete option template
     *
     * @param  int $id The option template ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsOptionTemplatesIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsOptionTemplatesIdDeleteAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restListingsOptionTemplatesIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restListingsOptionTemplatesIdDeleteRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsOptionTemplatesIdDelete'
     *
     * @param  int $id The option template ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsOptionTemplatesIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restListingsOptionTemplatesIdDeleteRequest(
        $id,
        string $contentType = self::contentTypes['restListingsOptionTemplatesIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsOptionTemplatesIdDelete'
            );
        }


        $resourcePath = '/rest/listings/option_templates/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsOptionTemplatesIdGet
     *
     * Get option template
     *
     * @param  int $id The ID of the option template entry. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsOptionTemplatesIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\OptionTemplate
     */
    public function restListingsOptionTemplatesIdGet(
        int $id,
        string $contentType = self::contentTypes['restListingsOptionTemplatesIdGet'][0]
    ): \ck\Model\OptionTemplate
    {
        list($response) = $this->restListingsOptionTemplatesIdGetWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation restListingsOptionTemplatesIdGetWithHttpInfo
     *
     * Get option template
     *
     * @param  int $id The ID of the option template entry. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsOptionTemplatesIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\OptionTemplate, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsOptionTemplatesIdGetWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restListingsOptionTemplatesIdGet'][0]
    ): array
    {
        $request = $this->restListingsOptionTemplatesIdGetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\OptionTemplate' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\OptionTemplate' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\OptionTemplate', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\OptionTemplate';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\OptionTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsOptionTemplatesIdGetAsync
     *
     * Get option template
     *
     * @param  int $id The ID of the option template entry. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsOptionTemplatesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsOptionTemplatesIdGetAsync(
        int $id,
        string $contentType = self::contentTypes['restListingsOptionTemplatesIdGet'][0]
    ): PromiseInterface
    {
        return $this->restListingsOptionTemplatesIdGetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsOptionTemplatesIdGetAsyncWithHttpInfo
     *
     * Get option template
     *
     * @param  int $id The ID of the option template entry. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsOptionTemplatesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsOptionTemplatesIdGetAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restListingsOptionTemplatesIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\OptionTemplate';
        $request = $this->restListingsOptionTemplatesIdGetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsOptionTemplatesIdGet'
     *
     * @param  int $id The ID of the option template entry. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsOptionTemplatesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restListingsOptionTemplatesIdGetRequest(
        $id,
        string $contentType = self::contentTypes['restListingsOptionTemplatesIdGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsOptionTemplatesIdGet'
            );
        }


        $resourcePath = '/rest/listings/option_templates/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsOptionTemplatesIdPut
     *
     * Update option template
     *
     * @param  int $id The option template ID. (required)
     * @param  \ck\Model\RestListingsOptionTemplatesIdPutRequest|null $_rest_listings_option_templates_id _rest_listings_option_templates_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsOptionTemplatesIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\OptionTemplate
     */
    public function restListingsOptionTemplatesIdPut(
        int $id,
        ?\ck\Model\RestListingsOptionTemplatesIdPutRequest $_rest_listings_option_templates_id = null,
        string $contentType = self::contentTypes['restListingsOptionTemplatesIdPut'][0]
    ): \ck\Model\OptionTemplate
    {
        list($response) = $this->restListingsOptionTemplatesIdPutWithHttpInfo($id, $_rest_listings_option_templates_id, $contentType);
        return $response;
    }

    /**
     * Operation restListingsOptionTemplatesIdPutWithHttpInfo
     *
     * Update option template
     *
     * @param  int $id The option template ID. (required)
     * @param  \ck\Model\RestListingsOptionTemplatesIdPutRequest|null $_rest_listings_option_templates_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsOptionTemplatesIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\OptionTemplate, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsOptionTemplatesIdPutWithHttpInfo(
        int $id,
        ?\ck\Model\RestListingsOptionTemplatesIdPutRequest $_rest_listings_option_templates_id = null,
        string $contentType = self::contentTypes['restListingsOptionTemplatesIdPut'][0]
    ): array
    {
        $request = $this->restListingsOptionTemplatesIdPutRequest($id, $_rest_listings_option_templates_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\OptionTemplate' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\OptionTemplate' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\OptionTemplate', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\OptionTemplate';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\OptionTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsOptionTemplatesIdPutAsync
     *
     * Update option template
     *
     * @param  int $id The option template ID. (required)
     * @param  \ck\Model\RestListingsOptionTemplatesIdPutRequest|null $_rest_listings_option_templates_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsOptionTemplatesIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsOptionTemplatesIdPutAsync(
        int $id,
        ?\ck\Model\RestListingsOptionTemplatesIdPutRequest $_rest_listings_option_templates_id = null,
        string $contentType = self::contentTypes['restListingsOptionTemplatesIdPut'][0]
    ): PromiseInterface
    {
        return $this->restListingsOptionTemplatesIdPutAsyncWithHttpInfo($id, $_rest_listings_option_templates_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsOptionTemplatesIdPutAsyncWithHttpInfo
     *
     * Update option template
     *
     * @param  int $id The option template ID. (required)
     * @param  \ck\Model\RestListingsOptionTemplatesIdPutRequest|null $_rest_listings_option_templates_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsOptionTemplatesIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsOptionTemplatesIdPutAsyncWithHttpInfo(
        $id,
        $_rest_listings_option_templates_id = null,
        string $contentType = self::contentTypes['restListingsOptionTemplatesIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\OptionTemplate';
        $request = $this->restListingsOptionTemplatesIdPutRequest($id, $_rest_listings_option_templates_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsOptionTemplatesIdPut'
     *
     * @param  int $id The option template ID. (required)
     * @param  \ck\Model\RestListingsOptionTemplatesIdPutRequest|null $_rest_listings_option_templates_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsOptionTemplatesIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restListingsOptionTemplatesIdPutRequest(
        $id,
        $_rest_listings_option_templates_id = null,
        string $contentType = self::contentTypes['restListingsOptionTemplatesIdPut'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsOptionTemplatesIdPut'
            );
        }



        $resourcePath = '/rest/listings/option_templates/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_listings_option_templates_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_listings_option_templates_id));
            } else {
                $httpBody = $_rest_listings_option_templates_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsOptionTemplatesPost
     *
     * Create option template
     *
     * @param  \ck\Model\RestListingsOptionTemplatesPostRequest|null $_rest_listings_option_templates _rest_listings_option_templates (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsOptionTemplatesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\OptionTemplate
     */
    public function restListingsOptionTemplatesPost(
        ?\ck\Model\RestListingsOptionTemplatesPostRequest $_rest_listings_option_templates = null,
        string $contentType = self::contentTypes['restListingsOptionTemplatesPost'][0]
    ): \ck\Model\OptionTemplate
    {
        list($response) = $this->restListingsOptionTemplatesPostWithHttpInfo($_rest_listings_option_templates, $contentType);
        return $response;
    }

    /**
     * Operation restListingsOptionTemplatesPostWithHttpInfo
     *
     * Create option template
     *
     * @param  \ck\Model\RestListingsOptionTemplatesPostRequest|null $_rest_listings_option_templates (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsOptionTemplatesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\OptionTemplate, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsOptionTemplatesPostWithHttpInfo(
        ?\ck\Model\RestListingsOptionTemplatesPostRequest $_rest_listings_option_templates = null,
        string $contentType = self::contentTypes['restListingsOptionTemplatesPost'][0]
    ): array
    {
        $request = $this->restListingsOptionTemplatesPostRequest($_rest_listings_option_templates, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\OptionTemplate' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\OptionTemplate' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\OptionTemplate', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\OptionTemplate';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\OptionTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsOptionTemplatesPostAsync
     *
     * Create option template
     *
     * @param  \ck\Model\RestListingsOptionTemplatesPostRequest|null $_rest_listings_option_templates (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsOptionTemplatesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsOptionTemplatesPostAsync(
        ?\ck\Model\RestListingsOptionTemplatesPostRequest $_rest_listings_option_templates = null,
        string $contentType = self::contentTypes['restListingsOptionTemplatesPost'][0]
    ): PromiseInterface
    {
        return $this->restListingsOptionTemplatesPostAsyncWithHttpInfo($_rest_listings_option_templates, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsOptionTemplatesPostAsyncWithHttpInfo
     *
     * Create option template
     *
     * @param  \ck\Model\RestListingsOptionTemplatesPostRequest|null $_rest_listings_option_templates (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsOptionTemplatesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsOptionTemplatesPostAsyncWithHttpInfo(
        $_rest_listings_option_templates = null,
        string $contentType = self::contentTypes['restListingsOptionTemplatesPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\OptionTemplate';
        $request = $this->restListingsOptionTemplatesPostRequest($_rest_listings_option_templates, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsOptionTemplatesPost'
     *
     * @param  \ck\Model\RestListingsOptionTemplatesPostRequest|null $_rest_listings_option_templates (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsOptionTemplatesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restListingsOptionTemplatesPostRequest(
        $_rest_listings_option_templates = null,
        string $contentType = self::contentTypes['restListingsOptionTemplatesPost'][0]
    ): Request
    {



        $resourcePath = '/rest/listings/option_templates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_listings_option_templates)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_listings_option_templates));
            } else {
                $httpBody = $_rest_listings_option_templates;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsOptionTemplatesPreviewGet
     *
     * Get a preview list of option templates
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsOptionTemplatesPreviewGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object[]
     */
    public function restListingsOptionTemplatesPreviewGet(
        string $contentType = self::contentTypes['restListingsOptionTemplatesPreviewGet'][0]
    ): array
    {
        list($response) = $this->restListingsOptionTemplatesPreviewGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restListingsOptionTemplatesPreviewGetWithHttpInfo
     *
     * Get a preview list of option templates
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsOptionTemplatesPreviewGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsOptionTemplatesPreviewGetWithHttpInfo(
        string $contentType = self::contentTypes['restListingsOptionTemplatesPreviewGet'][0]
    ): array
    {
        $request = $this->restListingsOptionTemplatesPreviewGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsOptionTemplatesPreviewGetAsync
     *
     * Get a preview list of option templates
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsOptionTemplatesPreviewGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsOptionTemplatesPreviewGetAsync(
        string $contentType = self::contentTypes['restListingsOptionTemplatesPreviewGet'][0]
    ): PromiseInterface
    {
        return $this->restListingsOptionTemplatesPreviewGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsOptionTemplatesPreviewGetAsyncWithHttpInfo
     *
     * Get a preview list of option templates
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsOptionTemplatesPreviewGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsOptionTemplatesPreviewGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restListingsOptionTemplatesPreviewGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object[]';
        $request = $this->restListingsOptionTemplatesPreviewGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsOptionTemplatesPreviewGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsOptionTemplatesPreviewGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restListingsOptionTemplatesPreviewGetRequest(
        string $contentType = self::contentTypes['restListingsOptionTemplatesPreviewGet'][0]
    ): Request
    {


        $resourcePath = '/rest/listings/option_templates/preview';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsPost
     *
     * Create new listing
     *
     * @param  \ck\Model\RestListingsPostRequest|null $_rest_listings _rest_listings (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Listing
     */
    public function restListingsPost(
        ?\ck\Model\RestListingsPostRequest $_rest_listings = null,
        string $contentType = self::contentTypes['restListingsPost'][0]
    ): \ck\Model\Listing
    {
        list($response) = $this->restListingsPostWithHttpInfo($_rest_listings, $contentType);
        return $response;
    }

    /**
     * Operation restListingsPostWithHttpInfo
     *
     * Create new listing
     *
     * @param  \ck\Model\RestListingsPostRequest|null $_rest_listings (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Listing, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsPostWithHttpInfo(
        ?\ck\Model\RestListingsPostRequest $_rest_listings = null,
        string $contentType = self::contentTypes['restListingsPost'][0]
    ): array
    {
        $request = $this->restListingsPostRequest($_rest_listings, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Listing' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Listing' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Listing', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Listing';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Listing',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsPostAsync
     *
     * Create new listing
     *
     * @param  \ck\Model\RestListingsPostRequest|null $_rest_listings (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsPostAsync(
        ?\ck\Model\RestListingsPostRequest $_rest_listings = null,
        string $contentType = self::contentTypes['restListingsPost'][0]
    ): PromiseInterface
    {
        return $this->restListingsPostAsyncWithHttpInfo($_rest_listings, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsPostAsyncWithHttpInfo
     *
     * Create new listing
     *
     * @param  \ck\Model\RestListingsPostRequest|null $_rest_listings (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsPostAsyncWithHttpInfo(
        $_rest_listings = null,
        string $contentType = self::contentTypes['restListingsPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Listing';
        $request = $this->restListingsPostRequest($_rest_listings, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsPost'
     *
     * @param  \ck\Model\RestListingsPostRequest|null $_rest_listings (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restListingsPostRequest(
        $_rest_listings = null,
        string $contentType = self::contentTypes['restListingsPost'][0]
    ): Request
    {



        $resourcePath = '/rest/listings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_listings)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_listings));
            } else {
                $httpBody = $_rest_listings;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsShippingProfilesGet
     *
     * List listing shipping profiles
     *
     * @param  int|null $page The page of results to search for. (optional)
     * @param  int|null $items_per_page The number of items to list per page. (optional)
     * @param  int|null $id Filter that restricts the search result to listing shipping profiles that match the given ID(s). (optional)
     * @param  int|null $referrer_id Filter that restricts the search result to listing shipping profiles with given referrer ID(s). (optional)
     * @param  int|null $credentials_id Filter that restricts the search result to listing shipping profiles with given credential ID(s). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsShippingProfilesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestListingsShippingProfilesGet200Response
     */
    public function restListingsShippingProfilesGet(
        ?int $page = null,
        ?int $items_per_page = null,
        ?int $id = null,
        ?int $referrer_id = null,
        ?int $credentials_id = null,
        string $contentType = self::contentTypes['restListingsShippingProfilesGet'][0]
    ): \ck\Model\RestListingsShippingProfilesGet200Response
    {
        list($response) = $this->restListingsShippingProfilesGetWithHttpInfo($page, $items_per_page, $id, $referrer_id, $credentials_id, $contentType);
        return $response;
    }

    /**
     * Operation restListingsShippingProfilesGetWithHttpInfo
     *
     * List listing shipping profiles
     *
     * @param  int|null $page The page of results to search for. (optional)
     * @param  int|null $items_per_page The number of items to list per page. (optional)
     * @param  int|null $id Filter that restricts the search result to listing shipping profiles that match the given ID(s). (optional)
     * @param  int|null $referrer_id Filter that restricts the search result to listing shipping profiles with given referrer ID(s). (optional)
     * @param  int|null $credentials_id Filter that restricts the search result to listing shipping profiles with given credential ID(s). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsShippingProfilesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestListingsShippingProfilesGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsShippingProfilesGetWithHttpInfo(
        ?int $page = null,
        ?int $items_per_page = null,
        ?int $id = null,
        ?int $referrer_id = null,
        ?int $credentials_id = null,
        string $contentType = self::contentTypes['restListingsShippingProfilesGet'][0]
    ): array
    {
        $request = $this->restListingsShippingProfilesGetRequest($page, $items_per_page, $id, $referrer_id, $credentials_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestListingsShippingProfilesGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestListingsShippingProfilesGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestListingsShippingProfilesGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestListingsShippingProfilesGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestListingsShippingProfilesGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsShippingProfilesGetAsync
     *
     * List listing shipping profiles
     *
     * @param  int|null $page The page of results to search for. (optional)
     * @param  int|null $items_per_page The number of items to list per page. (optional)
     * @param  int|null $id Filter that restricts the search result to listing shipping profiles that match the given ID(s). (optional)
     * @param  int|null $referrer_id Filter that restricts the search result to listing shipping profiles with given referrer ID(s). (optional)
     * @param  int|null $credentials_id Filter that restricts the search result to listing shipping profiles with given credential ID(s). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsShippingProfilesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsShippingProfilesGetAsync(
        ?int $page = null,
        ?int $items_per_page = null,
        ?int $id = null,
        ?int $referrer_id = null,
        ?int $credentials_id = null,
        string $contentType = self::contentTypes['restListingsShippingProfilesGet'][0]
    ): PromiseInterface
    {
        return $this->restListingsShippingProfilesGetAsyncWithHttpInfo($page, $items_per_page, $id, $referrer_id, $credentials_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsShippingProfilesGetAsyncWithHttpInfo
     *
     * List listing shipping profiles
     *
     * @param  int|null $page The page of results to search for. (optional)
     * @param  int|null $items_per_page The number of items to list per page. (optional)
     * @param  int|null $id Filter that restricts the search result to listing shipping profiles that match the given ID(s). (optional)
     * @param  int|null $referrer_id Filter that restricts the search result to listing shipping profiles with given referrer ID(s). (optional)
     * @param  int|null $credentials_id Filter that restricts the search result to listing shipping profiles with given credential ID(s). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsShippingProfilesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsShippingProfilesGetAsyncWithHttpInfo(
        $page = null,
        $items_per_page = null,
        $id = null,
        $referrer_id = null,
        $credentials_id = null,
        string $contentType = self::contentTypes['restListingsShippingProfilesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestListingsShippingProfilesGet200Response';
        $request = $this->restListingsShippingProfilesGetRequest($page, $items_per_page, $id, $referrer_id, $credentials_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsShippingProfilesGet'
     *
     * @param  int|null $page The page of results to search for. (optional)
     * @param  int|null $items_per_page The number of items to list per page. (optional)
     * @param  int|null $id Filter that restricts the search result to listing shipping profiles that match the given ID(s). (optional)
     * @param  int|null $referrer_id Filter that restricts the search result to listing shipping profiles with given referrer ID(s). (optional)
     * @param  int|null $credentials_id Filter that restricts the search result to listing shipping profiles with given credential ID(s). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsShippingProfilesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restListingsShippingProfilesGetRequest(
        $page = null,
        $items_per_page = null,
        $id = null,
        $referrer_id = null,
        $credentials_id = null,
        string $contentType = self::contentTypes['restListingsShippingProfilesGet'][0]
    ): Request
    {







        $resourcePath = '/rest/listings/shipping_profiles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $items_per_page,
            'itemsPerPage', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $referrer_id,
            'referrerId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $credentials_id,
            'credentialsId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsShippingProfilesIdGet
     *
     * Get a shipping profile
     *
     * @param  int $id The ID of the listing shipping profile entry. (required)
     * @param  int|null $with An array with child instances to be loaded. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsShippingProfilesIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ShippingProfile
     */
    public function restListingsShippingProfilesIdGet(
        int $id,
        ?int $with = null,
        string $contentType = self::contentTypes['restListingsShippingProfilesIdGet'][0]
    ): \ck\Model\ShippingProfile
    {
        list($response) = $this->restListingsShippingProfilesIdGetWithHttpInfo($id, $with, $contentType);
        return $response;
    }

    /**
     * Operation restListingsShippingProfilesIdGetWithHttpInfo
     *
     * Get a shipping profile
     *
     * @param  int $id The ID of the listing shipping profile entry. (required)
     * @param  int|null $with An array with child instances to be loaded. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsShippingProfilesIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ShippingProfile, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsShippingProfilesIdGetWithHttpInfo(
        int $id,
        ?int $with = null,
        string $contentType = self::contentTypes['restListingsShippingProfilesIdGet'][0]
    ): array
    {
        $request = $this->restListingsShippingProfilesIdGetRequest($id, $with, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ShippingProfile' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ShippingProfile' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ShippingProfile', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ShippingProfile';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ShippingProfile',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsShippingProfilesIdGetAsync
     *
     * Get a shipping profile
     *
     * @param  int $id The ID of the listing shipping profile entry. (required)
     * @param  int|null $with An array with child instances to be loaded. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsShippingProfilesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsShippingProfilesIdGetAsync(
        int $id,
        ?int $with = null,
        string $contentType = self::contentTypes['restListingsShippingProfilesIdGet'][0]
    ): PromiseInterface
    {
        return $this->restListingsShippingProfilesIdGetAsyncWithHttpInfo($id, $with, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsShippingProfilesIdGetAsyncWithHttpInfo
     *
     * Get a shipping profile
     *
     * @param  int $id The ID of the listing shipping profile entry. (required)
     * @param  int|null $with An array with child instances to be loaded. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsShippingProfilesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsShippingProfilesIdGetAsyncWithHttpInfo(
        $id,
        $with = null,
        string $contentType = self::contentTypes['restListingsShippingProfilesIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ShippingProfile';
        $request = $this->restListingsShippingProfilesIdGetRequest($id, $with, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsShippingProfilesIdGet'
     *
     * @param  int $id The ID of the listing shipping profile entry. (required)
     * @param  int|null $with An array with child instances to be loaded. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsShippingProfilesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restListingsShippingProfilesIdGetRequest(
        $id,
        $with = null,
        string $contentType = self::contentTypes['restListingsShippingProfilesIdGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsShippingProfilesIdGet'
            );
        }



        $resourcePath = '/rest/listings/shipping_profiles/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsStockDependenceTypesGet
     *
     * List listing stock dependence types
     *
     * @param  int|null $page The page of results to search for. (optional)
     * @param  int|null $items_per_page The number of items to list per page. (optional)
     * @param  int|null $with An array with child instances to be loaded. Available values: &#39;names&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsStockDependenceTypesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestListingsStockDependenceTypesGet200Response
     */
    public function restListingsStockDependenceTypesGet(
        ?int $page = null,
        ?int $items_per_page = null,
        ?int $with = null,
        string $contentType = self::contentTypes['restListingsStockDependenceTypesGet'][0]
    ): \ck\Model\RestListingsStockDependenceTypesGet200Response
    {
        list($response) = $this->restListingsStockDependenceTypesGetWithHttpInfo($page, $items_per_page, $with, $contentType);
        return $response;
    }

    /**
     * Operation restListingsStockDependenceTypesGetWithHttpInfo
     *
     * List listing stock dependence types
     *
     * @param  int|null $page The page of results to search for. (optional)
     * @param  int|null $items_per_page The number of items to list per page. (optional)
     * @param  int|null $with An array with child instances to be loaded. Available values: &#39;names&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsStockDependenceTypesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestListingsStockDependenceTypesGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsStockDependenceTypesGetWithHttpInfo(
        ?int $page = null,
        ?int $items_per_page = null,
        ?int $with = null,
        string $contentType = self::contentTypes['restListingsStockDependenceTypesGet'][0]
    ): array
    {
        $request = $this->restListingsStockDependenceTypesGetRequest($page, $items_per_page, $with, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestListingsStockDependenceTypesGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestListingsStockDependenceTypesGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestListingsStockDependenceTypesGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestListingsStockDependenceTypesGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestListingsStockDependenceTypesGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsStockDependenceTypesGetAsync
     *
     * List listing stock dependence types
     *
     * @param  int|null $page The page of results to search for. (optional)
     * @param  int|null $items_per_page The number of items to list per page. (optional)
     * @param  int|null $with An array with child instances to be loaded. Available values: &#39;names&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsStockDependenceTypesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsStockDependenceTypesGetAsync(
        ?int $page = null,
        ?int $items_per_page = null,
        ?int $with = null,
        string $contentType = self::contentTypes['restListingsStockDependenceTypesGet'][0]
    ): PromiseInterface
    {
        return $this->restListingsStockDependenceTypesGetAsyncWithHttpInfo($page, $items_per_page, $with, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsStockDependenceTypesGetAsyncWithHttpInfo
     *
     * List listing stock dependence types
     *
     * @param  int|null $page The page of results to search for. (optional)
     * @param  int|null $items_per_page The number of items to list per page. (optional)
     * @param  int|null $with An array with child instances to be loaded. Available values: &#39;names&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsStockDependenceTypesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsStockDependenceTypesGetAsyncWithHttpInfo(
        $page = null,
        $items_per_page = null,
        $with = null,
        string $contentType = self::contentTypes['restListingsStockDependenceTypesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestListingsStockDependenceTypesGet200Response';
        $request = $this->restListingsStockDependenceTypesGetRequest($page, $items_per_page, $with, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsStockDependenceTypesGet'
     *
     * @param  int|null $page The page of results to search for. (optional)
     * @param  int|null $items_per_page The number of items to list per page. (optional)
     * @param  int|null $with An array with child instances to be loaded. Available values: &#39;names&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsStockDependenceTypesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restListingsStockDependenceTypesGetRequest(
        $page = null,
        $items_per_page = null,
        $with = null,
        string $contentType = self::contentTypes['restListingsStockDependenceTypesGet'][0]
    ): Request
    {





        $resourcePath = '/rest/listings/stock_dependence_types';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $items_per_page,
            'itemsPerPage', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsStockDependenceTypesIdGet
     *
     * Get a listing stock dependence type
     *
     * @param  int $id The ID of the listing stock dependence type entry. (required)
     * @param  int|null $with An array with child instances to be loaded. Available values: &#39;names&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsStockDependenceTypesIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\StockDependenceType
     */
    public function restListingsStockDependenceTypesIdGet(
        int $id,
        ?int $with = null,
        string $contentType = self::contentTypes['restListingsStockDependenceTypesIdGet'][0]
    ): \ck\Model\StockDependenceType
    {
        list($response) = $this->restListingsStockDependenceTypesIdGetWithHttpInfo($id, $with, $contentType);
        return $response;
    }

    /**
     * Operation restListingsStockDependenceTypesIdGetWithHttpInfo
     *
     * Get a listing stock dependence type
     *
     * @param  int $id The ID of the listing stock dependence type entry. (required)
     * @param  int|null $with An array with child instances to be loaded. Available values: &#39;names&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsStockDependenceTypesIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\StockDependenceType, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsStockDependenceTypesIdGetWithHttpInfo(
        int $id,
        ?int $with = null,
        string $contentType = self::contentTypes['restListingsStockDependenceTypesIdGet'][0]
    ): array
    {
        $request = $this->restListingsStockDependenceTypesIdGetRequest($id, $with, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\StockDependenceType' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\StockDependenceType' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\StockDependenceType', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\StockDependenceType';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\StockDependenceType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsStockDependenceTypesIdGetAsync
     *
     * Get a listing stock dependence type
     *
     * @param  int $id The ID of the listing stock dependence type entry. (required)
     * @param  int|null $with An array with child instances to be loaded. Available values: &#39;names&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsStockDependenceTypesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsStockDependenceTypesIdGetAsync(
        int $id,
        ?int $with = null,
        string $contentType = self::contentTypes['restListingsStockDependenceTypesIdGet'][0]
    ): PromiseInterface
    {
        return $this->restListingsStockDependenceTypesIdGetAsyncWithHttpInfo($id, $with, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsStockDependenceTypesIdGetAsyncWithHttpInfo
     *
     * Get a listing stock dependence type
     *
     * @param  int $id The ID of the listing stock dependence type entry. (required)
     * @param  int|null $with An array with child instances to be loaded. Available values: &#39;names&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsStockDependenceTypesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsStockDependenceTypesIdGetAsyncWithHttpInfo(
        $id,
        $with = null,
        string $contentType = self::contentTypes['restListingsStockDependenceTypesIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\StockDependenceType';
        $request = $this->restListingsStockDependenceTypesIdGetRequest($id, $with, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsStockDependenceTypesIdGet'
     *
     * @param  int $id The ID of the listing stock dependence type entry. (required)
     * @param  int|null $with An array with child instances to be loaded. Available values: &#39;names&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsStockDependenceTypesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restListingsStockDependenceTypesIdGetRequest(
        $id,
        $with = null,
        string $contentType = self::contentTypes['restListingsStockDependenceTypesIdGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsStockDependenceTypesIdGet'
            );
        }



        $resourcePath = '/rest/listings/stock_dependence_types/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsTypesGet
     *
     * List listing types
     *
     * @param  int|null $page The page of results to search for. (optional)
     * @param  int|null $items_per_page The number of items to list per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsTypesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestListingsTypesGet200Response
     */
    public function restListingsTypesGet(
        ?int $page = null,
        ?int $items_per_page = null,
        string $contentType = self::contentTypes['restListingsTypesGet'][0]
    ): \ck\Model\RestListingsTypesGet200Response
    {
        list($response) = $this->restListingsTypesGetWithHttpInfo($page, $items_per_page, $contentType);
        return $response;
    }

    /**
     * Operation restListingsTypesGetWithHttpInfo
     *
     * List listing types
     *
     * @param  int|null $page The page of results to search for. (optional)
     * @param  int|null $items_per_page The number of items to list per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsTypesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestListingsTypesGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsTypesGetWithHttpInfo(
        ?int $page = null,
        ?int $items_per_page = null,
        string $contentType = self::contentTypes['restListingsTypesGet'][0]
    ): array
    {
        $request = $this->restListingsTypesGetRequest($page, $items_per_page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestListingsTypesGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestListingsTypesGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestListingsTypesGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestListingsTypesGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestListingsTypesGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsTypesGetAsync
     *
     * List listing types
     *
     * @param  int|null $page The page of results to search for. (optional)
     * @param  int|null $items_per_page The number of items to list per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsTypesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsTypesGetAsync(
        ?int $page = null,
        ?int $items_per_page = null,
        string $contentType = self::contentTypes['restListingsTypesGet'][0]
    ): PromiseInterface
    {
        return $this->restListingsTypesGetAsyncWithHttpInfo($page, $items_per_page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsTypesGetAsyncWithHttpInfo
     *
     * List listing types
     *
     * @param  int|null $page The page of results to search for. (optional)
     * @param  int|null $items_per_page The number of items to list per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsTypesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsTypesGetAsyncWithHttpInfo(
        $page = null,
        $items_per_page = null,
        string $contentType = self::contentTypes['restListingsTypesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestListingsTypesGet200Response';
        $request = $this->restListingsTypesGetRequest($page, $items_per_page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsTypesGet'
     *
     * @param  int|null $page The page of results to search for. (optional)
     * @param  int|null $items_per_page The number of items to list per page. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsTypesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restListingsTypesGetRequest(
        $page = null,
        $items_per_page = null,
        string $contentType = self::contentTypes['restListingsTypesGet'][0]
    ): Request
    {




        $resourcePath = '/rest/listings/types';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $items_per_page,
            'itemsPerPage', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsTypesIdGet
     *
     * Get a listing type
     *
     * @param  int $id The ID of the listing type entry. (required)
     * @param  int|null $with An array with child instances to be loaded. Available values: &#39;names&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsTypesIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ListingType
     */
    public function restListingsTypesIdGet(
        int $id,
        ?int $with = null,
        string $contentType = self::contentTypes['restListingsTypesIdGet'][0]
    ): \ck\Model\ListingType
    {
        list($response) = $this->restListingsTypesIdGetWithHttpInfo($id, $with, $contentType);
        return $response;
    }

    /**
     * Operation restListingsTypesIdGetWithHttpInfo
     *
     * Get a listing type
     *
     * @param  int $id The ID of the listing type entry. (required)
     * @param  int|null $with An array with child instances to be loaded. Available values: &#39;names&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsTypesIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ListingType, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsTypesIdGetWithHttpInfo(
        int $id,
        ?int $with = null,
        string $contentType = self::contentTypes['restListingsTypesIdGet'][0]
    ): array
    {
        $request = $this->restListingsTypesIdGetRequest($id, $with, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ListingType' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ListingType' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ListingType', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ListingType';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ListingType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsTypesIdGetAsync
     *
     * Get a listing type
     *
     * @param  int $id The ID of the listing type entry. (required)
     * @param  int|null $with An array with child instances to be loaded. Available values: &#39;names&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsTypesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsTypesIdGetAsync(
        int $id,
        ?int $with = null,
        string $contentType = self::contentTypes['restListingsTypesIdGet'][0]
    ): PromiseInterface
    {
        return $this->restListingsTypesIdGetAsyncWithHttpInfo($id, $with, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsTypesIdGetAsyncWithHttpInfo
     *
     * Get a listing type
     *
     * @param  int $id The ID of the listing type entry. (required)
     * @param  int|null $with An array with child instances to be loaded. Available values: &#39;names&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsTypesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restListingsTypesIdGetAsyncWithHttpInfo(
        $id,
        $with = null,
        string $contentType = self::contentTypes['restListingsTypesIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ListingType';
        $request = $this->restListingsTypesIdGetRequest($id, $with, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsTypesIdGet'
     *
     * @param  int $id The ID of the listing type entry. (required)
     * @param  int|null $with An array with child instances to be loaded. Available values: &#39;names&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restListingsTypesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restListingsTypesIdGetRequest(
        $id,
        $with = null,
        string $contentType = self::contentTypes['restListingsTypesIdGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsTypesIdGet'
            );
        }



        $resourcePath = '/rest/listings/types/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption(): array
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
