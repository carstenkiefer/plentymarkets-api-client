<?php
/**
 * OrderApi
 * PHP version 8.1
 *
 * @package  ck
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * plentymarkets REST-API
 *
 * The plentymarkets REST API expands the functionality of the plentymarkets CMS and allows access to resources, i.e. data records, via unique URI paths
 *
 * The version of the OpenAPI document: 1.0.0
 * @generated Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 7.1.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace ck\Api;

use InvalidArgumentException;
use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use GuzzleHttp\Promise\PromiseInterface;
use ck\ApiException;
use ck\Configuration;
use ck\HeaderSelector;
use ck\ObjectSerializer;

/**
 * OrderApi Class Doc Comment
 *
 * @package  ck
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class OrderApi
{
    /**
     * @var ClientInterface
     */
    protected ClientInterface $client;

    /**
     * @var Configuration
     */
    protected Configuration $config;

    /**
     * @var HeaderSelector
     */
    protected HeaderSelector $headerSelector;

    /**
     * @var int Host index
     */
    protected int $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'restDeliveryOrdersOrderIdDelete' => [
            'application/json',
        ],
        'restDeliveryOrdersOrderIdPut' => [
            'application/json',
        ],
        'restDeliveryOrdersPost' => [
            'application/json',
        ],
        'restOrdersContactsContactIdGet' => [
            'application/json',
        ],
        'restOrdersContactsContactIdMultiOrderPost' => [
            'application/json',
        ],
        'restOrdersCouponsCampaignsCampaignIdCodesPost' => [
            'application/json',
        ],
        'restOrdersCouponsCampaignsCodesCodeDelete' => [
            'application/json',
        ],
        'restOrdersCouponsCampaignsCodesCodeDisabledIsDisabledPut' => [
            'application/json',
        ],
        'restOrdersCouponsCampaignsCodesCodeGet' => [
            'application/json',
        ],
        'restOrdersCouponsCodesContactsContactIdGet' => [
            'application/json',
        ],
        'restOrdersCouponsCodesCouponPost' => [
            'application/json',
        ],
        'restOrdersCouponsCodesPost' => [
            'application/json',
        ],
        'restOrdersCurrenciesCountriesCountryIdGet' => [
            'application/json',
        ],
        'restOrdersCurrenciesCurrencyIsoCountriesGet' => [
            'application/json',
        ],
        'restOrdersCurrenciesCurrencyIsoExchangeRateGet' => [
            'application/json',
        ],
        'restOrdersCurrenciesCurrencyIsoGet' => [
            'application/json',
        ],
        'restOrdersCurrenciesExchangeRatesFromCurrencyIsoGet' => [
            'application/json',
        ],
        'restOrdersCurrenciesExchangeRatesToCurrencyIsoGet' => [
            'application/json',
        ],
        'restOrdersCurrenciesGet' => [
            'application/json',
        ],
        'restOrdersDatesTypesGet' => [
            'application/json',
        ],
        'restOrdersDatesTypesTypeIdGet' => [
            'application/json',
        ],
        'restOrdersDatesTypesTypeIdNamesGet' => [
            'application/json',
        ],
        'restOrdersDatesTypesTypeIdNamesLangGet' => [
            'application/json',
        ],
        'restOrdersDocumentsAccountingSummaryGet' => [
            'application/json',
        ],
        'restOrdersGet' => [
            'application/json',
        ],
        'restOrdersItemsDatesIdDelete' => [
            'application/json',
        ],
        'restOrdersItemsDatesIdGet' => [
            'application/json',
        ],
        'restOrdersItemsDatesIdPut' => [
            'application/json',
        ],
        'restOrdersItemsDatesPost' => [
            'application/json',
        ],
        'restOrdersItemsOrderItemIdBookingPost' => [
            'application/json',
        ],
        'restOrdersItemsOrderItemIdDatesGet' => [
            'application/json',
        ],
        'restOrdersItemsOrderItemIdDatesTypeIdDelete' => [
            'application/json',
        ],
        'restOrdersItemsOrderItemIdDatesTypeIdGet' => [
            'application/json',
        ],
        'restOrdersItemsOrderItemIdDatesTypeIdPost' => [
            'application/json',
        ],
        'restOrdersItemsOrderItemIdDatesTypeIdPut' => [
            'application/json',
        ],
        'restOrdersItemsOrderItemIdPropertiesGet' => [
            'application/json',
        ],
        'restOrdersItemsOrderItemIdPropertiesTypeIdDelete' => [
            'application/json',
        ],
        'restOrdersItemsOrderItemIdPropertiesTypeIdGet' => [
            'application/json',
        ],
        'restOrdersItemsOrderItemIdPropertiesTypeIdPost' => [
            'application/json',
        ],
        'restOrdersItemsOrderItemIdPropertiesTypeIdPut' => [
            'application/json',
        ],
        'restOrdersItemsOrderItemIdTransactionsGet' => [
            'application/json',
        ],
        'restOrdersItemsOrderItemIdTransactionsPost' => [
            'application/json',
        ],
        'restOrdersItemsOutgoingStocksDelete' => [
            'application/json',
        ],
        'restOrdersItemsPropertiesIdDelete' => [
            'application/json',
        ],
        'restOrdersItemsPropertiesIdGet' => [
            'application/json',
        ],
        'restOrdersItemsPropertiesIdPut' => [
            'application/json',
        ],
        'restOrdersItemsPropertiesPost' => [
            'application/json',
        ],
        'restOrdersItemsTransactionsBookingPost' => [
            'application/json',
        ],
        'restOrdersItemsTransactionsGet' => [
            'application/json',
        ],
        'restOrdersItemsTransactionsTransactionIdDelete' => [
            'application/json',
        ],
        'restOrdersItemsTransactionsTransactionIdPut' => [
            'application/json',
        ],
        'restOrdersOrderIdBookingPost' => [
            'application/json',
        ],
        'restOrdersOrderIdCancelPut' => [
            'application/json',
        ],
        'restOrdersOrderIdContactWishGet' => [
            'application/json',
        ],
        'restOrdersOrderIdCouponsCouponPost' => [
            'application/json',
        ],
        'restOrdersOrderIdDatesGet' => [
            'application/json',
        ],
        'restOrdersOrderIdDatesTypeIdGet' => [
            'application/json',
        ],
        'restOrdersOrderIdDelete' => [
            'application/json',
        ],
        'restOrdersOrderIdDeliveryOrdersAutomaticPost' => [
            'application/json',
        ],
        'restOrdersOrderIdDeliveryOrdersPost' => [
            'application/json',
        ],
        'restOrdersOrderIdGet' => [
            'application/json',
        ],
        'restOrdersOrderIdItemsGet' => [
            'application/json',
        ],
        'restOrdersOrderIdItemsOrderItemIdDelete' => [
            'application/json',
        ],
        'restOrdersOrderIdItemsOrderItemIdSerialNumbersGet' => [
            'application/json',
        ],
        'restOrdersOrderIdItemsSerialNumbersGet' => [
            'application/json',
        ],
        'restOrdersOrderIdOutgoingStocksDelete' => [
            'application/json',
        ],
        'restOrdersOrderIdOutgoingStocksPost' => [
            'application/json',
        ],
        'restOrdersOrderIdPackagenumbersGet' => [
            'application/json',
        ],
        'restOrdersOrderIdPropertiesPost' => [
            'application/json',
        ],
        'restOrdersOrderIdPropertiesTypeIdDelete' => [
            'application/json',
        ],
        'restOrdersOrderIdPropertiesTypeIdPut' => [
            'application/json',
        ],
        'restOrdersOrderIdPut' => [
            'application/json',
        ],
        'restOrdersOrderIdShippingCancelShipmentDelete' => [
            'application/json',
        ],
        'restOrdersOrderIdShippingPackagesDelete' => [
            'application/json',
        ],
        'restOrdersOrderIdShippingPackagesGet' => [
            'application/json',
        ],
        'restOrdersOrderIdShippingPackagesItemsGet' => [
            'application/json',
        ],
        'restOrdersOrderIdShippingPackagesOrderShippingPackageIdDelete' => [
            'application/json',
        ],
        'restOrdersOrderIdShippingPackagesOrderShippingPackageIdGet' => [
            'application/json',
        ],
        'restOrdersOrderIdShippingPackagesOrderShippingPackageIdPut' => [
            'application/json',
        ],
        'restOrdersOrderIdShippingPackagesPackedItemsGet' => [
            'application/json',
        ],
        'restOrdersOrderIdShippingPackagesPost' => [
            'application/json',
        ],
        'restOrdersOrderIdShippingPackagesUnpackedItemsGet' => [
            'application/json',
        ],
        'restOrdersOrderIdShippingPalletsPackagesItemsGet' => [
            'application/json',
        ],
        'restOrdersOrderIdShippingPalletsPalletIdPackagesDelete' => [
            'application/json',
        ],
        'restOrdersOrderIdShippingPalletsPalletIdPackagesGet' => [
            'application/json',
        ],
        'restOrdersOrderIdShippingPalletsPalletIdPackagesPut' => [
            'application/json',
        ],
        'restOrdersOrderIdShippingRegisterShipmentPost' => [
            'application/json',
        ],
        'restOrdersOrderIdShippingShippingInformationAdditionalDataPut' => [
            'application/json',
        ],
        'restOrdersOrderIdShippingShippingInformationDelete' => [
            'application/json',
        ],
        'restOrdersOrderIdShippingShippingInformationGet' => [
            'application/json',
        ],
        'restOrdersOrderIdShippingShippingInformationStatusPut' => [
            'application/json',
        ],
        'restOrdersOrderIdStatusHistoryGet' => [
            'application/json',
        ],
        'restOrdersOrderIdTransactionsPost' => [
            'application/json',
        ],
        'restOrdersPost' => [
            'application/json',
        ],
        'restOrdersPropertiesIdDelete' => [
            'application/json',
        ],
        'restOrdersPropertiesIdPut' => [
            'application/json',
        ],
        'restOrdersPropertiesTypesGet' => [
            'application/json',
        ],
        'restOrdersPropertiesTypesPost' => [
            'application/json',
        ],
        'restOrdersPropertiesTypesTypeIdDelete' => [
            'application/json',
        ],
        'restOrdersPropertiesTypesTypeIdGet' => [
            'application/json',
        ],
        'restOrdersPropertiesTypesTypeIdPut' => [
            'application/json',
        ],
        'restOrdersReferrersGet' => [
            'application/json',
        ],
        'restOrdersShippingCountriesGet' => [
            'application/json',
        ],
        'restOrdersShippingPackageTypesGet' => [
            'application/json',
        ],
        'restOrdersShippingPackageTypesShippingPackageTypeIdGet' => [
            'application/json',
        ],
        'restOrdersShippingPackagesItemsIdDelete' => [
            'application/json',
        ],
        'restOrdersShippingPackagesItemsIdPut' => [
            'application/json',
        ],
        'restOrdersShippingPackagesItemsPackageIdItemIdVariationIdDelete' => [
            'application/json',
        ],
        'restOrdersShippingPackagesItemsPackageIdItemIdVariationIdPut' => [
            'application/json',
        ],
        'restOrdersShippingPackagesPackageIdItemsGet' => [
            'application/json',
        ],
        'restOrdersShippingPackagesPackageIdItemsPost' => [
            'application/json',
        ],
        'restOrdersShippingPalletsGet' => [
            'application/json',
        ],
        'restOrdersShippingPalletsPalletIdDelete' => [
            'application/json',
        ],
        'restOrdersShippingPalletsPalletIdGet' => [
            'application/json',
        ],
        'restOrdersShippingPalletsPalletIdPut' => [
            'application/json',
        ],
        'restOrdersShippingPalletsPost' => [
            'application/json',
        ],
        'restOrdersShippingParcelServiceRegionsParcelServiceRegionIdGet' => [
            'application/json',
        ],
        'restOrdersShippingPresetsGet' => [
            'application/json',
        ],
        'restOrdersShippingPresetsPresetIdGet' => [
            'application/json',
        ],
        'restOrdersShippingPresetsPresetIdParcelServiceRegionsGet' => [
            'application/json',
        ],
        'restOrdersShippingReturnsReturnsServiceProvidersGet' => [
            'application/json',
        ],
        'restOrdersShippingReturnsReturnsServiceProvidersPluginsGet' => [
            'application/json',
        ],
        'restOrdersShippingReturnsReturnsServiceProvidersProviderIdGet' => [
            'application/json',
        ],
        'restOrdersShippingShippingInformationGet' => [
            'application/json',
        ],
        'restOrdersShippingShippingInformationPost' => [
            'application/json',
        ],
        'restOrdersShippingShippingServiceProvidersGet' => [
            'application/json',
        ],
        'restOrdersShippingShippingServiceProvidersPluginsGet' => [
            'application/json',
        ],
        'restOrdersShippingShippingServiceProvidersPost' => [
            'application/json',
        ],
        'restOrdersShippingShippingServiceProvidersShippingServiceProviderIdGet' => [
            'application/json',
        ],
        'restOrdersStatusHistoryGet' => [
            'application/json',
        ],
        'restOrdersStatusesAllGet' => [
            'application/json',
        ],
        'restOrdersStatusesGet' => [
            'application/json',
        ],
        'restOrdersStatusesGroupFunctionsPost' => [
            'application/json',
        ],
        'restOrdersStatusesPost' => [
            'application/json',
        ],
        'restOrdersStatusesStatusIdDelete' => [
            'application/json',
        ],
        'restOrdersStatusesStatusIdGet' => [
            'application/json',
        ],
        'restOrdersStatusesStatusIdPut' => [
            'application/json',
        ],
        'restRedistributionsOrderIdDelete' => [
            'application/json',
        ],
        'restRedistributionsOrderIdPut' => [
            'application/json',
        ],
        'restRedistributionsPost' => [
            'application/json',
        ],
        'restReordersOrderIdCurrencyPut' => [
            'application/json',
        ],
        'restReordersOrderIdDelete' => [
            'application/json',
        ],
        'restReordersOrderIdDeliveryDateGet' => [
            'application/json',
        ],
        'restReordersOrderIdDeliveryDatesPut' => [
            'application/json',
        ],
        'restReordersOrderIdPut' => [
            'application/json',
        ],
        'restReordersPost' => [
            'application/json',
        ],
        'restSystemSettingsTaricVatAssignmentGet' => [
            'application/json',
        ],
        'restSystemSettingsTaricVatAssignmentTaricCodeCountryIdDelete' => [
            'application/json',
        ],
        'restSystemSettingsTaricVatAssignmentTaricCodeCountryIdGet' => [
            'application/json',
        ],
        'restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPost' => [
            'application/json',
        ],
        'restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPut' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface|null $client
     * @param Configuration|null   $config
     * @param HeaderSelector|null  $selector
     * @param int                  $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex(int $hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex(): int
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig(): Configuration
    {
        return $this->config;
    }

    /**
     * Operation restDeliveryOrdersOrderIdDelete
     *
     * Delete a delivery order
     *
     * @param  int $order_id order_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restDeliveryOrdersOrderIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restDeliveryOrdersOrderIdDelete(
        int $order_id,
        string $contentType = self::contentTypes['restDeliveryOrdersOrderIdDelete'][0]
    ): object
    {
        list($response) = $this->restDeliveryOrdersOrderIdDeleteWithHttpInfo($order_id, $contentType);
        return $response;
    }

    /**
     * Operation restDeliveryOrdersOrderIdDeleteWithHttpInfo
     *
     * Delete a delivery order
     *
     * @param  int $order_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restDeliveryOrdersOrderIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restDeliveryOrdersOrderIdDeleteWithHttpInfo(
        int $order_id,
        string $contentType = self::contentTypes['restDeliveryOrdersOrderIdDelete'][0]
    ): array
    {
        $request = $this->restDeliveryOrdersOrderIdDeleteRequest($order_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restDeliveryOrdersOrderIdDeleteAsync
     *
     * Delete a delivery order
     *
     * @param  int $order_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restDeliveryOrdersOrderIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restDeliveryOrdersOrderIdDeleteAsync(
        int $order_id,
        string $contentType = self::contentTypes['restDeliveryOrdersOrderIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restDeliveryOrdersOrderIdDeleteAsyncWithHttpInfo($order_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restDeliveryOrdersOrderIdDeleteAsyncWithHttpInfo
     *
     * Delete a delivery order
     *
     * @param  int $order_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restDeliveryOrdersOrderIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restDeliveryOrdersOrderIdDeleteAsyncWithHttpInfo(
        $order_id,
        string $contentType = self::contentTypes['restDeliveryOrdersOrderIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restDeliveryOrdersOrderIdDeleteRequest($order_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restDeliveryOrdersOrderIdDelete'
     *
     * @param  int $order_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restDeliveryOrdersOrderIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restDeliveryOrdersOrderIdDeleteRequest(
        $order_id,
        string $contentType = self::contentTypes['restDeliveryOrdersOrderIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restDeliveryOrdersOrderIdDelete'
            );
        }


        $resourcePath = '/rest/delivery_orders/{orderId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restDeliveryOrdersOrderIdPut
     *
     * Update a delivery order
     *
     * @param  int $order_id order_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restDeliveryOrdersOrderIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Order
     */
    public function restDeliveryOrdersOrderIdPut(
        int $order_id,
        string $contentType = self::contentTypes['restDeliveryOrdersOrderIdPut'][0]
    ): \ck\Model\Order
    {
        list($response) = $this->restDeliveryOrdersOrderIdPutWithHttpInfo($order_id, $contentType);
        return $response;
    }

    /**
     * Operation restDeliveryOrdersOrderIdPutWithHttpInfo
     *
     * Update a delivery order
     *
     * @param  int $order_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restDeliveryOrdersOrderIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Order, HTTP status code, HTTP response headers (array of strings)
     */
    public function restDeliveryOrdersOrderIdPutWithHttpInfo(
        int $order_id,
        string $contentType = self::contentTypes['restDeliveryOrdersOrderIdPut'][0]
    ): array
    {
        $request = $this->restDeliveryOrdersOrderIdPutRequest($order_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Order' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Order' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Order', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Order';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Order',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restDeliveryOrdersOrderIdPutAsync
     *
     * Update a delivery order
     *
     * @param  int $order_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restDeliveryOrdersOrderIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restDeliveryOrdersOrderIdPutAsync(
        int $order_id,
        string $contentType = self::contentTypes['restDeliveryOrdersOrderIdPut'][0]
    ): PromiseInterface
    {
        return $this->restDeliveryOrdersOrderIdPutAsyncWithHttpInfo($order_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restDeliveryOrdersOrderIdPutAsyncWithHttpInfo
     *
     * Update a delivery order
     *
     * @param  int $order_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restDeliveryOrdersOrderIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restDeliveryOrdersOrderIdPutAsyncWithHttpInfo(
        $order_id,
        string $contentType = self::contentTypes['restDeliveryOrdersOrderIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Order';
        $request = $this->restDeliveryOrdersOrderIdPutRequest($order_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restDeliveryOrdersOrderIdPut'
     *
     * @param  int $order_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restDeliveryOrdersOrderIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restDeliveryOrdersOrderIdPutRequest(
        $order_id,
        string $contentType = self::contentTypes['restDeliveryOrdersOrderIdPut'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restDeliveryOrdersOrderIdPut'
            );
        }


        $resourcePath = '/rest/delivery_orders/{orderId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restDeliveryOrdersPost
     *
     * Create a delivery order
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restDeliveryOrdersPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Order
     */
    public function restDeliveryOrdersPost(
        string $contentType = self::contentTypes['restDeliveryOrdersPost'][0]
    ): \ck\Model\Order
    {
        list($response) = $this->restDeliveryOrdersPostWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restDeliveryOrdersPostWithHttpInfo
     *
     * Create a delivery order
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restDeliveryOrdersPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Order, HTTP status code, HTTP response headers (array of strings)
     */
    public function restDeliveryOrdersPostWithHttpInfo(
        string $contentType = self::contentTypes['restDeliveryOrdersPost'][0]
    ): array
    {
        $request = $this->restDeliveryOrdersPostRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Order' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Order' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Order', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Order';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Order',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restDeliveryOrdersPostAsync
     *
     * Create a delivery order
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restDeliveryOrdersPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restDeliveryOrdersPostAsync(
        string $contentType = self::contentTypes['restDeliveryOrdersPost'][0]
    ): PromiseInterface
    {
        return $this->restDeliveryOrdersPostAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restDeliveryOrdersPostAsyncWithHttpInfo
     *
     * Create a delivery order
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restDeliveryOrdersPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restDeliveryOrdersPostAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restDeliveryOrdersPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Order';
        $request = $this->restDeliveryOrdersPostRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restDeliveryOrdersPost'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restDeliveryOrdersPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restDeliveryOrdersPostRequest(
        string $contentType = self::contentTypes['restDeliveryOrdersPost'][0]
    ): Request
    {


        $resourcePath = '/rest/delivery_orders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersContactsContactIdGet
     *
     * List orders of a contact
     *
     * @param  int $contact_id The ID of the contact. (required)
     * @param  int $page The page to get. The default page that will be returned is page 1. (required)
     * @param  int $items_per_page The number of orders to be displayed per page. The default number of orders per page is 50. (required)
     * @param  int|null $with Load additional relations for an order. The following relations are available:      * &lt;ul&gt;        &lt;li&gt;&#39;addresses&#39; &#x3D; The address objects linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;relations&#39; &#x3D; The order relation reference instances that are associated with the order. These instances contain information such as the reference type. The available reference types are parent and reorder. The ID of the reference and the relation itself are also available.&lt;/li&gt;        &lt;li&gt;&#39;comments&#39; &#x3D; The order comments.&lt;/li&gt;        &lt;li&gt;&#39;location&#39; &#x3D; The accounting location linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;payments&#39; &#x3D; The payments linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;documents&#39; &#x3D; The documents linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;contactSender&#39; &#x3D; The contact belonging the contact-sender relation.&lt;/li&gt;        &lt;li&gt;&#39;contactReceiver&#39; &#x3D; The contact belonging to the contact-receiver relation.&lt;/li&gt;        &lt;li&gt;&#39;warehouseSender&#39; &#x3D; The warehouse belonging to the warehouse-sender relation.&lt;/li&gt;        &lt;li&gt;&#39;warehouseReceiver&#39; &#x3D; The warehouse belonging to the warehouse-receiver relation.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.variation&#39; &#x3D; The variation data belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.giftCardCodes&#39; &#x3D; The gift card codes belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.transactions&#39; &#x3D; The transactions belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.serialNumbers&#39; &#x3D; The serial numbers belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.variationBarcodes&#39; &#x3D; The barcodes belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.comments&#39; &#x3D; The comments belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;shippingPackages&#39; &#x3D; The shipping packages that are associated with the order.&lt;/li&gt;        &lt;li&gt;&lt;b&gt;deprecated&lt;/b&gt; &#39;orderItems.warehouseLocations&#39; &#x3D; The warehouse locations linked to the order item.&lt;/li&gt;      &lt;/ul&gt;     Example: &lt;code&gt;?with[]&#x3D;addresses&amp;with[]&#x3D;orderItems.variation&lt;/code&gt; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersContactsContactIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestOrdersGet200Response
     */
    public function restOrdersContactsContactIdGet(
        int $contact_id,
        int $page,
        int $items_per_page,
        ?int $with = null,
        string $contentType = self::contentTypes['restOrdersContactsContactIdGet'][0]
    ): \ck\Model\RestOrdersGet200Response
    {
        list($response) = $this->restOrdersContactsContactIdGetWithHttpInfo($contact_id, $page, $items_per_page, $with, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersContactsContactIdGetWithHttpInfo
     *
     * List orders of a contact
     *
     * @param  int $contact_id The ID of the contact. (required)
     * @param  int $page The page to get. The default page that will be returned is page 1. (required)
     * @param  int $items_per_page The number of orders to be displayed per page. The default number of orders per page is 50. (required)
     * @param  int|null $with Load additional relations for an order. The following relations are available:      * &lt;ul&gt;        &lt;li&gt;&#39;addresses&#39; &#x3D; The address objects linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;relations&#39; &#x3D; The order relation reference instances that are associated with the order. These instances contain information such as the reference type. The available reference types are parent and reorder. The ID of the reference and the relation itself are also available.&lt;/li&gt;        &lt;li&gt;&#39;comments&#39; &#x3D; The order comments.&lt;/li&gt;        &lt;li&gt;&#39;location&#39; &#x3D; The accounting location linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;payments&#39; &#x3D; The payments linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;documents&#39; &#x3D; The documents linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;contactSender&#39; &#x3D; The contact belonging the contact-sender relation.&lt;/li&gt;        &lt;li&gt;&#39;contactReceiver&#39; &#x3D; The contact belonging to the contact-receiver relation.&lt;/li&gt;        &lt;li&gt;&#39;warehouseSender&#39; &#x3D; The warehouse belonging to the warehouse-sender relation.&lt;/li&gt;        &lt;li&gt;&#39;warehouseReceiver&#39; &#x3D; The warehouse belonging to the warehouse-receiver relation.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.variation&#39; &#x3D; The variation data belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.giftCardCodes&#39; &#x3D; The gift card codes belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.transactions&#39; &#x3D; The transactions belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.serialNumbers&#39; &#x3D; The serial numbers belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.variationBarcodes&#39; &#x3D; The barcodes belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.comments&#39; &#x3D; The comments belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;shippingPackages&#39; &#x3D; The shipping packages that are associated with the order.&lt;/li&gt;        &lt;li&gt;&lt;b&gt;deprecated&lt;/b&gt; &#39;orderItems.warehouseLocations&#39; &#x3D; The warehouse locations linked to the order item.&lt;/li&gt;      &lt;/ul&gt;     Example: &lt;code&gt;?with[]&#x3D;addresses&amp;with[]&#x3D;orderItems.variation&lt;/code&gt; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersContactsContactIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestOrdersGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersContactsContactIdGetWithHttpInfo(
        int $contact_id,
        int $page,
        int $items_per_page,
        ?int $with = null,
        string $contentType = self::contentTypes['restOrdersContactsContactIdGet'][0]
    ): array
    {
        $request = $this->restOrdersContactsContactIdGetRequest($contact_id, $page, $items_per_page, $with, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestOrdersGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestOrdersGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestOrdersGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestOrdersGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestOrdersGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersContactsContactIdGetAsync
     *
     * List orders of a contact
     *
     * @param  int $contact_id The ID of the contact. (required)
     * @param  int $page The page to get. The default page that will be returned is page 1. (required)
     * @param  int $items_per_page The number of orders to be displayed per page. The default number of orders per page is 50. (required)
     * @param  int|null $with Load additional relations for an order. The following relations are available:      * &lt;ul&gt;        &lt;li&gt;&#39;addresses&#39; &#x3D; The address objects linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;relations&#39; &#x3D; The order relation reference instances that are associated with the order. These instances contain information such as the reference type. The available reference types are parent and reorder. The ID of the reference and the relation itself are also available.&lt;/li&gt;        &lt;li&gt;&#39;comments&#39; &#x3D; The order comments.&lt;/li&gt;        &lt;li&gt;&#39;location&#39; &#x3D; The accounting location linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;payments&#39; &#x3D; The payments linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;documents&#39; &#x3D; The documents linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;contactSender&#39; &#x3D; The contact belonging the contact-sender relation.&lt;/li&gt;        &lt;li&gt;&#39;contactReceiver&#39; &#x3D; The contact belonging to the contact-receiver relation.&lt;/li&gt;        &lt;li&gt;&#39;warehouseSender&#39; &#x3D; The warehouse belonging to the warehouse-sender relation.&lt;/li&gt;        &lt;li&gt;&#39;warehouseReceiver&#39; &#x3D; The warehouse belonging to the warehouse-receiver relation.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.variation&#39; &#x3D; The variation data belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.giftCardCodes&#39; &#x3D; The gift card codes belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.transactions&#39; &#x3D; The transactions belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.serialNumbers&#39; &#x3D; The serial numbers belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.variationBarcodes&#39; &#x3D; The barcodes belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.comments&#39; &#x3D; The comments belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;shippingPackages&#39; &#x3D; The shipping packages that are associated with the order.&lt;/li&gt;        &lt;li&gt;&lt;b&gt;deprecated&lt;/b&gt; &#39;orderItems.warehouseLocations&#39; &#x3D; The warehouse locations linked to the order item.&lt;/li&gt;      &lt;/ul&gt;     Example: &lt;code&gt;?with[]&#x3D;addresses&amp;with[]&#x3D;orderItems.variation&lt;/code&gt; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersContactsContactIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersContactsContactIdGetAsync(
        int $contact_id,
        int $page,
        int $items_per_page,
        ?int $with = null,
        string $contentType = self::contentTypes['restOrdersContactsContactIdGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersContactsContactIdGetAsyncWithHttpInfo($contact_id, $page, $items_per_page, $with, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersContactsContactIdGetAsyncWithHttpInfo
     *
     * List orders of a contact
     *
     * @param  int $contact_id The ID of the contact. (required)
     * @param  int $page The page to get. The default page that will be returned is page 1. (required)
     * @param  int $items_per_page The number of orders to be displayed per page. The default number of orders per page is 50. (required)
     * @param  int|null $with Load additional relations for an order. The following relations are available:      * &lt;ul&gt;        &lt;li&gt;&#39;addresses&#39; &#x3D; The address objects linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;relations&#39; &#x3D; The order relation reference instances that are associated with the order. These instances contain information such as the reference type. The available reference types are parent and reorder. The ID of the reference and the relation itself are also available.&lt;/li&gt;        &lt;li&gt;&#39;comments&#39; &#x3D; The order comments.&lt;/li&gt;        &lt;li&gt;&#39;location&#39; &#x3D; The accounting location linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;payments&#39; &#x3D; The payments linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;documents&#39; &#x3D; The documents linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;contactSender&#39; &#x3D; The contact belonging the contact-sender relation.&lt;/li&gt;        &lt;li&gt;&#39;contactReceiver&#39; &#x3D; The contact belonging to the contact-receiver relation.&lt;/li&gt;        &lt;li&gt;&#39;warehouseSender&#39; &#x3D; The warehouse belonging to the warehouse-sender relation.&lt;/li&gt;        &lt;li&gt;&#39;warehouseReceiver&#39; &#x3D; The warehouse belonging to the warehouse-receiver relation.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.variation&#39; &#x3D; The variation data belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.giftCardCodes&#39; &#x3D; The gift card codes belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.transactions&#39; &#x3D; The transactions belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.serialNumbers&#39; &#x3D; The serial numbers belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.variationBarcodes&#39; &#x3D; The barcodes belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.comments&#39; &#x3D; The comments belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;shippingPackages&#39; &#x3D; The shipping packages that are associated with the order.&lt;/li&gt;        &lt;li&gt;&lt;b&gt;deprecated&lt;/b&gt; &#39;orderItems.warehouseLocations&#39; &#x3D; The warehouse locations linked to the order item.&lt;/li&gt;      &lt;/ul&gt;     Example: &lt;code&gt;?with[]&#x3D;addresses&amp;with[]&#x3D;orderItems.variation&lt;/code&gt; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersContactsContactIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersContactsContactIdGetAsyncWithHttpInfo(
        $contact_id,
        $page,
        $items_per_page,
        $with = null,
        string $contentType = self::contentTypes['restOrdersContactsContactIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestOrdersGet200Response';
        $request = $this->restOrdersContactsContactIdGetRequest($contact_id, $page, $items_per_page, $with, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersContactsContactIdGet'
     *
     * @param  int $contact_id The ID of the contact. (required)
     * @param  int $page The page to get. The default page that will be returned is page 1. (required)
     * @param  int $items_per_page The number of orders to be displayed per page. The default number of orders per page is 50. (required)
     * @param  int|null $with Load additional relations for an order. The following relations are available:      * &lt;ul&gt;        &lt;li&gt;&#39;addresses&#39; &#x3D; The address objects linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;relations&#39; &#x3D; The order relation reference instances that are associated with the order. These instances contain information such as the reference type. The available reference types are parent and reorder. The ID of the reference and the relation itself are also available.&lt;/li&gt;        &lt;li&gt;&#39;comments&#39; &#x3D; The order comments.&lt;/li&gt;        &lt;li&gt;&#39;location&#39; &#x3D; The accounting location linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;payments&#39; &#x3D; The payments linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;documents&#39; &#x3D; The documents linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;contactSender&#39; &#x3D; The contact belonging the contact-sender relation.&lt;/li&gt;        &lt;li&gt;&#39;contactReceiver&#39; &#x3D; The contact belonging to the contact-receiver relation.&lt;/li&gt;        &lt;li&gt;&#39;warehouseSender&#39; &#x3D; The warehouse belonging to the warehouse-sender relation.&lt;/li&gt;        &lt;li&gt;&#39;warehouseReceiver&#39; &#x3D; The warehouse belonging to the warehouse-receiver relation.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.variation&#39; &#x3D; The variation data belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.giftCardCodes&#39; &#x3D; The gift card codes belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.transactions&#39; &#x3D; The transactions belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.serialNumbers&#39; &#x3D; The serial numbers belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.variationBarcodes&#39; &#x3D; The barcodes belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.comments&#39; &#x3D; The comments belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;shippingPackages&#39; &#x3D; The shipping packages that are associated with the order.&lt;/li&gt;        &lt;li&gt;&lt;b&gt;deprecated&lt;/b&gt; &#39;orderItems.warehouseLocations&#39; &#x3D; The warehouse locations linked to the order item.&lt;/li&gt;      &lt;/ul&gt;     Example: &lt;code&gt;?with[]&#x3D;addresses&amp;with[]&#x3D;orderItems.variation&lt;/code&gt; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersContactsContactIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersContactsContactIdGetRequest(
        $contact_id,
        $page,
        $items_per_page,
        $with = null,
        string $contentType = self::contentTypes['restOrdersContactsContactIdGet'][0]
    ): Request
    {

        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restOrdersContactsContactIdGet'
            );
        }

        // verify the required parameter 'page' is set
        if ($page === null || (is_array($page) && count($page) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $page when calling restOrdersContactsContactIdGet'
            );
        }

        // verify the required parameter 'items_per_page' is set
        if ($items_per_page === null || (is_array($items_per_page) && count($items_per_page) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $items_per_page when calling restOrdersContactsContactIdGet'
            );
        }



        $resourcePath = '/rest/orders/contacts/{contactId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $items_per_page,
            'itemsPerPage', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersContactsContactIdMultiOrderPost
     *
     * Create a multi-order
     *
     * @param  int $contact_id contact_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersContactsContactIdMultiOrderPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Order
     */
    public function restOrdersContactsContactIdMultiOrderPost(
        int $contact_id,
        string $contentType = self::contentTypes['restOrdersContactsContactIdMultiOrderPost'][0]
    ): \ck\Model\Order
    {
        list($response) = $this->restOrdersContactsContactIdMultiOrderPostWithHttpInfo($contact_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersContactsContactIdMultiOrderPostWithHttpInfo
     *
     * Create a multi-order
     *
     * @param  int $contact_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersContactsContactIdMultiOrderPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Order, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersContactsContactIdMultiOrderPostWithHttpInfo(
        int $contact_id,
        string $contentType = self::contentTypes['restOrdersContactsContactIdMultiOrderPost'][0]
    ): array
    {
        $request = $this->restOrdersContactsContactIdMultiOrderPostRequest($contact_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Order' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Order' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Order', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Order';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Order',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersContactsContactIdMultiOrderPostAsync
     *
     * Create a multi-order
     *
     * @param  int $contact_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersContactsContactIdMultiOrderPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersContactsContactIdMultiOrderPostAsync(
        int $contact_id,
        string $contentType = self::contentTypes['restOrdersContactsContactIdMultiOrderPost'][0]
    ): PromiseInterface
    {
        return $this->restOrdersContactsContactIdMultiOrderPostAsyncWithHttpInfo($contact_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersContactsContactIdMultiOrderPostAsyncWithHttpInfo
     *
     * Create a multi-order
     *
     * @param  int $contact_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersContactsContactIdMultiOrderPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersContactsContactIdMultiOrderPostAsyncWithHttpInfo(
        $contact_id,
        string $contentType = self::contentTypes['restOrdersContactsContactIdMultiOrderPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Order';
        $request = $this->restOrdersContactsContactIdMultiOrderPostRequest($contact_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersContactsContactIdMultiOrderPost'
     *
     * @param  int $contact_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersContactsContactIdMultiOrderPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersContactsContactIdMultiOrderPostRequest(
        $contact_id,
        string $contentType = self::contentTypes['restOrdersContactsContactIdMultiOrderPost'][0]
    ): Request
    {

        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restOrdersContactsContactIdMultiOrderPost'
            );
        }


        $resourcePath = '/rest/orders/contacts/{contactId}/multi_order';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersCouponsCampaignsCampaignIdCodesPost
     *
     * Create a coupon code
     *
     * @param  int $campaign_id campaign_id (required)
     * @param  \ck\Model\RestOrdersCouponsCampaignsCampaignIdCodesPostRequest|null $_rest_orders_coupons_campaigns_campaign_id_codes _rest_orders_coupons_campaigns_campaign_id_codes (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCouponsCampaignsCampaignIdCodesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\CouponCampaignCode
     */
    public function restOrdersCouponsCampaignsCampaignIdCodesPost(
        int $campaign_id,
        ?\ck\Model\RestOrdersCouponsCampaignsCampaignIdCodesPostRequest $_rest_orders_coupons_campaigns_campaign_id_codes = null,
        string $contentType = self::contentTypes['restOrdersCouponsCampaignsCampaignIdCodesPost'][0]
    ): \ck\Model\CouponCampaignCode
    {
        list($response) = $this->restOrdersCouponsCampaignsCampaignIdCodesPostWithHttpInfo($campaign_id, $_rest_orders_coupons_campaigns_campaign_id_codes, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersCouponsCampaignsCampaignIdCodesPostWithHttpInfo
     *
     * Create a coupon code
     *
     * @param  int $campaign_id (required)
     * @param  \ck\Model\RestOrdersCouponsCampaignsCampaignIdCodesPostRequest|null $_rest_orders_coupons_campaigns_campaign_id_codes (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCouponsCampaignsCampaignIdCodesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\CouponCampaignCode, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersCouponsCampaignsCampaignIdCodesPostWithHttpInfo(
        int $campaign_id,
        ?\ck\Model\RestOrdersCouponsCampaignsCampaignIdCodesPostRequest $_rest_orders_coupons_campaigns_campaign_id_codes = null,
        string $contentType = self::contentTypes['restOrdersCouponsCampaignsCampaignIdCodesPost'][0]
    ): array
    {
        $request = $this->restOrdersCouponsCampaignsCampaignIdCodesPostRequest($campaign_id, $_rest_orders_coupons_campaigns_campaign_id_codes, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\CouponCampaignCode' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\CouponCampaignCode' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\CouponCampaignCode', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\CouponCampaignCode';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\CouponCampaignCode',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersCouponsCampaignsCampaignIdCodesPostAsync
     *
     * Create a coupon code
     *
     * @param  int $campaign_id (required)
     * @param  \ck\Model\RestOrdersCouponsCampaignsCampaignIdCodesPostRequest|null $_rest_orders_coupons_campaigns_campaign_id_codes (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCouponsCampaignsCampaignIdCodesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersCouponsCampaignsCampaignIdCodesPostAsync(
        int $campaign_id,
        ?\ck\Model\RestOrdersCouponsCampaignsCampaignIdCodesPostRequest $_rest_orders_coupons_campaigns_campaign_id_codes = null,
        string $contentType = self::contentTypes['restOrdersCouponsCampaignsCampaignIdCodesPost'][0]
    ): PromiseInterface
    {
        return $this->restOrdersCouponsCampaignsCampaignIdCodesPostAsyncWithHttpInfo($campaign_id, $_rest_orders_coupons_campaigns_campaign_id_codes, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersCouponsCampaignsCampaignIdCodesPostAsyncWithHttpInfo
     *
     * Create a coupon code
     *
     * @param  int $campaign_id (required)
     * @param  \ck\Model\RestOrdersCouponsCampaignsCampaignIdCodesPostRequest|null $_rest_orders_coupons_campaigns_campaign_id_codes (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCouponsCampaignsCampaignIdCodesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersCouponsCampaignsCampaignIdCodesPostAsyncWithHttpInfo(
        $campaign_id,
        $_rest_orders_coupons_campaigns_campaign_id_codes = null,
        string $contentType = self::contentTypes['restOrdersCouponsCampaignsCampaignIdCodesPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\CouponCampaignCode';
        $request = $this->restOrdersCouponsCampaignsCampaignIdCodesPostRequest($campaign_id, $_rest_orders_coupons_campaigns_campaign_id_codes, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersCouponsCampaignsCampaignIdCodesPost'
     *
     * @param  int $campaign_id (required)
     * @param  \ck\Model\RestOrdersCouponsCampaignsCampaignIdCodesPostRequest|null $_rest_orders_coupons_campaigns_campaign_id_codes (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCouponsCampaignsCampaignIdCodesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersCouponsCampaignsCampaignIdCodesPostRequest(
        $campaign_id,
        $_rest_orders_coupons_campaigns_campaign_id_codes = null,
        string $contentType = self::contentTypes['restOrdersCouponsCampaignsCampaignIdCodesPost'][0]
    ): Request
    {

        // verify the required parameter 'campaign_id' is set
        if ($campaign_id === null || (is_array($campaign_id) && count($campaign_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $campaign_id when calling restOrdersCouponsCampaignsCampaignIdCodesPost'
            );
        }



        $resourcePath = '/rest/orders/coupons/campaigns/{campaignId}/codes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($campaign_id !== null) {
            $resourcePath = str_replace(
                '{' . 'campaignId' . '}',
                ObjectSerializer::toPathValue($campaign_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_orders_coupons_campaigns_campaign_id_codes)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_orders_coupons_campaigns_campaign_id_codes));
            } else {
                $httpBody = $_rest_orders_coupons_campaigns_campaign_id_codes;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersCouponsCampaignsCodesCodeDelete
     *
     * Delete a coupon
     *
     * @param  int $code code (required)
     * @param  int|null $without_used Do not delete used coupons (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCouponsCampaignsCodesCodeDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restOrdersCouponsCampaignsCodesCodeDelete(
        int $code,
        ?int $without_used = null,
        string $contentType = self::contentTypes['restOrdersCouponsCampaignsCodesCodeDelete'][0]
    ): object
    {
        list($response) = $this->restOrdersCouponsCampaignsCodesCodeDeleteWithHttpInfo($code, $without_used, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersCouponsCampaignsCodesCodeDeleteWithHttpInfo
     *
     * Delete a coupon
     *
     * @param  int $code (required)
     * @param  int|null $without_used Do not delete used coupons (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCouponsCampaignsCodesCodeDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersCouponsCampaignsCodesCodeDeleteWithHttpInfo(
        int $code,
        ?int $without_used = null,
        string $contentType = self::contentTypes['restOrdersCouponsCampaignsCodesCodeDelete'][0]
    ): array
    {
        $request = $this->restOrdersCouponsCampaignsCodesCodeDeleteRequest($code, $without_used, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersCouponsCampaignsCodesCodeDeleteAsync
     *
     * Delete a coupon
     *
     * @param  int $code (required)
     * @param  int|null $without_used Do not delete used coupons (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCouponsCampaignsCodesCodeDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersCouponsCampaignsCodesCodeDeleteAsync(
        int $code,
        ?int $without_used = null,
        string $contentType = self::contentTypes['restOrdersCouponsCampaignsCodesCodeDelete'][0]
    ): PromiseInterface
    {
        return $this->restOrdersCouponsCampaignsCodesCodeDeleteAsyncWithHttpInfo($code, $without_used, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersCouponsCampaignsCodesCodeDeleteAsyncWithHttpInfo
     *
     * Delete a coupon
     *
     * @param  int $code (required)
     * @param  int|null $without_used Do not delete used coupons (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCouponsCampaignsCodesCodeDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersCouponsCampaignsCodesCodeDeleteAsyncWithHttpInfo(
        $code,
        $without_used = null,
        string $contentType = self::contentTypes['restOrdersCouponsCampaignsCodesCodeDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restOrdersCouponsCampaignsCodesCodeDeleteRequest($code, $without_used, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersCouponsCampaignsCodesCodeDelete'
     *
     * @param  int $code (required)
     * @param  int|null $without_used Do not delete used coupons (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCouponsCampaignsCodesCodeDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersCouponsCampaignsCodesCodeDeleteRequest(
        $code,
        $without_used = null,
        string $contentType = self::contentTypes['restOrdersCouponsCampaignsCodesCodeDelete'][0]
    ): Request
    {

        // verify the required parameter 'code' is set
        if ($code === null || (is_array($code) && count($code) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $code when calling restOrdersCouponsCampaignsCodesCodeDelete'
            );
        }



        $resourcePath = '/rest/orders/coupons/campaigns/codes/{code}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $without_used,
            'withoutUsed', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($code !== null) {
            $resourcePath = str_replace(
                '{' . 'code' . '}',
                ObjectSerializer::toPathValue($code),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersCouponsCampaignsCodesCodeDisabledIsDisabledPut
     *
     * Disable or enable coupon
     *
     * @param  int $code code (required)
     * @param  int $is_disabled is_disabled (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCouponsCampaignsCodesCodeDisabledIsDisabledPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restOrdersCouponsCampaignsCodesCodeDisabledIsDisabledPut(
        int $code,
        int $is_disabled,
        string $contentType = self::contentTypes['restOrdersCouponsCampaignsCodesCodeDisabledIsDisabledPut'][0]
    ): object
    {
        list($response) = $this->restOrdersCouponsCampaignsCodesCodeDisabledIsDisabledPutWithHttpInfo($code, $is_disabled, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersCouponsCampaignsCodesCodeDisabledIsDisabledPutWithHttpInfo
     *
     * Disable or enable coupon
     *
     * @param  int $code (required)
     * @param  int $is_disabled (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCouponsCampaignsCodesCodeDisabledIsDisabledPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersCouponsCampaignsCodesCodeDisabledIsDisabledPutWithHttpInfo(
        int $code,
        int $is_disabled,
        string $contentType = self::contentTypes['restOrdersCouponsCampaignsCodesCodeDisabledIsDisabledPut'][0]
    ): array
    {
        $request = $this->restOrdersCouponsCampaignsCodesCodeDisabledIsDisabledPutRequest($code, $is_disabled, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersCouponsCampaignsCodesCodeDisabledIsDisabledPutAsync
     *
     * Disable or enable coupon
     *
     * @param  int $code (required)
     * @param  int $is_disabled (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCouponsCampaignsCodesCodeDisabledIsDisabledPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersCouponsCampaignsCodesCodeDisabledIsDisabledPutAsync(
        int $code,
        int $is_disabled,
        string $contentType = self::contentTypes['restOrdersCouponsCampaignsCodesCodeDisabledIsDisabledPut'][0]
    ): PromiseInterface
    {
        return $this->restOrdersCouponsCampaignsCodesCodeDisabledIsDisabledPutAsyncWithHttpInfo($code, $is_disabled, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersCouponsCampaignsCodesCodeDisabledIsDisabledPutAsyncWithHttpInfo
     *
     * Disable or enable coupon
     *
     * @param  int $code (required)
     * @param  int $is_disabled (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCouponsCampaignsCodesCodeDisabledIsDisabledPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersCouponsCampaignsCodesCodeDisabledIsDisabledPutAsyncWithHttpInfo(
        $code,
        $is_disabled,
        string $contentType = self::contentTypes['restOrdersCouponsCampaignsCodesCodeDisabledIsDisabledPut'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restOrdersCouponsCampaignsCodesCodeDisabledIsDisabledPutRequest($code, $is_disabled, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersCouponsCampaignsCodesCodeDisabledIsDisabledPut'
     *
     * @param  int $code (required)
     * @param  int $is_disabled (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCouponsCampaignsCodesCodeDisabledIsDisabledPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersCouponsCampaignsCodesCodeDisabledIsDisabledPutRequest(
        $code,
        $is_disabled,
        string $contentType = self::contentTypes['restOrdersCouponsCampaignsCodesCodeDisabledIsDisabledPut'][0]
    ): Request
    {

        // verify the required parameter 'code' is set
        if ($code === null || (is_array($code) && count($code) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $code when calling restOrdersCouponsCampaignsCodesCodeDisabledIsDisabledPut'
            );
        }

        // verify the required parameter 'is_disabled' is set
        if ($is_disabled === null || (is_array($is_disabled) && count($is_disabled) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $is_disabled when calling restOrdersCouponsCampaignsCodesCodeDisabledIsDisabledPut'
            );
        }


        $resourcePath = '/rest/orders/coupons/campaigns/codes/{code}/disabled/{isDisabled}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($code !== null) {
            $resourcePath = str_replace(
                '{' . 'code' . '}',
                ObjectSerializer::toPathValue($code),
                $resourcePath
            );
        }
        // path params
        if ($is_disabled !== null) {
            $resourcePath = str_replace(
                '{' . 'isDisabled' . '}',
                ObjectSerializer::toPathValue($is_disabled),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersCouponsCampaignsCodesCodeGet
     *
     * Get coupon code information
     *
     * @param  string $code The coupon code (required)
     * @param  string|null $with Load additional relations for a coupon code. Currently possible are:      * &lt;ul&gt;      *   &lt;li&gt;&#39;campaign&#39; &#x3D; The coupon campaign to which this code belongs to.&lt;/li&gt;      * &lt;/ul&gt;      * Example: &lt;code&gt;?with&#x3D;campaign&lt;/code&gt; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCouponsCampaignsCodesCodeGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\CouponCampaignCode
     */
    public function restOrdersCouponsCampaignsCodesCodeGet(
        string $code,
        ?string $with = null,
        string $contentType = self::contentTypes['restOrdersCouponsCampaignsCodesCodeGet'][0]
    ): \ck\Model\CouponCampaignCode
    {
        list($response) = $this->restOrdersCouponsCampaignsCodesCodeGetWithHttpInfo($code, $with, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersCouponsCampaignsCodesCodeGetWithHttpInfo
     *
     * Get coupon code information
     *
     * @param  string $code The coupon code (required)
     * @param  string|null $with Load additional relations for a coupon code. Currently possible are:      * &lt;ul&gt;      *   &lt;li&gt;&#39;campaign&#39; &#x3D; The coupon campaign to which this code belongs to.&lt;/li&gt;      * &lt;/ul&gt;      * Example: &lt;code&gt;?with&#x3D;campaign&lt;/code&gt; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCouponsCampaignsCodesCodeGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\CouponCampaignCode, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersCouponsCampaignsCodesCodeGetWithHttpInfo(
        string $code,
        ?string $with = null,
        string $contentType = self::contentTypes['restOrdersCouponsCampaignsCodesCodeGet'][0]
    ): array
    {
        $request = $this->restOrdersCouponsCampaignsCodesCodeGetRequest($code, $with, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\CouponCampaignCode' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\CouponCampaignCode' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\CouponCampaignCode', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\CouponCampaignCode';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\CouponCampaignCode',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersCouponsCampaignsCodesCodeGetAsync
     *
     * Get coupon code information
     *
     * @param  string $code The coupon code (required)
     * @param  string|null $with Load additional relations for a coupon code. Currently possible are:      * &lt;ul&gt;      *   &lt;li&gt;&#39;campaign&#39; &#x3D; The coupon campaign to which this code belongs to.&lt;/li&gt;      * &lt;/ul&gt;      * Example: &lt;code&gt;?with&#x3D;campaign&lt;/code&gt; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCouponsCampaignsCodesCodeGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersCouponsCampaignsCodesCodeGetAsync(
        string $code,
        ?string $with = null,
        string $contentType = self::contentTypes['restOrdersCouponsCampaignsCodesCodeGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersCouponsCampaignsCodesCodeGetAsyncWithHttpInfo($code, $with, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersCouponsCampaignsCodesCodeGetAsyncWithHttpInfo
     *
     * Get coupon code information
     *
     * @param  string $code The coupon code (required)
     * @param  string|null $with Load additional relations for a coupon code. Currently possible are:      * &lt;ul&gt;      *   &lt;li&gt;&#39;campaign&#39; &#x3D; The coupon campaign to which this code belongs to.&lt;/li&gt;      * &lt;/ul&gt;      * Example: &lt;code&gt;?with&#x3D;campaign&lt;/code&gt; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCouponsCampaignsCodesCodeGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersCouponsCampaignsCodesCodeGetAsyncWithHttpInfo(
        $code,
        $with = null,
        string $contentType = self::contentTypes['restOrdersCouponsCampaignsCodesCodeGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\CouponCampaignCode';
        $request = $this->restOrdersCouponsCampaignsCodesCodeGetRequest($code, $with, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersCouponsCampaignsCodesCodeGet'
     *
     * @param  string $code The coupon code (required)
     * @param  string|null $with Load additional relations for a coupon code. Currently possible are:      * &lt;ul&gt;      *   &lt;li&gt;&#39;campaign&#39; &#x3D; The coupon campaign to which this code belongs to.&lt;/li&gt;      * &lt;/ul&gt;      * Example: &lt;code&gt;?with&#x3D;campaign&lt;/code&gt; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCouponsCampaignsCodesCodeGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersCouponsCampaignsCodesCodeGetRequest(
        $code,
        $with = null,
        string $contentType = self::contentTypes['restOrdersCouponsCampaignsCodesCodeGet'][0]
    ): Request
    {

        // verify the required parameter 'code' is set
        if ($code === null || (is_array($code) && count($code) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $code when calling restOrdersCouponsCampaignsCodesCodeGet'
            );
        }



        $resourcePath = '/rest/orders/coupons/campaigns/codes/{code}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($code !== null) {
            $resourcePath = str_replace(
                '{' . 'code' . '}',
                ObjectSerializer::toPathValue($code),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersCouponsCodesContactsContactIdGet
     *
     * List redeemed coupon codes of a contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int|null $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int|null $items_per_page The number of coupons to be displayed per page. The default number of coupons per page is 50. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCouponsCodesContactsContactIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestOrdersCouponsCodesContactsContactIdGet200Response
     */
    public function restOrdersCouponsCodesContactsContactIdGet(
        int $contact_id,
        ?int $page = null,
        ?int $items_per_page = null,
        string $contentType = self::contentTypes['restOrdersCouponsCodesContactsContactIdGet'][0]
    ): \ck\Model\RestOrdersCouponsCodesContactsContactIdGet200Response
    {
        list($response) = $this->restOrdersCouponsCodesContactsContactIdGetWithHttpInfo($contact_id, $page, $items_per_page, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersCouponsCodesContactsContactIdGetWithHttpInfo
     *
     * List redeemed coupon codes of a contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int|null $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int|null $items_per_page The number of coupons to be displayed per page. The default number of coupons per page is 50. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCouponsCodesContactsContactIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestOrdersCouponsCodesContactsContactIdGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersCouponsCodesContactsContactIdGetWithHttpInfo(
        int $contact_id,
        ?int $page = null,
        ?int $items_per_page = null,
        string $contentType = self::contentTypes['restOrdersCouponsCodesContactsContactIdGet'][0]
    ): array
    {
        $request = $this->restOrdersCouponsCodesContactsContactIdGetRequest($contact_id, $page, $items_per_page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestOrdersCouponsCodesContactsContactIdGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestOrdersCouponsCodesContactsContactIdGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestOrdersCouponsCodesContactsContactIdGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestOrdersCouponsCodesContactsContactIdGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestOrdersCouponsCodesContactsContactIdGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersCouponsCodesContactsContactIdGetAsync
     *
     * List redeemed coupon codes of a contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int|null $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int|null $items_per_page The number of coupons to be displayed per page. The default number of coupons per page is 50. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCouponsCodesContactsContactIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersCouponsCodesContactsContactIdGetAsync(
        int $contact_id,
        ?int $page = null,
        ?int $items_per_page = null,
        string $contentType = self::contentTypes['restOrdersCouponsCodesContactsContactIdGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersCouponsCodesContactsContactIdGetAsyncWithHttpInfo($contact_id, $page, $items_per_page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersCouponsCodesContactsContactIdGetAsyncWithHttpInfo
     *
     * List redeemed coupon codes of a contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int|null $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int|null $items_per_page The number of coupons to be displayed per page. The default number of coupons per page is 50. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCouponsCodesContactsContactIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersCouponsCodesContactsContactIdGetAsyncWithHttpInfo(
        $contact_id,
        $page = null,
        $items_per_page = null,
        string $contentType = self::contentTypes['restOrdersCouponsCodesContactsContactIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestOrdersCouponsCodesContactsContactIdGet200Response';
        $request = $this->restOrdersCouponsCodesContactsContactIdGetRequest($contact_id, $page, $items_per_page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersCouponsCodesContactsContactIdGet'
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int|null $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int|null $items_per_page The number of coupons to be displayed per page. The default number of coupons per page is 50. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCouponsCodesContactsContactIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersCouponsCodesContactsContactIdGetRequest(
        $contact_id,
        $page = null,
        $items_per_page = null,
        string $contentType = self::contentTypes['restOrdersCouponsCodesContactsContactIdGet'][0]
    ): Request
    {

        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restOrdersCouponsCodesContactsContactIdGet'
            );
        }




        $resourcePath = '/rest/orders/coupons/codes/contacts/{contactId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $items_per_page,
            'itemsPerPage', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersCouponsCodesCouponPost
     *
     * Validate a coupon
     *
     * @param  string $coupon The coupon to validate. (required)
     * @param  int $plenty_id The plenty id. (required)
     * @param  int $ship_to_country The country of delivery. (required)
     * @param  bool|null $call_from_scheduler Flag that indicates whether the validation is requested by a subscription order or not. TRUE &#x3D; The validation is requested by a subscription order. FALSE &#x3D; The validation is not requested by a subscription order. (optional)
     * @param  string|null $tax_id_number The tax id number. (optional)
     * @param  int|null $contact_class The contact class. (optional)
     * @param  int|null $contact_type The contact type. (optional)
     * @param  \ck\Model\RestOrdersCouponsCodesPostRequest|null $_rest_orders_coupons_codes_coupon _rest_orders_coupons_codes_coupon (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCouponsCodesCouponPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\CouponCodeValidation
     */
    public function restOrdersCouponsCodesCouponPost(
        string $coupon,
        int $plenty_id,
        int $ship_to_country,
        ?bool $call_from_scheduler = null,
        ?string $tax_id_number = null,
        ?int $contact_class = null,
        ?int $contact_type = null,
        ?\ck\Model\RestOrdersCouponsCodesPostRequest $_rest_orders_coupons_codes_coupon = null,
        string $contentType = self::contentTypes['restOrdersCouponsCodesCouponPost'][0]
    ): \ck\Model\CouponCodeValidation
    {
        list($response) = $this->restOrdersCouponsCodesCouponPostWithHttpInfo($coupon, $plenty_id, $ship_to_country, $call_from_scheduler, $tax_id_number, $contact_class, $contact_type, $_rest_orders_coupons_codes_coupon, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersCouponsCodesCouponPostWithHttpInfo
     *
     * Validate a coupon
     *
     * @param  string $coupon The coupon to validate. (required)
     * @param  int $plenty_id The plenty id. (required)
     * @param  int $ship_to_country The country of delivery. (required)
     * @param  bool|null $call_from_scheduler Flag that indicates whether the validation is requested by a subscription order or not. TRUE &#x3D; The validation is requested by a subscription order. FALSE &#x3D; The validation is not requested by a subscription order. (optional)
     * @param  string|null $tax_id_number The tax id number. (optional)
     * @param  int|null $contact_class The contact class. (optional)
     * @param  int|null $contact_type The contact type. (optional)
     * @param  \ck\Model\RestOrdersCouponsCodesPostRequest|null $_rest_orders_coupons_codes_coupon (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCouponsCodesCouponPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\CouponCodeValidation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersCouponsCodesCouponPostWithHttpInfo(
        string $coupon,
        int $plenty_id,
        int $ship_to_country,
        ?bool $call_from_scheduler = null,
        ?string $tax_id_number = null,
        ?int $contact_class = null,
        ?int $contact_type = null,
        ?\ck\Model\RestOrdersCouponsCodesPostRequest $_rest_orders_coupons_codes_coupon = null,
        string $contentType = self::contentTypes['restOrdersCouponsCodesCouponPost'][0]
    ): array
    {
        $request = $this->restOrdersCouponsCodesCouponPostRequest($coupon, $plenty_id, $ship_to_country, $call_from_scheduler, $tax_id_number, $contact_class, $contact_type, $_rest_orders_coupons_codes_coupon, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\CouponCodeValidation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\CouponCodeValidation' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\CouponCodeValidation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\CouponCodeValidation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\CouponCodeValidation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersCouponsCodesCouponPostAsync
     *
     * Validate a coupon
     *
     * @param  string $coupon The coupon to validate. (required)
     * @param  int $plenty_id The plenty id. (required)
     * @param  int $ship_to_country The country of delivery. (required)
     * @param  bool|null $call_from_scheduler Flag that indicates whether the validation is requested by a subscription order or not. TRUE &#x3D; The validation is requested by a subscription order. FALSE &#x3D; The validation is not requested by a subscription order. (optional)
     * @param  string|null $tax_id_number The tax id number. (optional)
     * @param  int|null $contact_class The contact class. (optional)
     * @param  int|null $contact_type The contact type. (optional)
     * @param  \ck\Model\RestOrdersCouponsCodesPostRequest|null $_rest_orders_coupons_codes_coupon (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCouponsCodesCouponPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersCouponsCodesCouponPostAsync(
        string $coupon,
        int $plenty_id,
        int $ship_to_country,
        ?bool $call_from_scheduler = null,
        ?string $tax_id_number = null,
        ?int $contact_class = null,
        ?int $contact_type = null,
        ?\ck\Model\RestOrdersCouponsCodesPostRequest $_rest_orders_coupons_codes_coupon = null,
        string $contentType = self::contentTypes['restOrdersCouponsCodesCouponPost'][0]
    ): PromiseInterface
    {
        return $this->restOrdersCouponsCodesCouponPostAsyncWithHttpInfo($coupon, $plenty_id, $ship_to_country, $call_from_scheduler, $tax_id_number, $contact_class, $contact_type, $_rest_orders_coupons_codes_coupon, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersCouponsCodesCouponPostAsyncWithHttpInfo
     *
     * Validate a coupon
     *
     * @param  string $coupon The coupon to validate. (required)
     * @param  int $plenty_id The plenty id. (required)
     * @param  int $ship_to_country The country of delivery. (required)
     * @param  bool|null $call_from_scheduler Flag that indicates whether the validation is requested by a subscription order or not. TRUE &#x3D; The validation is requested by a subscription order. FALSE &#x3D; The validation is not requested by a subscription order. (optional)
     * @param  string|null $tax_id_number The tax id number. (optional)
     * @param  int|null $contact_class The contact class. (optional)
     * @param  int|null $contact_type The contact type. (optional)
     * @param  \ck\Model\RestOrdersCouponsCodesPostRequest|null $_rest_orders_coupons_codes_coupon (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCouponsCodesCouponPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersCouponsCodesCouponPostAsyncWithHttpInfo(
        $coupon,
        $plenty_id,
        $ship_to_country,
        $call_from_scheduler = null,
        $tax_id_number = null,
        $contact_class = null,
        $contact_type = null,
        $_rest_orders_coupons_codes_coupon = null,
        string $contentType = self::contentTypes['restOrdersCouponsCodesCouponPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\CouponCodeValidation';
        $request = $this->restOrdersCouponsCodesCouponPostRequest($coupon, $plenty_id, $ship_to_country, $call_from_scheduler, $tax_id_number, $contact_class, $contact_type, $_rest_orders_coupons_codes_coupon, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersCouponsCodesCouponPost'
     *
     * @param  string $coupon The coupon to validate. (required)
     * @param  int $plenty_id The plenty id. (required)
     * @param  int $ship_to_country The country of delivery. (required)
     * @param  bool|null $call_from_scheduler Flag that indicates whether the validation is requested by a subscription order or not. TRUE &#x3D; The validation is requested by a subscription order. FALSE &#x3D; The validation is not requested by a subscription order. (optional)
     * @param  string|null $tax_id_number The tax id number. (optional)
     * @param  int|null $contact_class The contact class. (optional)
     * @param  int|null $contact_type The contact type. (optional)
     * @param  \ck\Model\RestOrdersCouponsCodesPostRequest|null $_rest_orders_coupons_codes_coupon (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCouponsCodesCouponPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersCouponsCodesCouponPostRequest(
        $coupon,
        $plenty_id,
        $ship_to_country,
        $call_from_scheduler = null,
        $tax_id_number = null,
        $contact_class = null,
        $contact_type = null,
        $_rest_orders_coupons_codes_coupon = null,
        string $contentType = self::contentTypes['restOrdersCouponsCodesCouponPost'][0]
    ): Request
    {

        // verify the required parameter 'coupon' is set
        if ($coupon === null || (is_array($coupon) && count($coupon) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $coupon when calling restOrdersCouponsCodesCouponPost'
            );
        }

        // verify the required parameter 'plenty_id' is set
        if ($plenty_id === null || (is_array($plenty_id) && count($plenty_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $plenty_id when calling restOrdersCouponsCodesCouponPost'
            );
        }

        // verify the required parameter 'ship_to_country' is set
        if ($ship_to_country === null || (is_array($ship_to_country) && count($ship_to_country) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $ship_to_country when calling restOrdersCouponsCodesCouponPost'
            );
        }







        $resourcePath = '/rest/orders/coupons/codes/{coupon}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $call_from_scheduler,
            'callFromScheduler', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $plenty_id,
            'plentyId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ship_to_country,
            'shipToCountry', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tax_id_number,
            'taxIdNumber', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $contact_class,
            'contactClass', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $contact_type,
            'contactType', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($coupon !== null) {
            $resourcePath = str_replace(
                '{' . 'coupon' . '}',
                ObjectSerializer::toPathValue($coupon),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_orders_coupons_codes_coupon)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_orders_coupons_codes_coupon));
            } else {
                $httpBody = $_rest_orders_coupons_codes_coupon;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersCouponsCodesPost
     *
     * Validate multiple coupons
     *
     * @param  int $coupons The coupons to validate. (required)
     * @param  int $plenty_id The plenty id. (required)
     * @param  int $ship_to_country The country of delivery. (required)
     * @param  bool|null $call_from_scheduler Flag that indicates whether the validation is requested by a subscription order or not. TRUE &#x3D; The validation is requested by a subscription order. FALSE &#x3D; The validation is not requested by a subscription order. (optional)
     * @param  string|null $tax_id_number The tax id number. (optional)
     * @param  int|null $contact_class The contact class. (optional)
     * @param  int|null $contact_type The contact type. (optional)
     * @param  \ck\Model\RestOrdersCouponsCodesPostRequest|null $_rest_orders_coupons_codes _rest_orders_coupons_codes (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCouponsCodesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\CouponCodeValidation[]
     */
    public function restOrdersCouponsCodesPost(
        int $coupons,
        int $plenty_id,
        int $ship_to_country,
        ?bool $call_from_scheduler = null,
        ?string $tax_id_number = null,
        ?int $contact_class = null,
        ?int $contact_type = null,
        ?\ck\Model\RestOrdersCouponsCodesPostRequest $_rest_orders_coupons_codes = null,
        string $contentType = self::contentTypes['restOrdersCouponsCodesPost'][0]
    ): array
    {
        list($response) = $this->restOrdersCouponsCodesPostWithHttpInfo($coupons, $plenty_id, $ship_to_country, $call_from_scheduler, $tax_id_number, $contact_class, $contact_type, $_rest_orders_coupons_codes, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersCouponsCodesPostWithHttpInfo
     *
     * Validate multiple coupons
     *
     * @param  int $coupons The coupons to validate. (required)
     * @param  int $plenty_id The plenty id. (required)
     * @param  int $ship_to_country The country of delivery. (required)
     * @param  bool|null $call_from_scheduler Flag that indicates whether the validation is requested by a subscription order or not. TRUE &#x3D; The validation is requested by a subscription order. FALSE &#x3D; The validation is not requested by a subscription order. (optional)
     * @param  string|null $tax_id_number The tax id number. (optional)
     * @param  int|null $contact_class The contact class. (optional)
     * @param  int|null $contact_type The contact type. (optional)
     * @param  \ck\Model\RestOrdersCouponsCodesPostRequest|null $_rest_orders_coupons_codes (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCouponsCodesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\CouponCodeValidation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersCouponsCodesPostWithHttpInfo(
        int $coupons,
        int $plenty_id,
        int $ship_to_country,
        ?bool $call_from_scheduler = null,
        ?string $tax_id_number = null,
        ?int $contact_class = null,
        ?int $contact_type = null,
        ?\ck\Model\RestOrdersCouponsCodesPostRequest $_rest_orders_coupons_codes = null,
        string $contentType = self::contentTypes['restOrdersCouponsCodesPost'][0]
    ): array
    {
        $request = $this->restOrdersCouponsCodesPostRequest($coupons, $plenty_id, $ship_to_country, $call_from_scheduler, $tax_id_number, $contact_class, $contact_type, $_rest_orders_coupons_codes, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\CouponCodeValidation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\CouponCodeValidation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\CouponCodeValidation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\CouponCodeValidation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\CouponCodeValidation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersCouponsCodesPostAsync
     *
     * Validate multiple coupons
     *
     * @param  int $coupons The coupons to validate. (required)
     * @param  int $plenty_id The plenty id. (required)
     * @param  int $ship_to_country The country of delivery. (required)
     * @param  bool|null $call_from_scheduler Flag that indicates whether the validation is requested by a subscription order or not. TRUE &#x3D; The validation is requested by a subscription order. FALSE &#x3D; The validation is not requested by a subscription order. (optional)
     * @param  string|null $tax_id_number The tax id number. (optional)
     * @param  int|null $contact_class The contact class. (optional)
     * @param  int|null $contact_type The contact type. (optional)
     * @param  \ck\Model\RestOrdersCouponsCodesPostRequest|null $_rest_orders_coupons_codes (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCouponsCodesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersCouponsCodesPostAsync(
        int $coupons,
        int $plenty_id,
        int $ship_to_country,
        ?bool $call_from_scheduler = null,
        ?string $tax_id_number = null,
        ?int $contact_class = null,
        ?int $contact_type = null,
        ?\ck\Model\RestOrdersCouponsCodesPostRequest $_rest_orders_coupons_codes = null,
        string $contentType = self::contentTypes['restOrdersCouponsCodesPost'][0]
    ): PromiseInterface
    {
        return $this->restOrdersCouponsCodesPostAsyncWithHttpInfo($coupons, $plenty_id, $ship_to_country, $call_from_scheduler, $tax_id_number, $contact_class, $contact_type, $_rest_orders_coupons_codes, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersCouponsCodesPostAsyncWithHttpInfo
     *
     * Validate multiple coupons
     *
     * @param  int $coupons The coupons to validate. (required)
     * @param  int $plenty_id The plenty id. (required)
     * @param  int $ship_to_country The country of delivery. (required)
     * @param  bool|null $call_from_scheduler Flag that indicates whether the validation is requested by a subscription order or not. TRUE &#x3D; The validation is requested by a subscription order. FALSE &#x3D; The validation is not requested by a subscription order. (optional)
     * @param  string|null $tax_id_number The tax id number. (optional)
     * @param  int|null $contact_class The contact class. (optional)
     * @param  int|null $contact_type The contact type. (optional)
     * @param  \ck\Model\RestOrdersCouponsCodesPostRequest|null $_rest_orders_coupons_codes (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCouponsCodesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersCouponsCodesPostAsyncWithHttpInfo(
        $coupons,
        $plenty_id,
        $ship_to_country,
        $call_from_scheduler = null,
        $tax_id_number = null,
        $contact_class = null,
        $contact_type = null,
        $_rest_orders_coupons_codes = null,
        string $contentType = self::contentTypes['restOrdersCouponsCodesPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\CouponCodeValidation[]';
        $request = $this->restOrdersCouponsCodesPostRequest($coupons, $plenty_id, $ship_to_country, $call_from_scheduler, $tax_id_number, $contact_class, $contact_type, $_rest_orders_coupons_codes, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersCouponsCodesPost'
     *
     * @param  int $coupons The coupons to validate. (required)
     * @param  int $plenty_id The plenty id. (required)
     * @param  int $ship_to_country The country of delivery. (required)
     * @param  bool|null $call_from_scheduler Flag that indicates whether the validation is requested by a subscription order or not. TRUE &#x3D; The validation is requested by a subscription order. FALSE &#x3D; The validation is not requested by a subscription order. (optional)
     * @param  string|null $tax_id_number The tax id number. (optional)
     * @param  int|null $contact_class The contact class. (optional)
     * @param  int|null $contact_type The contact type. (optional)
     * @param  \ck\Model\RestOrdersCouponsCodesPostRequest|null $_rest_orders_coupons_codes (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCouponsCodesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersCouponsCodesPostRequest(
        $coupons,
        $plenty_id,
        $ship_to_country,
        $call_from_scheduler = null,
        $tax_id_number = null,
        $contact_class = null,
        $contact_type = null,
        $_rest_orders_coupons_codes = null,
        string $contentType = self::contentTypes['restOrdersCouponsCodesPost'][0]
    ): Request
    {

        // verify the required parameter 'coupons' is set
        if ($coupons === null || (is_array($coupons) && count($coupons) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $coupons when calling restOrdersCouponsCodesPost'
            );
        }

        // verify the required parameter 'plenty_id' is set
        if ($plenty_id === null || (is_array($plenty_id) && count($plenty_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $plenty_id when calling restOrdersCouponsCodesPost'
            );
        }

        // verify the required parameter 'ship_to_country' is set
        if ($ship_to_country === null || (is_array($ship_to_country) && count($ship_to_country) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $ship_to_country when calling restOrdersCouponsCodesPost'
            );
        }







        $resourcePath = '/rest/orders/coupons/codes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $coupons,
            'coupons', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $call_from_scheduler,
            'callFromScheduler', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $plenty_id,
            'plentyId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ship_to_country,
            'shipToCountry', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tax_id_number,
            'taxIdNumber', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $contact_class,
            'contactClass', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $contact_type,
            'contactType', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_orders_coupons_codes)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_orders_coupons_codes));
            } else {
                $httpBody = $_rest_orders_coupons_codes;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersCurrenciesCountriesCountryIdGet
     *
     * Get a currency for a country
     *
     * @param  int $country_id country_id (required)
     * @param  int|null $columns The attributes to be loaded (optional)
     * @param  int|null $with The relations to be loaded. Valid relations are &#39;names&#39; or &#39;countries&#39;). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCurrenciesCountriesCountryIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Currency
     */
    public function restOrdersCurrenciesCountriesCountryIdGet(
        int $country_id,
        ?int $columns = null,
        ?int $with = null,
        string $contentType = self::contentTypes['restOrdersCurrenciesCountriesCountryIdGet'][0]
    ): \ck\Model\Currency
    {
        list($response) = $this->restOrdersCurrenciesCountriesCountryIdGetWithHttpInfo($country_id, $columns, $with, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersCurrenciesCountriesCountryIdGetWithHttpInfo
     *
     * Get a currency for a country
     *
     * @param  int $country_id (required)
     * @param  int|null $columns The attributes to be loaded (optional)
     * @param  int|null $with The relations to be loaded. Valid relations are &#39;names&#39; or &#39;countries&#39;). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCurrenciesCountriesCountryIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Currency, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersCurrenciesCountriesCountryIdGetWithHttpInfo(
        int $country_id,
        ?int $columns = null,
        ?int $with = null,
        string $contentType = self::contentTypes['restOrdersCurrenciesCountriesCountryIdGet'][0]
    ): array
    {
        $request = $this->restOrdersCurrenciesCountriesCountryIdGetRequest($country_id, $columns, $with, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Currency' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Currency' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Currency', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Currency';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Currency',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersCurrenciesCountriesCountryIdGetAsync
     *
     * Get a currency for a country
     *
     * @param  int $country_id (required)
     * @param  int|null $columns The attributes to be loaded (optional)
     * @param  int|null $with The relations to be loaded. Valid relations are &#39;names&#39; or &#39;countries&#39;). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCurrenciesCountriesCountryIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersCurrenciesCountriesCountryIdGetAsync(
        int $country_id,
        ?int $columns = null,
        ?int $with = null,
        string $contentType = self::contentTypes['restOrdersCurrenciesCountriesCountryIdGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersCurrenciesCountriesCountryIdGetAsyncWithHttpInfo($country_id, $columns, $with, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersCurrenciesCountriesCountryIdGetAsyncWithHttpInfo
     *
     * Get a currency for a country
     *
     * @param  int $country_id (required)
     * @param  int|null $columns The attributes to be loaded (optional)
     * @param  int|null $with The relations to be loaded. Valid relations are &#39;names&#39; or &#39;countries&#39;). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCurrenciesCountriesCountryIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersCurrenciesCountriesCountryIdGetAsyncWithHttpInfo(
        $country_id,
        $columns = null,
        $with = null,
        string $contentType = self::contentTypes['restOrdersCurrenciesCountriesCountryIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Currency';
        $request = $this->restOrdersCurrenciesCountriesCountryIdGetRequest($country_id, $columns, $with, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersCurrenciesCountriesCountryIdGet'
     *
     * @param  int $country_id (required)
     * @param  int|null $columns The attributes to be loaded (optional)
     * @param  int|null $with The relations to be loaded. Valid relations are &#39;names&#39; or &#39;countries&#39;). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCurrenciesCountriesCountryIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersCurrenciesCountriesCountryIdGetRequest(
        $country_id,
        $columns = null,
        $with = null,
        string $contentType = self::contentTypes['restOrdersCurrenciesCountriesCountryIdGet'][0]
    ): Request
    {

        // verify the required parameter 'country_id' is set
        if ($country_id === null || (is_array($country_id) && count($country_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $country_id when calling restOrdersCurrenciesCountriesCountryIdGet'
            );
        }




        $resourcePath = '/rest/orders/currencies/countries/{countryId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $columns,
            'columns', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($country_id !== null) {
            $resourcePath = str_replace(
                '{' . 'countryId' . '}',
                ObjectSerializer::toPathValue($country_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersCurrenciesCurrencyIsoCountriesGet
     *
     * List countries for a currency
     *
     * @param  string $currency_iso The ISO 4217 code of the currency (required)
     * @param  int|null $columns The attributes to be loaded (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCurrenciesCurrencyIsoCountriesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Country[]
     */
    public function restOrdersCurrenciesCurrencyIsoCountriesGet(
        string $currency_iso,
        ?int $columns = null,
        string $contentType = self::contentTypes['restOrdersCurrenciesCurrencyIsoCountriesGet'][0]
    ): array
    {
        list($response) = $this->restOrdersCurrenciesCurrencyIsoCountriesGetWithHttpInfo($currency_iso, $columns, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersCurrenciesCurrencyIsoCountriesGetWithHttpInfo
     *
     * List countries for a currency
     *
     * @param  string $currency_iso The ISO 4217 code of the currency (required)
     * @param  int|null $columns The attributes to be loaded (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCurrenciesCurrencyIsoCountriesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Country[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersCurrenciesCurrencyIsoCountriesGetWithHttpInfo(
        string $currency_iso,
        ?int $columns = null,
        string $contentType = self::contentTypes['restOrdersCurrenciesCurrencyIsoCountriesGet'][0]
    ): array
    {
        $request = $this->restOrdersCurrenciesCurrencyIsoCountriesGetRequest($currency_iso, $columns, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Country[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Country[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Country[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Country[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Country[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersCurrenciesCurrencyIsoCountriesGetAsync
     *
     * List countries for a currency
     *
     * @param  string $currency_iso The ISO 4217 code of the currency (required)
     * @param  int|null $columns The attributes to be loaded (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCurrenciesCurrencyIsoCountriesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersCurrenciesCurrencyIsoCountriesGetAsync(
        string $currency_iso,
        ?int $columns = null,
        string $contentType = self::contentTypes['restOrdersCurrenciesCurrencyIsoCountriesGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersCurrenciesCurrencyIsoCountriesGetAsyncWithHttpInfo($currency_iso, $columns, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersCurrenciesCurrencyIsoCountriesGetAsyncWithHttpInfo
     *
     * List countries for a currency
     *
     * @param  string $currency_iso The ISO 4217 code of the currency (required)
     * @param  int|null $columns The attributes to be loaded (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCurrenciesCurrencyIsoCountriesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersCurrenciesCurrencyIsoCountriesGetAsyncWithHttpInfo(
        $currency_iso,
        $columns = null,
        string $contentType = self::contentTypes['restOrdersCurrenciesCurrencyIsoCountriesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Country[]';
        $request = $this->restOrdersCurrenciesCurrencyIsoCountriesGetRequest($currency_iso, $columns, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersCurrenciesCurrencyIsoCountriesGet'
     *
     * @param  string $currency_iso The ISO 4217 code of the currency (required)
     * @param  int|null $columns The attributes to be loaded (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCurrenciesCurrencyIsoCountriesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersCurrenciesCurrencyIsoCountriesGetRequest(
        $currency_iso,
        $columns = null,
        string $contentType = self::contentTypes['restOrdersCurrenciesCurrencyIsoCountriesGet'][0]
    ): Request
    {

        // verify the required parameter 'currency_iso' is set
        if ($currency_iso === null || (is_array($currency_iso) && count($currency_iso) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $currency_iso when calling restOrdersCurrenciesCurrencyIsoCountriesGet'
            );
        }



        $resourcePath = '/rest/orders/currencies/{currencyIso}/countries';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $columns,
            'columns', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($currency_iso !== null) {
            $resourcePath = str_replace(
                '{' . 'currencyIso' . '}',
                ObjectSerializer::toPathValue($currency_iso),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersCurrenciesCurrencyIsoExchangeRateGet
     *
     * Get the exchange rate for a currency
     *
     * @param  int $currency_iso currency_iso (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCurrenciesCurrencyIsoExchangeRateGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\CurrencyExchangeRate
     */
    public function restOrdersCurrenciesCurrencyIsoExchangeRateGet(
        int $currency_iso,
        string $contentType = self::contentTypes['restOrdersCurrenciesCurrencyIsoExchangeRateGet'][0]
    ): \ck\Model\CurrencyExchangeRate
    {
        list($response) = $this->restOrdersCurrenciesCurrencyIsoExchangeRateGetWithHttpInfo($currency_iso, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersCurrenciesCurrencyIsoExchangeRateGetWithHttpInfo
     *
     * Get the exchange rate for a currency
     *
     * @param  int $currency_iso (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCurrenciesCurrencyIsoExchangeRateGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\CurrencyExchangeRate, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersCurrenciesCurrencyIsoExchangeRateGetWithHttpInfo(
        int $currency_iso,
        string $contentType = self::contentTypes['restOrdersCurrenciesCurrencyIsoExchangeRateGet'][0]
    ): array
    {
        $request = $this->restOrdersCurrenciesCurrencyIsoExchangeRateGetRequest($currency_iso, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\CurrencyExchangeRate' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\CurrencyExchangeRate' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\CurrencyExchangeRate', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\CurrencyExchangeRate';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\CurrencyExchangeRate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersCurrenciesCurrencyIsoExchangeRateGetAsync
     *
     * Get the exchange rate for a currency
     *
     * @param  int $currency_iso (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCurrenciesCurrencyIsoExchangeRateGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersCurrenciesCurrencyIsoExchangeRateGetAsync(
        int $currency_iso,
        string $contentType = self::contentTypes['restOrdersCurrenciesCurrencyIsoExchangeRateGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersCurrenciesCurrencyIsoExchangeRateGetAsyncWithHttpInfo($currency_iso, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersCurrenciesCurrencyIsoExchangeRateGetAsyncWithHttpInfo
     *
     * Get the exchange rate for a currency
     *
     * @param  int $currency_iso (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCurrenciesCurrencyIsoExchangeRateGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersCurrenciesCurrencyIsoExchangeRateGetAsyncWithHttpInfo(
        $currency_iso,
        string $contentType = self::contentTypes['restOrdersCurrenciesCurrencyIsoExchangeRateGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\CurrencyExchangeRate';
        $request = $this->restOrdersCurrenciesCurrencyIsoExchangeRateGetRequest($currency_iso, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersCurrenciesCurrencyIsoExchangeRateGet'
     *
     * @param  int $currency_iso (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCurrenciesCurrencyIsoExchangeRateGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersCurrenciesCurrencyIsoExchangeRateGetRequest(
        $currency_iso,
        string $contentType = self::contentTypes['restOrdersCurrenciesCurrencyIsoExchangeRateGet'][0]
    ): Request
    {

        // verify the required parameter 'currency_iso' is set
        if ($currency_iso === null || (is_array($currency_iso) && count($currency_iso) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $currency_iso when calling restOrdersCurrenciesCurrencyIsoExchangeRateGet'
            );
        }


        $resourcePath = '/rest/orders/currencies/{currencyIso}/exchangeRate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($currency_iso !== null) {
            $resourcePath = str_replace(
                '{' . 'currencyIso' . '}',
                ObjectSerializer::toPathValue($currency_iso),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersCurrenciesCurrencyIsoGet
     *
     * Get a currency
     *
     * @param  string $currency_iso The ISO 4217 code of the currency (required)
     * @param  int|null $columns The attributes to be loaded (optional)
     * @param  int|null $with The relations to be loaded. Valid relations are &#39;names&#39; or &#39;countries&#39; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCurrenciesCurrencyIsoGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Currency
     */
    public function restOrdersCurrenciesCurrencyIsoGet(
        string $currency_iso,
        ?int $columns = null,
        ?int $with = null,
        string $contentType = self::contentTypes['restOrdersCurrenciesCurrencyIsoGet'][0]
    ): \ck\Model\Currency
    {
        list($response) = $this->restOrdersCurrenciesCurrencyIsoGetWithHttpInfo($currency_iso, $columns, $with, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersCurrenciesCurrencyIsoGetWithHttpInfo
     *
     * Get a currency
     *
     * @param  string $currency_iso The ISO 4217 code of the currency (required)
     * @param  int|null $columns The attributes to be loaded (optional)
     * @param  int|null $with The relations to be loaded. Valid relations are &#39;names&#39; or &#39;countries&#39; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCurrenciesCurrencyIsoGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Currency, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersCurrenciesCurrencyIsoGetWithHttpInfo(
        string $currency_iso,
        ?int $columns = null,
        ?int $with = null,
        string $contentType = self::contentTypes['restOrdersCurrenciesCurrencyIsoGet'][0]
    ): array
    {
        $request = $this->restOrdersCurrenciesCurrencyIsoGetRequest($currency_iso, $columns, $with, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Currency' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Currency' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Currency', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Currency';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Currency',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersCurrenciesCurrencyIsoGetAsync
     *
     * Get a currency
     *
     * @param  string $currency_iso The ISO 4217 code of the currency (required)
     * @param  int|null $columns The attributes to be loaded (optional)
     * @param  int|null $with The relations to be loaded. Valid relations are &#39;names&#39; or &#39;countries&#39; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCurrenciesCurrencyIsoGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersCurrenciesCurrencyIsoGetAsync(
        string $currency_iso,
        ?int $columns = null,
        ?int $with = null,
        string $contentType = self::contentTypes['restOrdersCurrenciesCurrencyIsoGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersCurrenciesCurrencyIsoGetAsyncWithHttpInfo($currency_iso, $columns, $with, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersCurrenciesCurrencyIsoGetAsyncWithHttpInfo
     *
     * Get a currency
     *
     * @param  string $currency_iso The ISO 4217 code of the currency (required)
     * @param  int|null $columns The attributes to be loaded (optional)
     * @param  int|null $with The relations to be loaded. Valid relations are &#39;names&#39; or &#39;countries&#39; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCurrenciesCurrencyIsoGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersCurrenciesCurrencyIsoGetAsyncWithHttpInfo(
        $currency_iso,
        $columns = null,
        $with = null,
        string $contentType = self::contentTypes['restOrdersCurrenciesCurrencyIsoGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Currency';
        $request = $this->restOrdersCurrenciesCurrencyIsoGetRequest($currency_iso, $columns, $with, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersCurrenciesCurrencyIsoGet'
     *
     * @param  string $currency_iso The ISO 4217 code of the currency (required)
     * @param  int|null $columns The attributes to be loaded (optional)
     * @param  int|null $with The relations to be loaded. Valid relations are &#39;names&#39; or &#39;countries&#39; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCurrenciesCurrencyIsoGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersCurrenciesCurrencyIsoGetRequest(
        $currency_iso,
        $columns = null,
        $with = null,
        string $contentType = self::contentTypes['restOrdersCurrenciesCurrencyIsoGet'][0]
    ): Request
    {

        // verify the required parameter 'currency_iso' is set
        if ($currency_iso === null || (is_array($currency_iso) && count($currency_iso) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $currency_iso when calling restOrdersCurrenciesCurrencyIsoGet'
            );
        }




        $resourcePath = '/rest/orders/currencies/{currencyIso}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $columns,
            'columns', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($currency_iso !== null) {
            $resourcePath = str_replace(
                '{' . 'currencyIso' . '}',
                ObjectSerializer::toPathValue($currency_iso),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersCurrenciesExchangeRatesFromCurrencyIsoGet
     *
     * Get the exchange rates from a currency
     *
     * @param  int $currency_iso currency_iso (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCurrenciesExchangeRatesFromCurrencyIsoGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object[]
     */
    public function restOrdersCurrenciesExchangeRatesFromCurrencyIsoGet(
        int $currency_iso,
        string $contentType = self::contentTypes['restOrdersCurrenciesExchangeRatesFromCurrencyIsoGet'][0]
    ): array
    {
        list($response) = $this->restOrdersCurrenciesExchangeRatesFromCurrencyIsoGetWithHttpInfo($currency_iso, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersCurrenciesExchangeRatesFromCurrencyIsoGetWithHttpInfo
     *
     * Get the exchange rates from a currency
     *
     * @param  int $currency_iso (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCurrenciesExchangeRatesFromCurrencyIsoGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersCurrenciesExchangeRatesFromCurrencyIsoGetWithHttpInfo(
        int $currency_iso,
        string $contentType = self::contentTypes['restOrdersCurrenciesExchangeRatesFromCurrencyIsoGet'][0]
    ): array
    {
        $request = $this->restOrdersCurrenciesExchangeRatesFromCurrencyIsoGetRequest($currency_iso, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersCurrenciesExchangeRatesFromCurrencyIsoGetAsync
     *
     * Get the exchange rates from a currency
     *
     * @param  int $currency_iso (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCurrenciesExchangeRatesFromCurrencyIsoGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersCurrenciesExchangeRatesFromCurrencyIsoGetAsync(
        int $currency_iso,
        string $contentType = self::contentTypes['restOrdersCurrenciesExchangeRatesFromCurrencyIsoGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersCurrenciesExchangeRatesFromCurrencyIsoGetAsyncWithHttpInfo($currency_iso, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersCurrenciesExchangeRatesFromCurrencyIsoGetAsyncWithHttpInfo
     *
     * Get the exchange rates from a currency
     *
     * @param  int $currency_iso (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCurrenciesExchangeRatesFromCurrencyIsoGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersCurrenciesExchangeRatesFromCurrencyIsoGetAsyncWithHttpInfo(
        $currency_iso,
        string $contentType = self::contentTypes['restOrdersCurrenciesExchangeRatesFromCurrencyIsoGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object[]';
        $request = $this->restOrdersCurrenciesExchangeRatesFromCurrencyIsoGetRequest($currency_iso, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersCurrenciesExchangeRatesFromCurrencyIsoGet'
     *
     * @param  int $currency_iso (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCurrenciesExchangeRatesFromCurrencyIsoGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersCurrenciesExchangeRatesFromCurrencyIsoGetRequest(
        $currency_iso,
        string $contentType = self::contentTypes['restOrdersCurrenciesExchangeRatesFromCurrencyIsoGet'][0]
    ): Request
    {

        // verify the required parameter 'currency_iso' is set
        if ($currency_iso === null || (is_array($currency_iso) && count($currency_iso) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $currency_iso when calling restOrdersCurrenciesExchangeRatesFromCurrencyIsoGet'
            );
        }


        $resourcePath = '/rest/orders/currencies/exchange_rates/from/{currencyIso}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($currency_iso !== null) {
            $resourcePath = str_replace(
                '{' . 'currencyIso' . '}',
                ObjectSerializer::toPathValue($currency_iso),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersCurrenciesExchangeRatesToCurrencyIsoGet
     *
     * Get the exchange rates to a currency
     *
     * @param  int $currency_iso currency_iso (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCurrenciesExchangeRatesToCurrencyIsoGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object[]
     */
    public function restOrdersCurrenciesExchangeRatesToCurrencyIsoGet(
        int $currency_iso,
        string $contentType = self::contentTypes['restOrdersCurrenciesExchangeRatesToCurrencyIsoGet'][0]
    ): array
    {
        list($response) = $this->restOrdersCurrenciesExchangeRatesToCurrencyIsoGetWithHttpInfo($currency_iso, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersCurrenciesExchangeRatesToCurrencyIsoGetWithHttpInfo
     *
     * Get the exchange rates to a currency
     *
     * @param  int $currency_iso (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCurrenciesExchangeRatesToCurrencyIsoGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersCurrenciesExchangeRatesToCurrencyIsoGetWithHttpInfo(
        int $currency_iso,
        string $contentType = self::contentTypes['restOrdersCurrenciesExchangeRatesToCurrencyIsoGet'][0]
    ): array
    {
        $request = $this->restOrdersCurrenciesExchangeRatesToCurrencyIsoGetRequest($currency_iso, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersCurrenciesExchangeRatesToCurrencyIsoGetAsync
     *
     * Get the exchange rates to a currency
     *
     * @param  int $currency_iso (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCurrenciesExchangeRatesToCurrencyIsoGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersCurrenciesExchangeRatesToCurrencyIsoGetAsync(
        int $currency_iso,
        string $contentType = self::contentTypes['restOrdersCurrenciesExchangeRatesToCurrencyIsoGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersCurrenciesExchangeRatesToCurrencyIsoGetAsyncWithHttpInfo($currency_iso, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersCurrenciesExchangeRatesToCurrencyIsoGetAsyncWithHttpInfo
     *
     * Get the exchange rates to a currency
     *
     * @param  int $currency_iso (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCurrenciesExchangeRatesToCurrencyIsoGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersCurrenciesExchangeRatesToCurrencyIsoGetAsyncWithHttpInfo(
        $currency_iso,
        string $contentType = self::contentTypes['restOrdersCurrenciesExchangeRatesToCurrencyIsoGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object[]';
        $request = $this->restOrdersCurrenciesExchangeRatesToCurrencyIsoGetRequest($currency_iso, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersCurrenciesExchangeRatesToCurrencyIsoGet'
     *
     * @param  int $currency_iso (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCurrenciesExchangeRatesToCurrencyIsoGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersCurrenciesExchangeRatesToCurrencyIsoGetRequest(
        $currency_iso,
        string $contentType = self::contentTypes['restOrdersCurrenciesExchangeRatesToCurrencyIsoGet'][0]
    ): Request
    {

        // verify the required parameter 'currency_iso' is set
        if ($currency_iso === null || (is_array($currency_iso) && count($currency_iso) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $currency_iso when calling restOrdersCurrenciesExchangeRatesToCurrencyIsoGet'
            );
        }


        $resourcePath = '/rest/orders/currencies/exchange_rates/to/{currencyIso}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($currency_iso !== null) {
            $resourcePath = str_replace(
                '{' . 'currencyIso' . '}',
                ObjectSerializer::toPathValue($currency_iso),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersCurrenciesGet
     *
     * List currencies
     *
     * @param  int|null $columns The attributes to be loaded (optional)
     * @param  int|null $with The relations to be loaded. Valid relations are &#39;names&#39; or &#39;countries&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCurrenciesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Currency[]
     */
    public function restOrdersCurrenciesGet(
        ?int $columns = null,
        ?int $with = null,
        string $contentType = self::contentTypes['restOrdersCurrenciesGet'][0]
    ): array
    {
        list($response) = $this->restOrdersCurrenciesGetWithHttpInfo($columns, $with, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersCurrenciesGetWithHttpInfo
     *
     * List currencies
     *
     * @param  int|null $columns The attributes to be loaded (optional)
     * @param  int|null $with The relations to be loaded. Valid relations are &#39;names&#39; or &#39;countries&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCurrenciesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Currency[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersCurrenciesGetWithHttpInfo(
        ?int $columns = null,
        ?int $with = null,
        string $contentType = self::contentTypes['restOrdersCurrenciesGet'][0]
    ): array
    {
        $request = $this->restOrdersCurrenciesGetRequest($columns, $with, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Currency[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Currency[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Currency[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Currency[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Currency[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersCurrenciesGetAsync
     *
     * List currencies
     *
     * @param  int|null $columns The attributes to be loaded (optional)
     * @param  int|null $with The relations to be loaded. Valid relations are &#39;names&#39; or &#39;countries&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCurrenciesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersCurrenciesGetAsync(
        ?int $columns = null,
        ?int $with = null,
        string $contentType = self::contentTypes['restOrdersCurrenciesGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersCurrenciesGetAsyncWithHttpInfo($columns, $with, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersCurrenciesGetAsyncWithHttpInfo
     *
     * List currencies
     *
     * @param  int|null $columns The attributes to be loaded (optional)
     * @param  int|null $with The relations to be loaded. Valid relations are &#39;names&#39; or &#39;countries&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCurrenciesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersCurrenciesGetAsyncWithHttpInfo(
        $columns = null,
        $with = null,
        string $contentType = self::contentTypes['restOrdersCurrenciesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Currency[]';
        $request = $this->restOrdersCurrenciesGetRequest($columns, $with, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersCurrenciesGet'
     *
     * @param  int|null $columns The attributes to be loaded (optional)
     * @param  int|null $with The relations to be loaded. Valid relations are &#39;names&#39; or &#39;countries&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersCurrenciesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersCurrenciesGetRequest(
        $columns = null,
        $with = null,
        string $contentType = self::contentTypes['restOrdersCurrenciesGet'][0]
    ): Request
    {




        $resourcePath = '/rest/orders/currencies';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $columns,
            'columns', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersDatesTypesGet
     *
     * List order date types
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersDatesTypesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\OrderDateType[]
     */
    public function restOrdersDatesTypesGet(
        string $contentType = self::contentTypes['restOrdersDatesTypesGet'][0]
    ): array
    {
        list($response) = $this->restOrdersDatesTypesGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restOrdersDatesTypesGetWithHttpInfo
     *
     * List order date types
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersDatesTypesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\OrderDateType[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersDatesTypesGetWithHttpInfo(
        string $contentType = self::contentTypes['restOrdersDatesTypesGet'][0]
    ): array
    {
        $request = $this->restOrdersDatesTypesGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\OrderDateType[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\OrderDateType[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\OrderDateType[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\OrderDateType[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\OrderDateType[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersDatesTypesGetAsync
     *
     * List order date types
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersDatesTypesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersDatesTypesGetAsync(
        string $contentType = self::contentTypes['restOrdersDatesTypesGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersDatesTypesGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersDatesTypesGetAsyncWithHttpInfo
     *
     * List order date types
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersDatesTypesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersDatesTypesGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restOrdersDatesTypesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\OrderDateType[]';
        $request = $this->restOrdersDatesTypesGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersDatesTypesGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersDatesTypesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersDatesTypesGetRequest(
        string $contentType = self::contentTypes['restOrdersDatesTypesGet'][0]
    ): Request
    {


        $resourcePath = '/rest/orders/dates/types';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersDatesTypesTypeIdGet
     *
     * Find an order date type
     *
     * @param  int $type_id type_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersDatesTypesTypeIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\OrderDateType
     */
    public function restOrdersDatesTypesTypeIdGet(
        int $type_id,
        string $contentType = self::contentTypes['restOrdersDatesTypesTypeIdGet'][0]
    ): \ck\Model\OrderDateType
    {
        list($response) = $this->restOrdersDatesTypesTypeIdGetWithHttpInfo($type_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersDatesTypesTypeIdGetWithHttpInfo
     *
     * Find an order date type
     *
     * @param  int $type_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersDatesTypesTypeIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\OrderDateType, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersDatesTypesTypeIdGetWithHttpInfo(
        int $type_id,
        string $contentType = self::contentTypes['restOrdersDatesTypesTypeIdGet'][0]
    ): array
    {
        $request = $this->restOrdersDatesTypesTypeIdGetRequest($type_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\OrderDateType' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\OrderDateType' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\OrderDateType', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\OrderDateType';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\OrderDateType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersDatesTypesTypeIdGetAsync
     *
     * Find an order date type
     *
     * @param  int $type_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersDatesTypesTypeIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersDatesTypesTypeIdGetAsync(
        int $type_id,
        string $contentType = self::contentTypes['restOrdersDatesTypesTypeIdGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersDatesTypesTypeIdGetAsyncWithHttpInfo($type_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersDatesTypesTypeIdGetAsyncWithHttpInfo
     *
     * Find an order date type
     *
     * @param  int $type_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersDatesTypesTypeIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersDatesTypesTypeIdGetAsyncWithHttpInfo(
        $type_id,
        string $contentType = self::contentTypes['restOrdersDatesTypesTypeIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\OrderDateType';
        $request = $this->restOrdersDatesTypesTypeIdGetRequest($type_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersDatesTypesTypeIdGet'
     *
     * @param  int $type_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersDatesTypesTypeIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersDatesTypesTypeIdGetRequest(
        $type_id,
        string $contentType = self::contentTypes['restOrdersDatesTypesTypeIdGet'][0]
    ): Request
    {

        // verify the required parameter 'type_id' is set
        if ($type_id === null || (is_array($type_id) && count($type_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $type_id when calling restOrdersDatesTypesTypeIdGet'
            );
        }


        $resourcePath = '/rest/orders/dates/types/{typeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'typeId' . '}',
                ObjectSerializer::toPathValue($type_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersDatesTypesTypeIdNamesGet
     *
     * List names of an order date type
     *
     * @param  int $type_id The Id of the OrderDateType to be found (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersDatesTypesTypeIdNamesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\OrderDateTypeName[]
     */
    public function restOrdersDatesTypesTypeIdNamesGet(
        int $type_id,
        string $contentType = self::contentTypes['restOrdersDatesTypesTypeIdNamesGet'][0]
    ): array
    {
        list($response) = $this->restOrdersDatesTypesTypeIdNamesGetWithHttpInfo($type_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersDatesTypesTypeIdNamesGetWithHttpInfo
     *
     * List names of an order date type
     *
     * @param  int $type_id The Id of the OrderDateType to be found (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersDatesTypesTypeIdNamesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\OrderDateTypeName[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersDatesTypesTypeIdNamesGetWithHttpInfo(
        int $type_id,
        string $contentType = self::contentTypes['restOrdersDatesTypesTypeIdNamesGet'][0]
    ): array
    {
        $request = $this->restOrdersDatesTypesTypeIdNamesGetRequest($type_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\OrderDateTypeName[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\OrderDateTypeName[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\OrderDateTypeName[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\OrderDateTypeName[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\OrderDateTypeName[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersDatesTypesTypeIdNamesGetAsync
     *
     * List names of an order date type
     *
     * @param  int $type_id The Id of the OrderDateType to be found (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersDatesTypesTypeIdNamesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersDatesTypesTypeIdNamesGetAsync(
        int $type_id,
        string $contentType = self::contentTypes['restOrdersDatesTypesTypeIdNamesGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersDatesTypesTypeIdNamesGetAsyncWithHttpInfo($type_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersDatesTypesTypeIdNamesGetAsyncWithHttpInfo
     *
     * List names of an order date type
     *
     * @param  int $type_id The Id of the OrderDateType to be found (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersDatesTypesTypeIdNamesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersDatesTypesTypeIdNamesGetAsyncWithHttpInfo(
        $type_id,
        string $contentType = self::contentTypes['restOrdersDatesTypesTypeIdNamesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\OrderDateTypeName[]';
        $request = $this->restOrdersDatesTypesTypeIdNamesGetRequest($type_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersDatesTypesTypeIdNamesGet'
     *
     * @param  int $type_id The Id of the OrderDateType to be found (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersDatesTypesTypeIdNamesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersDatesTypesTypeIdNamesGetRequest(
        $type_id,
        string $contentType = self::contentTypes['restOrdersDatesTypesTypeIdNamesGet'][0]
    ): Request
    {

        // verify the required parameter 'type_id' is set
        if ($type_id === null || (is_array($type_id) && count($type_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $type_id when calling restOrdersDatesTypesTypeIdNamesGet'
            );
        }


        $resourcePath = '/rest/orders/dates/types/{typeId}/names';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'typeId' . '}',
                ObjectSerializer::toPathValue($type_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersDatesTypesTypeIdNamesLangGet
     *
     * Get a name of an order date type
     *
     * @param  int $type_id The ID of the order date type that should be found (required)
     * @param  string $lang The language of the order date type name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersDatesTypesTypeIdNamesLangGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\OrderDateTypeName
     */
    public function restOrdersDatesTypesTypeIdNamesLangGet(
        int $type_id,
        string $lang,
        string $contentType = self::contentTypes['restOrdersDatesTypesTypeIdNamesLangGet'][0]
    ): \ck\Model\OrderDateTypeName
    {
        list($response) = $this->restOrdersDatesTypesTypeIdNamesLangGetWithHttpInfo($type_id, $lang, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersDatesTypesTypeIdNamesLangGetWithHttpInfo
     *
     * Get a name of an order date type
     *
     * @param  int $type_id The ID of the order date type that should be found (required)
     * @param  string $lang The language of the order date type name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersDatesTypesTypeIdNamesLangGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\OrderDateTypeName, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersDatesTypesTypeIdNamesLangGetWithHttpInfo(
        int $type_id,
        string $lang,
        string $contentType = self::contentTypes['restOrdersDatesTypesTypeIdNamesLangGet'][0]
    ): array
    {
        $request = $this->restOrdersDatesTypesTypeIdNamesLangGetRequest($type_id, $lang, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\OrderDateTypeName' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\OrderDateTypeName' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\OrderDateTypeName', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\OrderDateTypeName';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\OrderDateTypeName',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersDatesTypesTypeIdNamesLangGetAsync
     *
     * Get a name of an order date type
     *
     * @param  int $type_id The ID of the order date type that should be found (required)
     * @param  string $lang The language of the order date type name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersDatesTypesTypeIdNamesLangGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersDatesTypesTypeIdNamesLangGetAsync(
        int $type_id,
        string $lang,
        string $contentType = self::contentTypes['restOrdersDatesTypesTypeIdNamesLangGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersDatesTypesTypeIdNamesLangGetAsyncWithHttpInfo($type_id, $lang, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersDatesTypesTypeIdNamesLangGetAsyncWithHttpInfo
     *
     * Get a name of an order date type
     *
     * @param  int $type_id The ID of the order date type that should be found (required)
     * @param  string $lang The language of the order date type name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersDatesTypesTypeIdNamesLangGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersDatesTypesTypeIdNamesLangGetAsyncWithHttpInfo(
        $type_id,
        $lang,
        string $contentType = self::contentTypes['restOrdersDatesTypesTypeIdNamesLangGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\OrderDateTypeName';
        $request = $this->restOrdersDatesTypesTypeIdNamesLangGetRequest($type_id, $lang, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersDatesTypesTypeIdNamesLangGet'
     *
     * @param  int $type_id The ID of the order date type that should be found (required)
     * @param  string $lang The language of the order date type name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersDatesTypesTypeIdNamesLangGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersDatesTypesTypeIdNamesLangGetRequest(
        $type_id,
        $lang,
        string $contentType = self::contentTypes['restOrdersDatesTypesTypeIdNamesLangGet'][0]
    ): Request
    {

        // verify the required parameter 'type_id' is set
        if ($type_id === null || (is_array($type_id) && count($type_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $type_id when calling restOrdersDatesTypesTypeIdNamesLangGet'
            );
        }

        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $lang when calling restOrdersDatesTypesTypeIdNamesLangGet'
            );
        }


        $resourcePath = '/rest/orders/dates/types/{typeId}/names/{lang}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'typeId' . '}',
                ObjectSerializer::toPathValue($type_id),
                $resourcePath
            );
        }
        // path params
        if ($lang !== null) {
            $resourcePath = str_replace(
                '{' . 'lang' . '}',
                ObjectSerializer::toPathValue($lang),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersDocumentsAccountingSummaryGet
     *
     * List document accounting summaries
     *
     * @param  int|null $order_id The ID of the order. (optional)
     * @param  string|null $document_type The document type. The types that can be returned are the following: reversal_document (reversal document for an invoice) and reversal_refund (reversal document for an invoice). (optional)
     * @param  string|null $created_at_from Get entries with createdAt date after this date. (optional)
     * @param  string|null $created_at_to Get entries with createdAt date before this date. (optional)
     * @param  int|null $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int|null $items_per_page The number of summaries that should be displayed per page. The default number of orders per page is 10. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersDocumentsAccountingSummaryGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restOrdersDocumentsAccountingSummaryGet(
        ?int $order_id = null,
        ?string $document_type = null,
        ?string $created_at_from = null,
        ?string $created_at_to = null,
        ?int $page = null,
        ?int $items_per_page = null,
        string $contentType = self::contentTypes['restOrdersDocumentsAccountingSummaryGet'][0]
    ): object
    {
        list($response) = $this->restOrdersDocumentsAccountingSummaryGetWithHttpInfo($order_id, $document_type, $created_at_from, $created_at_to, $page, $items_per_page, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersDocumentsAccountingSummaryGetWithHttpInfo
     *
     * List document accounting summaries
     *
     * @param  int|null $order_id The ID of the order. (optional)
     * @param  string|null $document_type The document type. The types that can be returned are the following: reversal_document (reversal document for an invoice) and reversal_refund (reversal document for an invoice). (optional)
     * @param  string|null $created_at_from Get entries with createdAt date after this date. (optional)
     * @param  string|null $created_at_to Get entries with createdAt date before this date. (optional)
     * @param  int|null $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int|null $items_per_page The number of summaries that should be displayed per page. The default number of orders per page is 10. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersDocumentsAccountingSummaryGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersDocumentsAccountingSummaryGetWithHttpInfo(
        ?int $order_id = null,
        ?string $document_type = null,
        ?string $created_at_from = null,
        ?string $created_at_to = null,
        ?int $page = null,
        ?int $items_per_page = null,
        string $contentType = self::contentTypes['restOrdersDocumentsAccountingSummaryGet'][0]
    ): array
    {
        $request = $this->restOrdersDocumentsAccountingSummaryGetRequest($order_id, $document_type, $created_at_from, $created_at_to, $page, $items_per_page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersDocumentsAccountingSummaryGetAsync
     *
     * List document accounting summaries
     *
     * @param  int|null $order_id The ID of the order. (optional)
     * @param  string|null $document_type The document type. The types that can be returned are the following: reversal_document (reversal document for an invoice) and reversal_refund (reversal document for an invoice). (optional)
     * @param  string|null $created_at_from Get entries with createdAt date after this date. (optional)
     * @param  string|null $created_at_to Get entries with createdAt date before this date. (optional)
     * @param  int|null $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int|null $items_per_page The number of summaries that should be displayed per page. The default number of orders per page is 10. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersDocumentsAccountingSummaryGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersDocumentsAccountingSummaryGetAsync(
        ?int $order_id = null,
        ?string $document_type = null,
        ?string $created_at_from = null,
        ?string $created_at_to = null,
        ?int $page = null,
        ?int $items_per_page = null,
        string $contentType = self::contentTypes['restOrdersDocumentsAccountingSummaryGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersDocumentsAccountingSummaryGetAsyncWithHttpInfo($order_id, $document_type, $created_at_from, $created_at_to, $page, $items_per_page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersDocumentsAccountingSummaryGetAsyncWithHttpInfo
     *
     * List document accounting summaries
     *
     * @param  int|null $order_id The ID of the order. (optional)
     * @param  string|null $document_type The document type. The types that can be returned are the following: reversal_document (reversal document for an invoice) and reversal_refund (reversal document for an invoice). (optional)
     * @param  string|null $created_at_from Get entries with createdAt date after this date. (optional)
     * @param  string|null $created_at_to Get entries with createdAt date before this date. (optional)
     * @param  int|null $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int|null $items_per_page The number of summaries that should be displayed per page. The default number of orders per page is 10. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersDocumentsAccountingSummaryGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersDocumentsAccountingSummaryGetAsyncWithHttpInfo(
        $order_id = null,
        $document_type = null,
        $created_at_from = null,
        $created_at_to = null,
        $page = null,
        $items_per_page = null,
        string $contentType = self::contentTypes['restOrdersDocumentsAccountingSummaryGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restOrdersDocumentsAccountingSummaryGetRequest($order_id, $document_type, $created_at_from, $created_at_to, $page, $items_per_page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersDocumentsAccountingSummaryGet'
     *
     * @param  int|null $order_id The ID of the order. (optional)
     * @param  string|null $document_type The document type. The types that can be returned are the following: reversal_document (reversal document for an invoice) and reversal_refund (reversal document for an invoice). (optional)
     * @param  string|null $created_at_from Get entries with createdAt date after this date. (optional)
     * @param  string|null $created_at_to Get entries with createdAt date before this date. (optional)
     * @param  int|null $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int|null $items_per_page The number of summaries that should be displayed per page. The default number of orders per page is 10. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersDocumentsAccountingSummaryGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersDocumentsAccountingSummaryGetRequest(
        $order_id = null,
        $document_type = null,
        $created_at_from = null,
        $created_at_to = null,
        $page = null,
        $items_per_page = null,
        string $contentType = self::contentTypes['restOrdersDocumentsAccountingSummaryGet'][0]
    ): Request
    {








        $resourcePath = '/rest/orders/documents/accounting_summary';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order_id,
            'orderId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $document_type,
            'documentType', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_at_from,
            'createdAtFrom', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_at_to,
            'createdAtTo', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $items_per_page,
            'itemsPerPage', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersGet
     *
     * Search order
     *
     * @param  string|null $order_type Filter that restricts the search result to orders of specific order types. The ID of the order types must be specified. Several order type IDs can be entered separated by commas. @see order model typeId (optional)
     * @param  int|null $contact_id Filter that restricts the search result to orders of a contact. The ID of the contact must be specified. (optional)
     * @param  int|null $referrer_id Filter that restricts the search result to orders of a specific order referrer. The ID of the order referrer must be specified. (optional)
     * @param  int|null $shipping_profile_id Filter that restricts the search result to orders with a specific shipping profile. The ID of shipping profile must be specified. (optional)
     * @param  int|null $shipping_service_provider_id Filter that restricts the search result to orders with a specific shipping service provider (like DHL, UPS, etc.). The ID of shipping service provider must be specified. (optional)
     * @param  int|null $owner_user_id Filter that restricts the search result to orders with a specific owner. The user ID of the owner must be specified. (optional)
     * @param  int|null $warehouse_id Filter that restricts the search result to orders with a specific main warehouse. The ID of the warehouse must be specified. (optional)
     * @param  bool|null $is_ebay_plus Filter that restricts the search result to orders with the referrer eBay PLUS. (optional)
     * @param  int|null $included_variation Filter that restricts the search result to orders including a specific variation. The ID of the variation must be specified. (optional)
     * @param  int|null $included_item Filter that restricts the search result to orders including a specific item. The ID of the item must be specified. (optional)
     * @param  int|null $order_ids Filter that restricts the search result to orders with a specific ID. To list several orders, the order IDs must be enetered separated by commas. (optional)
     * @param  int|null $country_id Filter that restricts the search result to orders with a specific delivery or invoice country. The ID of the country must be specified. (optional)
     * @param  string|null $order_item_name Filter that restricts the search result to orders including a specific item name. The name of the item must be specified. (optional)
     * @param  int|null $variation_number Filter that restricts the search result to orders including a specific variation number. The number of the variation must be specified. (optional)
     * @param  int|null $sender_contact Filter that restricts the search result to orders including a specific sender of the type contact. For example, the supplier is a sender of the type contact for reorders. The ID of the sender must be specified. (optional)
     * @param  int|null $sender_warehouse Filter that restricts the search result to orders including a specific sender of the type warehouse. For example, the sending warehouse is a sender of the type warehouse for redistributions. The ID of the sender must be specified. (optional)
     * @param  int|null $receiver_contact Filter that restricts the search result to orders including a specific receiver of the type contact. For example, a receiver of the type contact is the recipient of a main order. The ID of the receiver must be specified. (optional)
     * @param  int|null $receiver_warehouse Filter that restricts the search result to orders with a specific receiver of the type warehouse. TFor example, the receiving receiving warehouse is a receiver of the type warehouse for redistributions. The ID of the receiver must be specified. (optional)
     * @param  string|null $external_order_id Filter that restricts the search result to orders including a specific external order ID. The external order ID must be specified. (optional)
     * @param  int|null $client_id Filter that restricts the search result to orders belonging to a specific client. The ID of the client must be specified. (optional)
     * @param  string|null $payment_status Filter that restricts the search result to orders with a specific payment status. Valid values are unpaid, partlyPaid, fullyPaid, overpaid. One of these values must be specified. (optional)
     * @param  string|null $updated_at_from Filter that restricts the search result to orders that were last updated on a specified date. The date has to be entered in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $updated_at_to Filter that restricts the search result to orders that were last updated within a specified period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be entered in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $created_at_from Filter that restricts the search result to orders that were created from a specified date up to the present date. This filter can be used alone or can be combined with the CreatedAtTo filter. The date has to be entered in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $created_at_to Filter that restricts the search result to orders that were created within a certain period of time. This filter can be used alone or can be combined with the CreatedAtFrom filter. The date has to be entered in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $paid_at_from Filter that restricts the search result to orders that received a payment on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $paid_at_to Filter that restricts the search result to orders that received a payment within a certain period of time. This filter can be used alone or can be combined with the paidAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $outgoing_items_booked_at_from Filter that restricts the search result to orders where the outgoing items were booked on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $outgoing_items_booked_at_to Filter that restricts the search result to orders where the outgoing items were booked within a specified period of time. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  int|null $status_from Filter that restricts the search result to orders in a specific order status. The value of the order status must be specified. (optional)
     * @param  int|null $status_to Filter that restricts the search result to orders within a range of order statuses. This filter can be used alone or can be combined with the statusFrom filter. The value of the order status must be specified. (optional)
     * @param  string|null $has_document Filter that restricts the search result to orders which hold the given document type. Valid values are &lt;i&gt;multi_invoice&lt;/i&gt;, &lt;i&gt;multi_credit_note&lt;/i&gt;, &lt;i&gt;success_confirmation&lt;/i&gt;, &lt;i&gt;return_note&lt;/i&gt;, &lt;i&gt;pickup_delivery&lt;/i&gt;, &lt;i&gt;repair_bill&lt;/i&gt;, &lt;i&gt;dunning_letter&lt;/i&gt;, &lt;i&gt;offer&lt;/i&gt;, &lt;i&gt;order_confirmation&lt;/i&gt;, &lt;i&gt;credit_note&lt;/i&gt;, &lt;i&gt;correction_document&lt;/i&gt;, &lt;i&gt;delivery_note&lt;/i&gt;, &lt;i&gt;invoice&lt;/i&gt;, &lt;i&gt;invoice_external&lt;/i&gt;, &lt;i&gt;receipt&lt;/i&gt; (optional)
     * @param  string|null $has_document_number Filter that restricts the search result to orders which hold documents with given number. (optional)
     * @param  int|null $parent_order_id Filter that restricts the search result to orders which have the given order ID as parent. (optional)
     * @param  bool|null $add_order_items Add the order items to the results. Default &#x3D; true. (optional)
     * @param  int|null $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int|null $items_per_page The number of orders to be displayed per page. The default number of orders per page is 50. (optional)
     * @param  int|null $with Load additional relations for an order. Currently possible are:     &lt;ul&gt;     &lt;li&gt;&#39;addresses&#39; &#x3D; The address objects that are associated with the order.&lt;/li&gt;     &lt;li&gt;&#39;relations&#39; &#x3D; The order relation reference instances that are associated with the order. These instances contain information such as the the reference type, the ID of the reference and the relation itself.&lt;/li&gt;     &lt;li&gt;&#39;comments&#39; &#x3D; The order comments.&lt;/li&gt;     &lt;li&gt;&#39;location&#39; &#x3D; The accounting location of the order.&lt;/li&gt;     &lt;li&gt;&#39;payments&#39; &#x3D; The payments that are associated with the order.&lt;/li&gt;     &lt;li&gt;&#39;documents&#39; &#x3D; The documents that are associated with the order.&lt;/li&gt;     &lt;li&gt;&#39;contactSender&#39; &#x3D; The associated contact for the contact-sender relation.&lt;/li&gt;     &lt;li&gt;&#39;contactReceiver&#39; &#x3D; The associated contact for the contact-receiver relation.&lt;/li&gt;     &lt;li&gt;&#39;warehouseSender&#39; &#x3D; The associated warehouse for the warehouse-sender relation.&lt;/li&gt;     &lt;li&gt;&#39;warehouseReceiver&#39; &#x3D; The associated warehouse for the warehouse-receiver relation.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.variation&#39; &#x3D; The variation that is associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.giftCardCodes&#39; &#x3D; The gift card codes that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.transactions&#39; &#x3D; The transactions that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.serialNumbers&#39; &#x3D; The serial numbers that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.variationBarcodes&#39; &#x3D; The barcodes that are associated with variation of the order item.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.comments&#39; &#x3D; The comments that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;originOrderReferences&#39; &#x3D; The references to other orders, e.g. returns or credit notes, associated with this order.&lt;/li&gt;     &lt;li&gt;&#39;shippingPackages&#39; &#x3D; The shipping packages that are associated with the order.&lt;/li&gt;     &lt;li&gt;&lt;b&gt;deprecated&lt;/b&gt; &#39;orderItems.warehouseLocations&#39; &#x3D; The warehouse locations that are associated with the order item.&lt;/li&gt;     &lt;/ul&gt;     Example: &lt;code&gt;?with[]&#x3D;addresses&amp;with[]&#x3D;orderItems.variation&lt;/code&gt; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestOrdersGet200Response
     */
    public function restOrdersGet(
        ?string $order_type = null,
        ?int $contact_id = null,
        ?int $referrer_id = null,
        ?int $shipping_profile_id = null,
        ?int $shipping_service_provider_id = null,
        ?int $owner_user_id = null,
        ?int $warehouse_id = null,
        ?bool $is_ebay_plus = null,
        ?int $included_variation = null,
        ?int $included_item = null,
        ?int $order_ids = null,
        ?int $country_id = null,
        ?string $order_item_name = null,
        ?int $variation_number = null,
        ?int $sender_contact = null,
        ?int $sender_warehouse = null,
        ?int $receiver_contact = null,
        ?int $receiver_warehouse = null,
        ?string $external_order_id = null,
        ?int $client_id = null,
        ?string $payment_status = null,
        ?string $updated_at_from = null,
        ?string $updated_at_to = null,
        ?string $created_at_from = null,
        ?string $created_at_to = null,
        ?string $paid_at_from = null,
        ?string $paid_at_to = null,
        ?string $outgoing_items_booked_at_from = null,
        ?string $outgoing_items_booked_at_to = null,
        ?int $status_from = null,
        ?int $status_to = null,
        ?string $has_document = null,
        ?string $has_document_number = null,
        ?int $parent_order_id = null,
        ?bool $add_order_items = null,
        ?int $page = null,
        ?int $items_per_page = null,
        ?int $with = null,
        string $contentType = self::contentTypes['restOrdersGet'][0]
    ): \ck\Model\RestOrdersGet200Response
    {
        list($response) = $this->restOrdersGetWithHttpInfo($order_type, $contact_id, $referrer_id, $shipping_profile_id, $shipping_service_provider_id, $owner_user_id, $warehouse_id, $is_ebay_plus, $included_variation, $included_item, $order_ids, $country_id, $order_item_name, $variation_number, $sender_contact, $sender_warehouse, $receiver_contact, $receiver_warehouse, $external_order_id, $client_id, $payment_status, $updated_at_from, $updated_at_to, $created_at_from, $created_at_to, $paid_at_from, $paid_at_to, $outgoing_items_booked_at_from, $outgoing_items_booked_at_to, $status_from, $status_to, $has_document, $has_document_number, $parent_order_id, $add_order_items, $page, $items_per_page, $with, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersGetWithHttpInfo
     *
     * Search order
     *
     * @param  string|null $order_type Filter that restricts the search result to orders of specific order types. The ID of the order types must be specified. Several order type IDs can be entered separated by commas. @see order model typeId (optional)
     * @param  int|null $contact_id Filter that restricts the search result to orders of a contact. The ID of the contact must be specified. (optional)
     * @param  int|null $referrer_id Filter that restricts the search result to orders of a specific order referrer. The ID of the order referrer must be specified. (optional)
     * @param  int|null $shipping_profile_id Filter that restricts the search result to orders with a specific shipping profile. The ID of shipping profile must be specified. (optional)
     * @param  int|null $shipping_service_provider_id Filter that restricts the search result to orders with a specific shipping service provider (like DHL, UPS, etc.). The ID of shipping service provider must be specified. (optional)
     * @param  int|null $owner_user_id Filter that restricts the search result to orders with a specific owner. The user ID of the owner must be specified. (optional)
     * @param  int|null $warehouse_id Filter that restricts the search result to orders with a specific main warehouse. The ID of the warehouse must be specified. (optional)
     * @param  bool|null $is_ebay_plus Filter that restricts the search result to orders with the referrer eBay PLUS. (optional)
     * @param  int|null $included_variation Filter that restricts the search result to orders including a specific variation. The ID of the variation must be specified. (optional)
     * @param  int|null $included_item Filter that restricts the search result to orders including a specific item. The ID of the item must be specified. (optional)
     * @param  int|null $order_ids Filter that restricts the search result to orders with a specific ID. To list several orders, the order IDs must be enetered separated by commas. (optional)
     * @param  int|null $country_id Filter that restricts the search result to orders with a specific delivery or invoice country. The ID of the country must be specified. (optional)
     * @param  string|null $order_item_name Filter that restricts the search result to orders including a specific item name. The name of the item must be specified. (optional)
     * @param  int|null $variation_number Filter that restricts the search result to orders including a specific variation number. The number of the variation must be specified. (optional)
     * @param  int|null $sender_contact Filter that restricts the search result to orders including a specific sender of the type contact. For example, the supplier is a sender of the type contact for reorders. The ID of the sender must be specified. (optional)
     * @param  int|null $sender_warehouse Filter that restricts the search result to orders including a specific sender of the type warehouse. For example, the sending warehouse is a sender of the type warehouse for redistributions. The ID of the sender must be specified. (optional)
     * @param  int|null $receiver_contact Filter that restricts the search result to orders including a specific receiver of the type contact. For example, a receiver of the type contact is the recipient of a main order. The ID of the receiver must be specified. (optional)
     * @param  int|null $receiver_warehouse Filter that restricts the search result to orders with a specific receiver of the type warehouse. TFor example, the receiving receiving warehouse is a receiver of the type warehouse for redistributions. The ID of the receiver must be specified. (optional)
     * @param  string|null $external_order_id Filter that restricts the search result to orders including a specific external order ID. The external order ID must be specified. (optional)
     * @param  int|null $client_id Filter that restricts the search result to orders belonging to a specific client. The ID of the client must be specified. (optional)
     * @param  string|null $payment_status Filter that restricts the search result to orders with a specific payment status. Valid values are unpaid, partlyPaid, fullyPaid, overpaid. One of these values must be specified. (optional)
     * @param  string|null $updated_at_from Filter that restricts the search result to orders that were last updated on a specified date. The date has to be entered in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $updated_at_to Filter that restricts the search result to orders that were last updated within a specified period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be entered in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $created_at_from Filter that restricts the search result to orders that were created from a specified date up to the present date. This filter can be used alone or can be combined with the CreatedAtTo filter. The date has to be entered in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $created_at_to Filter that restricts the search result to orders that were created within a certain period of time. This filter can be used alone or can be combined with the CreatedAtFrom filter. The date has to be entered in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $paid_at_from Filter that restricts the search result to orders that received a payment on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $paid_at_to Filter that restricts the search result to orders that received a payment within a certain period of time. This filter can be used alone or can be combined with the paidAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $outgoing_items_booked_at_from Filter that restricts the search result to orders where the outgoing items were booked on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $outgoing_items_booked_at_to Filter that restricts the search result to orders where the outgoing items were booked within a specified period of time. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  int|null $status_from Filter that restricts the search result to orders in a specific order status. The value of the order status must be specified. (optional)
     * @param  int|null $status_to Filter that restricts the search result to orders within a range of order statuses. This filter can be used alone or can be combined with the statusFrom filter. The value of the order status must be specified. (optional)
     * @param  string|null $has_document Filter that restricts the search result to orders which hold the given document type. Valid values are &lt;i&gt;multi_invoice&lt;/i&gt;, &lt;i&gt;multi_credit_note&lt;/i&gt;, &lt;i&gt;success_confirmation&lt;/i&gt;, &lt;i&gt;return_note&lt;/i&gt;, &lt;i&gt;pickup_delivery&lt;/i&gt;, &lt;i&gt;repair_bill&lt;/i&gt;, &lt;i&gt;dunning_letter&lt;/i&gt;, &lt;i&gt;offer&lt;/i&gt;, &lt;i&gt;order_confirmation&lt;/i&gt;, &lt;i&gt;credit_note&lt;/i&gt;, &lt;i&gt;correction_document&lt;/i&gt;, &lt;i&gt;delivery_note&lt;/i&gt;, &lt;i&gt;invoice&lt;/i&gt;, &lt;i&gt;invoice_external&lt;/i&gt;, &lt;i&gt;receipt&lt;/i&gt; (optional)
     * @param  string|null $has_document_number Filter that restricts the search result to orders which hold documents with given number. (optional)
     * @param  int|null $parent_order_id Filter that restricts the search result to orders which have the given order ID as parent. (optional)
     * @param  bool|null $add_order_items Add the order items to the results. Default &#x3D; true. (optional)
     * @param  int|null $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int|null $items_per_page The number of orders to be displayed per page. The default number of orders per page is 50. (optional)
     * @param  int|null $with Load additional relations for an order. Currently possible are:     &lt;ul&gt;     &lt;li&gt;&#39;addresses&#39; &#x3D; The address objects that are associated with the order.&lt;/li&gt;     &lt;li&gt;&#39;relations&#39; &#x3D; The order relation reference instances that are associated with the order. These instances contain information such as the the reference type, the ID of the reference and the relation itself.&lt;/li&gt;     &lt;li&gt;&#39;comments&#39; &#x3D; The order comments.&lt;/li&gt;     &lt;li&gt;&#39;location&#39; &#x3D; The accounting location of the order.&lt;/li&gt;     &lt;li&gt;&#39;payments&#39; &#x3D; The payments that are associated with the order.&lt;/li&gt;     &lt;li&gt;&#39;documents&#39; &#x3D; The documents that are associated with the order.&lt;/li&gt;     &lt;li&gt;&#39;contactSender&#39; &#x3D; The associated contact for the contact-sender relation.&lt;/li&gt;     &lt;li&gt;&#39;contactReceiver&#39; &#x3D; The associated contact for the contact-receiver relation.&lt;/li&gt;     &lt;li&gt;&#39;warehouseSender&#39; &#x3D; The associated warehouse for the warehouse-sender relation.&lt;/li&gt;     &lt;li&gt;&#39;warehouseReceiver&#39; &#x3D; The associated warehouse for the warehouse-receiver relation.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.variation&#39; &#x3D; The variation that is associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.giftCardCodes&#39; &#x3D; The gift card codes that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.transactions&#39; &#x3D; The transactions that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.serialNumbers&#39; &#x3D; The serial numbers that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.variationBarcodes&#39; &#x3D; The barcodes that are associated with variation of the order item.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.comments&#39; &#x3D; The comments that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;originOrderReferences&#39; &#x3D; The references to other orders, e.g. returns or credit notes, associated with this order.&lt;/li&gt;     &lt;li&gt;&#39;shippingPackages&#39; &#x3D; The shipping packages that are associated with the order.&lt;/li&gt;     &lt;li&gt;&lt;b&gt;deprecated&lt;/b&gt; &#39;orderItems.warehouseLocations&#39; &#x3D; The warehouse locations that are associated with the order item.&lt;/li&gt;     &lt;/ul&gt;     Example: &lt;code&gt;?with[]&#x3D;addresses&amp;with[]&#x3D;orderItems.variation&lt;/code&gt; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestOrdersGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersGetWithHttpInfo(
        ?string $order_type = null,
        ?int $contact_id = null,
        ?int $referrer_id = null,
        ?int $shipping_profile_id = null,
        ?int $shipping_service_provider_id = null,
        ?int $owner_user_id = null,
        ?int $warehouse_id = null,
        ?bool $is_ebay_plus = null,
        ?int $included_variation = null,
        ?int $included_item = null,
        ?int $order_ids = null,
        ?int $country_id = null,
        ?string $order_item_name = null,
        ?int $variation_number = null,
        ?int $sender_contact = null,
        ?int $sender_warehouse = null,
        ?int $receiver_contact = null,
        ?int $receiver_warehouse = null,
        ?string $external_order_id = null,
        ?int $client_id = null,
        ?string $payment_status = null,
        ?string $updated_at_from = null,
        ?string $updated_at_to = null,
        ?string $created_at_from = null,
        ?string $created_at_to = null,
        ?string $paid_at_from = null,
        ?string $paid_at_to = null,
        ?string $outgoing_items_booked_at_from = null,
        ?string $outgoing_items_booked_at_to = null,
        ?int $status_from = null,
        ?int $status_to = null,
        ?string $has_document = null,
        ?string $has_document_number = null,
        ?int $parent_order_id = null,
        ?bool $add_order_items = null,
        ?int $page = null,
        ?int $items_per_page = null,
        ?int $with = null,
        string $contentType = self::contentTypes['restOrdersGet'][0]
    ): array
    {
        $request = $this->restOrdersGetRequest($order_type, $contact_id, $referrer_id, $shipping_profile_id, $shipping_service_provider_id, $owner_user_id, $warehouse_id, $is_ebay_plus, $included_variation, $included_item, $order_ids, $country_id, $order_item_name, $variation_number, $sender_contact, $sender_warehouse, $receiver_contact, $receiver_warehouse, $external_order_id, $client_id, $payment_status, $updated_at_from, $updated_at_to, $created_at_from, $created_at_to, $paid_at_from, $paid_at_to, $outgoing_items_booked_at_from, $outgoing_items_booked_at_to, $status_from, $status_to, $has_document, $has_document_number, $parent_order_id, $add_order_items, $page, $items_per_page, $with, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestOrdersGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestOrdersGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestOrdersGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestOrdersGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestOrdersGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersGetAsync
     *
     * Search order
     *
     * @param  string|null $order_type Filter that restricts the search result to orders of specific order types. The ID of the order types must be specified. Several order type IDs can be entered separated by commas. @see order model typeId (optional)
     * @param  int|null $contact_id Filter that restricts the search result to orders of a contact. The ID of the contact must be specified. (optional)
     * @param  int|null $referrer_id Filter that restricts the search result to orders of a specific order referrer. The ID of the order referrer must be specified. (optional)
     * @param  int|null $shipping_profile_id Filter that restricts the search result to orders with a specific shipping profile. The ID of shipping profile must be specified. (optional)
     * @param  int|null $shipping_service_provider_id Filter that restricts the search result to orders with a specific shipping service provider (like DHL, UPS, etc.). The ID of shipping service provider must be specified. (optional)
     * @param  int|null $owner_user_id Filter that restricts the search result to orders with a specific owner. The user ID of the owner must be specified. (optional)
     * @param  int|null $warehouse_id Filter that restricts the search result to orders with a specific main warehouse. The ID of the warehouse must be specified. (optional)
     * @param  bool|null $is_ebay_plus Filter that restricts the search result to orders with the referrer eBay PLUS. (optional)
     * @param  int|null $included_variation Filter that restricts the search result to orders including a specific variation. The ID of the variation must be specified. (optional)
     * @param  int|null $included_item Filter that restricts the search result to orders including a specific item. The ID of the item must be specified. (optional)
     * @param  int|null $order_ids Filter that restricts the search result to orders with a specific ID. To list several orders, the order IDs must be enetered separated by commas. (optional)
     * @param  int|null $country_id Filter that restricts the search result to orders with a specific delivery or invoice country. The ID of the country must be specified. (optional)
     * @param  string|null $order_item_name Filter that restricts the search result to orders including a specific item name. The name of the item must be specified. (optional)
     * @param  int|null $variation_number Filter that restricts the search result to orders including a specific variation number. The number of the variation must be specified. (optional)
     * @param  int|null $sender_contact Filter that restricts the search result to orders including a specific sender of the type contact. For example, the supplier is a sender of the type contact for reorders. The ID of the sender must be specified. (optional)
     * @param  int|null $sender_warehouse Filter that restricts the search result to orders including a specific sender of the type warehouse. For example, the sending warehouse is a sender of the type warehouse for redistributions. The ID of the sender must be specified. (optional)
     * @param  int|null $receiver_contact Filter that restricts the search result to orders including a specific receiver of the type contact. For example, a receiver of the type contact is the recipient of a main order. The ID of the receiver must be specified. (optional)
     * @param  int|null $receiver_warehouse Filter that restricts the search result to orders with a specific receiver of the type warehouse. TFor example, the receiving receiving warehouse is a receiver of the type warehouse for redistributions. The ID of the receiver must be specified. (optional)
     * @param  string|null $external_order_id Filter that restricts the search result to orders including a specific external order ID. The external order ID must be specified. (optional)
     * @param  int|null $client_id Filter that restricts the search result to orders belonging to a specific client. The ID of the client must be specified. (optional)
     * @param  string|null $payment_status Filter that restricts the search result to orders with a specific payment status. Valid values are unpaid, partlyPaid, fullyPaid, overpaid. One of these values must be specified. (optional)
     * @param  string|null $updated_at_from Filter that restricts the search result to orders that were last updated on a specified date. The date has to be entered in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $updated_at_to Filter that restricts the search result to orders that were last updated within a specified period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be entered in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $created_at_from Filter that restricts the search result to orders that were created from a specified date up to the present date. This filter can be used alone or can be combined with the CreatedAtTo filter. The date has to be entered in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $created_at_to Filter that restricts the search result to orders that were created within a certain period of time. This filter can be used alone or can be combined with the CreatedAtFrom filter. The date has to be entered in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $paid_at_from Filter that restricts the search result to orders that received a payment on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $paid_at_to Filter that restricts the search result to orders that received a payment within a certain period of time. This filter can be used alone or can be combined with the paidAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $outgoing_items_booked_at_from Filter that restricts the search result to orders where the outgoing items were booked on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $outgoing_items_booked_at_to Filter that restricts the search result to orders where the outgoing items were booked within a specified period of time. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  int|null $status_from Filter that restricts the search result to orders in a specific order status. The value of the order status must be specified. (optional)
     * @param  int|null $status_to Filter that restricts the search result to orders within a range of order statuses. This filter can be used alone or can be combined with the statusFrom filter. The value of the order status must be specified. (optional)
     * @param  string|null $has_document Filter that restricts the search result to orders which hold the given document type. Valid values are &lt;i&gt;multi_invoice&lt;/i&gt;, &lt;i&gt;multi_credit_note&lt;/i&gt;, &lt;i&gt;success_confirmation&lt;/i&gt;, &lt;i&gt;return_note&lt;/i&gt;, &lt;i&gt;pickup_delivery&lt;/i&gt;, &lt;i&gt;repair_bill&lt;/i&gt;, &lt;i&gt;dunning_letter&lt;/i&gt;, &lt;i&gt;offer&lt;/i&gt;, &lt;i&gt;order_confirmation&lt;/i&gt;, &lt;i&gt;credit_note&lt;/i&gt;, &lt;i&gt;correction_document&lt;/i&gt;, &lt;i&gt;delivery_note&lt;/i&gt;, &lt;i&gt;invoice&lt;/i&gt;, &lt;i&gt;invoice_external&lt;/i&gt;, &lt;i&gt;receipt&lt;/i&gt; (optional)
     * @param  string|null $has_document_number Filter that restricts the search result to orders which hold documents with given number. (optional)
     * @param  int|null $parent_order_id Filter that restricts the search result to orders which have the given order ID as parent. (optional)
     * @param  bool|null $add_order_items Add the order items to the results. Default &#x3D; true. (optional)
     * @param  int|null $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int|null $items_per_page The number of orders to be displayed per page. The default number of orders per page is 50. (optional)
     * @param  int|null $with Load additional relations for an order. Currently possible are:     &lt;ul&gt;     &lt;li&gt;&#39;addresses&#39; &#x3D; The address objects that are associated with the order.&lt;/li&gt;     &lt;li&gt;&#39;relations&#39; &#x3D; The order relation reference instances that are associated with the order. These instances contain information such as the the reference type, the ID of the reference and the relation itself.&lt;/li&gt;     &lt;li&gt;&#39;comments&#39; &#x3D; The order comments.&lt;/li&gt;     &lt;li&gt;&#39;location&#39; &#x3D; The accounting location of the order.&lt;/li&gt;     &lt;li&gt;&#39;payments&#39; &#x3D; The payments that are associated with the order.&lt;/li&gt;     &lt;li&gt;&#39;documents&#39; &#x3D; The documents that are associated with the order.&lt;/li&gt;     &lt;li&gt;&#39;contactSender&#39; &#x3D; The associated contact for the contact-sender relation.&lt;/li&gt;     &lt;li&gt;&#39;contactReceiver&#39; &#x3D; The associated contact for the contact-receiver relation.&lt;/li&gt;     &lt;li&gt;&#39;warehouseSender&#39; &#x3D; The associated warehouse for the warehouse-sender relation.&lt;/li&gt;     &lt;li&gt;&#39;warehouseReceiver&#39; &#x3D; The associated warehouse for the warehouse-receiver relation.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.variation&#39; &#x3D; The variation that is associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.giftCardCodes&#39; &#x3D; The gift card codes that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.transactions&#39; &#x3D; The transactions that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.serialNumbers&#39; &#x3D; The serial numbers that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.variationBarcodes&#39; &#x3D; The barcodes that are associated with variation of the order item.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.comments&#39; &#x3D; The comments that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;originOrderReferences&#39; &#x3D; The references to other orders, e.g. returns or credit notes, associated with this order.&lt;/li&gt;     &lt;li&gt;&#39;shippingPackages&#39; &#x3D; The shipping packages that are associated with the order.&lt;/li&gt;     &lt;li&gt;&lt;b&gt;deprecated&lt;/b&gt; &#39;orderItems.warehouseLocations&#39; &#x3D; The warehouse locations that are associated with the order item.&lt;/li&gt;     &lt;/ul&gt;     Example: &lt;code&gt;?with[]&#x3D;addresses&amp;with[]&#x3D;orderItems.variation&lt;/code&gt; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersGetAsync(
        ?string $order_type = null,
        ?int $contact_id = null,
        ?int $referrer_id = null,
        ?int $shipping_profile_id = null,
        ?int $shipping_service_provider_id = null,
        ?int $owner_user_id = null,
        ?int $warehouse_id = null,
        ?bool $is_ebay_plus = null,
        ?int $included_variation = null,
        ?int $included_item = null,
        ?int $order_ids = null,
        ?int $country_id = null,
        ?string $order_item_name = null,
        ?int $variation_number = null,
        ?int $sender_contact = null,
        ?int $sender_warehouse = null,
        ?int $receiver_contact = null,
        ?int $receiver_warehouse = null,
        ?string $external_order_id = null,
        ?int $client_id = null,
        ?string $payment_status = null,
        ?string $updated_at_from = null,
        ?string $updated_at_to = null,
        ?string $created_at_from = null,
        ?string $created_at_to = null,
        ?string $paid_at_from = null,
        ?string $paid_at_to = null,
        ?string $outgoing_items_booked_at_from = null,
        ?string $outgoing_items_booked_at_to = null,
        ?int $status_from = null,
        ?int $status_to = null,
        ?string $has_document = null,
        ?string $has_document_number = null,
        ?int $parent_order_id = null,
        ?bool $add_order_items = null,
        ?int $page = null,
        ?int $items_per_page = null,
        ?int $with = null,
        string $contentType = self::contentTypes['restOrdersGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersGetAsyncWithHttpInfo($order_type, $contact_id, $referrer_id, $shipping_profile_id, $shipping_service_provider_id, $owner_user_id, $warehouse_id, $is_ebay_plus, $included_variation, $included_item, $order_ids, $country_id, $order_item_name, $variation_number, $sender_contact, $sender_warehouse, $receiver_contact, $receiver_warehouse, $external_order_id, $client_id, $payment_status, $updated_at_from, $updated_at_to, $created_at_from, $created_at_to, $paid_at_from, $paid_at_to, $outgoing_items_booked_at_from, $outgoing_items_booked_at_to, $status_from, $status_to, $has_document, $has_document_number, $parent_order_id, $add_order_items, $page, $items_per_page, $with, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersGetAsyncWithHttpInfo
     *
     * Search order
     *
     * @param  string|null $order_type Filter that restricts the search result to orders of specific order types. The ID of the order types must be specified. Several order type IDs can be entered separated by commas. @see order model typeId (optional)
     * @param  int|null $contact_id Filter that restricts the search result to orders of a contact. The ID of the contact must be specified. (optional)
     * @param  int|null $referrer_id Filter that restricts the search result to orders of a specific order referrer. The ID of the order referrer must be specified. (optional)
     * @param  int|null $shipping_profile_id Filter that restricts the search result to orders with a specific shipping profile. The ID of shipping profile must be specified. (optional)
     * @param  int|null $shipping_service_provider_id Filter that restricts the search result to orders with a specific shipping service provider (like DHL, UPS, etc.). The ID of shipping service provider must be specified. (optional)
     * @param  int|null $owner_user_id Filter that restricts the search result to orders with a specific owner. The user ID of the owner must be specified. (optional)
     * @param  int|null $warehouse_id Filter that restricts the search result to orders with a specific main warehouse. The ID of the warehouse must be specified. (optional)
     * @param  bool|null $is_ebay_plus Filter that restricts the search result to orders with the referrer eBay PLUS. (optional)
     * @param  int|null $included_variation Filter that restricts the search result to orders including a specific variation. The ID of the variation must be specified. (optional)
     * @param  int|null $included_item Filter that restricts the search result to orders including a specific item. The ID of the item must be specified. (optional)
     * @param  int|null $order_ids Filter that restricts the search result to orders with a specific ID. To list several orders, the order IDs must be enetered separated by commas. (optional)
     * @param  int|null $country_id Filter that restricts the search result to orders with a specific delivery or invoice country. The ID of the country must be specified. (optional)
     * @param  string|null $order_item_name Filter that restricts the search result to orders including a specific item name. The name of the item must be specified. (optional)
     * @param  int|null $variation_number Filter that restricts the search result to orders including a specific variation number. The number of the variation must be specified. (optional)
     * @param  int|null $sender_contact Filter that restricts the search result to orders including a specific sender of the type contact. For example, the supplier is a sender of the type contact for reorders. The ID of the sender must be specified. (optional)
     * @param  int|null $sender_warehouse Filter that restricts the search result to orders including a specific sender of the type warehouse. For example, the sending warehouse is a sender of the type warehouse for redistributions. The ID of the sender must be specified. (optional)
     * @param  int|null $receiver_contact Filter that restricts the search result to orders including a specific receiver of the type contact. For example, a receiver of the type contact is the recipient of a main order. The ID of the receiver must be specified. (optional)
     * @param  int|null $receiver_warehouse Filter that restricts the search result to orders with a specific receiver of the type warehouse. TFor example, the receiving receiving warehouse is a receiver of the type warehouse for redistributions. The ID of the receiver must be specified. (optional)
     * @param  string|null $external_order_id Filter that restricts the search result to orders including a specific external order ID. The external order ID must be specified. (optional)
     * @param  int|null $client_id Filter that restricts the search result to orders belonging to a specific client. The ID of the client must be specified. (optional)
     * @param  string|null $payment_status Filter that restricts the search result to orders with a specific payment status. Valid values are unpaid, partlyPaid, fullyPaid, overpaid. One of these values must be specified. (optional)
     * @param  string|null $updated_at_from Filter that restricts the search result to orders that were last updated on a specified date. The date has to be entered in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $updated_at_to Filter that restricts the search result to orders that were last updated within a specified period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be entered in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $created_at_from Filter that restricts the search result to orders that were created from a specified date up to the present date. This filter can be used alone or can be combined with the CreatedAtTo filter. The date has to be entered in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $created_at_to Filter that restricts the search result to orders that were created within a certain period of time. This filter can be used alone or can be combined with the CreatedAtFrom filter. The date has to be entered in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $paid_at_from Filter that restricts the search result to orders that received a payment on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $paid_at_to Filter that restricts the search result to orders that received a payment within a certain period of time. This filter can be used alone or can be combined with the paidAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $outgoing_items_booked_at_from Filter that restricts the search result to orders where the outgoing items were booked on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $outgoing_items_booked_at_to Filter that restricts the search result to orders where the outgoing items were booked within a specified period of time. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  int|null $status_from Filter that restricts the search result to orders in a specific order status. The value of the order status must be specified. (optional)
     * @param  int|null $status_to Filter that restricts the search result to orders within a range of order statuses. This filter can be used alone or can be combined with the statusFrom filter. The value of the order status must be specified. (optional)
     * @param  string|null $has_document Filter that restricts the search result to orders which hold the given document type. Valid values are &lt;i&gt;multi_invoice&lt;/i&gt;, &lt;i&gt;multi_credit_note&lt;/i&gt;, &lt;i&gt;success_confirmation&lt;/i&gt;, &lt;i&gt;return_note&lt;/i&gt;, &lt;i&gt;pickup_delivery&lt;/i&gt;, &lt;i&gt;repair_bill&lt;/i&gt;, &lt;i&gt;dunning_letter&lt;/i&gt;, &lt;i&gt;offer&lt;/i&gt;, &lt;i&gt;order_confirmation&lt;/i&gt;, &lt;i&gt;credit_note&lt;/i&gt;, &lt;i&gt;correction_document&lt;/i&gt;, &lt;i&gt;delivery_note&lt;/i&gt;, &lt;i&gt;invoice&lt;/i&gt;, &lt;i&gt;invoice_external&lt;/i&gt;, &lt;i&gt;receipt&lt;/i&gt; (optional)
     * @param  string|null $has_document_number Filter that restricts the search result to orders which hold documents with given number. (optional)
     * @param  int|null $parent_order_id Filter that restricts the search result to orders which have the given order ID as parent. (optional)
     * @param  bool|null $add_order_items Add the order items to the results. Default &#x3D; true. (optional)
     * @param  int|null $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int|null $items_per_page The number of orders to be displayed per page. The default number of orders per page is 50. (optional)
     * @param  int|null $with Load additional relations for an order. Currently possible are:     &lt;ul&gt;     &lt;li&gt;&#39;addresses&#39; &#x3D; The address objects that are associated with the order.&lt;/li&gt;     &lt;li&gt;&#39;relations&#39; &#x3D; The order relation reference instances that are associated with the order. These instances contain information such as the the reference type, the ID of the reference and the relation itself.&lt;/li&gt;     &lt;li&gt;&#39;comments&#39; &#x3D; The order comments.&lt;/li&gt;     &lt;li&gt;&#39;location&#39; &#x3D; The accounting location of the order.&lt;/li&gt;     &lt;li&gt;&#39;payments&#39; &#x3D; The payments that are associated with the order.&lt;/li&gt;     &lt;li&gt;&#39;documents&#39; &#x3D; The documents that are associated with the order.&lt;/li&gt;     &lt;li&gt;&#39;contactSender&#39; &#x3D; The associated contact for the contact-sender relation.&lt;/li&gt;     &lt;li&gt;&#39;contactReceiver&#39; &#x3D; The associated contact for the contact-receiver relation.&lt;/li&gt;     &lt;li&gt;&#39;warehouseSender&#39; &#x3D; The associated warehouse for the warehouse-sender relation.&lt;/li&gt;     &lt;li&gt;&#39;warehouseReceiver&#39; &#x3D; The associated warehouse for the warehouse-receiver relation.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.variation&#39; &#x3D; The variation that is associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.giftCardCodes&#39; &#x3D; The gift card codes that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.transactions&#39; &#x3D; The transactions that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.serialNumbers&#39; &#x3D; The serial numbers that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.variationBarcodes&#39; &#x3D; The barcodes that are associated with variation of the order item.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.comments&#39; &#x3D; The comments that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;originOrderReferences&#39; &#x3D; The references to other orders, e.g. returns or credit notes, associated with this order.&lt;/li&gt;     &lt;li&gt;&#39;shippingPackages&#39; &#x3D; The shipping packages that are associated with the order.&lt;/li&gt;     &lt;li&gt;&lt;b&gt;deprecated&lt;/b&gt; &#39;orderItems.warehouseLocations&#39; &#x3D; The warehouse locations that are associated with the order item.&lt;/li&gt;     &lt;/ul&gt;     Example: &lt;code&gt;?with[]&#x3D;addresses&amp;with[]&#x3D;orderItems.variation&lt;/code&gt; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersGetAsyncWithHttpInfo(
        $order_type = null,
        $contact_id = null,
        $referrer_id = null,
        $shipping_profile_id = null,
        $shipping_service_provider_id = null,
        $owner_user_id = null,
        $warehouse_id = null,
        $is_ebay_plus = null,
        $included_variation = null,
        $included_item = null,
        $order_ids = null,
        $country_id = null,
        $order_item_name = null,
        $variation_number = null,
        $sender_contact = null,
        $sender_warehouse = null,
        $receiver_contact = null,
        $receiver_warehouse = null,
        $external_order_id = null,
        $client_id = null,
        $payment_status = null,
        $updated_at_from = null,
        $updated_at_to = null,
        $created_at_from = null,
        $created_at_to = null,
        $paid_at_from = null,
        $paid_at_to = null,
        $outgoing_items_booked_at_from = null,
        $outgoing_items_booked_at_to = null,
        $status_from = null,
        $status_to = null,
        $has_document = null,
        $has_document_number = null,
        $parent_order_id = null,
        $add_order_items = null,
        $page = null,
        $items_per_page = null,
        $with = null,
        string $contentType = self::contentTypes['restOrdersGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestOrdersGet200Response';
        $request = $this->restOrdersGetRequest($order_type, $contact_id, $referrer_id, $shipping_profile_id, $shipping_service_provider_id, $owner_user_id, $warehouse_id, $is_ebay_plus, $included_variation, $included_item, $order_ids, $country_id, $order_item_name, $variation_number, $sender_contact, $sender_warehouse, $receiver_contact, $receiver_warehouse, $external_order_id, $client_id, $payment_status, $updated_at_from, $updated_at_to, $created_at_from, $created_at_to, $paid_at_from, $paid_at_to, $outgoing_items_booked_at_from, $outgoing_items_booked_at_to, $status_from, $status_to, $has_document, $has_document_number, $parent_order_id, $add_order_items, $page, $items_per_page, $with, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersGet'
     *
     * @param  string|null $order_type Filter that restricts the search result to orders of specific order types. The ID of the order types must be specified. Several order type IDs can be entered separated by commas. @see order model typeId (optional)
     * @param  int|null $contact_id Filter that restricts the search result to orders of a contact. The ID of the contact must be specified. (optional)
     * @param  int|null $referrer_id Filter that restricts the search result to orders of a specific order referrer. The ID of the order referrer must be specified. (optional)
     * @param  int|null $shipping_profile_id Filter that restricts the search result to orders with a specific shipping profile. The ID of shipping profile must be specified. (optional)
     * @param  int|null $shipping_service_provider_id Filter that restricts the search result to orders with a specific shipping service provider (like DHL, UPS, etc.). The ID of shipping service provider must be specified. (optional)
     * @param  int|null $owner_user_id Filter that restricts the search result to orders with a specific owner. The user ID of the owner must be specified. (optional)
     * @param  int|null $warehouse_id Filter that restricts the search result to orders with a specific main warehouse. The ID of the warehouse must be specified. (optional)
     * @param  bool|null $is_ebay_plus Filter that restricts the search result to orders with the referrer eBay PLUS. (optional)
     * @param  int|null $included_variation Filter that restricts the search result to orders including a specific variation. The ID of the variation must be specified. (optional)
     * @param  int|null $included_item Filter that restricts the search result to orders including a specific item. The ID of the item must be specified. (optional)
     * @param  int|null $order_ids Filter that restricts the search result to orders with a specific ID. To list several orders, the order IDs must be enetered separated by commas. (optional)
     * @param  int|null $country_id Filter that restricts the search result to orders with a specific delivery or invoice country. The ID of the country must be specified. (optional)
     * @param  string|null $order_item_name Filter that restricts the search result to orders including a specific item name. The name of the item must be specified. (optional)
     * @param  int|null $variation_number Filter that restricts the search result to orders including a specific variation number. The number of the variation must be specified. (optional)
     * @param  int|null $sender_contact Filter that restricts the search result to orders including a specific sender of the type contact. For example, the supplier is a sender of the type contact for reorders. The ID of the sender must be specified. (optional)
     * @param  int|null $sender_warehouse Filter that restricts the search result to orders including a specific sender of the type warehouse. For example, the sending warehouse is a sender of the type warehouse for redistributions. The ID of the sender must be specified. (optional)
     * @param  int|null $receiver_contact Filter that restricts the search result to orders including a specific receiver of the type contact. For example, a receiver of the type contact is the recipient of a main order. The ID of the receiver must be specified. (optional)
     * @param  int|null $receiver_warehouse Filter that restricts the search result to orders with a specific receiver of the type warehouse. TFor example, the receiving receiving warehouse is a receiver of the type warehouse for redistributions. The ID of the receiver must be specified. (optional)
     * @param  string|null $external_order_id Filter that restricts the search result to orders including a specific external order ID. The external order ID must be specified. (optional)
     * @param  int|null $client_id Filter that restricts the search result to orders belonging to a specific client. The ID of the client must be specified. (optional)
     * @param  string|null $payment_status Filter that restricts the search result to orders with a specific payment status. Valid values are unpaid, partlyPaid, fullyPaid, overpaid. One of these values must be specified. (optional)
     * @param  string|null $updated_at_from Filter that restricts the search result to orders that were last updated on a specified date. The date has to be entered in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $updated_at_to Filter that restricts the search result to orders that were last updated within a specified period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be entered in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $created_at_from Filter that restricts the search result to orders that were created from a specified date up to the present date. This filter can be used alone or can be combined with the CreatedAtTo filter. The date has to be entered in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $created_at_to Filter that restricts the search result to orders that were created within a certain period of time. This filter can be used alone or can be combined with the CreatedAtFrom filter. The date has to be entered in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $paid_at_from Filter that restricts the search result to orders that received a payment on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $paid_at_to Filter that restricts the search result to orders that received a payment within a certain period of time. This filter can be used alone or can be combined with the paidAtFrom filter. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $outgoing_items_booked_at_from Filter that restricts the search result to orders where the outgoing items were booked on the specified date. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  string|null $outgoing_items_booked_at_to Filter that restricts the search result to orders where the outgoing items were booked within a specified period of time. The date has to be in the W3C format, e.g. &#39;2016-10-24T13:33:23+02:00&#39;. (optional)
     * @param  int|null $status_from Filter that restricts the search result to orders in a specific order status. The value of the order status must be specified. (optional)
     * @param  int|null $status_to Filter that restricts the search result to orders within a range of order statuses. This filter can be used alone or can be combined with the statusFrom filter. The value of the order status must be specified. (optional)
     * @param  string|null $has_document Filter that restricts the search result to orders which hold the given document type. Valid values are &lt;i&gt;multi_invoice&lt;/i&gt;, &lt;i&gt;multi_credit_note&lt;/i&gt;, &lt;i&gt;success_confirmation&lt;/i&gt;, &lt;i&gt;return_note&lt;/i&gt;, &lt;i&gt;pickup_delivery&lt;/i&gt;, &lt;i&gt;repair_bill&lt;/i&gt;, &lt;i&gt;dunning_letter&lt;/i&gt;, &lt;i&gt;offer&lt;/i&gt;, &lt;i&gt;order_confirmation&lt;/i&gt;, &lt;i&gt;credit_note&lt;/i&gt;, &lt;i&gt;correction_document&lt;/i&gt;, &lt;i&gt;delivery_note&lt;/i&gt;, &lt;i&gt;invoice&lt;/i&gt;, &lt;i&gt;invoice_external&lt;/i&gt;, &lt;i&gt;receipt&lt;/i&gt; (optional)
     * @param  string|null $has_document_number Filter that restricts the search result to orders which hold documents with given number. (optional)
     * @param  int|null $parent_order_id Filter that restricts the search result to orders which have the given order ID as parent. (optional)
     * @param  bool|null $add_order_items Add the order items to the results. Default &#x3D; true. (optional)
     * @param  int|null $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int|null $items_per_page The number of orders to be displayed per page. The default number of orders per page is 50. (optional)
     * @param  int|null $with Load additional relations for an order. Currently possible are:     &lt;ul&gt;     &lt;li&gt;&#39;addresses&#39; &#x3D; The address objects that are associated with the order.&lt;/li&gt;     &lt;li&gt;&#39;relations&#39; &#x3D; The order relation reference instances that are associated with the order. These instances contain information such as the the reference type, the ID of the reference and the relation itself.&lt;/li&gt;     &lt;li&gt;&#39;comments&#39; &#x3D; The order comments.&lt;/li&gt;     &lt;li&gt;&#39;location&#39; &#x3D; The accounting location of the order.&lt;/li&gt;     &lt;li&gt;&#39;payments&#39; &#x3D; The payments that are associated with the order.&lt;/li&gt;     &lt;li&gt;&#39;documents&#39; &#x3D; The documents that are associated with the order.&lt;/li&gt;     &lt;li&gt;&#39;contactSender&#39; &#x3D; The associated contact for the contact-sender relation.&lt;/li&gt;     &lt;li&gt;&#39;contactReceiver&#39; &#x3D; The associated contact for the contact-receiver relation.&lt;/li&gt;     &lt;li&gt;&#39;warehouseSender&#39; &#x3D; The associated warehouse for the warehouse-sender relation.&lt;/li&gt;     &lt;li&gt;&#39;warehouseReceiver&#39; &#x3D; The associated warehouse for the warehouse-receiver relation.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.variation&#39; &#x3D; The variation that is associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.giftCardCodes&#39; &#x3D; The gift card codes that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.transactions&#39; &#x3D; The transactions that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.serialNumbers&#39; &#x3D; The serial numbers that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.variationBarcodes&#39; &#x3D; The barcodes that are associated with variation of the order item.&lt;/li&gt;     &lt;li&gt;&#39;orderItems.comments&#39; &#x3D; The comments that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;originOrderReferences&#39; &#x3D; The references to other orders, e.g. returns or credit notes, associated with this order.&lt;/li&gt;     &lt;li&gt;&#39;shippingPackages&#39; &#x3D; The shipping packages that are associated with the order.&lt;/li&gt;     &lt;li&gt;&lt;b&gt;deprecated&lt;/b&gt; &#39;orderItems.warehouseLocations&#39; &#x3D; The warehouse locations that are associated with the order item.&lt;/li&gt;     &lt;/ul&gt;     Example: &lt;code&gt;?with[]&#x3D;addresses&amp;with[]&#x3D;orderItems.variation&lt;/code&gt; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersGetRequest(
        $order_type = null,
        $contact_id = null,
        $referrer_id = null,
        $shipping_profile_id = null,
        $shipping_service_provider_id = null,
        $owner_user_id = null,
        $warehouse_id = null,
        $is_ebay_plus = null,
        $included_variation = null,
        $included_item = null,
        $order_ids = null,
        $country_id = null,
        $order_item_name = null,
        $variation_number = null,
        $sender_contact = null,
        $sender_warehouse = null,
        $receiver_contact = null,
        $receiver_warehouse = null,
        $external_order_id = null,
        $client_id = null,
        $payment_status = null,
        $updated_at_from = null,
        $updated_at_to = null,
        $created_at_from = null,
        $created_at_to = null,
        $paid_at_from = null,
        $paid_at_to = null,
        $outgoing_items_booked_at_from = null,
        $outgoing_items_booked_at_to = null,
        $status_from = null,
        $status_to = null,
        $has_document = null,
        $has_document_number = null,
        $parent_order_id = null,
        $add_order_items = null,
        $page = null,
        $items_per_page = null,
        $with = null,
        string $contentType = self::contentTypes['restOrdersGet'][0]
    ): Request
    {








































        $resourcePath = '/rest/orders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order_type,
            'orderType', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $contact_id,
            'contactId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $referrer_id,
            'referrerId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $shipping_profile_id,
            'shippingProfileId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $shipping_service_provider_id,
            'shippingServiceProviderId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $owner_user_id,
            'ownerUserId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $warehouse_id,
            'warehouseId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_ebay_plus,
            'isEbayPlus', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $included_variation,
            'includedVariation', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $included_item,
            'includedItem', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order_ids,
            'orderIds', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $country_id,
            'countryId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order_item_name,
            'orderItemName', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $variation_number,
            'variationNumber', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender_contact,
            'sender.contact', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender_warehouse,
            'sender.warehouse', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $receiver_contact,
            'receiver.contact', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $receiver_warehouse,
            'receiver.warehouse', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $external_order_id,
            'externalOrderId', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $client_id,
            'clientId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $payment_status,
            'paymentStatus', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_at_from,
            'updatedAtFrom', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_at_to,
            'updatedAtTo', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_at_from,
            'createdAtFrom', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_at_to,
            'createdAtTo', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $paid_at_from,
            'paidAtFrom', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $paid_at_to,
            'paidAtTo', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $outgoing_items_booked_at_from,
            'outgoingItemsBookedAtFrom', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $outgoing_items_booked_at_to,
            'outgoingItemsBookedAtTo', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status_from,
            'statusFrom', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status_to,
            'statusTo', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $has_document,
            'hasDocument', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $has_document_number,
            'hasDocumentNumber', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $parent_order_id,
            'parentOrderId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $add_order_items,
            'addOrderItems', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $items_per_page,
            'itemsPerPage', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersItemsDatesIdDelete
     *
     * Delete a date of an order item
     *
     * @param  int $id The ID of the order item date (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsDatesIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restOrdersItemsDatesIdDelete(
        int $id,
        string $contentType = self::contentTypes['restOrdersItemsDatesIdDelete'][0]
    ): void
    {
        $this->restOrdersItemsDatesIdDeleteWithHttpInfo($id, $contentType);
    }

    /**
     * Operation restOrdersItemsDatesIdDeleteWithHttpInfo
     *
     * Delete a date of an order item
     *
     * @param  int $id The ID of the order item date (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsDatesIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersItemsDatesIdDeleteWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restOrdersItemsDatesIdDelete'][0]
    ): array
    {
        $request = $this->restOrdersItemsDatesIdDeleteRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersItemsDatesIdDeleteAsync
     *
     * Delete a date of an order item
     *
     * @param  int $id The ID of the order item date (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsDatesIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersItemsDatesIdDeleteAsync(
        int $id,
        string $contentType = self::contentTypes['restOrdersItemsDatesIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restOrdersItemsDatesIdDeleteAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersItemsDatesIdDeleteAsyncWithHttpInfo
     *
     * Delete a date of an order item
     *
     * @param  int $id The ID of the order item date (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsDatesIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersItemsDatesIdDeleteAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restOrdersItemsDatesIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restOrdersItemsDatesIdDeleteRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersItemsDatesIdDelete'
     *
     * @param  int $id The ID of the order item date (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsDatesIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersItemsDatesIdDeleteRequest(
        $id,
        string $contentType = self::contentTypes['restOrdersItemsDatesIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restOrdersItemsDatesIdDelete'
            );
        }


        $resourcePath = '/rest/orders/items/dates/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersItemsDatesIdGet
     *
     * Get date of an order item
     *
     * @param  int $id The ID of the order item date (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsDatesIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\OrderItemDate
     */
    public function restOrdersItemsDatesIdGet(
        int $id,
        string $contentType = self::contentTypes['restOrdersItemsDatesIdGet'][0]
    ): \ck\Model\OrderItemDate
    {
        list($response) = $this->restOrdersItemsDatesIdGetWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersItemsDatesIdGetWithHttpInfo
     *
     * Get date of an order item
     *
     * @param  int $id The ID of the order item date (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsDatesIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\OrderItemDate, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersItemsDatesIdGetWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restOrdersItemsDatesIdGet'][0]
    ): array
    {
        $request = $this->restOrdersItemsDatesIdGetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\OrderItemDate' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\OrderItemDate' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\OrderItemDate', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\OrderItemDate';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\OrderItemDate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersItemsDatesIdGetAsync
     *
     * Get date of an order item
     *
     * @param  int $id The ID of the order item date (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsDatesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersItemsDatesIdGetAsync(
        int $id,
        string $contentType = self::contentTypes['restOrdersItemsDatesIdGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersItemsDatesIdGetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersItemsDatesIdGetAsyncWithHttpInfo
     *
     * Get date of an order item
     *
     * @param  int $id The ID of the order item date (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsDatesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersItemsDatesIdGetAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restOrdersItemsDatesIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\OrderItemDate';
        $request = $this->restOrdersItemsDatesIdGetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersItemsDatesIdGet'
     *
     * @param  int $id The ID of the order item date (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsDatesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersItemsDatesIdGetRequest(
        $id,
        string $contentType = self::contentTypes['restOrdersItemsDatesIdGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restOrdersItemsDatesIdGet'
            );
        }


        $resourcePath = '/rest/orders/items/dates/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersItemsDatesIdPut
     *
     * Update a date of an order item
     *
     * @param  int $id The ID of the order item date (required)
     * @param  \ck\Model\RestOrdersItemsDatesIdPutRequest|null $_rest_orders_items_dates_id _rest_orders_items_dates_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsDatesIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\OrderItemDate
     */
    public function restOrdersItemsDatesIdPut(
        int $id,
        ?\ck\Model\RestOrdersItemsDatesIdPutRequest $_rest_orders_items_dates_id = null,
        string $contentType = self::contentTypes['restOrdersItemsDatesIdPut'][0]
    ): \ck\Model\OrderItemDate
    {
        list($response) = $this->restOrdersItemsDatesIdPutWithHttpInfo($id, $_rest_orders_items_dates_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersItemsDatesIdPutWithHttpInfo
     *
     * Update a date of an order item
     *
     * @param  int $id The ID of the order item date (required)
     * @param  \ck\Model\RestOrdersItemsDatesIdPutRequest|null $_rest_orders_items_dates_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsDatesIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\OrderItemDate, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersItemsDatesIdPutWithHttpInfo(
        int $id,
        ?\ck\Model\RestOrdersItemsDatesIdPutRequest $_rest_orders_items_dates_id = null,
        string $contentType = self::contentTypes['restOrdersItemsDatesIdPut'][0]
    ): array
    {
        $request = $this->restOrdersItemsDatesIdPutRequest($id, $_rest_orders_items_dates_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\OrderItemDate' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\OrderItemDate' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\OrderItemDate', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\OrderItemDate';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\OrderItemDate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersItemsDatesIdPutAsync
     *
     * Update a date of an order item
     *
     * @param  int $id The ID of the order item date (required)
     * @param  \ck\Model\RestOrdersItemsDatesIdPutRequest|null $_rest_orders_items_dates_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsDatesIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersItemsDatesIdPutAsync(
        int $id,
        ?\ck\Model\RestOrdersItemsDatesIdPutRequest $_rest_orders_items_dates_id = null,
        string $contentType = self::contentTypes['restOrdersItemsDatesIdPut'][0]
    ): PromiseInterface
    {
        return $this->restOrdersItemsDatesIdPutAsyncWithHttpInfo($id, $_rest_orders_items_dates_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersItemsDatesIdPutAsyncWithHttpInfo
     *
     * Update a date of an order item
     *
     * @param  int $id The ID of the order item date (required)
     * @param  \ck\Model\RestOrdersItemsDatesIdPutRequest|null $_rest_orders_items_dates_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsDatesIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersItemsDatesIdPutAsyncWithHttpInfo(
        $id,
        $_rest_orders_items_dates_id = null,
        string $contentType = self::contentTypes['restOrdersItemsDatesIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\OrderItemDate';
        $request = $this->restOrdersItemsDatesIdPutRequest($id, $_rest_orders_items_dates_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersItemsDatesIdPut'
     *
     * @param  int $id The ID of the order item date (required)
     * @param  \ck\Model\RestOrdersItemsDatesIdPutRequest|null $_rest_orders_items_dates_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsDatesIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersItemsDatesIdPutRequest(
        $id,
        $_rest_orders_items_dates_id = null,
        string $contentType = self::contentTypes['restOrdersItemsDatesIdPut'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restOrdersItemsDatesIdPut'
            );
        }



        $resourcePath = '/rest/orders/items/dates/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_orders_items_dates_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_orders_items_dates_id));
            } else {
                $httpBody = $_rest_orders_items_dates_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersItemsDatesPost
     *
     * Create a date for an order item
     *
     * @param  \ck\Model\RestOrdersItemsDatesPostRequest|null $_rest_orders_items_dates _rest_orders_items_dates (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsDatesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\OrderItemDate
     */
    public function restOrdersItemsDatesPost(
        ?\ck\Model\RestOrdersItemsDatesPostRequest $_rest_orders_items_dates = null,
        string $contentType = self::contentTypes['restOrdersItemsDatesPost'][0]
    ): \ck\Model\OrderItemDate
    {
        list($response) = $this->restOrdersItemsDatesPostWithHttpInfo($_rest_orders_items_dates, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersItemsDatesPostWithHttpInfo
     *
     * Create a date for an order item
     *
     * @param  \ck\Model\RestOrdersItemsDatesPostRequest|null $_rest_orders_items_dates (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsDatesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\OrderItemDate, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersItemsDatesPostWithHttpInfo(
        ?\ck\Model\RestOrdersItemsDatesPostRequest $_rest_orders_items_dates = null,
        string $contentType = self::contentTypes['restOrdersItemsDatesPost'][0]
    ): array
    {
        $request = $this->restOrdersItemsDatesPostRequest($_rest_orders_items_dates, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\OrderItemDate' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\OrderItemDate' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\OrderItemDate', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\OrderItemDate';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\OrderItemDate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersItemsDatesPostAsync
     *
     * Create a date for an order item
     *
     * @param  \ck\Model\RestOrdersItemsDatesPostRequest|null $_rest_orders_items_dates (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsDatesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersItemsDatesPostAsync(
        ?\ck\Model\RestOrdersItemsDatesPostRequest $_rest_orders_items_dates = null,
        string $contentType = self::contentTypes['restOrdersItemsDatesPost'][0]
    ): PromiseInterface
    {
        return $this->restOrdersItemsDatesPostAsyncWithHttpInfo($_rest_orders_items_dates, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersItemsDatesPostAsyncWithHttpInfo
     *
     * Create a date for an order item
     *
     * @param  \ck\Model\RestOrdersItemsDatesPostRequest|null $_rest_orders_items_dates (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsDatesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersItemsDatesPostAsyncWithHttpInfo(
        $_rest_orders_items_dates = null,
        string $contentType = self::contentTypes['restOrdersItemsDatesPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\OrderItemDate';
        $request = $this->restOrdersItemsDatesPostRequest($_rest_orders_items_dates, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersItemsDatesPost'
     *
     * @param  \ck\Model\RestOrdersItemsDatesPostRequest|null $_rest_orders_items_dates (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsDatesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersItemsDatesPostRequest(
        $_rest_orders_items_dates = null,
        string $contentType = self::contentTypes['restOrdersItemsDatesPost'][0]
    ): Request
    {



        $resourcePath = '/rest/orders/items/dates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_orders_items_dates)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_orders_items_dates));
            } else {
                $httpBody = $_rest_orders_items_dates;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersItemsOrderItemIdBookingPost
     *
     * Book an order item in
     *
     * @param  int $order_item_id The ID of the order item. (required)
     * @param  string|null $delivery_note_number If desired, set the delivery note number provided by the supplier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdBookingPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restOrdersItemsOrderItemIdBookingPost(
        int $order_item_id,
        ?string $delivery_note_number = null,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdBookingPost'][0]
    ): object
    {
        list($response) = $this->restOrdersItemsOrderItemIdBookingPostWithHttpInfo($order_item_id, $delivery_note_number, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersItemsOrderItemIdBookingPostWithHttpInfo
     *
     * Book an order item in
     *
     * @param  int $order_item_id The ID of the order item. (required)
     * @param  string|null $delivery_note_number If desired, set the delivery note number provided by the supplier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdBookingPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersItemsOrderItemIdBookingPostWithHttpInfo(
        int $order_item_id,
        ?string $delivery_note_number = null,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdBookingPost'][0]
    ): array
    {
        $request = $this->restOrdersItemsOrderItemIdBookingPostRequest($order_item_id, $delivery_note_number, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersItemsOrderItemIdBookingPostAsync
     *
     * Book an order item in
     *
     * @param  int $order_item_id The ID of the order item. (required)
     * @param  string|null $delivery_note_number If desired, set the delivery note number provided by the supplier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdBookingPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersItemsOrderItemIdBookingPostAsync(
        int $order_item_id,
        ?string $delivery_note_number = null,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdBookingPost'][0]
    ): PromiseInterface
    {
        return $this->restOrdersItemsOrderItemIdBookingPostAsyncWithHttpInfo($order_item_id, $delivery_note_number, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersItemsOrderItemIdBookingPostAsyncWithHttpInfo
     *
     * Book an order item in
     *
     * @param  int $order_item_id The ID of the order item. (required)
     * @param  string|null $delivery_note_number If desired, set the delivery note number provided by the supplier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdBookingPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersItemsOrderItemIdBookingPostAsyncWithHttpInfo(
        $order_item_id,
        $delivery_note_number = null,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdBookingPost'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restOrdersItemsOrderItemIdBookingPostRequest($order_item_id, $delivery_note_number, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersItemsOrderItemIdBookingPost'
     *
     * @param  int $order_item_id The ID of the order item. (required)
     * @param  string|null $delivery_note_number If desired, set the delivery note number provided by the supplier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdBookingPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersItemsOrderItemIdBookingPostRequest(
        $order_item_id,
        $delivery_note_number = null,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdBookingPost'][0]
    ): Request
    {

        // verify the required parameter 'order_item_id' is set
        if ($order_item_id === null || (is_array($order_item_id) && count($order_item_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_item_id when calling restOrdersItemsOrderItemIdBookingPost'
            );
        }



        $resourcePath = '/rest/orders/items/{orderItemId}/booking';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $delivery_note_number,
            'deliveryNoteNumber', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($order_item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderItemId' . '}',
                ObjectSerializer::toPathValue($order_item_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersItemsOrderItemIdDatesGet
     *
     * List all dates of an order item
     *
     * @param  int $order_item_id The ID of the order item (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdDatesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\OrderItemDate[]
     */
    public function restOrdersItemsOrderItemIdDatesGet(
        int $order_item_id,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdDatesGet'][0]
    ): array
    {
        list($response) = $this->restOrdersItemsOrderItemIdDatesGetWithHttpInfo($order_item_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersItemsOrderItemIdDatesGetWithHttpInfo
     *
     * List all dates of an order item
     *
     * @param  int $order_item_id The ID of the order item (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdDatesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\OrderItemDate[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersItemsOrderItemIdDatesGetWithHttpInfo(
        int $order_item_id,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdDatesGet'][0]
    ): array
    {
        $request = $this->restOrdersItemsOrderItemIdDatesGetRequest($order_item_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\OrderItemDate[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\OrderItemDate[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\OrderItemDate[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\OrderItemDate[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\OrderItemDate[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersItemsOrderItemIdDatesGetAsync
     *
     * List all dates of an order item
     *
     * @param  int $order_item_id The ID of the order item (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdDatesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersItemsOrderItemIdDatesGetAsync(
        int $order_item_id,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdDatesGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersItemsOrderItemIdDatesGetAsyncWithHttpInfo($order_item_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersItemsOrderItemIdDatesGetAsyncWithHttpInfo
     *
     * List all dates of an order item
     *
     * @param  int $order_item_id The ID of the order item (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdDatesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersItemsOrderItemIdDatesGetAsyncWithHttpInfo(
        $order_item_id,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdDatesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\OrderItemDate[]';
        $request = $this->restOrdersItemsOrderItemIdDatesGetRequest($order_item_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersItemsOrderItemIdDatesGet'
     *
     * @param  int $order_item_id The ID of the order item (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdDatesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersItemsOrderItemIdDatesGetRequest(
        $order_item_id,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdDatesGet'][0]
    ): Request
    {

        // verify the required parameter 'order_item_id' is set
        if ($order_item_id === null || (is_array($order_item_id) && count($order_item_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_item_id when calling restOrdersItemsOrderItemIdDatesGet'
            );
        }


        $resourcePath = '/rest/orders/items/{orderItemId}/dates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderItemId' . '}',
                ObjectSerializer::toPathValue($order_item_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersItemsOrderItemIdDatesTypeIdDelete
     *
     * Delete a date of an order item by order item and date type
     *
     * @param  int $order_item_id The ID of the order item (required)
     * @param  int $type_id The ID of the order date (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdDatesTypeIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restOrdersItemsOrderItemIdDatesTypeIdDelete(
        int $order_item_id,
        int $type_id,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdDatesTypeIdDelete'][0]
    ): void
    {
        $this->restOrdersItemsOrderItemIdDatesTypeIdDeleteWithHttpInfo($order_item_id, $type_id, $contentType);
    }

    /**
     * Operation restOrdersItemsOrderItemIdDatesTypeIdDeleteWithHttpInfo
     *
     * Delete a date of an order item by order item and date type
     *
     * @param  int $order_item_id The ID of the order item (required)
     * @param  int $type_id The ID of the order date (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdDatesTypeIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersItemsOrderItemIdDatesTypeIdDeleteWithHttpInfo(
        int $order_item_id,
        int $type_id,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdDatesTypeIdDelete'][0]
    ): array
    {
        $request = $this->restOrdersItemsOrderItemIdDatesTypeIdDeleteRequest($order_item_id, $type_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersItemsOrderItemIdDatesTypeIdDeleteAsync
     *
     * Delete a date of an order item by order item and date type
     *
     * @param  int $order_item_id The ID of the order item (required)
     * @param  int $type_id The ID of the order date (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdDatesTypeIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersItemsOrderItemIdDatesTypeIdDeleteAsync(
        int $order_item_id,
        int $type_id,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdDatesTypeIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restOrdersItemsOrderItemIdDatesTypeIdDeleteAsyncWithHttpInfo($order_item_id, $type_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersItemsOrderItemIdDatesTypeIdDeleteAsyncWithHttpInfo
     *
     * Delete a date of an order item by order item and date type
     *
     * @param  int $order_item_id The ID of the order item (required)
     * @param  int $type_id The ID of the order date (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdDatesTypeIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersItemsOrderItemIdDatesTypeIdDeleteAsyncWithHttpInfo(
        $order_item_id,
        $type_id,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdDatesTypeIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restOrdersItemsOrderItemIdDatesTypeIdDeleteRequest($order_item_id, $type_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersItemsOrderItemIdDatesTypeIdDelete'
     *
     * @param  int $order_item_id The ID of the order item (required)
     * @param  int $type_id The ID of the order date (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdDatesTypeIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersItemsOrderItemIdDatesTypeIdDeleteRequest(
        $order_item_id,
        $type_id,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdDatesTypeIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'order_item_id' is set
        if ($order_item_id === null || (is_array($order_item_id) && count($order_item_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_item_id when calling restOrdersItemsOrderItemIdDatesTypeIdDelete'
            );
        }

        // verify the required parameter 'type_id' is set
        if ($type_id === null || (is_array($type_id) && count($type_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $type_id when calling restOrdersItemsOrderItemIdDatesTypeIdDelete'
            );
        }


        $resourcePath = '/rest/orders/items/{orderItemId}/dates/{typeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderItemId' . '}',
                ObjectSerializer::toPathValue($order_item_id),
                $resourcePath
            );
        }
        // path params
        if ($type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'typeId' . '}',
                ObjectSerializer::toPathValue($type_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersItemsOrderItemIdDatesTypeIdGet
     *
     * Get a date of an order item by order item and date type
     *
     * @param  int $order_item_id The ID of the order item (required)
     * @param  int $type_id The ID of the order date type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdDatesTypeIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\OrderItemDate
     */
    public function restOrdersItemsOrderItemIdDatesTypeIdGet(
        int $order_item_id,
        int $type_id,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdDatesTypeIdGet'][0]
    ): \ck\Model\OrderItemDate
    {
        list($response) = $this->restOrdersItemsOrderItemIdDatesTypeIdGetWithHttpInfo($order_item_id, $type_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersItemsOrderItemIdDatesTypeIdGetWithHttpInfo
     *
     * Get a date of an order item by order item and date type
     *
     * @param  int $order_item_id The ID of the order item (required)
     * @param  int $type_id The ID of the order date type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdDatesTypeIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\OrderItemDate, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersItemsOrderItemIdDatesTypeIdGetWithHttpInfo(
        int $order_item_id,
        int $type_id,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdDatesTypeIdGet'][0]
    ): array
    {
        $request = $this->restOrdersItemsOrderItemIdDatesTypeIdGetRequest($order_item_id, $type_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\OrderItemDate' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\OrderItemDate' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\OrderItemDate', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\OrderItemDate';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\OrderItemDate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersItemsOrderItemIdDatesTypeIdGetAsync
     *
     * Get a date of an order item by order item and date type
     *
     * @param  int $order_item_id The ID of the order item (required)
     * @param  int $type_id The ID of the order date type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdDatesTypeIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersItemsOrderItemIdDatesTypeIdGetAsync(
        int $order_item_id,
        int $type_id,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdDatesTypeIdGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersItemsOrderItemIdDatesTypeIdGetAsyncWithHttpInfo($order_item_id, $type_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersItemsOrderItemIdDatesTypeIdGetAsyncWithHttpInfo
     *
     * Get a date of an order item by order item and date type
     *
     * @param  int $order_item_id The ID of the order item (required)
     * @param  int $type_id The ID of the order date type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdDatesTypeIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersItemsOrderItemIdDatesTypeIdGetAsyncWithHttpInfo(
        $order_item_id,
        $type_id,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdDatesTypeIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\OrderItemDate';
        $request = $this->restOrdersItemsOrderItemIdDatesTypeIdGetRequest($order_item_id, $type_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersItemsOrderItemIdDatesTypeIdGet'
     *
     * @param  int $order_item_id The ID of the order item (required)
     * @param  int $type_id The ID of the order date type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdDatesTypeIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersItemsOrderItemIdDatesTypeIdGetRequest(
        $order_item_id,
        $type_id,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdDatesTypeIdGet'][0]
    ): Request
    {

        // verify the required parameter 'order_item_id' is set
        if ($order_item_id === null || (is_array($order_item_id) && count($order_item_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_item_id when calling restOrdersItemsOrderItemIdDatesTypeIdGet'
            );
        }

        // verify the required parameter 'type_id' is set
        if ($type_id === null || (is_array($type_id) && count($type_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $type_id when calling restOrdersItemsOrderItemIdDatesTypeIdGet'
            );
        }


        $resourcePath = '/rest/orders/items/{orderItemId}/dates/{typeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderItemId' . '}',
                ObjectSerializer::toPathValue($order_item_id),
                $resourcePath
            );
        }
        // path params
        if ($type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'typeId' . '}',
                ObjectSerializer::toPathValue($type_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersItemsOrderItemIdDatesTypeIdPost
     *
     * Create a date for an order item by order item and date type
     *
     * @param  int $order_item_id The ID of the order item (required)
     * @param  int $type_id The ID of the order date type (required)
     * @param  \ck\Model\RestOrdersItemsDatesPostRequest|null $_rest_orders_items_order_item_id_dates_type_id _rest_orders_items_order_item_id_dates_type_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdDatesTypeIdPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\OrderItemDate
     */
    public function restOrdersItemsOrderItemIdDatesTypeIdPost(
        int $order_item_id,
        int $type_id,
        ?\ck\Model\RestOrdersItemsDatesPostRequest $_rest_orders_items_order_item_id_dates_type_id = null,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdDatesTypeIdPost'][0]
    ): \ck\Model\OrderItemDate
    {
        list($response) = $this->restOrdersItemsOrderItemIdDatesTypeIdPostWithHttpInfo($order_item_id, $type_id, $_rest_orders_items_order_item_id_dates_type_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersItemsOrderItemIdDatesTypeIdPostWithHttpInfo
     *
     * Create a date for an order item by order item and date type
     *
     * @param  int $order_item_id The ID of the order item (required)
     * @param  int $type_id The ID of the order date type (required)
     * @param  \ck\Model\RestOrdersItemsDatesPostRequest|null $_rest_orders_items_order_item_id_dates_type_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdDatesTypeIdPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\OrderItemDate, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersItemsOrderItemIdDatesTypeIdPostWithHttpInfo(
        int $order_item_id,
        int $type_id,
        ?\ck\Model\RestOrdersItemsDatesPostRequest $_rest_orders_items_order_item_id_dates_type_id = null,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdDatesTypeIdPost'][0]
    ): array
    {
        $request = $this->restOrdersItemsOrderItemIdDatesTypeIdPostRequest($order_item_id, $type_id, $_rest_orders_items_order_item_id_dates_type_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\OrderItemDate' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\OrderItemDate' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\OrderItemDate', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\OrderItemDate';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\OrderItemDate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersItemsOrderItemIdDatesTypeIdPostAsync
     *
     * Create a date for an order item by order item and date type
     *
     * @param  int $order_item_id The ID of the order item (required)
     * @param  int $type_id The ID of the order date type (required)
     * @param  \ck\Model\RestOrdersItemsDatesPostRequest|null $_rest_orders_items_order_item_id_dates_type_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdDatesTypeIdPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersItemsOrderItemIdDatesTypeIdPostAsync(
        int $order_item_id,
        int $type_id,
        ?\ck\Model\RestOrdersItemsDatesPostRequest $_rest_orders_items_order_item_id_dates_type_id = null,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdDatesTypeIdPost'][0]
    ): PromiseInterface
    {
        return $this->restOrdersItemsOrderItemIdDatesTypeIdPostAsyncWithHttpInfo($order_item_id, $type_id, $_rest_orders_items_order_item_id_dates_type_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersItemsOrderItemIdDatesTypeIdPostAsyncWithHttpInfo
     *
     * Create a date for an order item by order item and date type
     *
     * @param  int $order_item_id The ID of the order item (required)
     * @param  int $type_id The ID of the order date type (required)
     * @param  \ck\Model\RestOrdersItemsDatesPostRequest|null $_rest_orders_items_order_item_id_dates_type_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdDatesTypeIdPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersItemsOrderItemIdDatesTypeIdPostAsyncWithHttpInfo(
        $order_item_id,
        $type_id,
        $_rest_orders_items_order_item_id_dates_type_id = null,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdDatesTypeIdPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\OrderItemDate';
        $request = $this->restOrdersItemsOrderItemIdDatesTypeIdPostRequest($order_item_id, $type_id, $_rest_orders_items_order_item_id_dates_type_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersItemsOrderItemIdDatesTypeIdPost'
     *
     * @param  int $order_item_id The ID of the order item (required)
     * @param  int $type_id The ID of the order date type (required)
     * @param  \ck\Model\RestOrdersItemsDatesPostRequest|null $_rest_orders_items_order_item_id_dates_type_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdDatesTypeIdPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersItemsOrderItemIdDatesTypeIdPostRequest(
        $order_item_id,
        $type_id,
        $_rest_orders_items_order_item_id_dates_type_id = null,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdDatesTypeIdPost'][0]
    ): Request
    {

        // verify the required parameter 'order_item_id' is set
        if ($order_item_id === null || (is_array($order_item_id) && count($order_item_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_item_id when calling restOrdersItemsOrderItemIdDatesTypeIdPost'
            );
        }

        // verify the required parameter 'type_id' is set
        if ($type_id === null || (is_array($type_id) && count($type_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $type_id when calling restOrdersItemsOrderItemIdDatesTypeIdPost'
            );
        }



        $resourcePath = '/rest/orders/items/{orderItemId}/dates/{typeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderItemId' . '}',
                ObjectSerializer::toPathValue($order_item_id),
                $resourcePath
            );
        }
        // path params
        if ($type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'typeId' . '}',
                ObjectSerializer::toPathValue($type_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_orders_items_order_item_id_dates_type_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_orders_items_order_item_id_dates_type_id));
            } else {
                $httpBody = $_rest_orders_items_order_item_id_dates_type_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersItemsOrderItemIdDatesTypeIdPut
     *
     * Update a date of an order item by order item and date type
     *
     * @param  int $order_item_id The ID of the order item (required)
     * @param  int $type_id The ID of the order date type (required)
     * @param  \ck\Model\RestOrdersItemsDatesIdPutRequest|null $_rest_orders_items_order_item_id_dates_type_id _rest_orders_items_order_item_id_dates_type_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdDatesTypeIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\OrderItemDate
     */
    public function restOrdersItemsOrderItemIdDatesTypeIdPut(
        int $order_item_id,
        int $type_id,
        ?\ck\Model\RestOrdersItemsDatesIdPutRequest $_rest_orders_items_order_item_id_dates_type_id = null,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdDatesTypeIdPut'][0]
    ): \ck\Model\OrderItemDate
    {
        list($response) = $this->restOrdersItemsOrderItemIdDatesTypeIdPutWithHttpInfo($order_item_id, $type_id, $_rest_orders_items_order_item_id_dates_type_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersItemsOrderItemIdDatesTypeIdPutWithHttpInfo
     *
     * Update a date of an order item by order item and date type
     *
     * @param  int $order_item_id The ID of the order item (required)
     * @param  int $type_id The ID of the order date type (required)
     * @param  \ck\Model\RestOrdersItemsDatesIdPutRequest|null $_rest_orders_items_order_item_id_dates_type_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdDatesTypeIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\OrderItemDate, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersItemsOrderItemIdDatesTypeIdPutWithHttpInfo(
        int $order_item_id,
        int $type_id,
        ?\ck\Model\RestOrdersItemsDatesIdPutRequest $_rest_orders_items_order_item_id_dates_type_id = null,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdDatesTypeIdPut'][0]
    ): array
    {
        $request = $this->restOrdersItemsOrderItemIdDatesTypeIdPutRequest($order_item_id, $type_id, $_rest_orders_items_order_item_id_dates_type_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\OrderItemDate' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\OrderItemDate' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\OrderItemDate', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\OrderItemDate';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\OrderItemDate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersItemsOrderItemIdDatesTypeIdPutAsync
     *
     * Update a date of an order item by order item and date type
     *
     * @param  int $order_item_id The ID of the order item (required)
     * @param  int $type_id The ID of the order date type (required)
     * @param  \ck\Model\RestOrdersItemsDatesIdPutRequest|null $_rest_orders_items_order_item_id_dates_type_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdDatesTypeIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersItemsOrderItemIdDatesTypeIdPutAsync(
        int $order_item_id,
        int $type_id,
        ?\ck\Model\RestOrdersItemsDatesIdPutRequest $_rest_orders_items_order_item_id_dates_type_id = null,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdDatesTypeIdPut'][0]
    ): PromiseInterface
    {
        return $this->restOrdersItemsOrderItemIdDatesTypeIdPutAsyncWithHttpInfo($order_item_id, $type_id, $_rest_orders_items_order_item_id_dates_type_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersItemsOrderItemIdDatesTypeIdPutAsyncWithHttpInfo
     *
     * Update a date of an order item by order item and date type
     *
     * @param  int $order_item_id The ID of the order item (required)
     * @param  int $type_id The ID of the order date type (required)
     * @param  \ck\Model\RestOrdersItemsDatesIdPutRequest|null $_rest_orders_items_order_item_id_dates_type_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdDatesTypeIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersItemsOrderItemIdDatesTypeIdPutAsyncWithHttpInfo(
        $order_item_id,
        $type_id,
        $_rest_orders_items_order_item_id_dates_type_id = null,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdDatesTypeIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\OrderItemDate';
        $request = $this->restOrdersItemsOrderItemIdDatesTypeIdPutRequest($order_item_id, $type_id, $_rest_orders_items_order_item_id_dates_type_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersItemsOrderItemIdDatesTypeIdPut'
     *
     * @param  int $order_item_id The ID of the order item (required)
     * @param  int $type_id The ID of the order date type (required)
     * @param  \ck\Model\RestOrdersItemsDatesIdPutRequest|null $_rest_orders_items_order_item_id_dates_type_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdDatesTypeIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersItemsOrderItemIdDatesTypeIdPutRequest(
        $order_item_id,
        $type_id,
        $_rest_orders_items_order_item_id_dates_type_id = null,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdDatesTypeIdPut'][0]
    ): Request
    {

        // verify the required parameter 'order_item_id' is set
        if ($order_item_id === null || (is_array($order_item_id) && count($order_item_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_item_id when calling restOrdersItemsOrderItemIdDatesTypeIdPut'
            );
        }

        // verify the required parameter 'type_id' is set
        if ($type_id === null || (is_array($type_id) && count($type_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $type_id when calling restOrdersItemsOrderItemIdDatesTypeIdPut'
            );
        }



        $resourcePath = '/rest/orders/items/{orderItemId}/dates/{typeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderItemId' . '}',
                ObjectSerializer::toPathValue($order_item_id),
                $resourcePath
            );
        }
        // path params
        if ($type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'typeId' . '}',
                ObjectSerializer::toPathValue($type_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_orders_items_order_item_id_dates_type_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_orders_items_order_item_id_dates_type_id));
            } else {
                $httpBody = $_rest_orders_items_order_item_id_dates_type_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersItemsOrderItemIdPropertiesGet
     *
     * Get all order item properties
     *
     * @param  int $order_item_id The order item ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdPropertiesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\OrderItemProperty[]
     */
    public function restOrdersItemsOrderItemIdPropertiesGet(
        int $order_item_id,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdPropertiesGet'][0]
    ): array
    {
        list($response) = $this->restOrdersItemsOrderItemIdPropertiesGetWithHttpInfo($order_item_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersItemsOrderItemIdPropertiesGetWithHttpInfo
     *
     * Get all order item properties
     *
     * @param  int $order_item_id The order item ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdPropertiesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\OrderItemProperty[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersItemsOrderItemIdPropertiesGetWithHttpInfo(
        int $order_item_id,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdPropertiesGet'][0]
    ): array
    {
        $request = $this->restOrdersItemsOrderItemIdPropertiesGetRequest($order_item_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\OrderItemProperty[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\OrderItemProperty[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\OrderItemProperty[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\OrderItemProperty[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\OrderItemProperty[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersItemsOrderItemIdPropertiesGetAsync
     *
     * Get all order item properties
     *
     * @param  int $order_item_id The order item ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdPropertiesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersItemsOrderItemIdPropertiesGetAsync(
        int $order_item_id,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdPropertiesGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersItemsOrderItemIdPropertiesGetAsyncWithHttpInfo($order_item_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersItemsOrderItemIdPropertiesGetAsyncWithHttpInfo
     *
     * Get all order item properties
     *
     * @param  int $order_item_id The order item ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdPropertiesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersItemsOrderItemIdPropertiesGetAsyncWithHttpInfo(
        $order_item_id,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdPropertiesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\OrderItemProperty[]';
        $request = $this->restOrdersItemsOrderItemIdPropertiesGetRequest($order_item_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersItemsOrderItemIdPropertiesGet'
     *
     * @param  int $order_item_id The order item ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdPropertiesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersItemsOrderItemIdPropertiesGetRequest(
        $order_item_id,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdPropertiesGet'][0]
    ): Request
    {

        // verify the required parameter 'order_item_id' is set
        if ($order_item_id === null || (is_array($order_item_id) && count($order_item_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_item_id when calling restOrdersItemsOrderItemIdPropertiesGet'
            );
        }


        $resourcePath = '/rest/orders/items/{orderItemId}/properties';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderItemId' . '}',
                ObjectSerializer::toPathValue($order_item_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersItemsOrderItemIdPropertiesTypeIdDelete
     *
     * Delete order item property
     *
     * @param  int $order_item_id The order item ID. (required)
     * @param  int $type_id The order item property type ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdPropertiesTypeIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restOrdersItemsOrderItemIdPropertiesTypeIdDelete(
        int $order_item_id,
        int $type_id,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdPropertiesTypeIdDelete'][0]
    ): void
    {
        $this->restOrdersItemsOrderItemIdPropertiesTypeIdDeleteWithHttpInfo($order_item_id, $type_id, $contentType);
    }

    /**
     * Operation restOrdersItemsOrderItemIdPropertiesTypeIdDeleteWithHttpInfo
     *
     * Delete order item property
     *
     * @param  int $order_item_id The order item ID. (required)
     * @param  int $type_id The order item property type ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdPropertiesTypeIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersItemsOrderItemIdPropertiesTypeIdDeleteWithHttpInfo(
        int $order_item_id,
        int $type_id,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdPropertiesTypeIdDelete'][0]
    ): array
    {
        $request = $this->restOrdersItemsOrderItemIdPropertiesTypeIdDeleteRequest($order_item_id, $type_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersItemsOrderItemIdPropertiesTypeIdDeleteAsync
     *
     * Delete order item property
     *
     * @param  int $order_item_id The order item ID. (required)
     * @param  int $type_id The order item property type ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdPropertiesTypeIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersItemsOrderItemIdPropertiesTypeIdDeleteAsync(
        int $order_item_id,
        int $type_id,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdPropertiesTypeIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restOrdersItemsOrderItemIdPropertiesTypeIdDeleteAsyncWithHttpInfo($order_item_id, $type_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersItemsOrderItemIdPropertiesTypeIdDeleteAsyncWithHttpInfo
     *
     * Delete order item property
     *
     * @param  int $order_item_id The order item ID. (required)
     * @param  int $type_id The order item property type ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdPropertiesTypeIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersItemsOrderItemIdPropertiesTypeIdDeleteAsyncWithHttpInfo(
        $order_item_id,
        $type_id,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdPropertiesTypeIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restOrdersItemsOrderItemIdPropertiesTypeIdDeleteRequest($order_item_id, $type_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersItemsOrderItemIdPropertiesTypeIdDelete'
     *
     * @param  int $order_item_id The order item ID. (required)
     * @param  int $type_id The order item property type ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdPropertiesTypeIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersItemsOrderItemIdPropertiesTypeIdDeleteRequest(
        $order_item_id,
        $type_id,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdPropertiesTypeIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'order_item_id' is set
        if ($order_item_id === null || (is_array($order_item_id) && count($order_item_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_item_id when calling restOrdersItemsOrderItemIdPropertiesTypeIdDelete'
            );
        }

        // verify the required parameter 'type_id' is set
        if ($type_id === null || (is_array($type_id) && count($type_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $type_id when calling restOrdersItemsOrderItemIdPropertiesTypeIdDelete'
            );
        }


        $resourcePath = '/rest/orders/items/{orderItemId}/properties/{typeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderItemId' . '}',
                ObjectSerializer::toPathValue($order_item_id),
                $resourcePath
            );
        }
        // path params
        if ($type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'typeId' . '}',
                ObjectSerializer::toPathValue($type_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersItemsOrderItemIdPropertiesTypeIdGet
     *
     * Get order item property
     *
     * @param  int $order_item_id The ID of the order item. (required)
     * @param  int $type_id The ID of the order item property type. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdPropertiesTypeIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\OrderItemProperty
     */
    public function restOrdersItemsOrderItemIdPropertiesTypeIdGet(
        int $order_item_id,
        int $type_id,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdPropertiesTypeIdGet'][0]
    ): \ck\Model\OrderItemProperty
    {
        list($response) = $this->restOrdersItemsOrderItemIdPropertiesTypeIdGetWithHttpInfo($order_item_id, $type_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersItemsOrderItemIdPropertiesTypeIdGetWithHttpInfo
     *
     * Get order item property
     *
     * @param  int $order_item_id The ID of the order item. (required)
     * @param  int $type_id The ID of the order item property type. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdPropertiesTypeIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\OrderItemProperty, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersItemsOrderItemIdPropertiesTypeIdGetWithHttpInfo(
        int $order_item_id,
        int $type_id,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdPropertiesTypeIdGet'][0]
    ): array
    {
        $request = $this->restOrdersItemsOrderItemIdPropertiesTypeIdGetRequest($order_item_id, $type_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\OrderItemProperty' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\OrderItemProperty' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\OrderItemProperty', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\OrderItemProperty';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\OrderItemProperty',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersItemsOrderItemIdPropertiesTypeIdGetAsync
     *
     * Get order item property
     *
     * @param  int $order_item_id The ID of the order item. (required)
     * @param  int $type_id The ID of the order item property type. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdPropertiesTypeIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersItemsOrderItemIdPropertiesTypeIdGetAsync(
        int $order_item_id,
        int $type_id,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdPropertiesTypeIdGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersItemsOrderItemIdPropertiesTypeIdGetAsyncWithHttpInfo($order_item_id, $type_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersItemsOrderItemIdPropertiesTypeIdGetAsyncWithHttpInfo
     *
     * Get order item property
     *
     * @param  int $order_item_id The ID of the order item. (required)
     * @param  int $type_id The ID of the order item property type. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdPropertiesTypeIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersItemsOrderItemIdPropertiesTypeIdGetAsyncWithHttpInfo(
        $order_item_id,
        $type_id,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdPropertiesTypeIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\OrderItemProperty';
        $request = $this->restOrdersItemsOrderItemIdPropertiesTypeIdGetRequest($order_item_id, $type_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersItemsOrderItemIdPropertiesTypeIdGet'
     *
     * @param  int $order_item_id The ID of the order item. (required)
     * @param  int $type_id The ID of the order item property type. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdPropertiesTypeIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersItemsOrderItemIdPropertiesTypeIdGetRequest(
        $order_item_id,
        $type_id,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdPropertiesTypeIdGet'][0]
    ): Request
    {

        // verify the required parameter 'order_item_id' is set
        if ($order_item_id === null || (is_array($order_item_id) && count($order_item_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_item_id when calling restOrdersItemsOrderItemIdPropertiesTypeIdGet'
            );
        }

        // verify the required parameter 'type_id' is set
        if ($type_id === null || (is_array($type_id) && count($type_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $type_id when calling restOrdersItemsOrderItemIdPropertiesTypeIdGet'
            );
        }


        $resourcePath = '/rest/orders/items/{orderItemId}/properties/{typeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderItemId' . '}',
                ObjectSerializer::toPathValue($order_item_id),
                $resourcePath
            );
        }
        // path params
        if ($type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'typeId' . '}',
                ObjectSerializer::toPathValue($type_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersItemsOrderItemIdPropertiesTypeIdPost
     *
     * Create order item property
     *
     * @param  int $order_item_id The order item ID. (required)
     * @param  int $type_id The order item property type ID. (required)
     * @param  \ck\Model\RestOrdersItemsPropertiesPostRequest|null $_rest_orders_items_order_item_id_properties_type_id _rest_orders_items_order_item_id_properties_type_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdPropertiesTypeIdPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\OrderItemProperty
     */
    public function restOrdersItemsOrderItemIdPropertiesTypeIdPost(
        int $order_item_id,
        int $type_id,
        ?\ck\Model\RestOrdersItemsPropertiesPostRequest $_rest_orders_items_order_item_id_properties_type_id = null,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdPropertiesTypeIdPost'][0]
    ): \ck\Model\OrderItemProperty
    {
        list($response) = $this->restOrdersItemsOrderItemIdPropertiesTypeIdPostWithHttpInfo($order_item_id, $type_id, $_rest_orders_items_order_item_id_properties_type_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersItemsOrderItemIdPropertiesTypeIdPostWithHttpInfo
     *
     * Create order item property
     *
     * @param  int $order_item_id The order item ID. (required)
     * @param  int $type_id The order item property type ID. (required)
     * @param  \ck\Model\RestOrdersItemsPropertiesPostRequest|null $_rest_orders_items_order_item_id_properties_type_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdPropertiesTypeIdPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\OrderItemProperty, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersItemsOrderItemIdPropertiesTypeIdPostWithHttpInfo(
        int $order_item_id,
        int $type_id,
        ?\ck\Model\RestOrdersItemsPropertiesPostRequest $_rest_orders_items_order_item_id_properties_type_id = null,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdPropertiesTypeIdPost'][0]
    ): array
    {
        $request = $this->restOrdersItemsOrderItemIdPropertiesTypeIdPostRequest($order_item_id, $type_id, $_rest_orders_items_order_item_id_properties_type_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\OrderItemProperty' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\OrderItemProperty' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\OrderItemProperty', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\OrderItemProperty';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\OrderItemProperty',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersItemsOrderItemIdPropertiesTypeIdPostAsync
     *
     * Create order item property
     *
     * @param  int $order_item_id The order item ID. (required)
     * @param  int $type_id The order item property type ID. (required)
     * @param  \ck\Model\RestOrdersItemsPropertiesPostRequest|null $_rest_orders_items_order_item_id_properties_type_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdPropertiesTypeIdPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersItemsOrderItemIdPropertiesTypeIdPostAsync(
        int $order_item_id,
        int $type_id,
        ?\ck\Model\RestOrdersItemsPropertiesPostRequest $_rest_orders_items_order_item_id_properties_type_id = null,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdPropertiesTypeIdPost'][0]
    ): PromiseInterface
    {
        return $this->restOrdersItemsOrderItemIdPropertiesTypeIdPostAsyncWithHttpInfo($order_item_id, $type_id, $_rest_orders_items_order_item_id_properties_type_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersItemsOrderItemIdPropertiesTypeIdPostAsyncWithHttpInfo
     *
     * Create order item property
     *
     * @param  int $order_item_id The order item ID. (required)
     * @param  int $type_id The order item property type ID. (required)
     * @param  \ck\Model\RestOrdersItemsPropertiesPostRequest|null $_rest_orders_items_order_item_id_properties_type_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdPropertiesTypeIdPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersItemsOrderItemIdPropertiesTypeIdPostAsyncWithHttpInfo(
        $order_item_id,
        $type_id,
        $_rest_orders_items_order_item_id_properties_type_id = null,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdPropertiesTypeIdPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\OrderItemProperty';
        $request = $this->restOrdersItemsOrderItemIdPropertiesTypeIdPostRequest($order_item_id, $type_id, $_rest_orders_items_order_item_id_properties_type_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersItemsOrderItemIdPropertiesTypeIdPost'
     *
     * @param  int $order_item_id The order item ID. (required)
     * @param  int $type_id The order item property type ID. (required)
     * @param  \ck\Model\RestOrdersItemsPropertiesPostRequest|null $_rest_orders_items_order_item_id_properties_type_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdPropertiesTypeIdPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersItemsOrderItemIdPropertiesTypeIdPostRequest(
        $order_item_id,
        $type_id,
        $_rest_orders_items_order_item_id_properties_type_id = null,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdPropertiesTypeIdPost'][0]
    ): Request
    {

        // verify the required parameter 'order_item_id' is set
        if ($order_item_id === null || (is_array($order_item_id) && count($order_item_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_item_id when calling restOrdersItemsOrderItemIdPropertiesTypeIdPost'
            );
        }

        // verify the required parameter 'type_id' is set
        if ($type_id === null || (is_array($type_id) && count($type_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $type_id when calling restOrdersItemsOrderItemIdPropertiesTypeIdPost'
            );
        }



        $resourcePath = '/rest/orders/items/{orderItemId}/properties/{typeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderItemId' . '}',
                ObjectSerializer::toPathValue($order_item_id),
                $resourcePath
            );
        }
        // path params
        if ($type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'typeId' . '}',
                ObjectSerializer::toPathValue($type_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_orders_items_order_item_id_properties_type_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_orders_items_order_item_id_properties_type_id));
            } else {
                $httpBody = $_rest_orders_items_order_item_id_properties_type_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersItemsOrderItemIdPropertiesTypeIdPut
     *
     * Update order item property
     *
     * @param  int $order_item_id The order item ID. (required)
     * @param  int $type_id The order item property type ID. (required)
     * @param  \ck\Model\RestOrdersItemsPropertiesIdPutRequest|null $_rest_orders_items_order_item_id_properties_type_id _rest_orders_items_order_item_id_properties_type_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdPropertiesTypeIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\OrderItemProperty
     */
    public function restOrdersItemsOrderItemIdPropertiesTypeIdPut(
        int $order_item_id,
        int $type_id,
        ?\ck\Model\RestOrdersItemsPropertiesIdPutRequest $_rest_orders_items_order_item_id_properties_type_id = null,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdPropertiesTypeIdPut'][0]
    ): \ck\Model\OrderItemProperty
    {
        list($response) = $this->restOrdersItemsOrderItemIdPropertiesTypeIdPutWithHttpInfo($order_item_id, $type_id, $_rest_orders_items_order_item_id_properties_type_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersItemsOrderItemIdPropertiesTypeIdPutWithHttpInfo
     *
     * Update order item property
     *
     * @param  int $order_item_id The order item ID. (required)
     * @param  int $type_id The order item property type ID. (required)
     * @param  \ck\Model\RestOrdersItemsPropertiesIdPutRequest|null $_rest_orders_items_order_item_id_properties_type_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdPropertiesTypeIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\OrderItemProperty, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersItemsOrderItemIdPropertiesTypeIdPutWithHttpInfo(
        int $order_item_id,
        int $type_id,
        ?\ck\Model\RestOrdersItemsPropertiesIdPutRequest $_rest_orders_items_order_item_id_properties_type_id = null,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdPropertiesTypeIdPut'][0]
    ): array
    {
        $request = $this->restOrdersItemsOrderItemIdPropertiesTypeIdPutRequest($order_item_id, $type_id, $_rest_orders_items_order_item_id_properties_type_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\OrderItemProperty' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\OrderItemProperty' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\OrderItemProperty', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\OrderItemProperty';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\OrderItemProperty',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersItemsOrderItemIdPropertiesTypeIdPutAsync
     *
     * Update order item property
     *
     * @param  int $order_item_id The order item ID. (required)
     * @param  int $type_id The order item property type ID. (required)
     * @param  \ck\Model\RestOrdersItemsPropertiesIdPutRequest|null $_rest_orders_items_order_item_id_properties_type_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdPropertiesTypeIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersItemsOrderItemIdPropertiesTypeIdPutAsync(
        int $order_item_id,
        int $type_id,
        ?\ck\Model\RestOrdersItemsPropertiesIdPutRequest $_rest_orders_items_order_item_id_properties_type_id = null,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdPropertiesTypeIdPut'][0]
    ): PromiseInterface
    {
        return $this->restOrdersItemsOrderItemIdPropertiesTypeIdPutAsyncWithHttpInfo($order_item_id, $type_id, $_rest_orders_items_order_item_id_properties_type_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersItemsOrderItemIdPropertiesTypeIdPutAsyncWithHttpInfo
     *
     * Update order item property
     *
     * @param  int $order_item_id The order item ID. (required)
     * @param  int $type_id The order item property type ID. (required)
     * @param  \ck\Model\RestOrdersItemsPropertiesIdPutRequest|null $_rest_orders_items_order_item_id_properties_type_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdPropertiesTypeIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersItemsOrderItemIdPropertiesTypeIdPutAsyncWithHttpInfo(
        $order_item_id,
        $type_id,
        $_rest_orders_items_order_item_id_properties_type_id = null,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdPropertiesTypeIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\OrderItemProperty';
        $request = $this->restOrdersItemsOrderItemIdPropertiesTypeIdPutRequest($order_item_id, $type_id, $_rest_orders_items_order_item_id_properties_type_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersItemsOrderItemIdPropertiesTypeIdPut'
     *
     * @param  int $order_item_id The order item ID. (required)
     * @param  int $type_id The order item property type ID. (required)
     * @param  \ck\Model\RestOrdersItemsPropertiesIdPutRequest|null $_rest_orders_items_order_item_id_properties_type_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdPropertiesTypeIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersItemsOrderItemIdPropertiesTypeIdPutRequest(
        $order_item_id,
        $type_id,
        $_rest_orders_items_order_item_id_properties_type_id = null,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdPropertiesTypeIdPut'][0]
    ): Request
    {

        // verify the required parameter 'order_item_id' is set
        if ($order_item_id === null || (is_array($order_item_id) && count($order_item_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_item_id when calling restOrdersItemsOrderItemIdPropertiesTypeIdPut'
            );
        }

        // verify the required parameter 'type_id' is set
        if ($type_id === null || (is_array($type_id) && count($type_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $type_id when calling restOrdersItemsOrderItemIdPropertiesTypeIdPut'
            );
        }



        $resourcePath = '/rest/orders/items/{orderItemId}/properties/{typeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderItemId' . '}',
                ObjectSerializer::toPathValue($order_item_id),
                $resourcePath
            );
        }
        // path params
        if ($type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'typeId' . '}',
                ObjectSerializer::toPathValue($type_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_orders_items_order_item_id_properties_type_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_orders_items_order_item_id_properties_type_id));
            } else {
                $httpBody = $_rest_orders_items_order_item_id_properties_type_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersItemsOrderItemIdTransactionsGet
     *
     * List order item transactions
     *
     * @param  int $order_item_id The ID of the order item (required)
     * @param  int|null $columns The properties to be loaded (optional)
     * @param  int|null $with Load additional relations for a transaction. Currently possible are &#39;orderItem&#39; and &#39;warehouseLocation&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdTransactionsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\OrderItemTransaction[]
     */
    public function restOrdersItemsOrderItemIdTransactionsGet(
        int $order_item_id,
        ?int $columns = null,
        ?int $with = null,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdTransactionsGet'][0]
    ): array
    {
        list($response) = $this->restOrdersItemsOrderItemIdTransactionsGetWithHttpInfo($order_item_id, $columns, $with, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersItemsOrderItemIdTransactionsGetWithHttpInfo
     *
     * List order item transactions
     *
     * @param  int $order_item_id The ID of the order item (required)
     * @param  int|null $columns The properties to be loaded (optional)
     * @param  int|null $with Load additional relations for a transaction. Currently possible are &#39;orderItem&#39; and &#39;warehouseLocation&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdTransactionsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\OrderItemTransaction[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersItemsOrderItemIdTransactionsGetWithHttpInfo(
        int $order_item_id,
        ?int $columns = null,
        ?int $with = null,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdTransactionsGet'][0]
    ): array
    {
        $request = $this->restOrdersItemsOrderItemIdTransactionsGetRequest($order_item_id, $columns, $with, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\OrderItemTransaction[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\OrderItemTransaction[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\OrderItemTransaction[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\OrderItemTransaction[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\OrderItemTransaction[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersItemsOrderItemIdTransactionsGetAsync
     *
     * List order item transactions
     *
     * @param  int $order_item_id The ID of the order item (required)
     * @param  int|null $columns The properties to be loaded (optional)
     * @param  int|null $with Load additional relations for a transaction. Currently possible are &#39;orderItem&#39; and &#39;warehouseLocation&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdTransactionsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersItemsOrderItemIdTransactionsGetAsync(
        int $order_item_id,
        ?int $columns = null,
        ?int $with = null,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdTransactionsGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersItemsOrderItemIdTransactionsGetAsyncWithHttpInfo($order_item_id, $columns, $with, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersItemsOrderItemIdTransactionsGetAsyncWithHttpInfo
     *
     * List order item transactions
     *
     * @param  int $order_item_id The ID of the order item (required)
     * @param  int|null $columns The properties to be loaded (optional)
     * @param  int|null $with Load additional relations for a transaction. Currently possible are &#39;orderItem&#39; and &#39;warehouseLocation&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdTransactionsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersItemsOrderItemIdTransactionsGetAsyncWithHttpInfo(
        $order_item_id,
        $columns = null,
        $with = null,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdTransactionsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\OrderItemTransaction[]';
        $request = $this->restOrdersItemsOrderItemIdTransactionsGetRequest($order_item_id, $columns, $with, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersItemsOrderItemIdTransactionsGet'
     *
     * @param  int $order_item_id The ID of the order item (required)
     * @param  int|null $columns The properties to be loaded (optional)
     * @param  int|null $with Load additional relations for a transaction. Currently possible are &#39;orderItem&#39; and &#39;warehouseLocation&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdTransactionsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersItemsOrderItemIdTransactionsGetRequest(
        $order_item_id,
        $columns = null,
        $with = null,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdTransactionsGet'][0]
    ): Request
    {

        // verify the required parameter 'order_item_id' is set
        if ($order_item_id === null || (is_array($order_item_id) && count($order_item_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_item_id when calling restOrdersItemsOrderItemIdTransactionsGet'
            );
        }




        $resourcePath = '/rest/orders/items/{orderItemId}/transactions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $columns,
            'columns', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($order_item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderItemId' . '}',
                ObjectSerializer::toPathValue($order_item_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersItemsOrderItemIdTransactionsPost
     *
     * Create order item transaction
     *
     * @param  int $order_item_id order_item_id (required)
     * @param  \ck\Model\RestOrdersItemsOrderItemIdTransactionsPostRequest|null $_rest_orders_items_order_item_id_transactions _rest_orders_items_order_item_id_transactions (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdTransactionsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\OrderItemTransaction
     */
    public function restOrdersItemsOrderItemIdTransactionsPost(
        int $order_item_id,
        ?\ck\Model\RestOrdersItemsOrderItemIdTransactionsPostRequest $_rest_orders_items_order_item_id_transactions = null,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdTransactionsPost'][0]
    ): \ck\Model\OrderItemTransaction
    {
        list($response) = $this->restOrdersItemsOrderItemIdTransactionsPostWithHttpInfo($order_item_id, $_rest_orders_items_order_item_id_transactions, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersItemsOrderItemIdTransactionsPostWithHttpInfo
     *
     * Create order item transaction
     *
     * @param  int $order_item_id (required)
     * @param  \ck\Model\RestOrdersItemsOrderItemIdTransactionsPostRequest|null $_rest_orders_items_order_item_id_transactions (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdTransactionsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\OrderItemTransaction, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersItemsOrderItemIdTransactionsPostWithHttpInfo(
        int $order_item_id,
        ?\ck\Model\RestOrdersItemsOrderItemIdTransactionsPostRequest $_rest_orders_items_order_item_id_transactions = null,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdTransactionsPost'][0]
    ): array
    {
        $request = $this->restOrdersItemsOrderItemIdTransactionsPostRequest($order_item_id, $_rest_orders_items_order_item_id_transactions, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\OrderItemTransaction' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\OrderItemTransaction' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\OrderItemTransaction', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\OrderItemTransaction';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\OrderItemTransaction',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersItemsOrderItemIdTransactionsPostAsync
     *
     * Create order item transaction
     *
     * @param  int $order_item_id (required)
     * @param  \ck\Model\RestOrdersItemsOrderItemIdTransactionsPostRequest|null $_rest_orders_items_order_item_id_transactions (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdTransactionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersItemsOrderItemIdTransactionsPostAsync(
        int $order_item_id,
        ?\ck\Model\RestOrdersItemsOrderItemIdTransactionsPostRequest $_rest_orders_items_order_item_id_transactions = null,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdTransactionsPost'][0]
    ): PromiseInterface
    {
        return $this->restOrdersItemsOrderItemIdTransactionsPostAsyncWithHttpInfo($order_item_id, $_rest_orders_items_order_item_id_transactions, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersItemsOrderItemIdTransactionsPostAsyncWithHttpInfo
     *
     * Create order item transaction
     *
     * @param  int $order_item_id (required)
     * @param  \ck\Model\RestOrdersItemsOrderItemIdTransactionsPostRequest|null $_rest_orders_items_order_item_id_transactions (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdTransactionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersItemsOrderItemIdTransactionsPostAsyncWithHttpInfo(
        $order_item_id,
        $_rest_orders_items_order_item_id_transactions = null,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdTransactionsPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\OrderItemTransaction';
        $request = $this->restOrdersItemsOrderItemIdTransactionsPostRequest($order_item_id, $_rest_orders_items_order_item_id_transactions, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersItemsOrderItemIdTransactionsPost'
     *
     * @param  int $order_item_id (required)
     * @param  \ck\Model\RestOrdersItemsOrderItemIdTransactionsPostRequest|null $_rest_orders_items_order_item_id_transactions (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOrderItemIdTransactionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersItemsOrderItemIdTransactionsPostRequest(
        $order_item_id,
        $_rest_orders_items_order_item_id_transactions = null,
        string $contentType = self::contentTypes['restOrdersItemsOrderItemIdTransactionsPost'][0]
    ): Request
    {

        // verify the required parameter 'order_item_id' is set
        if ($order_item_id === null || (is_array($order_item_id) && count($order_item_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_item_id when calling restOrdersItemsOrderItemIdTransactionsPost'
            );
        }



        $resourcePath = '/rest/orders/items/{orderItemId}/transactions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderItemId' . '}',
                ObjectSerializer::toPathValue($order_item_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_orders_items_order_item_id_transactions)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_orders_items_order_item_id_transactions));
            } else {
                $httpBody = $_rest_orders_items_order_item_id_transactions;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersItemsOutgoingStocksDelete
     *
     * Revert outgoing stock for order items
     *
     * @param  \ck\Model\RestOrdersItemsOutgoingStocksDeleteRequest|null $_rest_orders_items_outgoing_stocks _rest_orders_items_outgoing_stocks (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOutgoingStocksDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restOrdersItemsOutgoingStocksDelete(
        ?\ck\Model\RestOrdersItemsOutgoingStocksDeleteRequest $_rest_orders_items_outgoing_stocks = null,
        string $contentType = self::contentTypes['restOrdersItemsOutgoingStocksDelete'][0]
    ): void
    {
        $this->restOrdersItemsOutgoingStocksDeleteWithHttpInfo($_rest_orders_items_outgoing_stocks, $contentType);
    }

    /**
     * Operation restOrdersItemsOutgoingStocksDeleteWithHttpInfo
     *
     * Revert outgoing stock for order items
     *
     * @param  \ck\Model\RestOrdersItemsOutgoingStocksDeleteRequest|null $_rest_orders_items_outgoing_stocks (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOutgoingStocksDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersItemsOutgoingStocksDeleteWithHttpInfo(
        ?\ck\Model\RestOrdersItemsOutgoingStocksDeleteRequest $_rest_orders_items_outgoing_stocks = null,
        string $contentType = self::contentTypes['restOrdersItemsOutgoingStocksDelete'][0]
    ): array
    {
        $request = $this->restOrdersItemsOutgoingStocksDeleteRequest($_rest_orders_items_outgoing_stocks, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersItemsOutgoingStocksDeleteAsync
     *
     * Revert outgoing stock for order items
     *
     * @param  \ck\Model\RestOrdersItemsOutgoingStocksDeleteRequest|null $_rest_orders_items_outgoing_stocks (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOutgoingStocksDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersItemsOutgoingStocksDeleteAsync(
        ?\ck\Model\RestOrdersItemsOutgoingStocksDeleteRequest $_rest_orders_items_outgoing_stocks = null,
        string $contentType = self::contentTypes['restOrdersItemsOutgoingStocksDelete'][0]
    ): PromiseInterface
    {
        return $this->restOrdersItemsOutgoingStocksDeleteAsyncWithHttpInfo($_rest_orders_items_outgoing_stocks, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersItemsOutgoingStocksDeleteAsyncWithHttpInfo
     *
     * Revert outgoing stock for order items
     *
     * @param  \ck\Model\RestOrdersItemsOutgoingStocksDeleteRequest|null $_rest_orders_items_outgoing_stocks (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOutgoingStocksDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersItemsOutgoingStocksDeleteAsyncWithHttpInfo(
        $_rest_orders_items_outgoing_stocks = null,
        string $contentType = self::contentTypes['restOrdersItemsOutgoingStocksDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restOrdersItemsOutgoingStocksDeleteRequest($_rest_orders_items_outgoing_stocks, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersItemsOutgoingStocksDelete'
     *
     * @param  \ck\Model\RestOrdersItemsOutgoingStocksDeleteRequest|null $_rest_orders_items_outgoing_stocks (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsOutgoingStocksDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersItemsOutgoingStocksDeleteRequest(
        $_rest_orders_items_outgoing_stocks = null,
        string $contentType = self::contentTypes['restOrdersItemsOutgoingStocksDelete'][0]
    ): Request
    {



        $resourcePath = '/rest/orders/items/outgoing_stocks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_orders_items_outgoing_stocks)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_orders_items_outgoing_stocks));
            } else {
                $httpBody = $_rest_orders_items_outgoing_stocks;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersItemsPropertiesIdDelete
     *
     * Delete order item property
     *
     * @param  int $id The ID of the order item property. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsPropertiesIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restOrdersItemsPropertiesIdDelete(
        int $id,
        string $contentType = self::contentTypes['restOrdersItemsPropertiesIdDelete'][0]
    ): void
    {
        $this->restOrdersItemsPropertiesIdDeleteWithHttpInfo($id, $contentType);
    }

    /**
     * Operation restOrdersItemsPropertiesIdDeleteWithHttpInfo
     *
     * Delete order item property
     *
     * @param  int $id The ID of the order item property. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsPropertiesIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersItemsPropertiesIdDeleteWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restOrdersItemsPropertiesIdDelete'][0]
    ): array
    {
        $request = $this->restOrdersItemsPropertiesIdDeleteRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersItemsPropertiesIdDeleteAsync
     *
     * Delete order item property
     *
     * @param  int $id The ID of the order item property. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsPropertiesIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersItemsPropertiesIdDeleteAsync(
        int $id,
        string $contentType = self::contentTypes['restOrdersItemsPropertiesIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restOrdersItemsPropertiesIdDeleteAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersItemsPropertiesIdDeleteAsyncWithHttpInfo
     *
     * Delete order item property
     *
     * @param  int $id The ID of the order item property. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsPropertiesIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersItemsPropertiesIdDeleteAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restOrdersItemsPropertiesIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restOrdersItemsPropertiesIdDeleteRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersItemsPropertiesIdDelete'
     *
     * @param  int $id The ID of the order item property. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsPropertiesIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersItemsPropertiesIdDeleteRequest(
        $id,
        string $contentType = self::contentTypes['restOrdersItemsPropertiesIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restOrdersItemsPropertiesIdDelete'
            );
        }


        $resourcePath = '/rest/orders/items/properties/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersItemsPropertiesIdGet
     *
     * Get order item property
     *
     * @param  int $id The ID of the order item property. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsPropertiesIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\OrderItemProperty
     */
    public function restOrdersItemsPropertiesIdGet(
        int $id,
        string $contentType = self::contentTypes['restOrdersItemsPropertiesIdGet'][0]
    ): \ck\Model\OrderItemProperty
    {
        list($response) = $this->restOrdersItemsPropertiesIdGetWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersItemsPropertiesIdGetWithHttpInfo
     *
     * Get order item property
     *
     * @param  int $id The ID of the order item property. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsPropertiesIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\OrderItemProperty, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersItemsPropertiesIdGetWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restOrdersItemsPropertiesIdGet'][0]
    ): array
    {
        $request = $this->restOrdersItemsPropertiesIdGetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\OrderItemProperty' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\OrderItemProperty' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\OrderItemProperty', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\OrderItemProperty';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\OrderItemProperty',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersItemsPropertiesIdGetAsync
     *
     * Get order item property
     *
     * @param  int $id The ID of the order item property. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsPropertiesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersItemsPropertiesIdGetAsync(
        int $id,
        string $contentType = self::contentTypes['restOrdersItemsPropertiesIdGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersItemsPropertiesIdGetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersItemsPropertiesIdGetAsyncWithHttpInfo
     *
     * Get order item property
     *
     * @param  int $id The ID of the order item property. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsPropertiesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersItemsPropertiesIdGetAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restOrdersItemsPropertiesIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\OrderItemProperty';
        $request = $this->restOrdersItemsPropertiesIdGetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersItemsPropertiesIdGet'
     *
     * @param  int $id The ID of the order item property. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsPropertiesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersItemsPropertiesIdGetRequest(
        $id,
        string $contentType = self::contentTypes['restOrdersItemsPropertiesIdGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restOrdersItemsPropertiesIdGet'
            );
        }


        $resourcePath = '/rest/orders/items/properties/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersItemsPropertiesIdPut
     *
     * Update order item property
     *
     * @param  int $id The ID of the order item property instance to be updated. (required)
     * @param  \ck\Model\RestOrdersItemsPropertiesIdPutRequest|null $_rest_orders_items_properties_id _rest_orders_items_properties_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsPropertiesIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\OrderItemProperty
     */
    public function restOrdersItemsPropertiesIdPut(
        int $id,
        ?\ck\Model\RestOrdersItemsPropertiesIdPutRequest $_rest_orders_items_properties_id = null,
        string $contentType = self::contentTypes['restOrdersItemsPropertiesIdPut'][0]
    ): \ck\Model\OrderItemProperty
    {
        list($response) = $this->restOrdersItemsPropertiesIdPutWithHttpInfo($id, $_rest_orders_items_properties_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersItemsPropertiesIdPutWithHttpInfo
     *
     * Update order item property
     *
     * @param  int $id The ID of the order item property instance to be updated. (required)
     * @param  \ck\Model\RestOrdersItemsPropertiesIdPutRequest|null $_rest_orders_items_properties_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsPropertiesIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\OrderItemProperty, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersItemsPropertiesIdPutWithHttpInfo(
        int $id,
        ?\ck\Model\RestOrdersItemsPropertiesIdPutRequest $_rest_orders_items_properties_id = null,
        string $contentType = self::contentTypes['restOrdersItemsPropertiesIdPut'][0]
    ): array
    {
        $request = $this->restOrdersItemsPropertiesIdPutRequest($id, $_rest_orders_items_properties_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\OrderItemProperty' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\OrderItemProperty' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\OrderItemProperty', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\OrderItemProperty';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\OrderItemProperty',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersItemsPropertiesIdPutAsync
     *
     * Update order item property
     *
     * @param  int $id The ID of the order item property instance to be updated. (required)
     * @param  \ck\Model\RestOrdersItemsPropertiesIdPutRequest|null $_rest_orders_items_properties_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsPropertiesIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersItemsPropertiesIdPutAsync(
        int $id,
        ?\ck\Model\RestOrdersItemsPropertiesIdPutRequest $_rest_orders_items_properties_id = null,
        string $contentType = self::contentTypes['restOrdersItemsPropertiesIdPut'][0]
    ): PromiseInterface
    {
        return $this->restOrdersItemsPropertiesIdPutAsyncWithHttpInfo($id, $_rest_orders_items_properties_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersItemsPropertiesIdPutAsyncWithHttpInfo
     *
     * Update order item property
     *
     * @param  int $id The ID of the order item property instance to be updated. (required)
     * @param  \ck\Model\RestOrdersItemsPropertiesIdPutRequest|null $_rest_orders_items_properties_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsPropertiesIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersItemsPropertiesIdPutAsyncWithHttpInfo(
        $id,
        $_rest_orders_items_properties_id = null,
        string $contentType = self::contentTypes['restOrdersItemsPropertiesIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\OrderItemProperty';
        $request = $this->restOrdersItemsPropertiesIdPutRequest($id, $_rest_orders_items_properties_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersItemsPropertiesIdPut'
     *
     * @param  int $id The ID of the order item property instance to be updated. (required)
     * @param  \ck\Model\RestOrdersItemsPropertiesIdPutRequest|null $_rest_orders_items_properties_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsPropertiesIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersItemsPropertiesIdPutRequest(
        $id,
        $_rest_orders_items_properties_id = null,
        string $contentType = self::contentTypes['restOrdersItemsPropertiesIdPut'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restOrdersItemsPropertiesIdPut'
            );
        }



        $resourcePath = '/rest/orders/items/properties/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_orders_items_properties_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_orders_items_properties_id));
            } else {
                $httpBody = $_rest_orders_items_properties_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersItemsPropertiesPost
     *
     * Create order item property
     *
     * @param  \ck\Model\RestOrdersItemsPropertiesPostRequest|null $_rest_orders_items_properties _rest_orders_items_properties (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsPropertiesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\OrderItemProperty
     */
    public function restOrdersItemsPropertiesPost(
        ?\ck\Model\RestOrdersItemsPropertiesPostRequest $_rest_orders_items_properties = null,
        string $contentType = self::contentTypes['restOrdersItemsPropertiesPost'][0]
    ): \ck\Model\OrderItemProperty
    {
        list($response) = $this->restOrdersItemsPropertiesPostWithHttpInfo($_rest_orders_items_properties, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersItemsPropertiesPostWithHttpInfo
     *
     * Create order item property
     *
     * @param  \ck\Model\RestOrdersItemsPropertiesPostRequest|null $_rest_orders_items_properties (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsPropertiesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\OrderItemProperty, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersItemsPropertiesPostWithHttpInfo(
        ?\ck\Model\RestOrdersItemsPropertiesPostRequest $_rest_orders_items_properties = null,
        string $contentType = self::contentTypes['restOrdersItemsPropertiesPost'][0]
    ): array
    {
        $request = $this->restOrdersItemsPropertiesPostRequest($_rest_orders_items_properties, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\OrderItemProperty' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\OrderItemProperty' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\OrderItemProperty', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\OrderItemProperty';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\OrderItemProperty',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersItemsPropertiesPostAsync
     *
     * Create order item property
     *
     * @param  \ck\Model\RestOrdersItemsPropertiesPostRequest|null $_rest_orders_items_properties (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsPropertiesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersItemsPropertiesPostAsync(
        ?\ck\Model\RestOrdersItemsPropertiesPostRequest $_rest_orders_items_properties = null,
        string $contentType = self::contentTypes['restOrdersItemsPropertiesPost'][0]
    ): PromiseInterface
    {
        return $this->restOrdersItemsPropertiesPostAsyncWithHttpInfo($_rest_orders_items_properties, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersItemsPropertiesPostAsyncWithHttpInfo
     *
     * Create order item property
     *
     * @param  \ck\Model\RestOrdersItemsPropertiesPostRequest|null $_rest_orders_items_properties (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsPropertiesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersItemsPropertiesPostAsyncWithHttpInfo(
        $_rest_orders_items_properties = null,
        string $contentType = self::contentTypes['restOrdersItemsPropertiesPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\OrderItemProperty';
        $request = $this->restOrdersItemsPropertiesPostRequest($_rest_orders_items_properties, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersItemsPropertiesPost'
     *
     * @param  \ck\Model\RestOrdersItemsPropertiesPostRequest|null $_rest_orders_items_properties (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsPropertiesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersItemsPropertiesPostRequest(
        $_rest_orders_items_properties = null,
        string $contentType = self::contentTypes['restOrdersItemsPropertiesPost'][0]
    ): Request
    {



        $resourcePath = '/rest/orders/items/properties';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_orders_items_properties)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_orders_items_properties));
            } else {
                $httpBody = $_rest_orders_items_properties;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersItemsTransactionsBookingPost
     *
     * Book order item transactions
     *
     * @param  int $transaction_ids The IDs of the order item transactions. (required)
     * @param  string|null $delivery_note_number If desired, set a delivery note number. The delivery note number has to match the type of order item transaction. For incoming items, set an external delivery note number. For outgoing items, set an external or an internal delivery note number. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsTransactionsBookingPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restOrdersItemsTransactionsBookingPost(
        int $transaction_ids,
        ?string $delivery_note_number = null,
        string $contentType = self::contentTypes['restOrdersItemsTransactionsBookingPost'][0]
    ): object
    {
        list($response) = $this->restOrdersItemsTransactionsBookingPostWithHttpInfo($transaction_ids, $delivery_note_number, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersItemsTransactionsBookingPostWithHttpInfo
     *
     * Book order item transactions
     *
     * @param  int $transaction_ids The IDs of the order item transactions. (required)
     * @param  string|null $delivery_note_number If desired, set a delivery note number. The delivery note number has to match the type of order item transaction. For incoming items, set an external delivery note number. For outgoing items, set an external or an internal delivery note number. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsTransactionsBookingPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersItemsTransactionsBookingPostWithHttpInfo(
        int $transaction_ids,
        ?string $delivery_note_number = null,
        string $contentType = self::contentTypes['restOrdersItemsTransactionsBookingPost'][0]
    ): array
    {
        $request = $this->restOrdersItemsTransactionsBookingPostRequest($transaction_ids, $delivery_note_number, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersItemsTransactionsBookingPostAsync
     *
     * Book order item transactions
     *
     * @param  int $transaction_ids The IDs of the order item transactions. (required)
     * @param  string|null $delivery_note_number If desired, set a delivery note number. The delivery note number has to match the type of order item transaction. For incoming items, set an external delivery note number. For outgoing items, set an external or an internal delivery note number. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsTransactionsBookingPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersItemsTransactionsBookingPostAsync(
        int $transaction_ids,
        ?string $delivery_note_number = null,
        string $contentType = self::contentTypes['restOrdersItemsTransactionsBookingPost'][0]
    ): PromiseInterface
    {
        return $this->restOrdersItemsTransactionsBookingPostAsyncWithHttpInfo($transaction_ids, $delivery_note_number, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersItemsTransactionsBookingPostAsyncWithHttpInfo
     *
     * Book order item transactions
     *
     * @param  int $transaction_ids The IDs of the order item transactions. (required)
     * @param  string|null $delivery_note_number If desired, set a delivery note number. The delivery note number has to match the type of order item transaction. For incoming items, set an external delivery note number. For outgoing items, set an external or an internal delivery note number. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsTransactionsBookingPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersItemsTransactionsBookingPostAsyncWithHttpInfo(
        $transaction_ids,
        $delivery_note_number = null,
        string $contentType = self::contentTypes['restOrdersItemsTransactionsBookingPost'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restOrdersItemsTransactionsBookingPostRequest($transaction_ids, $delivery_note_number, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersItemsTransactionsBookingPost'
     *
     * @param  int $transaction_ids The IDs of the order item transactions. (required)
     * @param  string|null $delivery_note_number If desired, set a delivery note number. The delivery note number has to match the type of order item transaction. For incoming items, set an external delivery note number. For outgoing items, set an external or an internal delivery note number. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsTransactionsBookingPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersItemsTransactionsBookingPostRequest(
        $transaction_ids,
        $delivery_note_number = null,
        string $contentType = self::contentTypes['restOrdersItemsTransactionsBookingPost'][0]
    ): Request
    {

        // verify the required parameter 'transaction_ids' is set
        if ($transaction_ids === null || (is_array($transaction_ids) && count($transaction_ids) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $transaction_ids when calling restOrdersItemsTransactionsBookingPost'
            );
        }



        $resourcePath = '/rest/orders/items/transactions/booking';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $transaction_ids,
            'transactionIds', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $delivery_note_number,
            'deliveryNoteNumber', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersItemsTransactionsGet
     *
     * Search order item transactions
     *
     * @param  int|null $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int|null $items_per_page The number of orders to be displayed per page. The default number of orders per page is 50. (optional)
     * @param  int|null $columns Specifies the properties of the order item transactions to be loaded. (optional)
     * @param  int|null $with Loads additional relations of the order item transactions. The available relations are &#39;orderItem&#39; and &#39;warehouseLocation&#39;. (optional)
     * @param  string|null $sort_by Sort search result according to createdAt, updatedAt, orderItemId, receiptId or quantity. The default value is orderItemId. (optional)
     * @param  string|null $sort_order Sort direction desc or asc. The default value is asc. (optional)
     * @param  int|null $order_item_id The ID of the order item (optional)
     * @param  int|null $order_id The ID of the order (optional)
     * @param  string|null $direction The direction of the order item transactions (optional)
     * @param  string|null $status The status of the order item transactions (&#39;in&#39; for incoming or &#39;out&#39; for outgoing) (optional)
     * @param  bool|null $is_booked Returns all booked order item transactions. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsTransactionsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestOrdersItemsTransactionsGet200Response
     */
    public function restOrdersItemsTransactionsGet(
        ?int $page = null,
        ?int $items_per_page = null,
        ?int $columns = null,
        ?int $with = null,
        ?string $sort_by = null,
        ?string $sort_order = null,
        ?int $order_item_id = null,
        ?int $order_id = null,
        ?string $direction = null,
        ?string $status = null,
        ?bool $is_booked = null,
        string $contentType = self::contentTypes['restOrdersItemsTransactionsGet'][0]
    ): \ck\Model\RestOrdersItemsTransactionsGet200Response
    {
        list($response) = $this->restOrdersItemsTransactionsGetWithHttpInfo($page, $items_per_page, $columns, $with, $sort_by, $sort_order, $order_item_id, $order_id, $direction, $status, $is_booked, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersItemsTransactionsGetWithHttpInfo
     *
     * Search order item transactions
     *
     * @param  int|null $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int|null $items_per_page The number of orders to be displayed per page. The default number of orders per page is 50. (optional)
     * @param  int|null $columns Specifies the properties of the order item transactions to be loaded. (optional)
     * @param  int|null $with Loads additional relations of the order item transactions. The available relations are &#39;orderItem&#39; and &#39;warehouseLocation&#39;. (optional)
     * @param  string|null $sort_by Sort search result according to createdAt, updatedAt, orderItemId, receiptId or quantity. The default value is orderItemId. (optional)
     * @param  string|null $sort_order Sort direction desc or asc. The default value is asc. (optional)
     * @param  int|null $order_item_id The ID of the order item (optional)
     * @param  int|null $order_id The ID of the order (optional)
     * @param  string|null $direction The direction of the order item transactions (optional)
     * @param  string|null $status The status of the order item transactions (&#39;in&#39; for incoming or &#39;out&#39; for outgoing) (optional)
     * @param  bool|null $is_booked Returns all booked order item transactions. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsTransactionsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestOrdersItemsTransactionsGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersItemsTransactionsGetWithHttpInfo(
        ?int $page = null,
        ?int $items_per_page = null,
        ?int $columns = null,
        ?int $with = null,
        ?string $sort_by = null,
        ?string $sort_order = null,
        ?int $order_item_id = null,
        ?int $order_id = null,
        ?string $direction = null,
        ?string $status = null,
        ?bool $is_booked = null,
        string $contentType = self::contentTypes['restOrdersItemsTransactionsGet'][0]
    ): array
    {
        $request = $this->restOrdersItemsTransactionsGetRequest($page, $items_per_page, $columns, $with, $sort_by, $sort_order, $order_item_id, $order_id, $direction, $status, $is_booked, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestOrdersItemsTransactionsGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestOrdersItemsTransactionsGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestOrdersItemsTransactionsGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestOrdersItemsTransactionsGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestOrdersItemsTransactionsGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersItemsTransactionsGetAsync
     *
     * Search order item transactions
     *
     * @param  int|null $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int|null $items_per_page The number of orders to be displayed per page. The default number of orders per page is 50. (optional)
     * @param  int|null $columns Specifies the properties of the order item transactions to be loaded. (optional)
     * @param  int|null $with Loads additional relations of the order item transactions. The available relations are &#39;orderItem&#39; and &#39;warehouseLocation&#39;. (optional)
     * @param  string|null $sort_by Sort search result according to createdAt, updatedAt, orderItemId, receiptId or quantity. The default value is orderItemId. (optional)
     * @param  string|null $sort_order Sort direction desc or asc. The default value is asc. (optional)
     * @param  int|null $order_item_id The ID of the order item (optional)
     * @param  int|null $order_id The ID of the order (optional)
     * @param  string|null $direction The direction of the order item transactions (optional)
     * @param  string|null $status The status of the order item transactions (&#39;in&#39; for incoming or &#39;out&#39; for outgoing) (optional)
     * @param  bool|null $is_booked Returns all booked order item transactions. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsTransactionsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersItemsTransactionsGetAsync(
        ?int $page = null,
        ?int $items_per_page = null,
        ?int $columns = null,
        ?int $with = null,
        ?string $sort_by = null,
        ?string $sort_order = null,
        ?int $order_item_id = null,
        ?int $order_id = null,
        ?string $direction = null,
        ?string $status = null,
        ?bool $is_booked = null,
        string $contentType = self::contentTypes['restOrdersItemsTransactionsGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersItemsTransactionsGetAsyncWithHttpInfo($page, $items_per_page, $columns, $with, $sort_by, $sort_order, $order_item_id, $order_id, $direction, $status, $is_booked, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersItemsTransactionsGetAsyncWithHttpInfo
     *
     * Search order item transactions
     *
     * @param  int|null $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int|null $items_per_page The number of orders to be displayed per page. The default number of orders per page is 50. (optional)
     * @param  int|null $columns Specifies the properties of the order item transactions to be loaded. (optional)
     * @param  int|null $with Loads additional relations of the order item transactions. The available relations are &#39;orderItem&#39; and &#39;warehouseLocation&#39;. (optional)
     * @param  string|null $sort_by Sort search result according to createdAt, updatedAt, orderItemId, receiptId or quantity. The default value is orderItemId. (optional)
     * @param  string|null $sort_order Sort direction desc or asc. The default value is asc. (optional)
     * @param  int|null $order_item_id The ID of the order item (optional)
     * @param  int|null $order_id The ID of the order (optional)
     * @param  string|null $direction The direction of the order item transactions (optional)
     * @param  string|null $status The status of the order item transactions (&#39;in&#39; for incoming or &#39;out&#39; for outgoing) (optional)
     * @param  bool|null $is_booked Returns all booked order item transactions. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsTransactionsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersItemsTransactionsGetAsyncWithHttpInfo(
        $page = null,
        $items_per_page = null,
        $columns = null,
        $with = null,
        $sort_by = null,
        $sort_order = null,
        $order_item_id = null,
        $order_id = null,
        $direction = null,
        $status = null,
        $is_booked = null,
        string $contentType = self::contentTypes['restOrdersItemsTransactionsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestOrdersItemsTransactionsGet200Response';
        $request = $this->restOrdersItemsTransactionsGetRequest($page, $items_per_page, $columns, $with, $sort_by, $sort_order, $order_item_id, $order_id, $direction, $status, $is_booked, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersItemsTransactionsGet'
     *
     * @param  int|null $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int|null $items_per_page The number of orders to be displayed per page. The default number of orders per page is 50. (optional)
     * @param  int|null $columns Specifies the properties of the order item transactions to be loaded. (optional)
     * @param  int|null $with Loads additional relations of the order item transactions. The available relations are &#39;orderItem&#39; and &#39;warehouseLocation&#39;. (optional)
     * @param  string|null $sort_by Sort search result according to createdAt, updatedAt, orderItemId, receiptId or quantity. The default value is orderItemId. (optional)
     * @param  string|null $sort_order Sort direction desc or asc. The default value is asc. (optional)
     * @param  int|null $order_item_id The ID of the order item (optional)
     * @param  int|null $order_id The ID of the order (optional)
     * @param  string|null $direction The direction of the order item transactions (optional)
     * @param  string|null $status The status of the order item transactions (&#39;in&#39; for incoming or &#39;out&#39; for outgoing) (optional)
     * @param  bool|null $is_booked Returns all booked order item transactions. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsTransactionsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersItemsTransactionsGetRequest(
        $page = null,
        $items_per_page = null,
        $columns = null,
        $with = null,
        $sort_by = null,
        $sort_order = null,
        $order_item_id = null,
        $order_id = null,
        $direction = null,
        $status = null,
        $is_booked = null,
        string $contentType = self::contentTypes['restOrdersItemsTransactionsGet'][0]
    ): Request
    {













        $resourcePath = '/rest/orders/items/transactions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $items_per_page,
            'itemsPerPage', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $columns,
            'columns', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_by,
            'sortBy', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_order,
            'sortOrder', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order_item_id,
            'orderItemId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order_id,
            'orderId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $direction,
            'direction', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_booked,
            'isBooked', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersItemsTransactionsTransactionIdDelete
     *
     * Delete order item transaction
     *
     * @param  int $transaction_id transaction_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsTransactionsTransactionIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restOrdersItemsTransactionsTransactionIdDelete(
        int $transaction_id,
        string $contentType = self::contentTypes['restOrdersItemsTransactionsTransactionIdDelete'][0]
    ): object
    {
        list($response) = $this->restOrdersItemsTransactionsTransactionIdDeleteWithHttpInfo($transaction_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersItemsTransactionsTransactionIdDeleteWithHttpInfo
     *
     * Delete order item transaction
     *
     * @param  int $transaction_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsTransactionsTransactionIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersItemsTransactionsTransactionIdDeleteWithHttpInfo(
        int $transaction_id,
        string $contentType = self::contentTypes['restOrdersItemsTransactionsTransactionIdDelete'][0]
    ): array
    {
        $request = $this->restOrdersItemsTransactionsTransactionIdDeleteRequest($transaction_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersItemsTransactionsTransactionIdDeleteAsync
     *
     * Delete order item transaction
     *
     * @param  int $transaction_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsTransactionsTransactionIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersItemsTransactionsTransactionIdDeleteAsync(
        int $transaction_id,
        string $contentType = self::contentTypes['restOrdersItemsTransactionsTransactionIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restOrdersItemsTransactionsTransactionIdDeleteAsyncWithHttpInfo($transaction_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersItemsTransactionsTransactionIdDeleteAsyncWithHttpInfo
     *
     * Delete order item transaction
     *
     * @param  int $transaction_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsTransactionsTransactionIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersItemsTransactionsTransactionIdDeleteAsyncWithHttpInfo(
        $transaction_id,
        string $contentType = self::contentTypes['restOrdersItemsTransactionsTransactionIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restOrdersItemsTransactionsTransactionIdDeleteRequest($transaction_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersItemsTransactionsTransactionIdDelete'
     *
     * @param  int $transaction_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsTransactionsTransactionIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersItemsTransactionsTransactionIdDeleteRequest(
        $transaction_id,
        string $contentType = self::contentTypes['restOrdersItemsTransactionsTransactionIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'transaction_id' is set
        if ($transaction_id === null || (is_array($transaction_id) && count($transaction_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $transaction_id when calling restOrdersItemsTransactionsTransactionIdDelete'
            );
        }


        $resourcePath = '/rest/orders/items/transactions/{transactionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($transaction_id !== null) {
            $resourcePath = str_replace(
                '{' . 'transactionId' . '}',
                ObjectSerializer::toPathValue($transaction_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersItemsTransactionsTransactionIdPut
     *
     * Update order item transaction
     *
     * @param  int $transaction_id transaction_id (required)
     * @param  \ck\Model\RestOrdersItemsTransactionsTransactionIdPutRequest|null $_rest_orders_items_transactions_transaction_id _rest_orders_items_transactions_transaction_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsTransactionsTransactionIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\OrderItemTransaction
     */
    public function restOrdersItemsTransactionsTransactionIdPut(
        int $transaction_id,
        ?\ck\Model\RestOrdersItemsTransactionsTransactionIdPutRequest $_rest_orders_items_transactions_transaction_id = null,
        string $contentType = self::contentTypes['restOrdersItemsTransactionsTransactionIdPut'][0]
    ): \ck\Model\OrderItemTransaction
    {
        list($response) = $this->restOrdersItemsTransactionsTransactionIdPutWithHttpInfo($transaction_id, $_rest_orders_items_transactions_transaction_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersItemsTransactionsTransactionIdPutWithHttpInfo
     *
     * Update order item transaction
     *
     * @param  int $transaction_id (required)
     * @param  \ck\Model\RestOrdersItemsTransactionsTransactionIdPutRequest|null $_rest_orders_items_transactions_transaction_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsTransactionsTransactionIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\OrderItemTransaction, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersItemsTransactionsTransactionIdPutWithHttpInfo(
        int $transaction_id,
        ?\ck\Model\RestOrdersItemsTransactionsTransactionIdPutRequest $_rest_orders_items_transactions_transaction_id = null,
        string $contentType = self::contentTypes['restOrdersItemsTransactionsTransactionIdPut'][0]
    ): array
    {
        $request = $this->restOrdersItemsTransactionsTransactionIdPutRequest($transaction_id, $_rest_orders_items_transactions_transaction_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\OrderItemTransaction' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\OrderItemTransaction' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\OrderItemTransaction', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\OrderItemTransaction';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\OrderItemTransaction',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersItemsTransactionsTransactionIdPutAsync
     *
     * Update order item transaction
     *
     * @param  int $transaction_id (required)
     * @param  \ck\Model\RestOrdersItemsTransactionsTransactionIdPutRequest|null $_rest_orders_items_transactions_transaction_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsTransactionsTransactionIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersItemsTransactionsTransactionIdPutAsync(
        int $transaction_id,
        ?\ck\Model\RestOrdersItemsTransactionsTransactionIdPutRequest $_rest_orders_items_transactions_transaction_id = null,
        string $contentType = self::contentTypes['restOrdersItemsTransactionsTransactionIdPut'][0]
    ): PromiseInterface
    {
        return $this->restOrdersItemsTransactionsTransactionIdPutAsyncWithHttpInfo($transaction_id, $_rest_orders_items_transactions_transaction_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersItemsTransactionsTransactionIdPutAsyncWithHttpInfo
     *
     * Update order item transaction
     *
     * @param  int $transaction_id (required)
     * @param  \ck\Model\RestOrdersItemsTransactionsTransactionIdPutRequest|null $_rest_orders_items_transactions_transaction_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsTransactionsTransactionIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersItemsTransactionsTransactionIdPutAsyncWithHttpInfo(
        $transaction_id,
        $_rest_orders_items_transactions_transaction_id = null,
        string $contentType = self::contentTypes['restOrdersItemsTransactionsTransactionIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\OrderItemTransaction';
        $request = $this->restOrdersItemsTransactionsTransactionIdPutRequest($transaction_id, $_rest_orders_items_transactions_transaction_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersItemsTransactionsTransactionIdPut'
     *
     * @param  int $transaction_id (required)
     * @param  \ck\Model\RestOrdersItemsTransactionsTransactionIdPutRequest|null $_rest_orders_items_transactions_transaction_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersItemsTransactionsTransactionIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersItemsTransactionsTransactionIdPutRequest(
        $transaction_id,
        $_rest_orders_items_transactions_transaction_id = null,
        string $contentType = self::contentTypes['restOrdersItemsTransactionsTransactionIdPut'][0]
    ): Request
    {

        // verify the required parameter 'transaction_id' is set
        if ($transaction_id === null || (is_array($transaction_id) && count($transaction_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $transaction_id when calling restOrdersItemsTransactionsTransactionIdPut'
            );
        }



        $resourcePath = '/rest/orders/items/transactions/{transactionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($transaction_id !== null) {
            $resourcePath = str_replace(
                '{' . 'transactionId' . '}',
                ObjectSerializer::toPathValue($transaction_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_orders_items_transactions_transaction_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_orders_items_transactions_transaction_id));
            } else {
                $httpBody = $_rest_orders_items_transactions_transaction_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdBookingPost
     *
     * Book an order in
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  string|null $delivery_note_number If desired, set the delivery note number provided by the supplier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdBookingPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restOrdersOrderIdBookingPost(
        int $order_id,
        ?string $delivery_note_number = null,
        string $contentType = self::contentTypes['restOrdersOrderIdBookingPost'][0]
    ): object
    {
        list($response) = $this->restOrdersOrderIdBookingPostWithHttpInfo($order_id, $delivery_note_number, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdBookingPostWithHttpInfo
     *
     * Book an order in
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  string|null $delivery_note_number If desired, set the delivery note number provided by the supplier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdBookingPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdBookingPostWithHttpInfo(
        int $order_id,
        ?string $delivery_note_number = null,
        string $contentType = self::contentTypes['restOrdersOrderIdBookingPost'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdBookingPostRequest($order_id, $delivery_note_number, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdBookingPostAsync
     *
     * Book an order in
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  string|null $delivery_note_number If desired, set the delivery note number provided by the supplier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdBookingPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdBookingPostAsync(
        int $order_id,
        ?string $delivery_note_number = null,
        string $contentType = self::contentTypes['restOrdersOrderIdBookingPost'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdBookingPostAsyncWithHttpInfo($order_id, $delivery_note_number, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdBookingPostAsyncWithHttpInfo
     *
     * Book an order in
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  string|null $delivery_note_number If desired, set the delivery note number provided by the supplier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdBookingPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdBookingPostAsyncWithHttpInfo(
        $order_id,
        $delivery_note_number = null,
        string $contentType = self::contentTypes['restOrdersOrderIdBookingPost'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restOrdersOrderIdBookingPostRequest($order_id, $delivery_note_number, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdBookingPost'
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  string|null $delivery_note_number If desired, set the delivery note number provided by the supplier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdBookingPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdBookingPostRequest(
        $order_id,
        $delivery_note_number = null,
        string $contentType = self::contentTypes['restOrdersOrderIdBookingPost'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdBookingPost'
            );
        }



        $resourcePath = '/rest/orders/{orderId}/booking';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $delivery_note_number,
            'deliveryNoteNumber', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdCancelPut
     *
     * Cancel an order
     *
     * @param  int $order_id The ID of the order to be canceled. (required)
     * @param  \ck\Model\RestOrdersOrderIdCancelPutRequest|null $_rest_orders_order_id_cancel _rest_orders_order_id_cancel (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdCancelPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restOrdersOrderIdCancelPut(
        int $order_id,
        ?\ck\Model\RestOrdersOrderIdCancelPutRequest $_rest_orders_order_id_cancel = null,
        string $contentType = self::contentTypes['restOrdersOrderIdCancelPut'][0]
    ): void
    {
        $this->restOrdersOrderIdCancelPutWithHttpInfo($order_id, $_rest_orders_order_id_cancel, $contentType);
    }

    /**
     * Operation restOrdersOrderIdCancelPutWithHttpInfo
     *
     * Cancel an order
     *
     * @param  int $order_id The ID of the order to be canceled. (required)
     * @param  \ck\Model\RestOrdersOrderIdCancelPutRequest|null $_rest_orders_order_id_cancel (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdCancelPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdCancelPutWithHttpInfo(
        int $order_id,
        ?\ck\Model\RestOrdersOrderIdCancelPutRequest $_rest_orders_order_id_cancel = null,
        string $contentType = self::contentTypes['restOrdersOrderIdCancelPut'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdCancelPutRequest($order_id, $_rest_orders_order_id_cancel, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdCancelPutAsync
     *
     * Cancel an order
     *
     * @param  int $order_id The ID of the order to be canceled. (required)
     * @param  \ck\Model\RestOrdersOrderIdCancelPutRequest|null $_rest_orders_order_id_cancel (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdCancelPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdCancelPutAsync(
        int $order_id,
        ?\ck\Model\RestOrdersOrderIdCancelPutRequest $_rest_orders_order_id_cancel = null,
        string $contentType = self::contentTypes['restOrdersOrderIdCancelPut'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdCancelPutAsyncWithHttpInfo($order_id, $_rest_orders_order_id_cancel, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdCancelPutAsyncWithHttpInfo
     *
     * Cancel an order
     *
     * @param  int $order_id The ID of the order to be canceled. (required)
     * @param  \ck\Model\RestOrdersOrderIdCancelPutRequest|null $_rest_orders_order_id_cancel (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdCancelPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdCancelPutAsyncWithHttpInfo(
        $order_id,
        $_rest_orders_order_id_cancel = null,
        string $contentType = self::contentTypes['restOrdersOrderIdCancelPut'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restOrdersOrderIdCancelPutRequest($order_id, $_rest_orders_order_id_cancel, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdCancelPut'
     *
     * @param  int $order_id The ID of the order to be canceled. (required)
     * @param  \ck\Model\RestOrdersOrderIdCancelPutRequest|null $_rest_orders_order_id_cancel (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdCancelPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdCancelPutRequest(
        $order_id,
        $_rest_orders_order_id_cancel = null,
        string $contentType = self::contentTypes['restOrdersOrderIdCancelPut'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdCancelPut'
            );
        }



        $resourcePath = '/rest/orders/{orderId}/cancel';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_orders_order_id_cancel)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_orders_order_id_cancel));
            } else {
                $httpBody = $_rest_orders_order_id_cancel;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdContactWishGet
     *
     * Get a contact wish
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdContactWishGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ContactWish
     */
    public function restOrdersOrderIdContactWishGet(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdContactWishGet'][0]
    ): \ck\Model\ContactWish
    {
        list($response) = $this->restOrdersOrderIdContactWishGetWithHttpInfo($order_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdContactWishGetWithHttpInfo
     *
     * Get a contact wish
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdContactWishGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ContactWish, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdContactWishGetWithHttpInfo(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdContactWishGet'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdContactWishGetRequest($order_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ContactWish' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ContactWish' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ContactWish', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ContactWish';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ContactWish',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdContactWishGetAsync
     *
     * Get a contact wish
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdContactWishGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdContactWishGetAsync(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdContactWishGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdContactWishGetAsyncWithHttpInfo($order_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdContactWishGetAsyncWithHttpInfo
     *
     * Get a contact wish
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdContactWishGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdContactWishGetAsyncWithHttpInfo(
        $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdContactWishGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ContactWish';
        $request = $this->restOrdersOrderIdContactWishGetRequest($order_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdContactWishGet'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdContactWishGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdContactWishGetRequest(
        $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdContactWishGet'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdContactWishGet'
            );
        }


        $resourcePath = '/rest/orders/{orderId}/contactWish';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdCouponsCouponPost
     *
     * Redeem a coupon code
     *
     * @param  int $order_id The ID of the order to redeem the coupon (required)
     * @param  string $coupon The coupon code to be redeemed (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdCouponsCouponPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\CouponCodeValidation
     */
    public function restOrdersOrderIdCouponsCouponPost(
        int $order_id,
        string $coupon,
        string $contentType = self::contentTypes['restOrdersOrderIdCouponsCouponPost'][0]
    ): \ck\Model\CouponCodeValidation
    {
        list($response) = $this->restOrdersOrderIdCouponsCouponPostWithHttpInfo($order_id, $coupon, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdCouponsCouponPostWithHttpInfo
     *
     * Redeem a coupon code
     *
     * @param  int $order_id The ID of the order to redeem the coupon (required)
     * @param  string $coupon The coupon code to be redeemed (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdCouponsCouponPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\CouponCodeValidation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdCouponsCouponPostWithHttpInfo(
        int $order_id,
        string $coupon,
        string $contentType = self::contentTypes['restOrdersOrderIdCouponsCouponPost'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdCouponsCouponPostRequest($order_id, $coupon, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\CouponCodeValidation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\CouponCodeValidation' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\CouponCodeValidation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\CouponCodeValidation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\CouponCodeValidation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdCouponsCouponPostAsync
     *
     * Redeem a coupon code
     *
     * @param  int $order_id The ID of the order to redeem the coupon (required)
     * @param  string $coupon The coupon code to be redeemed (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdCouponsCouponPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdCouponsCouponPostAsync(
        int $order_id,
        string $coupon,
        string $contentType = self::contentTypes['restOrdersOrderIdCouponsCouponPost'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdCouponsCouponPostAsyncWithHttpInfo($order_id, $coupon, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdCouponsCouponPostAsyncWithHttpInfo
     *
     * Redeem a coupon code
     *
     * @param  int $order_id The ID of the order to redeem the coupon (required)
     * @param  string $coupon The coupon code to be redeemed (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdCouponsCouponPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdCouponsCouponPostAsyncWithHttpInfo(
        $order_id,
        $coupon,
        string $contentType = self::contentTypes['restOrdersOrderIdCouponsCouponPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\CouponCodeValidation';
        $request = $this->restOrdersOrderIdCouponsCouponPostRequest($order_id, $coupon, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdCouponsCouponPost'
     *
     * @param  int $order_id The ID of the order to redeem the coupon (required)
     * @param  string $coupon The coupon code to be redeemed (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdCouponsCouponPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdCouponsCouponPostRequest(
        $order_id,
        $coupon,
        string $contentType = self::contentTypes['restOrdersOrderIdCouponsCouponPost'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdCouponsCouponPost'
            );
        }

        // verify the required parameter 'coupon' is set
        if ($coupon === null || (is_array($coupon) && count($coupon) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $coupon when calling restOrdersOrderIdCouponsCouponPost'
            );
        }


        $resourcePath = '/rest/orders/{orderId}/coupons/{coupon}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }
        // path params
        if ($coupon !== null) {
            $resourcePath = str_replace(
                '{' . 'coupon' . '}',
                ObjectSerializer::toPathValue($coupon),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDatesGet
     *
     * List all dates of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDatesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\OrderDate[]
     */
    public function restOrdersOrderIdDatesGet(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdDatesGet'][0]
    ): array
    {
        list($response) = $this->restOrdersOrderIdDatesGetWithHttpInfo($order_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdDatesGetWithHttpInfo
     *
     * List all dates of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDatesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\OrderDate[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDatesGetWithHttpInfo(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdDatesGet'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdDatesGetRequest($order_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\OrderDate[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\OrderDate[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\OrderDate[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\OrderDate[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\OrderDate[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDatesGetAsync
     *
     * List all dates of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDatesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdDatesGetAsync(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdDatesGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdDatesGetAsyncWithHttpInfo($order_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDatesGetAsyncWithHttpInfo
     *
     * List all dates of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDatesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdDatesGetAsyncWithHttpInfo(
        $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdDatesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\OrderDate[]';
        $request = $this->restOrdersOrderIdDatesGetRequest($order_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDatesGet'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDatesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdDatesGetRequest(
        $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdDatesGet'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDatesGet'
            );
        }


        $resourcePath = '/rest/orders/{orderId}/dates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDatesTypeIdGet
     *
     * Get a date
     *
     * @param  int $type_id The ID of the order date type that should be found (required)
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDatesTypeIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\OrderDate
     */
    public function restOrdersOrderIdDatesTypeIdGet(
        int $type_id,
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdDatesTypeIdGet'][0]
    ): \ck\Model\OrderDate
    {
        list($response) = $this->restOrdersOrderIdDatesTypeIdGetWithHttpInfo($type_id, $order_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdDatesTypeIdGetWithHttpInfo
     *
     * Get a date
     *
     * @param  int $type_id The ID of the order date type that should be found (required)
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDatesTypeIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\OrderDate, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDatesTypeIdGetWithHttpInfo(
        int $type_id,
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdDatesTypeIdGet'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdDatesTypeIdGetRequest($type_id, $order_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\OrderDate' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\OrderDate' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\OrderDate', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\OrderDate';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\OrderDate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDatesTypeIdGetAsync
     *
     * Get a date
     *
     * @param  int $type_id The ID of the order date type that should be found (required)
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDatesTypeIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdDatesTypeIdGetAsync(
        int $type_id,
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdDatesTypeIdGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdDatesTypeIdGetAsyncWithHttpInfo($type_id, $order_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDatesTypeIdGetAsyncWithHttpInfo
     *
     * Get a date
     *
     * @param  int $type_id The ID of the order date type that should be found (required)
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDatesTypeIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdDatesTypeIdGetAsyncWithHttpInfo(
        $type_id,
        $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdDatesTypeIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\OrderDate';
        $request = $this->restOrdersOrderIdDatesTypeIdGetRequest($type_id, $order_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDatesTypeIdGet'
     *
     * @param  int $type_id The ID of the order date type that should be found (required)
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDatesTypeIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdDatesTypeIdGetRequest(
        $type_id,
        $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdDatesTypeIdGet'][0]
    ): Request
    {

        // verify the required parameter 'type_id' is set
        if ($type_id === null || (is_array($type_id) && count($type_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $type_id when calling restOrdersOrderIdDatesTypeIdGet'
            );
        }

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDatesTypeIdGet'
            );
        }


        $resourcePath = '/rest/orders/{orderId}/dates/{typeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'typeId' . '}',
                ObjectSerializer::toPathValue($type_id),
                $resourcePath
            );
        }
        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDelete
     *
     * Delete an order
     *
     * @param  int $order_id The ID of the order to be deleted. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restOrdersOrderIdDelete(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdDelete'][0]
    ): void
    {
        $this->restOrdersOrderIdDeleteWithHttpInfo($order_id, $contentType);
    }

    /**
     * Operation restOrdersOrderIdDeleteWithHttpInfo
     *
     * Delete an order
     *
     * @param  int $order_id The ID of the order to be deleted. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDeleteWithHttpInfo(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdDelete'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdDeleteRequest($order_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDeleteAsync
     *
     * Delete an order
     *
     * @param  int $order_id The ID of the order to be deleted. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdDeleteAsync(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdDeleteAsyncWithHttpInfo($order_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDeleteAsyncWithHttpInfo
     *
     * Delete an order
     *
     * @param  int $order_id The ID of the order to be deleted. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdDeleteAsyncWithHttpInfo(
        $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restOrdersOrderIdDeleteRequest($order_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDelete'
     *
     * @param  int $order_id The ID of the order to be deleted. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdDeleteRequest(
        $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDelete'
            );
        }


        $resourcePath = '/rest/orders/{orderId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDeliveryOrdersAutomaticPost
     *
     * Create delivery orders automatically for all order items
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDeliveryOrdersAutomaticPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restOrdersOrderIdDeliveryOrdersAutomaticPost(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdDeliveryOrdersAutomaticPost'][0]
    ): object
    {
        list($response) = $this->restOrdersOrderIdDeliveryOrdersAutomaticPostWithHttpInfo($order_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdDeliveryOrdersAutomaticPostWithHttpInfo
     *
     * Create delivery orders automatically for all order items
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDeliveryOrdersAutomaticPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDeliveryOrdersAutomaticPostWithHttpInfo(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdDeliveryOrdersAutomaticPost'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdDeliveryOrdersAutomaticPostRequest($order_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDeliveryOrdersAutomaticPostAsync
     *
     * Create delivery orders automatically for all order items
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDeliveryOrdersAutomaticPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdDeliveryOrdersAutomaticPostAsync(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdDeliveryOrdersAutomaticPost'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdDeliveryOrdersAutomaticPostAsyncWithHttpInfo($order_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDeliveryOrdersAutomaticPostAsyncWithHttpInfo
     *
     * Create delivery orders automatically for all order items
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDeliveryOrdersAutomaticPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdDeliveryOrdersAutomaticPostAsyncWithHttpInfo(
        $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdDeliveryOrdersAutomaticPost'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restOrdersOrderIdDeliveryOrdersAutomaticPostRequest($order_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDeliveryOrdersAutomaticPost'
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDeliveryOrdersAutomaticPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdDeliveryOrdersAutomaticPostRequest(
        $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdDeliveryOrdersAutomaticPost'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDeliveryOrdersAutomaticPost'
            );
        }


        $resourcePath = '/rest/orders/{orderId}/delivery_orders/automatic';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDeliveryOrdersPost
     *
     * Create a delivery order from a parent order
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDeliveryOrdersPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Order
     */
    public function restOrdersOrderIdDeliveryOrdersPost(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdDeliveryOrdersPost'][0]
    ): \ck\Model\Order
    {
        list($response) = $this->restOrdersOrderIdDeliveryOrdersPostWithHttpInfo($order_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdDeliveryOrdersPostWithHttpInfo
     *
     * Create a delivery order from a parent order
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDeliveryOrdersPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Order, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDeliveryOrdersPostWithHttpInfo(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdDeliveryOrdersPost'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdDeliveryOrdersPostRequest($order_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Order' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Order' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Order', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Order';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Order',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDeliveryOrdersPostAsync
     *
     * Create a delivery order from a parent order
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDeliveryOrdersPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdDeliveryOrdersPostAsync(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdDeliveryOrdersPost'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdDeliveryOrdersPostAsyncWithHttpInfo($order_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDeliveryOrdersPostAsyncWithHttpInfo
     *
     * Create a delivery order from a parent order
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDeliveryOrdersPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdDeliveryOrdersPostAsyncWithHttpInfo(
        $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdDeliveryOrdersPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Order';
        $request = $this->restOrdersOrderIdDeliveryOrdersPostRequest($order_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDeliveryOrdersPost'
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdDeliveryOrdersPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdDeliveryOrdersPostRequest(
        $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdDeliveryOrdersPost'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDeliveryOrdersPost'
            );
        }


        $resourcePath = '/rest/orders/{orderId}/delivery_orders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdGet
     *
     * Get an order
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  int|null $with Load additional relations for an order. The following relations are available:      * &lt;ul&gt;        &lt;li&gt;&#39;addresses&#39; &#x3D; The address objects linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;relations&#39; &#x3D; The order relation reference instances that are associated with the order. These instances contain information such as the reference type. The available reference types are parent and reorder. The ID of the reference and the relation itself are also available.&lt;/li&gt;        &lt;li&gt;&#39;comments&#39; &#x3D; The order comments.&lt;/li&gt;        &lt;li&gt;&#39;location&#39; &#x3D; The accounting location linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;payments&#39; &#x3D; The payments linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;documents&#39; &#x3D; The documents linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;contactSender&#39; &#x3D; The contact belonging the contact-sender relation.&lt;/li&gt;        &lt;li&gt;&#39;contactReceiver&#39; &#x3D; The contact belonging to the contact-receiver relation.&lt;/li&gt;        &lt;li&gt;&#39;warehouseSender&#39; &#x3D; The warehouse belonging to the warehouse-sender relation.&lt;/li&gt;        &lt;li&gt;&#39;warehouseReceiver&#39; &#x3D; The warehouse belonging to the warehouse-receiver relation.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.variation&#39; &#x3D; The variation data belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.giftCardCodes&#39; &#x3D; The gift card codes belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.transactions&#39; &#x3D; The transactions belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.serialNumbers&#39; &#x3D; The serial numbers belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.variationBarcodes&#39; &#x3D; The barcodes belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.comments&#39; &#x3D; The comments belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;shippingPackages&#39; &#x3D; The shipping packages that are associated with the order.&lt;/li&gt;        &lt;li&gt;&lt;b&gt;deprecated&lt;/b&gt; &#39;orderItems.warehouseLocations&#39; &#x3D; The warehouse locations linked to the order item.&lt;/li&gt;      &lt;/ul&gt;      Example: &lt;code&gt;?with[]&#x3D;addresses&amp;with[]&#x3D;orderItems.variation&lt;/code&gt; (optional)
     * @param  bool|null $add_order_items Add the order items to the result. Default &#x3D; true. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Order
     */
    public function restOrdersOrderIdGet(
        int $order_id,
        ?int $with = null,
        ?bool $add_order_items = null,
        string $contentType = self::contentTypes['restOrdersOrderIdGet'][0]
    ): \ck\Model\Order
    {
        list($response) = $this->restOrdersOrderIdGetWithHttpInfo($order_id, $with, $add_order_items, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdGetWithHttpInfo
     *
     * Get an order
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  int|null $with Load additional relations for an order. The following relations are available:      * &lt;ul&gt;        &lt;li&gt;&#39;addresses&#39; &#x3D; The address objects linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;relations&#39; &#x3D; The order relation reference instances that are associated with the order. These instances contain information such as the reference type. The available reference types are parent and reorder. The ID of the reference and the relation itself are also available.&lt;/li&gt;        &lt;li&gt;&#39;comments&#39; &#x3D; The order comments.&lt;/li&gt;        &lt;li&gt;&#39;location&#39; &#x3D; The accounting location linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;payments&#39; &#x3D; The payments linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;documents&#39; &#x3D; The documents linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;contactSender&#39; &#x3D; The contact belonging the contact-sender relation.&lt;/li&gt;        &lt;li&gt;&#39;contactReceiver&#39; &#x3D; The contact belonging to the contact-receiver relation.&lt;/li&gt;        &lt;li&gt;&#39;warehouseSender&#39; &#x3D; The warehouse belonging to the warehouse-sender relation.&lt;/li&gt;        &lt;li&gt;&#39;warehouseReceiver&#39; &#x3D; The warehouse belonging to the warehouse-receiver relation.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.variation&#39; &#x3D; The variation data belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.giftCardCodes&#39; &#x3D; The gift card codes belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.transactions&#39; &#x3D; The transactions belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.serialNumbers&#39; &#x3D; The serial numbers belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.variationBarcodes&#39; &#x3D; The barcodes belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.comments&#39; &#x3D; The comments belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;shippingPackages&#39; &#x3D; The shipping packages that are associated with the order.&lt;/li&gt;        &lt;li&gt;&lt;b&gt;deprecated&lt;/b&gt; &#39;orderItems.warehouseLocations&#39; &#x3D; The warehouse locations linked to the order item.&lt;/li&gt;      &lt;/ul&gt;      Example: &lt;code&gt;?with[]&#x3D;addresses&amp;with[]&#x3D;orderItems.variation&lt;/code&gt; (optional)
     * @param  bool|null $add_order_items Add the order items to the result. Default &#x3D; true. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Order, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdGetWithHttpInfo(
        int $order_id,
        ?int $with = null,
        ?bool $add_order_items = null,
        string $contentType = self::contentTypes['restOrdersOrderIdGet'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdGetRequest($order_id, $with, $add_order_items, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Order' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Order' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Order', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Order';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Order',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdGetAsync
     *
     * Get an order
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  int|null $with Load additional relations for an order. The following relations are available:      * &lt;ul&gt;        &lt;li&gt;&#39;addresses&#39; &#x3D; The address objects linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;relations&#39; &#x3D; The order relation reference instances that are associated with the order. These instances contain information such as the reference type. The available reference types are parent and reorder. The ID of the reference and the relation itself are also available.&lt;/li&gt;        &lt;li&gt;&#39;comments&#39; &#x3D; The order comments.&lt;/li&gt;        &lt;li&gt;&#39;location&#39; &#x3D; The accounting location linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;payments&#39; &#x3D; The payments linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;documents&#39; &#x3D; The documents linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;contactSender&#39; &#x3D; The contact belonging the contact-sender relation.&lt;/li&gt;        &lt;li&gt;&#39;contactReceiver&#39; &#x3D; The contact belonging to the contact-receiver relation.&lt;/li&gt;        &lt;li&gt;&#39;warehouseSender&#39; &#x3D; The warehouse belonging to the warehouse-sender relation.&lt;/li&gt;        &lt;li&gt;&#39;warehouseReceiver&#39; &#x3D; The warehouse belonging to the warehouse-receiver relation.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.variation&#39; &#x3D; The variation data belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.giftCardCodes&#39; &#x3D; The gift card codes belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.transactions&#39; &#x3D; The transactions belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.serialNumbers&#39; &#x3D; The serial numbers belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.variationBarcodes&#39; &#x3D; The barcodes belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.comments&#39; &#x3D; The comments belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;shippingPackages&#39; &#x3D; The shipping packages that are associated with the order.&lt;/li&gt;        &lt;li&gt;&lt;b&gt;deprecated&lt;/b&gt; &#39;orderItems.warehouseLocations&#39; &#x3D; The warehouse locations linked to the order item.&lt;/li&gt;      &lt;/ul&gt;      Example: &lt;code&gt;?with[]&#x3D;addresses&amp;with[]&#x3D;orderItems.variation&lt;/code&gt; (optional)
     * @param  bool|null $add_order_items Add the order items to the result. Default &#x3D; true. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdGetAsync(
        int $order_id,
        ?int $with = null,
        ?bool $add_order_items = null,
        string $contentType = self::contentTypes['restOrdersOrderIdGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdGetAsyncWithHttpInfo($order_id, $with, $add_order_items, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdGetAsyncWithHttpInfo
     *
     * Get an order
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  int|null $with Load additional relations for an order. The following relations are available:      * &lt;ul&gt;        &lt;li&gt;&#39;addresses&#39; &#x3D; The address objects linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;relations&#39; &#x3D; The order relation reference instances that are associated with the order. These instances contain information such as the reference type. The available reference types are parent and reorder. The ID of the reference and the relation itself are also available.&lt;/li&gt;        &lt;li&gt;&#39;comments&#39; &#x3D; The order comments.&lt;/li&gt;        &lt;li&gt;&#39;location&#39; &#x3D; The accounting location linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;payments&#39; &#x3D; The payments linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;documents&#39; &#x3D; The documents linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;contactSender&#39; &#x3D; The contact belonging the contact-sender relation.&lt;/li&gt;        &lt;li&gt;&#39;contactReceiver&#39; &#x3D; The contact belonging to the contact-receiver relation.&lt;/li&gt;        &lt;li&gt;&#39;warehouseSender&#39; &#x3D; The warehouse belonging to the warehouse-sender relation.&lt;/li&gt;        &lt;li&gt;&#39;warehouseReceiver&#39; &#x3D; The warehouse belonging to the warehouse-receiver relation.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.variation&#39; &#x3D; The variation data belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.giftCardCodes&#39; &#x3D; The gift card codes belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.transactions&#39; &#x3D; The transactions belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.serialNumbers&#39; &#x3D; The serial numbers belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.variationBarcodes&#39; &#x3D; The barcodes belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.comments&#39; &#x3D; The comments belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;shippingPackages&#39; &#x3D; The shipping packages that are associated with the order.&lt;/li&gt;        &lt;li&gt;&lt;b&gt;deprecated&lt;/b&gt; &#39;orderItems.warehouseLocations&#39; &#x3D; The warehouse locations linked to the order item.&lt;/li&gt;      &lt;/ul&gt;      Example: &lt;code&gt;?with[]&#x3D;addresses&amp;with[]&#x3D;orderItems.variation&lt;/code&gt; (optional)
     * @param  bool|null $add_order_items Add the order items to the result. Default &#x3D; true. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdGetAsyncWithHttpInfo(
        $order_id,
        $with = null,
        $add_order_items = null,
        string $contentType = self::contentTypes['restOrdersOrderIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Order';
        $request = $this->restOrdersOrderIdGetRequest($order_id, $with, $add_order_items, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdGet'
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  int|null $with Load additional relations for an order. The following relations are available:      * &lt;ul&gt;        &lt;li&gt;&#39;addresses&#39; &#x3D; The address objects linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;relations&#39; &#x3D; The order relation reference instances that are associated with the order. These instances contain information such as the reference type. The available reference types are parent and reorder. The ID of the reference and the relation itself are also available.&lt;/li&gt;        &lt;li&gt;&#39;comments&#39; &#x3D; The order comments.&lt;/li&gt;        &lt;li&gt;&#39;location&#39; &#x3D; The accounting location linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;payments&#39; &#x3D; The payments linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;documents&#39; &#x3D; The documents linked to the order.&lt;/li&gt;        &lt;li&gt;&#39;contactSender&#39; &#x3D; The contact belonging the contact-sender relation.&lt;/li&gt;        &lt;li&gt;&#39;contactReceiver&#39; &#x3D; The contact belonging to the contact-receiver relation.&lt;/li&gt;        &lt;li&gt;&#39;warehouseSender&#39; &#x3D; The warehouse belonging to the warehouse-sender relation.&lt;/li&gt;        &lt;li&gt;&#39;warehouseReceiver&#39; &#x3D; The warehouse belonging to the warehouse-receiver relation.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.variation&#39; &#x3D; The variation data belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.giftCardCodes&#39; &#x3D; The gift card codes belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.transactions&#39; &#x3D; The transactions belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.serialNumbers&#39; &#x3D; The serial numbers belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.variationBarcodes&#39; &#x3D; The barcodes belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;orderItems.comments&#39; &#x3D; The comments belonging to the order item.&lt;/li&gt;        &lt;li&gt;&#39;shippingPackages&#39; &#x3D; The shipping packages that are associated with the order.&lt;/li&gt;        &lt;li&gt;&lt;b&gt;deprecated&lt;/b&gt; &#39;orderItems.warehouseLocations&#39; &#x3D; The warehouse locations linked to the order item.&lt;/li&gt;      &lt;/ul&gt;      Example: &lt;code&gt;?with[]&#x3D;addresses&amp;with[]&#x3D;orderItems.variation&lt;/code&gt; (optional)
     * @param  bool|null $add_order_items Add the order items to the result. Default &#x3D; true. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdGetRequest(
        $order_id,
        $with = null,
        $add_order_items = null,
        string $contentType = self::contentTypes['restOrdersOrderIdGet'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdGet'
            );
        }




        $resourcePath = '/rest/orders/{orderId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $add_order_items,
            'addOrderItems', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdItemsGet
     *
     * Search order items
     *
     * @param  int $order_id order_id (required)
     * @param  int|null $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int|null $items_per_page The number of order items to be displayed per page. The default number of order items per page is 50. The maximum number is 250. (optional)
     * @param  string|null $sort_by Sort search result according to itemVariationId, orderItemName, createdAt, updatedAt or id. The default value is orderItemId. (optional)
     * @param  string|null $sort_order Sort direction desc or asc. The default value is asc. (optional)
     * @param  int|null $with Load additional relations for an order item. Currently possible are:     &lt;ul&gt;     &lt;li&gt;&#39;variation&#39; &#x3D; The variation that is associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;giftCardCodes&#39; &#x3D; The gift card codes that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;transactions&#39; &#x3D; The transactions that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;serialNumbers&#39; &#x3D; The serial numbers that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;variationBarcodes&#39; &#x3D; The barcodes that are associated with variation of the order item.&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdItemsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestOrdersOrderIdItemsGet200Response
     */
    public function restOrdersOrderIdItemsGet(
        int $order_id,
        ?int $page = null,
        ?int $items_per_page = null,
        ?string $sort_by = null,
        ?string $sort_order = null,
        ?int $with = null,
        string $contentType = self::contentTypes['restOrdersOrderIdItemsGet'][0]
    ): \ck\Model\RestOrdersOrderIdItemsGet200Response
    {
        list($response) = $this->restOrdersOrderIdItemsGetWithHttpInfo($order_id, $page, $items_per_page, $sort_by, $sort_order, $with, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdItemsGetWithHttpInfo
     *
     * Search order items
     *
     * @param  int $order_id (required)
     * @param  int|null $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int|null $items_per_page The number of order items to be displayed per page. The default number of order items per page is 50. The maximum number is 250. (optional)
     * @param  string|null $sort_by Sort search result according to itemVariationId, orderItemName, createdAt, updatedAt or id. The default value is orderItemId. (optional)
     * @param  string|null $sort_order Sort direction desc or asc. The default value is asc. (optional)
     * @param  int|null $with Load additional relations for an order item. Currently possible are:     &lt;ul&gt;     &lt;li&gt;&#39;variation&#39; &#x3D; The variation that is associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;giftCardCodes&#39; &#x3D; The gift card codes that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;transactions&#39; &#x3D; The transactions that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;serialNumbers&#39; &#x3D; The serial numbers that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;variationBarcodes&#39; &#x3D; The barcodes that are associated with variation of the order item.&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdItemsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestOrdersOrderIdItemsGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdItemsGetWithHttpInfo(
        int $order_id,
        ?int $page = null,
        ?int $items_per_page = null,
        ?string $sort_by = null,
        ?string $sort_order = null,
        ?int $with = null,
        string $contentType = self::contentTypes['restOrdersOrderIdItemsGet'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdItemsGetRequest($order_id, $page, $items_per_page, $sort_by, $sort_order, $with, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestOrdersOrderIdItemsGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestOrdersOrderIdItemsGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestOrdersOrderIdItemsGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestOrdersOrderIdItemsGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestOrdersOrderIdItemsGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdItemsGetAsync
     *
     * Search order items
     *
     * @param  int $order_id (required)
     * @param  int|null $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int|null $items_per_page The number of order items to be displayed per page. The default number of order items per page is 50. The maximum number is 250. (optional)
     * @param  string|null $sort_by Sort search result according to itemVariationId, orderItemName, createdAt, updatedAt or id. The default value is orderItemId. (optional)
     * @param  string|null $sort_order Sort direction desc or asc. The default value is asc. (optional)
     * @param  int|null $with Load additional relations for an order item. Currently possible are:     &lt;ul&gt;     &lt;li&gt;&#39;variation&#39; &#x3D; The variation that is associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;giftCardCodes&#39; &#x3D; The gift card codes that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;transactions&#39; &#x3D; The transactions that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;serialNumbers&#39; &#x3D; The serial numbers that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;variationBarcodes&#39; &#x3D; The barcodes that are associated with variation of the order item.&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdItemsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdItemsGetAsync(
        int $order_id,
        ?int $page = null,
        ?int $items_per_page = null,
        ?string $sort_by = null,
        ?string $sort_order = null,
        ?int $with = null,
        string $contentType = self::contentTypes['restOrdersOrderIdItemsGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdItemsGetAsyncWithHttpInfo($order_id, $page, $items_per_page, $sort_by, $sort_order, $with, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdItemsGetAsyncWithHttpInfo
     *
     * Search order items
     *
     * @param  int $order_id (required)
     * @param  int|null $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int|null $items_per_page The number of order items to be displayed per page. The default number of order items per page is 50. The maximum number is 250. (optional)
     * @param  string|null $sort_by Sort search result according to itemVariationId, orderItemName, createdAt, updatedAt or id. The default value is orderItemId. (optional)
     * @param  string|null $sort_order Sort direction desc or asc. The default value is asc. (optional)
     * @param  int|null $with Load additional relations for an order item. Currently possible are:     &lt;ul&gt;     &lt;li&gt;&#39;variation&#39; &#x3D; The variation that is associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;giftCardCodes&#39; &#x3D; The gift card codes that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;transactions&#39; &#x3D; The transactions that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;serialNumbers&#39; &#x3D; The serial numbers that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;variationBarcodes&#39; &#x3D; The barcodes that are associated with variation of the order item.&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdItemsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdItemsGetAsyncWithHttpInfo(
        $order_id,
        $page = null,
        $items_per_page = null,
        $sort_by = null,
        $sort_order = null,
        $with = null,
        string $contentType = self::contentTypes['restOrdersOrderIdItemsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestOrdersOrderIdItemsGet200Response';
        $request = $this->restOrdersOrderIdItemsGetRequest($order_id, $page, $items_per_page, $sort_by, $sort_order, $with, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdItemsGet'
     *
     * @param  int $order_id (required)
     * @param  int|null $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int|null $items_per_page The number of order items to be displayed per page. The default number of order items per page is 50. The maximum number is 250. (optional)
     * @param  string|null $sort_by Sort search result according to itemVariationId, orderItemName, createdAt, updatedAt or id. The default value is orderItemId. (optional)
     * @param  string|null $sort_order Sort direction desc or asc. The default value is asc. (optional)
     * @param  int|null $with Load additional relations for an order item. Currently possible are:     &lt;ul&gt;     &lt;li&gt;&#39;variation&#39; &#x3D; The variation that is associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;giftCardCodes&#39; &#x3D; The gift card codes that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;transactions&#39; &#x3D; The transactions that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;serialNumbers&#39; &#x3D; The serial numbers that are associated with the order item.&lt;/li&gt;     &lt;li&gt;&#39;variationBarcodes&#39; &#x3D; The barcodes that are associated with variation of the order item.&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdItemsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdItemsGetRequest(
        $order_id,
        $page = null,
        $items_per_page = null,
        $sort_by = null,
        $sort_order = null,
        $with = null,
        string $contentType = self::contentTypes['restOrdersOrderIdItemsGet'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdItemsGet'
            );
        }







        $resourcePath = '/rest/orders/{orderId}/items';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $items_per_page,
            'itemsPerPage', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_by,
            'sortBy', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_order,
            'sortOrder', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdItemsOrderItemIdDelete
     *
     * Delete an order item
     *
     * @param  int $order_id The ID of the order that the item belongs to. (required)
     * @param  int $order_item_id The ID of the order item to be deleted. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdItemsOrderItemIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restOrdersOrderIdItemsOrderItemIdDelete(
        int $order_id,
        int $order_item_id,
        string $contentType = self::contentTypes['restOrdersOrderIdItemsOrderItemIdDelete'][0]
    ): void
    {
        $this->restOrdersOrderIdItemsOrderItemIdDeleteWithHttpInfo($order_id, $order_item_id, $contentType);
    }

    /**
     * Operation restOrdersOrderIdItemsOrderItemIdDeleteWithHttpInfo
     *
     * Delete an order item
     *
     * @param  int $order_id The ID of the order that the item belongs to. (required)
     * @param  int $order_item_id The ID of the order item to be deleted. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdItemsOrderItemIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdItemsOrderItemIdDeleteWithHttpInfo(
        int $order_id,
        int $order_item_id,
        string $contentType = self::contentTypes['restOrdersOrderIdItemsOrderItemIdDelete'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdItemsOrderItemIdDeleteRequest($order_id, $order_item_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdItemsOrderItemIdDeleteAsync
     *
     * Delete an order item
     *
     * @param  int $order_id The ID of the order that the item belongs to. (required)
     * @param  int $order_item_id The ID of the order item to be deleted. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdItemsOrderItemIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdItemsOrderItemIdDeleteAsync(
        int $order_id,
        int $order_item_id,
        string $contentType = self::contentTypes['restOrdersOrderIdItemsOrderItemIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdItemsOrderItemIdDeleteAsyncWithHttpInfo($order_id, $order_item_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdItemsOrderItemIdDeleteAsyncWithHttpInfo
     *
     * Delete an order item
     *
     * @param  int $order_id The ID of the order that the item belongs to. (required)
     * @param  int $order_item_id The ID of the order item to be deleted. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdItemsOrderItemIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdItemsOrderItemIdDeleteAsyncWithHttpInfo(
        $order_id,
        $order_item_id,
        string $contentType = self::contentTypes['restOrdersOrderIdItemsOrderItemIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restOrdersOrderIdItemsOrderItemIdDeleteRequest($order_id, $order_item_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdItemsOrderItemIdDelete'
     *
     * @param  int $order_id The ID of the order that the item belongs to. (required)
     * @param  int $order_item_id The ID of the order item to be deleted. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdItemsOrderItemIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdItemsOrderItemIdDeleteRequest(
        $order_id,
        $order_item_id,
        string $contentType = self::contentTypes['restOrdersOrderIdItemsOrderItemIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdItemsOrderItemIdDelete'
            );
        }

        // verify the required parameter 'order_item_id' is set
        if ($order_item_id === null || (is_array($order_item_id) && count($order_item_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_item_id when calling restOrdersOrderIdItemsOrderItemIdDelete'
            );
        }


        $resourcePath = '/rest/orders/{orderId}/items/{orderItemId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }
        // path params
        if ($order_item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderItemId' . '}',
                ObjectSerializer::toPathValue($order_item_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdItemsOrderItemIdSerialNumbersGet
     *
     * List serial numbers of an order item
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $order_item_id The ID of the order item (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdItemsOrderItemIdSerialNumbersGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\OrderSerialNumber[]
     */
    public function restOrdersOrderIdItemsOrderItemIdSerialNumbersGet(
        int $order_id,
        int $order_item_id,
        string $contentType = self::contentTypes['restOrdersOrderIdItemsOrderItemIdSerialNumbersGet'][0]
    ): array
    {
        list($response) = $this->restOrdersOrderIdItemsOrderItemIdSerialNumbersGetWithHttpInfo($order_id, $order_item_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdItemsOrderItemIdSerialNumbersGetWithHttpInfo
     *
     * List serial numbers of an order item
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $order_item_id The ID of the order item (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdItemsOrderItemIdSerialNumbersGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\OrderSerialNumber[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdItemsOrderItemIdSerialNumbersGetWithHttpInfo(
        int $order_id,
        int $order_item_id,
        string $contentType = self::contentTypes['restOrdersOrderIdItemsOrderItemIdSerialNumbersGet'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdItemsOrderItemIdSerialNumbersGetRequest($order_id, $order_item_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\OrderSerialNumber[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\OrderSerialNumber[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\OrderSerialNumber[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\OrderSerialNumber[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\OrderSerialNumber[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdItemsOrderItemIdSerialNumbersGetAsync
     *
     * List serial numbers of an order item
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $order_item_id The ID of the order item (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdItemsOrderItemIdSerialNumbersGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdItemsOrderItemIdSerialNumbersGetAsync(
        int $order_id,
        int $order_item_id,
        string $contentType = self::contentTypes['restOrdersOrderIdItemsOrderItemIdSerialNumbersGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdItemsOrderItemIdSerialNumbersGetAsyncWithHttpInfo($order_id, $order_item_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdItemsOrderItemIdSerialNumbersGetAsyncWithHttpInfo
     *
     * List serial numbers of an order item
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $order_item_id The ID of the order item (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdItemsOrderItemIdSerialNumbersGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdItemsOrderItemIdSerialNumbersGetAsyncWithHttpInfo(
        $order_id,
        $order_item_id,
        string $contentType = self::contentTypes['restOrdersOrderIdItemsOrderItemIdSerialNumbersGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\OrderSerialNumber[]';
        $request = $this->restOrdersOrderIdItemsOrderItemIdSerialNumbersGetRequest($order_id, $order_item_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdItemsOrderItemIdSerialNumbersGet'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $order_item_id The ID of the order item (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdItemsOrderItemIdSerialNumbersGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdItemsOrderItemIdSerialNumbersGetRequest(
        $order_id,
        $order_item_id,
        string $contentType = self::contentTypes['restOrdersOrderIdItemsOrderItemIdSerialNumbersGet'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdItemsOrderItemIdSerialNumbersGet'
            );
        }

        // verify the required parameter 'order_item_id' is set
        if ($order_item_id === null || (is_array($order_item_id) && count($order_item_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_item_id when calling restOrdersOrderIdItemsOrderItemIdSerialNumbersGet'
            );
        }


        $resourcePath = '/rest/orders/{orderId}/items/{orderItemId}/serialNumbers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }
        // path params
        if ($order_item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderItemId' . '}',
                ObjectSerializer::toPathValue($order_item_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdItemsSerialNumbersGet
     *
     * List serial numbers of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdItemsSerialNumbersGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\OrderSerialNumber[]
     */
    public function restOrdersOrderIdItemsSerialNumbersGet(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdItemsSerialNumbersGet'][0]
    ): array
    {
        list($response) = $this->restOrdersOrderIdItemsSerialNumbersGetWithHttpInfo($order_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdItemsSerialNumbersGetWithHttpInfo
     *
     * List serial numbers of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdItemsSerialNumbersGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\OrderSerialNumber[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdItemsSerialNumbersGetWithHttpInfo(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdItemsSerialNumbersGet'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdItemsSerialNumbersGetRequest($order_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\OrderSerialNumber[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\OrderSerialNumber[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\OrderSerialNumber[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\OrderSerialNumber[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\OrderSerialNumber[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdItemsSerialNumbersGetAsync
     *
     * List serial numbers of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdItemsSerialNumbersGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdItemsSerialNumbersGetAsync(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdItemsSerialNumbersGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdItemsSerialNumbersGetAsyncWithHttpInfo($order_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdItemsSerialNumbersGetAsyncWithHttpInfo
     *
     * List serial numbers of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdItemsSerialNumbersGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdItemsSerialNumbersGetAsyncWithHttpInfo(
        $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdItemsSerialNumbersGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\OrderSerialNumber[]';
        $request = $this->restOrdersOrderIdItemsSerialNumbersGetRequest($order_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdItemsSerialNumbersGet'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdItemsSerialNumbersGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdItemsSerialNumbersGetRequest(
        $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdItemsSerialNumbersGet'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdItemsSerialNumbersGet'
            );
        }


        $resourcePath = '/rest/orders/{orderId}/items/serialNumbers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdOutgoingStocksDelete
     *
     * Revert outgoing stock
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdOutgoingStocksDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restOrdersOrderIdOutgoingStocksDelete(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdOutgoingStocksDelete'][0]
    ): void
    {
        $this->restOrdersOrderIdOutgoingStocksDeleteWithHttpInfo($order_id, $contentType);
    }

    /**
     * Operation restOrdersOrderIdOutgoingStocksDeleteWithHttpInfo
     *
     * Revert outgoing stock
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdOutgoingStocksDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdOutgoingStocksDeleteWithHttpInfo(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdOutgoingStocksDelete'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdOutgoingStocksDeleteRequest($order_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdOutgoingStocksDeleteAsync
     *
     * Revert outgoing stock
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdOutgoingStocksDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdOutgoingStocksDeleteAsync(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdOutgoingStocksDelete'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdOutgoingStocksDeleteAsyncWithHttpInfo($order_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdOutgoingStocksDeleteAsyncWithHttpInfo
     *
     * Revert outgoing stock
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdOutgoingStocksDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdOutgoingStocksDeleteAsyncWithHttpInfo(
        $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdOutgoingStocksDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restOrdersOrderIdOutgoingStocksDeleteRequest($order_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdOutgoingStocksDelete'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdOutgoingStocksDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdOutgoingStocksDeleteRequest(
        $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdOutgoingStocksDelete'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdOutgoingStocksDelete'
            );
        }


        $resourcePath = '/rest/orders/{orderId}/outgoing_stocks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdOutgoingStocksPost
     *
     * Book out order items
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $date The date that is saved as booking date for the outgoing stock. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdOutgoingStocksPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restOrdersOrderIdOutgoingStocksPost(
        int $order_id,
        ?string $date = null,
        string $contentType = self::contentTypes['restOrdersOrderIdOutgoingStocksPost'][0]
    ): void
    {
        $this->restOrdersOrderIdOutgoingStocksPostWithHttpInfo($order_id, $date, $contentType);
    }

    /**
     * Operation restOrdersOrderIdOutgoingStocksPostWithHttpInfo
     *
     * Book out order items
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $date The date that is saved as booking date for the outgoing stock. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdOutgoingStocksPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdOutgoingStocksPostWithHttpInfo(
        int $order_id,
        ?string $date = null,
        string $contentType = self::contentTypes['restOrdersOrderIdOutgoingStocksPost'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdOutgoingStocksPostRequest($order_id, $date, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdOutgoingStocksPostAsync
     *
     * Book out order items
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $date The date that is saved as booking date for the outgoing stock. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdOutgoingStocksPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdOutgoingStocksPostAsync(
        int $order_id,
        ?string $date = null,
        string $contentType = self::contentTypes['restOrdersOrderIdOutgoingStocksPost'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdOutgoingStocksPostAsyncWithHttpInfo($order_id, $date, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdOutgoingStocksPostAsyncWithHttpInfo
     *
     * Book out order items
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $date The date that is saved as booking date for the outgoing stock. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdOutgoingStocksPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdOutgoingStocksPostAsyncWithHttpInfo(
        $order_id,
        $date = null,
        string $contentType = self::contentTypes['restOrdersOrderIdOutgoingStocksPost'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restOrdersOrderIdOutgoingStocksPostRequest($order_id, $date, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdOutgoingStocksPost'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string|null $date The date that is saved as booking date for the outgoing stock. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdOutgoingStocksPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdOutgoingStocksPostRequest(
        $order_id,
        $date = null,
        string $contentType = self::contentTypes['restOrdersOrderIdOutgoingStocksPost'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdOutgoingStocksPost'
            );
        }



        $resourcePath = '/rest/orders/{orderId}/outgoing_stocks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date,
            'date', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdPackagenumbersGet
     *
     * List package numbers of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdPackagenumbersGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object[]
     */
    public function restOrdersOrderIdPackagenumbersGet(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdPackagenumbersGet'][0]
    ): array
    {
        list($response) = $this->restOrdersOrderIdPackagenumbersGetWithHttpInfo($order_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdPackagenumbersGetWithHttpInfo
     *
     * List package numbers of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdPackagenumbersGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdPackagenumbersGetWithHttpInfo(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdPackagenumbersGet'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdPackagenumbersGetRequest($order_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdPackagenumbersGetAsync
     *
     * List package numbers of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdPackagenumbersGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdPackagenumbersGetAsync(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdPackagenumbersGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdPackagenumbersGetAsyncWithHttpInfo($order_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdPackagenumbersGetAsyncWithHttpInfo
     *
     * List package numbers of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdPackagenumbersGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdPackagenumbersGetAsyncWithHttpInfo(
        $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdPackagenumbersGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object[]';
        $request = $this->restOrdersOrderIdPackagenumbersGetRequest($order_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdPackagenumbersGet'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdPackagenumbersGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdPackagenumbersGetRequest(
        $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdPackagenumbersGet'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdPackagenumbersGet'
            );
        }


        $resourcePath = '/rest/orders/{orderId}/packagenumbers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdPropertiesPost
     *
     * Create property for an order
     *
     * @param  int $order_id order_id (required)
     * @param  \ck\Model\RestOrdersOrderIdPropertiesPostRequest|null $_rest_orders_order_id_properties _rest_orders_order_id_properties (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdPropertiesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\OrderProperty
     */
    public function restOrdersOrderIdPropertiesPost(
        int $order_id,
        ?\ck\Model\RestOrdersOrderIdPropertiesPostRequest $_rest_orders_order_id_properties = null,
        string $contentType = self::contentTypes['restOrdersOrderIdPropertiesPost'][0]
    ): \ck\Model\OrderProperty
    {
        list($response) = $this->restOrdersOrderIdPropertiesPostWithHttpInfo($order_id, $_rest_orders_order_id_properties, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdPropertiesPostWithHttpInfo
     *
     * Create property for an order
     *
     * @param  int $order_id (required)
     * @param  \ck\Model\RestOrdersOrderIdPropertiesPostRequest|null $_rest_orders_order_id_properties (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdPropertiesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\OrderProperty, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdPropertiesPostWithHttpInfo(
        int $order_id,
        ?\ck\Model\RestOrdersOrderIdPropertiesPostRequest $_rest_orders_order_id_properties = null,
        string $contentType = self::contentTypes['restOrdersOrderIdPropertiesPost'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdPropertiesPostRequest($order_id, $_rest_orders_order_id_properties, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\OrderProperty' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\OrderProperty' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\OrderProperty', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\OrderProperty';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\OrderProperty',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdPropertiesPostAsync
     *
     * Create property for an order
     *
     * @param  int $order_id (required)
     * @param  \ck\Model\RestOrdersOrderIdPropertiesPostRequest|null $_rest_orders_order_id_properties (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdPropertiesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdPropertiesPostAsync(
        int $order_id,
        ?\ck\Model\RestOrdersOrderIdPropertiesPostRequest $_rest_orders_order_id_properties = null,
        string $contentType = self::contentTypes['restOrdersOrderIdPropertiesPost'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdPropertiesPostAsyncWithHttpInfo($order_id, $_rest_orders_order_id_properties, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdPropertiesPostAsyncWithHttpInfo
     *
     * Create property for an order
     *
     * @param  int $order_id (required)
     * @param  \ck\Model\RestOrdersOrderIdPropertiesPostRequest|null $_rest_orders_order_id_properties (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdPropertiesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdPropertiesPostAsyncWithHttpInfo(
        $order_id,
        $_rest_orders_order_id_properties = null,
        string $contentType = self::contentTypes['restOrdersOrderIdPropertiesPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\OrderProperty';
        $request = $this->restOrdersOrderIdPropertiesPostRequest($order_id, $_rest_orders_order_id_properties, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdPropertiesPost'
     *
     * @param  int $order_id (required)
     * @param  \ck\Model\RestOrdersOrderIdPropertiesPostRequest|null $_rest_orders_order_id_properties (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdPropertiesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdPropertiesPostRequest(
        $order_id,
        $_rest_orders_order_id_properties = null,
        string $contentType = self::contentTypes['restOrdersOrderIdPropertiesPost'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdPropertiesPost'
            );
        }



        $resourcePath = '/rest/orders/{orderId}/properties';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_orders_order_id_properties)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_orders_order_id_properties));
            } else {
                $httpBody = $_rest_orders_order_id_properties;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdPropertiesTypeIdDelete
     *
     * Delete property of an order by order ID and property type ID
     *
     * @param  int $order_id order_id (required)
     * @param  int $type_id type_id (required)
     * @param  \ck\Model\RestOrdersOrderIdPropertiesTypeIdDeleteRequest|null $_rest_orders_order_id_properties_type_id _rest_orders_order_id_properties_type_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdPropertiesTypeIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restOrdersOrderIdPropertiesTypeIdDelete(
        int $order_id,
        int $type_id,
        ?\ck\Model\RestOrdersOrderIdPropertiesTypeIdDeleteRequest $_rest_orders_order_id_properties_type_id = null,
        string $contentType = self::contentTypes['restOrdersOrderIdPropertiesTypeIdDelete'][0]
    ): object
    {
        list($response) = $this->restOrdersOrderIdPropertiesTypeIdDeleteWithHttpInfo($order_id, $type_id, $_rest_orders_order_id_properties_type_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdPropertiesTypeIdDeleteWithHttpInfo
     *
     * Delete property of an order by order ID and property type ID
     *
     * @param  int $order_id (required)
     * @param  int $type_id (required)
     * @param  \ck\Model\RestOrdersOrderIdPropertiesTypeIdDeleteRequest|null $_rest_orders_order_id_properties_type_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdPropertiesTypeIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdPropertiesTypeIdDeleteWithHttpInfo(
        int $order_id,
        int $type_id,
        ?\ck\Model\RestOrdersOrderIdPropertiesTypeIdDeleteRequest $_rest_orders_order_id_properties_type_id = null,
        string $contentType = self::contentTypes['restOrdersOrderIdPropertiesTypeIdDelete'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdPropertiesTypeIdDeleteRequest($order_id, $type_id, $_rest_orders_order_id_properties_type_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdPropertiesTypeIdDeleteAsync
     *
     * Delete property of an order by order ID and property type ID
     *
     * @param  int $order_id (required)
     * @param  int $type_id (required)
     * @param  \ck\Model\RestOrdersOrderIdPropertiesTypeIdDeleteRequest|null $_rest_orders_order_id_properties_type_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdPropertiesTypeIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdPropertiesTypeIdDeleteAsync(
        int $order_id,
        int $type_id,
        ?\ck\Model\RestOrdersOrderIdPropertiesTypeIdDeleteRequest $_rest_orders_order_id_properties_type_id = null,
        string $contentType = self::contentTypes['restOrdersOrderIdPropertiesTypeIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdPropertiesTypeIdDeleteAsyncWithHttpInfo($order_id, $type_id, $_rest_orders_order_id_properties_type_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdPropertiesTypeIdDeleteAsyncWithHttpInfo
     *
     * Delete property of an order by order ID and property type ID
     *
     * @param  int $order_id (required)
     * @param  int $type_id (required)
     * @param  \ck\Model\RestOrdersOrderIdPropertiesTypeIdDeleteRequest|null $_rest_orders_order_id_properties_type_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdPropertiesTypeIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdPropertiesTypeIdDeleteAsyncWithHttpInfo(
        $order_id,
        $type_id,
        $_rest_orders_order_id_properties_type_id = null,
        string $contentType = self::contentTypes['restOrdersOrderIdPropertiesTypeIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restOrdersOrderIdPropertiesTypeIdDeleteRequest($order_id, $type_id, $_rest_orders_order_id_properties_type_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdPropertiesTypeIdDelete'
     *
     * @param  int $order_id (required)
     * @param  int $type_id (required)
     * @param  \ck\Model\RestOrdersOrderIdPropertiesTypeIdDeleteRequest|null $_rest_orders_order_id_properties_type_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdPropertiesTypeIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdPropertiesTypeIdDeleteRequest(
        $order_id,
        $type_id,
        $_rest_orders_order_id_properties_type_id = null,
        string $contentType = self::contentTypes['restOrdersOrderIdPropertiesTypeIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdPropertiesTypeIdDelete'
            );
        }

        // verify the required parameter 'type_id' is set
        if ($type_id === null || (is_array($type_id) && count($type_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $type_id when calling restOrdersOrderIdPropertiesTypeIdDelete'
            );
        }



        $resourcePath = '/rest/orders/{orderId}/properties/{typeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }
        // path params
        if ($type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'typeId' . '}',
                ObjectSerializer::toPathValue($type_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_orders_order_id_properties_type_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_orders_order_id_properties_type_id));
            } else {
                $httpBody = $_rest_orders_order_id_properties_type_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdPropertiesTypeIdPut
     *
     * Update property of an order by order ID and property ID
     *
     * @param  int $order_id order_id (required)
     * @param  int $type_id type_id (required)
     * @param  \ck\Model\RestOrdersOrderIdPropertiesPostRequest|null $_rest_orders_order_id_properties_type_id _rest_orders_order_id_properties_type_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdPropertiesTypeIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\OrderProperty
     */
    public function restOrdersOrderIdPropertiesTypeIdPut(
        int $order_id,
        int $type_id,
        ?\ck\Model\RestOrdersOrderIdPropertiesPostRequest $_rest_orders_order_id_properties_type_id = null,
        string $contentType = self::contentTypes['restOrdersOrderIdPropertiesTypeIdPut'][0]
    ): \ck\Model\OrderProperty
    {
        list($response) = $this->restOrdersOrderIdPropertiesTypeIdPutWithHttpInfo($order_id, $type_id, $_rest_orders_order_id_properties_type_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdPropertiesTypeIdPutWithHttpInfo
     *
     * Update property of an order by order ID and property ID
     *
     * @param  int $order_id (required)
     * @param  int $type_id (required)
     * @param  \ck\Model\RestOrdersOrderIdPropertiesPostRequest|null $_rest_orders_order_id_properties_type_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdPropertiesTypeIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\OrderProperty, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdPropertiesTypeIdPutWithHttpInfo(
        int $order_id,
        int $type_id,
        ?\ck\Model\RestOrdersOrderIdPropertiesPostRequest $_rest_orders_order_id_properties_type_id = null,
        string $contentType = self::contentTypes['restOrdersOrderIdPropertiesTypeIdPut'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdPropertiesTypeIdPutRequest($order_id, $type_id, $_rest_orders_order_id_properties_type_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\OrderProperty' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\OrderProperty' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\OrderProperty', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\OrderProperty';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\OrderProperty',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdPropertiesTypeIdPutAsync
     *
     * Update property of an order by order ID and property ID
     *
     * @param  int $order_id (required)
     * @param  int $type_id (required)
     * @param  \ck\Model\RestOrdersOrderIdPropertiesPostRequest|null $_rest_orders_order_id_properties_type_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdPropertiesTypeIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdPropertiesTypeIdPutAsync(
        int $order_id,
        int $type_id,
        ?\ck\Model\RestOrdersOrderIdPropertiesPostRequest $_rest_orders_order_id_properties_type_id = null,
        string $contentType = self::contentTypes['restOrdersOrderIdPropertiesTypeIdPut'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdPropertiesTypeIdPutAsyncWithHttpInfo($order_id, $type_id, $_rest_orders_order_id_properties_type_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdPropertiesTypeIdPutAsyncWithHttpInfo
     *
     * Update property of an order by order ID and property ID
     *
     * @param  int $order_id (required)
     * @param  int $type_id (required)
     * @param  \ck\Model\RestOrdersOrderIdPropertiesPostRequest|null $_rest_orders_order_id_properties_type_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdPropertiesTypeIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdPropertiesTypeIdPutAsyncWithHttpInfo(
        $order_id,
        $type_id,
        $_rest_orders_order_id_properties_type_id = null,
        string $contentType = self::contentTypes['restOrdersOrderIdPropertiesTypeIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\OrderProperty';
        $request = $this->restOrdersOrderIdPropertiesTypeIdPutRequest($order_id, $type_id, $_rest_orders_order_id_properties_type_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdPropertiesTypeIdPut'
     *
     * @param  int $order_id (required)
     * @param  int $type_id (required)
     * @param  \ck\Model\RestOrdersOrderIdPropertiesPostRequest|null $_rest_orders_order_id_properties_type_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdPropertiesTypeIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdPropertiesTypeIdPutRequest(
        $order_id,
        $type_id,
        $_rest_orders_order_id_properties_type_id = null,
        string $contentType = self::contentTypes['restOrdersOrderIdPropertiesTypeIdPut'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdPropertiesTypeIdPut'
            );
        }

        // verify the required parameter 'type_id' is set
        if ($type_id === null || (is_array($type_id) && count($type_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $type_id when calling restOrdersOrderIdPropertiesTypeIdPut'
            );
        }



        $resourcePath = '/rest/orders/{orderId}/properties/{typeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }
        // path params
        if ($type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'typeId' . '}',
                ObjectSerializer::toPathValue($type_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_orders_order_id_properties_type_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_orders_order_id_properties_type_id));
            } else {
                $httpBody = $_rest_orders_order_id_properties_type_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdPut
     *
     * Update an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  \ck\Model\RestOrdersOrderIdPutRequest|null $_rest_orders_order_id _rest_orders_order_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Order
     */
    public function restOrdersOrderIdPut(
        int $order_id,
        ?\ck\Model\RestOrdersOrderIdPutRequest $_rest_orders_order_id = null,
        string $contentType = self::contentTypes['restOrdersOrderIdPut'][0]
    ): \ck\Model\Order
    {
        list($response) = $this->restOrdersOrderIdPutWithHttpInfo($order_id, $_rest_orders_order_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdPutWithHttpInfo
     *
     * Update an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  \ck\Model\RestOrdersOrderIdPutRequest|null $_rest_orders_order_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Order, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdPutWithHttpInfo(
        int $order_id,
        ?\ck\Model\RestOrdersOrderIdPutRequest $_rest_orders_order_id = null,
        string $contentType = self::contentTypes['restOrdersOrderIdPut'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdPutRequest($order_id, $_rest_orders_order_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Order' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Order' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Order', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Order';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Order',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdPutAsync
     *
     * Update an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  \ck\Model\RestOrdersOrderIdPutRequest|null $_rest_orders_order_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdPutAsync(
        int $order_id,
        ?\ck\Model\RestOrdersOrderIdPutRequest $_rest_orders_order_id = null,
        string $contentType = self::contentTypes['restOrdersOrderIdPut'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdPutAsyncWithHttpInfo($order_id, $_rest_orders_order_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdPutAsyncWithHttpInfo
     *
     * Update an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  \ck\Model\RestOrdersOrderIdPutRequest|null $_rest_orders_order_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdPutAsyncWithHttpInfo(
        $order_id,
        $_rest_orders_order_id = null,
        string $contentType = self::contentTypes['restOrdersOrderIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Order';
        $request = $this->restOrdersOrderIdPutRequest($order_id, $_rest_orders_order_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdPut'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  \ck\Model\RestOrdersOrderIdPutRequest|null $_rest_orders_order_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdPutRequest(
        $order_id,
        $_rest_orders_order_id = null,
        string $contentType = self::contentTypes['restOrdersOrderIdPut'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdPut'
            );
        }



        $resourcePath = '/rest/orders/{orderId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_orders_order_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_orders_order_id));
            } else {
                $httpBody = $_rest_orders_order_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdShippingCancelShipmentDelete
     *
     * Cancel a shipment
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingCancelShipmentDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restOrdersOrderIdShippingCancelShipmentDelete(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingCancelShipmentDelete'][0]
    ): object
    {
        list($response) = $this->restOrdersOrderIdShippingCancelShipmentDeleteWithHttpInfo($order_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdShippingCancelShipmentDeleteWithHttpInfo
     *
     * Cancel a shipment
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingCancelShipmentDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdShippingCancelShipmentDeleteWithHttpInfo(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingCancelShipmentDelete'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdShippingCancelShipmentDeleteRequest($order_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdShippingCancelShipmentDeleteAsync
     *
     * Cancel a shipment
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingCancelShipmentDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdShippingCancelShipmentDeleteAsync(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingCancelShipmentDelete'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdShippingCancelShipmentDeleteAsyncWithHttpInfo($order_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdShippingCancelShipmentDeleteAsyncWithHttpInfo
     *
     * Cancel a shipment
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingCancelShipmentDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdShippingCancelShipmentDeleteAsyncWithHttpInfo(
        $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingCancelShipmentDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restOrdersOrderIdShippingCancelShipmentDeleteRequest($order_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdShippingCancelShipmentDelete'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingCancelShipmentDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdShippingCancelShipmentDeleteRequest(
        $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingCancelShipmentDelete'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdShippingCancelShipmentDelete'
            );
        }


        $resourcePath = '/rest/orders/{orderId}/shipping/cancel_shipment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesDelete
     *
     * Delete all order shipping packages for an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPackagesDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restOrdersOrderIdShippingPackagesDelete(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPackagesDelete'][0]
    ): void
    {
        $this->restOrdersOrderIdShippingPackagesDeleteWithHttpInfo($order_id, $contentType);
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesDeleteWithHttpInfo
     *
     * Delete all order shipping packages for an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPackagesDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdShippingPackagesDeleteWithHttpInfo(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPackagesDelete'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdShippingPackagesDeleteRequest($order_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesDeleteAsync
     *
     * Delete all order shipping packages for an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPackagesDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdShippingPackagesDeleteAsync(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPackagesDelete'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdShippingPackagesDeleteAsyncWithHttpInfo($order_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesDeleteAsyncWithHttpInfo
     *
     * Delete all order shipping packages for an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPackagesDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdShippingPackagesDeleteAsyncWithHttpInfo(
        $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPackagesDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restOrdersOrderIdShippingPackagesDeleteRequest($order_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdShippingPackagesDelete'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPackagesDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdShippingPackagesDeleteRequest(
        $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPackagesDelete'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdShippingPackagesDelete'
            );
        }


        $resourcePath = '/rest/orders/{orderId}/shipping/packages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesGet
     *
     * List order shipping packages
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int|null $columns The properties to be loaded (optional)
     * @param  string|null $with Possible value is &#39;labelBase64&#39; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPackagesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\OrderShippingPackage[]
     */
    public function restOrdersOrderIdShippingPackagesGet(
        int $order_id,
        ?int $columns = null,
        ?string $with = null,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPackagesGet'][0]
    ): array
    {
        list($response) = $this->restOrdersOrderIdShippingPackagesGetWithHttpInfo($order_id, $columns, $with, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesGetWithHttpInfo
     *
     * List order shipping packages
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int|null $columns The properties to be loaded (optional)
     * @param  string|null $with Possible value is &#39;labelBase64&#39; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPackagesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\OrderShippingPackage[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdShippingPackagesGetWithHttpInfo(
        int $order_id,
        ?int $columns = null,
        ?string $with = null,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPackagesGet'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdShippingPackagesGetRequest($order_id, $columns, $with, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\OrderShippingPackage[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\OrderShippingPackage[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\OrderShippingPackage[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\OrderShippingPackage[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\OrderShippingPackage[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesGetAsync
     *
     * List order shipping packages
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int|null $columns The properties to be loaded (optional)
     * @param  string|null $with Possible value is &#39;labelBase64&#39; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPackagesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdShippingPackagesGetAsync(
        int $order_id,
        ?int $columns = null,
        ?string $with = null,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPackagesGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdShippingPackagesGetAsyncWithHttpInfo($order_id, $columns, $with, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesGetAsyncWithHttpInfo
     *
     * List order shipping packages
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int|null $columns The properties to be loaded (optional)
     * @param  string|null $with Possible value is &#39;labelBase64&#39; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPackagesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdShippingPackagesGetAsyncWithHttpInfo(
        $order_id,
        $columns = null,
        $with = null,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPackagesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\OrderShippingPackage[]';
        $request = $this->restOrdersOrderIdShippingPackagesGetRequest($order_id, $columns, $with, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdShippingPackagesGet'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int|null $columns The properties to be loaded (optional)
     * @param  string|null $with Possible value is &#39;labelBase64&#39; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPackagesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdShippingPackagesGetRequest(
        $order_id,
        $columns = null,
        $with = null,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPackagesGet'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdShippingPackagesGet'
            );
        }




        $resourcePath = '/rest/orders/{orderId}/shipping/packages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $columns,
            'columns', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesItemsGet
     *
     * List items contained in packages of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPackagesItemsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\OrderShippingPackageItems
     */
    public function restOrdersOrderIdShippingPackagesItemsGet(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPackagesItemsGet'][0]
    ): \ck\Model\OrderShippingPackageItems
    {
        list($response) = $this->restOrdersOrderIdShippingPackagesItemsGetWithHttpInfo($order_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesItemsGetWithHttpInfo
     *
     * List items contained in packages of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPackagesItemsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\OrderShippingPackageItems, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdShippingPackagesItemsGetWithHttpInfo(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPackagesItemsGet'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdShippingPackagesItemsGetRequest($order_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\OrderShippingPackageItems' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\OrderShippingPackageItems' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\OrderShippingPackageItems', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\OrderShippingPackageItems';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\OrderShippingPackageItems',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesItemsGetAsync
     *
     * List items contained in packages of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPackagesItemsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdShippingPackagesItemsGetAsync(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPackagesItemsGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdShippingPackagesItemsGetAsyncWithHttpInfo($order_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesItemsGetAsyncWithHttpInfo
     *
     * List items contained in packages of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPackagesItemsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdShippingPackagesItemsGetAsyncWithHttpInfo(
        $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPackagesItemsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\OrderShippingPackageItems';
        $request = $this->restOrdersOrderIdShippingPackagesItemsGetRequest($order_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdShippingPackagesItemsGet'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPackagesItemsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdShippingPackagesItemsGetRequest(
        $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPackagesItemsGet'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdShippingPackagesItemsGet'
            );
        }


        $resourcePath = '/rest/orders/{orderId}/shipping/packages/items';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesOrderShippingPackageIdDelete
     *
     * Delete an order shipping package
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $order_shipping_package_id The ID of the order shipping package (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPackagesOrderShippingPackageIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restOrdersOrderIdShippingPackagesOrderShippingPackageIdDelete(
        int $order_id,
        int $order_shipping_package_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPackagesOrderShippingPackageIdDelete'][0]
    ): void
    {
        $this->restOrdersOrderIdShippingPackagesOrderShippingPackageIdDeleteWithHttpInfo($order_id, $order_shipping_package_id, $contentType);
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesOrderShippingPackageIdDeleteWithHttpInfo
     *
     * Delete an order shipping package
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $order_shipping_package_id The ID of the order shipping package (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPackagesOrderShippingPackageIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdShippingPackagesOrderShippingPackageIdDeleteWithHttpInfo(
        int $order_id,
        int $order_shipping_package_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPackagesOrderShippingPackageIdDelete'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdShippingPackagesOrderShippingPackageIdDeleteRequest($order_id, $order_shipping_package_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesOrderShippingPackageIdDeleteAsync
     *
     * Delete an order shipping package
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $order_shipping_package_id The ID of the order shipping package (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPackagesOrderShippingPackageIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdShippingPackagesOrderShippingPackageIdDeleteAsync(
        int $order_id,
        int $order_shipping_package_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPackagesOrderShippingPackageIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdShippingPackagesOrderShippingPackageIdDeleteAsyncWithHttpInfo($order_id, $order_shipping_package_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesOrderShippingPackageIdDeleteAsyncWithHttpInfo
     *
     * Delete an order shipping package
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $order_shipping_package_id The ID of the order shipping package (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPackagesOrderShippingPackageIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdShippingPackagesOrderShippingPackageIdDeleteAsyncWithHttpInfo(
        $order_id,
        $order_shipping_package_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPackagesOrderShippingPackageIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restOrdersOrderIdShippingPackagesOrderShippingPackageIdDeleteRequest($order_id, $order_shipping_package_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdShippingPackagesOrderShippingPackageIdDelete'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $order_shipping_package_id The ID of the order shipping package (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPackagesOrderShippingPackageIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdShippingPackagesOrderShippingPackageIdDeleteRequest(
        $order_id,
        $order_shipping_package_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPackagesOrderShippingPackageIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdShippingPackagesOrderShippingPackageIdDelete'
            );
        }

        // verify the required parameter 'order_shipping_package_id' is set
        if ($order_shipping_package_id === null || (is_array($order_shipping_package_id) && count($order_shipping_package_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_shipping_package_id when calling restOrdersOrderIdShippingPackagesOrderShippingPackageIdDelete'
            );
        }


        $resourcePath = '/rest/orders/{orderId}/shipping/packages/{orderShippingPackageId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }
        // path params
        if ($order_shipping_package_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderShippingPackageId' . '}',
                ObjectSerializer::toPathValue($order_shipping_package_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesOrderShippingPackageIdGet
     *
     * Get an order shipping package
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $order_shipping_package_id The ID of the order shipping package (required)
     * @param  int|null $columns The properties to be loaded (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPackagesOrderShippingPackageIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\OrderShippingPackage
     */
    public function restOrdersOrderIdShippingPackagesOrderShippingPackageIdGet(
        int $order_id,
        int $order_shipping_package_id,
        ?int $columns = null,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPackagesOrderShippingPackageIdGet'][0]
    ): \ck\Model\OrderShippingPackage
    {
        list($response) = $this->restOrdersOrderIdShippingPackagesOrderShippingPackageIdGetWithHttpInfo($order_id, $order_shipping_package_id, $columns, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesOrderShippingPackageIdGetWithHttpInfo
     *
     * Get an order shipping package
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $order_shipping_package_id The ID of the order shipping package (required)
     * @param  int|null $columns The properties to be loaded (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPackagesOrderShippingPackageIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\OrderShippingPackage, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdShippingPackagesOrderShippingPackageIdGetWithHttpInfo(
        int $order_id,
        int $order_shipping_package_id,
        ?int $columns = null,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPackagesOrderShippingPackageIdGet'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdShippingPackagesOrderShippingPackageIdGetRequest($order_id, $order_shipping_package_id, $columns, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\OrderShippingPackage' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\OrderShippingPackage' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\OrderShippingPackage', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\OrderShippingPackage';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\OrderShippingPackage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesOrderShippingPackageIdGetAsync
     *
     * Get an order shipping package
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $order_shipping_package_id The ID of the order shipping package (required)
     * @param  int|null $columns The properties to be loaded (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPackagesOrderShippingPackageIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdShippingPackagesOrderShippingPackageIdGetAsync(
        int $order_id,
        int $order_shipping_package_id,
        ?int $columns = null,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPackagesOrderShippingPackageIdGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdShippingPackagesOrderShippingPackageIdGetAsyncWithHttpInfo($order_id, $order_shipping_package_id, $columns, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesOrderShippingPackageIdGetAsyncWithHttpInfo
     *
     * Get an order shipping package
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $order_shipping_package_id The ID of the order shipping package (required)
     * @param  int|null $columns The properties to be loaded (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPackagesOrderShippingPackageIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdShippingPackagesOrderShippingPackageIdGetAsyncWithHttpInfo(
        $order_id,
        $order_shipping_package_id,
        $columns = null,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPackagesOrderShippingPackageIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\OrderShippingPackage';
        $request = $this->restOrdersOrderIdShippingPackagesOrderShippingPackageIdGetRequest($order_id, $order_shipping_package_id, $columns, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdShippingPackagesOrderShippingPackageIdGet'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $order_shipping_package_id The ID of the order shipping package (required)
     * @param  int|null $columns The properties to be loaded (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPackagesOrderShippingPackageIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdShippingPackagesOrderShippingPackageIdGetRequest(
        $order_id,
        $order_shipping_package_id,
        $columns = null,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPackagesOrderShippingPackageIdGet'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdShippingPackagesOrderShippingPackageIdGet'
            );
        }

        // verify the required parameter 'order_shipping_package_id' is set
        if ($order_shipping_package_id === null || (is_array($order_shipping_package_id) && count($order_shipping_package_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_shipping_package_id when calling restOrdersOrderIdShippingPackagesOrderShippingPackageIdGet'
            );
        }



        $resourcePath = '/rest/orders/{orderId}/shipping/packages/{orderShippingPackageId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $columns,
            'columns', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }
        // path params
        if ($order_shipping_package_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderShippingPackageId' . '}',
                ObjectSerializer::toPathValue($order_shipping_package_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesOrderShippingPackageIdPut
     *
     * Update an order shipping package
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $order_shipping_package_id The ID of the order shipping package (required)
     * @param  \ck\Model\RestOrdersOrderIdShippingPackagesOrderShippingPackageIdPutRequest|null $_rest_orders_order_id_shipping_packages_order_shipping_package_id _rest_orders_order_id_shipping_packages_order_shipping_package_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPackagesOrderShippingPackageIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\OrderShippingPackage
     */
    public function restOrdersOrderIdShippingPackagesOrderShippingPackageIdPut(
        int $order_id,
        int $order_shipping_package_id,
        ?\ck\Model\RestOrdersOrderIdShippingPackagesOrderShippingPackageIdPutRequest $_rest_orders_order_id_shipping_packages_order_shipping_package_id = null,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPackagesOrderShippingPackageIdPut'][0]
    ): \ck\Model\OrderShippingPackage
    {
        list($response) = $this->restOrdersOrderIdShippingPackagesOrderShippingPackageIdPutWithHttpInfo($order_id, $order_shipping_package_id, $_rest_orders_order_id_shipping_packages_order_shipping_package_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesOrderShippingPackageIdPutWithHttpInfo
     *
     * Update an order shipping package
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $order_shipping_package_id The ID of the order shipping package (required)
     * @param  \ck\Model\RestOrdersOrderIdShippingPackagesOrderShippingPackageIdPutRequest|null $_rest_orders_order_id_shipping_packages_order_shipping_package_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPackagesOrderShippingPackageIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\OrderShippingPackage, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdShippingPackagesOrderShippingPackageIdPutWithHttpInfo(
        int $order_id,
        int $order_shipping_package_id,
        ?\ck\Model\RestOrdersOrderIdShippingPackagesOrderShippingPackageIdPutRequest $_rest_orders_order_id_shipping_packages_order_shipping_package_id = null,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPackagesOrderShippingPackageIdPut'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdShippingPackagesOrderShippingPackageIdPutRequest($order_id, $order_shipping_package_id, $_rest_orders_order_id_shipping_packages_order_shipping_package_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\OrderShippingPackage' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\OrderShippingPackage' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\OrderShippingPackage', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\OrderShippingPackage';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\OrderShippingPackage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesOrderShippingPackageIdPutAsync
     *
     * Update an order shipping package
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $order_shipping_package_id The ID of the order shipping package (required)
     * @param  \ck\Model\RestOrdersOrderIdShippingPackagesOrderShippingPackageIdPutRequest|null $_rest_orders_order_id_shipping_packages_order_shipping_package_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPackagesOrderShippingPackageIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdShippingPackagesOrderShippingPackageIdPutAsync(
        int $order_id,
        int $order_shipping_package_id,
        ?\ck\Model\RestOrdersOrderIdShippingPackagesOrderShippingPackageIdPutRequest $_rest_orders_order_id_shipping_packages_order_shipping_package_id = null,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPackagesOrderShippingPackageIdPut'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdShippingPackagesOrderShippingPackageIdPutAsyncWithHttpInfo($order_id, $order_shipping_package_id, $_rest_orders_order_id_shipping_packages_order_shipping_package_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesOrderShippingPackageIdPutAsyncWithHttpInfo
     *
     * Update an order shipping package
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $order_shipping_package_id The ID of the order shipping package (required)
     * @param  \ck\Model\RestOrdersOrderIdShippingPackagesOrderShippingPackageIdPutRequest|null $_rest_orders_order_id_shipping_packages_order_shipping_package_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPackagesOrderShippingPackageIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdShippingPackagesOrderShippingPackageIdPutAsyncWithHttpInfo(
        $order_id,
        $order_shipping_package_id,
        $_rest_orders_order_id_shipping_packages_order_shipping_package_id = null,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPackagesOrderShippingPackageIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\OrderShippingPackage';
        $request = $this->restOrdersOrderIdShippingPackagesOrderShippingPackageIdPutRequest($order_id, $order_shipping_package_id, $_rest_orders_order_id_shipping_packages_order_shipping_package_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdShippingPackagesOrderShippingPackageIdPut'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $order_shipping_package_id The ID of the order shipping package (required)
     * @param  \ck\Model\RestOrdersOrderIdShippingPackagesOrderShippingPackageIdPutRequest|null $_rest_orders_order_id_shipping_packages_order_shipping_package_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPackagesOrderShippingPackageIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdShippingPackagesOrderShippingPackageIdPutRequest(
        $order_id,
        $order_shipping_package_id,
        $_rest_orders_order_id_shipping_packages_order_shipping_package_id = null,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPackagesOrderShippingPackageIdPut'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdShippingPackagesOrderShippingPackageIdPut'
            );
        }

        // verify the required parameter 'order_shipping_package_id' is set
        if ($order_shipping_package_id === null || (is_array($order_shipping_package_id) && count($order_shipping_package_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_shipping_package_id when calling restOrdersOrderIdShippingPackagesOrderShippingPackageIdPut'
            );
        }



        $resourcePath = '/rest/orders/{orderId}/shipping/packages/{orderShippingPackageId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }
        // path params
        if ($order_shipping_package_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderShippingPackageId' . '}',
                ObjectSerializer::toPathValue($order_shipping_package_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_orders_order_id_shipping_packages_order_shipping_package_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_orders_order_id_shipping_packages_order_shipping_package_id));
            } else {
                $httpBody = $_rest_orders_order_id_shipping_packages_order_shipping_package_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesPackedItemsGet
     *
     * List packed items of a shipping package by the order ID
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPackagesPackedItemsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object[]
     */
    public function restOrdersOrderIdShippingPackagesPackedItemsGet(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPackagesPackedItemsGet'][0]
    ): array
    {
        list($response) = $this->restOrdersOrderIdShippingPackagesPackedItemsGetWithHttpInfo($order_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesPackedItemsGetWithHttpInfo
     *
     * List packed items of a shipping package by the order ID
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPackagesPackedItemsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdShippingPackagesPackedItemsGetWithHttpInfo(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPackagesPackedItemsGet'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdShippingPackagesPackedItemsGetRequest($order_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesPackedItemsGetAsync
     *
     * List packed items of a shipping package by the order ID
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPackagesPackedItemsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdShippingPackagesPackedItemsGetAsync(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPackagesPackedItemsGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdShippingPackagesPackedItemsGetAsyncWithHttpInfo($order_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesPackedItemsGetAsyncWithHttpInfo
     *
     * List packed items of a shipping package by the order ID
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPackagesPackedItemsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdShippingPackagesPackedItemsGetAsyncWithHttpInfo(
        $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPackagesPackedItemsGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object[]';
        $request = $this->restOrdersOrderIdShippingPackagesPackedItemsGetRequest($order_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdShippingPackagesPackedItemsGet'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPackagesPackedItemsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdShippingPackagesPackedItemsGetRequest(
        $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPackagesPackedItemsGet'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdShippingPackagesPackedItemsGet'
            );
        }


        $resourcePath = '/rest/orders/{orderId}/shipping/packages/packed_items';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesPost
     *
     * Create an order shipping package
     *
     * @param  int $order_id The ID of the order (required)
     * @param  \ck\Model\RestOrdersOrderIdShippingPackagesPostRequest|null $_rest_orders_order_id_shipping_packages _rest_orders_order_id_shipping_packages (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPackagesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\OrderShippingPackage
     */
    public function restOrdersOrderIdShippingPackagesPost(
        int $order_id,
        ?\ck\Model\RestOrdersOrderIdShippingPackagesPostRequest $_rest_orders_order_id_shipping_packages = null,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPackagesPost'][0]
    ): \ck\Model\OrderShippingPackage
    {
        list($response) = $this->restOrdersOrderIdShippingPackagesPostWithHttpInfo($order_id, $_rest_orders_order_id_shipping_packages, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesPostWithHttpInfo
     *
     * Create an order shipping package
     *
     * @param  int $order_id The ID of the order (required)
     * @param  \ck\Model\RestOrdersOrderIdShippingPackagesPostRequest|null $_rest_orders_order_id_shipping_packages (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPackagesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\OrderShippingPackage, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdShippingPackagesPostWithHttpInfo(
        int $order_id,
        ?\ck\Model\RestOrdersOrderIdShippingPackagesPostRequest $_rest_orders_order_id_shipping_packages = null,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPackagesPost'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdShippingPackagesPostRequest($order_id, $_rest_orders_order_id_shipping_packages, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\OrderShippingPackage' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\OrderShippingPackage' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\OrderShippingPackage', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\OrderShippingPackage';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\OrderShippingPackage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesPostAsync
     *
     * Create an order shipping package
     *
     * @param  int $order_id The ID of the order (required)
     * @param  \ck\Model\RestOrdersOrderIdShippingPackagesPostRequest|null $_rest_orders_order_id_shipping_packages (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPackagesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdShippingPackagesPostAsync(
        int $order_id,
        ?\ck\Model\RestOrdersOrderIdShippingPackagesPostRequest $_rest_orders_order_id_shipping_packages = null,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPackagesPost'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdShippingPackagesPostAsyncWithHttpInfo($order_id, $_rest_orders_order_id_shipping_packages, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesPostAsyncWithHttpInfo
     *
     * Create an order shipping package
     *
     * @param  int $order_id The ID of the order (required)
     * @param  \ck\Model\RestOrdersOrderIdShippingPackagesPostRequest|null $_rest_orders_order_id_shipping_packages (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPackagesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdShippingPackagesPostAsyncWithHttpInfo(
        $order_id,
        $_rest_orders_order_id_shipping_packages = null,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPackagesPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\OrderShippingPackage';
        $request = $this->restOrdersOrderIdShippingPackagesPostRequest($order_id, $_rest_orders_order_id_shipping_packages, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdShippingPackagesPost'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  \ck\Model\RestOrdersOrderIdShippingPackagesPostRequest|null $_rest_orders_order_id_shipping_packages (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPackagesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdShippingPackagesPostRequest(
        $order_id,
        $_rest_orders_order_id_shipping_packages = null,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPackagesPost'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdShippingPackagesPost'
            );
        }



        $resourcePath = '/rest/orders/{orderId}/shipping/packages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_orders_order_id_shipping_packages)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_orders_order_id_shipping_packages));
            } else {
                $httpBody = $_rest_orders_order_id_shipping_packages;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesUnpackedItemsGet
     *
     * List unpacked items of a shipping package by the order ID
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPackagesUnpackedItemsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object[]
     */
    public function restOrdersOrderIdShippingPackagesUnpackedItemsGet(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPackagesUnpackedItemsGet'][0]
    ): array
    {
        list($response) = $this->restOrdersOrderIdShippingPackagesUnpackedItemsGetWithHttpInfo($order_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesUnpackedItemsGetWithHttpInfo
     *
     * List unpacked items of a shipping package by the order ID
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPackagesUnpackedItemsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdShippingPackagesUnpackedItemsGetWithHttpInfo(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPackagesUnpackedItemsGet'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdShippingPackagesUnpackedItemsGetRequest($order_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesUnpackedItemsGetAsync
     *
     * List unpacked items of a shipping package by the order ID
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPackagesUnpackedItemsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdShippingPackagesUnpackedItemsGetAsync(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPackagesUnpackedItemsGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdShippingPackagesUnpackedItemsGetAsyncWithHttpInfo($order_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdShippingPackagesUnpackedItemsGetAsyncWithHttpInfo
     *
     * List unpacked items of a shipping package by the order ID
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPackagesUnpackedItemsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdShippingPackagesUnpackedItemsGetAsyncWithHttpInfo(
        $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPackagesUnpackedItemsGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object[]';
        $request = $this->restOrdersOrderIdShippingPackagesUnpackedItemsGetRequest($order_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdShippingPackagesUnpackedItemsGet'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPackagesUnpackedItemsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdShippingPackagesUnpackedItemsGetRequest(
        $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPackagesUnpackedItemsGet'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdShippingPackagesUnpackedItemsGet'
            );
        }


        $resourcePath = '/rest/orders/{orderId}/shipping/packages/unpacked_items';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdShippingPalletsPackagesItemsGet
     *
     * List items contained in package pallets of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPalletsPackagesItemsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\OrderShippingPackageItems
     */
    public function restOrdersOrderIdShippingPalletsPackagesItemsGet(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPalletsPackagesItemsGet'][0]
    ): \ck\Model\OrderShippingPackageItems
    {
        list($response) = $this->restOrdersOrderIdShippingPalletsPackagesItemsGetWithHttpInfo($order_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdShippingPalletsPackagesItemsGetWithHttpInfo
     *
     * List items contained in package pallets of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPalletsPackagesItemsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\OrderShippingPackageItems, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdShippingPalletsPackagesItemsGetWithHttpInfo(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPalletsPackagesItemsGet'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdShippingPalletsPackagesItemsGetRequest($order_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\OrderShippingPackageItems' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\OrderShippingPackageItems' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\OrderShippingPackageItems', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\OrderShippingPackageItems';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\OrderShippingPackageItems',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdShippingPalletsPackagesItemsGetAsync
     *
     * List items contained in package pallets of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPalletsPackagesItemsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdShippingPalletsPackagesItemsGetAsync(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPalletsPackagesItemsGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdShippingPalletsPackagesItemsGetAsyncWithHttpInfo($order_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdShippingPalletsPackagesItemsGetAsyncWithHttpInfo
     *
     * List items contained in package pallets of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPalletsPackagesItemsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdShippingPalletsPackagesItemsGetAsyncWithHttpInfo(
        $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPalletsPackagesItemsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\OrderShippingPackageItems';
        $request = $this->restOrdersOrderIdShippingPalletsPackagesItemsGetRequest($order_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdShippingPalletsPackagesItemsGet'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPalletsPackagesItemsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdShippingPalletsPackagesItemsGetRequest(
        $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPalletsPackagesItemsGet'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdShippingPalletsPackagesItemsGet'
            );
        }


        $resourcePath = '/rest/orders/{orderId}/shipping/pallets/packages/items';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdShippingPalletsPalletIdPackagesDelete
     *
     * Delete all order shipping packages in a pallet
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $pallet_id The ID of the pallet (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPalletsPalletIdPackagesDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restOrdersOrderIdShippingPalletsPalletIdPackagesDelete(
        int $order_id,
        int $pallet_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPalletsPalletIdPackagesDelete'][0]
    ): object
    {
        list($response) = $this->restOrdersOrderIdShippingPalletsPalletIdPackagesDeleteWithHttpInfo($order_id, $pallet_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdShippingPalletsPalletIdPackagesDeleteWithHttpInfo
     *
     * Delete all order shipping packages in a pallet
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $pallet_id The ID of the pallet (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPalletsPalletIdPackagesDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdShippingPalletsPalletIdPackagesDeleteWithHttpInfo(
        int $order_id,
        int $pallet_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPalletsPalletIdPackagesDelete'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdShippingPalletsPalletIdPackagesDeleteRequest($order_id, $pallet_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdShippingPalletsPalletIdPackagesDeleteAsync
     *
     * Delete all order shipping packages in a pallet
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $pallet_id The ID of the pallet (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPalletsPalletIdPackagesDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdShippingPalletsPalletIdPackagesDeleteAsync(
        int $order_id,
        int $pallet_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPalletsPalletIdPackagesDelete'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdShippingPalletsPalletIdPackagesDeleteAsyncWithHttpInfo($order_id, $pallet_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdShippingPalletsPalletIdPackagesDeleteAsyncWithHttpInfo
     *
     * Delete all order shipping packages in a pallet
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $pallet_id The ID of the pallet (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPalletsPalletIdPackagesDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdShippingPalletsPalletIdPackagesDeleteAsyncWithHttpInfo(
        $order_id,
        $pallet_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPalletsPalletIdPackagesDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restOrdersOrderIdShippingPalletsPalletIdPackagesDeleteRequest($order_id, $pallet_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdShippingPalletsPalletIdPackagesDelete'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $pallet_id The ID of the pallet (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPalletsPalletIdPackagesDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdShippingPalletsPalletIdPackagesDeleteRequest(
        $order_id,
        $pallet_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPalletsPalletIdPackagesDelete'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdShippingPalletsPalletIdPackagesDelete'
            );
        }

        // verify the required parameter 'pallet_id' is set
        if ($pallet_id === null || (is_array($pallet_id) && count($pallet_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $pallet_id when calling restOrdersOrderIdShippingPalletsPalletIdPackagesDelete'
            );
        }


        $resourcePath = '/rest/orders/{orderId}/shipping/pallets/{palletId}/packages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }
        // path params
        if ($pallet_id !== null) {
            $resourcePath = str_replace(
                '{' . 'palletId' . '}',
                ObjectSerializer::toPathValue($pallet_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdShippingPalletsPalletIdPackagesGet
     *
     * List all packages contained in pallets of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $pallet_id The ID of the pallet (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPalletsPalletIdPackagesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\OrderShippingPackage[]
     */
    public function restOrdersOrderIdShippingPalletsPalletIdPackagesGet(
        int $order_id,
        int $pallet_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPalletsPalletIdPackagesGet'][0]
    ): array
    {
        list($response) = $this->restOrdersOrderIdShippingPalletsPalletIdPackagesGetWithHttpInfo($order_id, $pallet_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdShippingPalletsPalletIdPackagesGetWithHttpInfo
     *
     * List all packages contained in pallets of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $pallet_id The ID of the pallet (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPalletsPalletIdPackagesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\OrderShippingPackage[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdShippingPalletsPalletIdPackagesGetWithHttpInfo(
        int $order_id,
        int $pallet_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPalletsPalletIdPackagesGet'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdShippingPalletsPalletIdPackagesGetRequest($order_id, $pallet_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\OrderShippingPackage[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\OrderShippingPackage[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\OrderShippingPackage[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\OrderShippingPackage[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\OrderShippingPackage[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdShippingPalletsPalletIdPackagesGetAsync
     *
     * List all packages contained in pallets of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $pallet_id The ID of the pallet (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPalletsPalletIdPackagesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdShippingPalletsPalletIdPackagesGetAsync(
        int $order_id,
        int $pallet_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPalletsPalletIdPackagesGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdShippingPalletsPalletIdPackagesGetAsyncWithHttpInfo($order_id, $pallet_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdShippingPalletsPalletIdPackagesGetAsyncWithHttpInfo
     *
     * List all packages contained in pallets of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $pallet_id The ID of the pallet (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPalletsPalletIdPackagesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdShippingPalletsPalletIdPackagesGetAsyncWithHttpInfo(
        $order_id,
        $pallet_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPalletsPalletIdPackagesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\OrderShippingPackage[]';
        $request = $this->restOrdersOrderIdShippingPalletsPalletIdPackagesGetRequest($order_id, $pallet_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdShippingPalletsPalletIdPackagesGet'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $pallet_id The ID of the pallet (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPalletsPalletIdPackagesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdShippingPalletsPalletIdPackagesGetRequest(
        $order_id,
        $pallet_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPalletsPalletIdPackagesGet'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdShippingPalletsPalletIdPackagesGet'
            );
        }

        // verify the required parameter 'pallet_id' is set
        if ($pallet_id === null || (is_array($pallet_id) && count($pallet_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $pallet_id when calling restOrdersOrderIdShippingPalletsPalletIdPackagesGet'
            );
        }


        $resourcePath = '/rest/orders/{orderId}/shipping/pallets/{palletId}/packages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }
        // path params
        if ($pallet_id !== null) {
            $resourcePath = str_replace(
                '{' . 'palletId' . '}',
                ObjectSerializer::toPathValue($pallet_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdShippingPalletsPalletIdPackagesPut
     *
     * Update all packages in a pallet
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $pallet_id The ID of the pallet (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPalletsPalletIdPackagesPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restOrdersOrderIdShippingPalletsPalletIdPackagesPut(
        int $order_id,
        int $pallet_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPalletsPalletIdPackagesPut'][0]
    ): object
    {
        list($response) = $this->restOrdersOrderIdShippingPalletsPalletIdPackagesPutWithHttpInfo($order_id, $pallet_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdShippingPalletsPalletIdPackagesPutWithHttpInfo
     *
     * Update all packages in a pallet
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $pallet_id The ID of the pallet (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPalletsPalletIdPackagesPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdShippingPalletsPalletIdPackagesPutWithHttpInfo(
        int $order_id,
        int $pallet_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPalletsPalletIdPackagesPut'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdShippingPalletsPalletIdPackagesPutRequest($order_id, $pallet_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdShippingPalletsPalletIdPackagesPutAsync
     *
     * Update all packages in a pallet
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $pallet_id The ID of the pallet (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPalletsPalletIdPackagesPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdShippingPalletsPalletIdPackagesPutAsync(
        int $order_id,
        int $pallet_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPalletsPalletIdPackagesPut'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdShippingPalletsPalletIdPackagesPutAsyncWithHttpInfo($order_id, $pallet_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdShippingPalletsPalletIdPackagesPutAsyncWithHttpInfo
     *
     * Update all packages in a pallet
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $pallet_id The ID of the pallet (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPalletsPalletIdPackagesPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdShippingPalletsPalletIdPackagesPutAsyncWithHttpInfo(
        $order_id,
        $pallet_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPalletsPalletIdPackagesPut'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restOrdersOrderIdShippingPalletsPalletIdPackagesPutRequest($order_id, $pallet_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdShippingPalletsPalletIdPackagesPut'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $pallet_id The ID of the pallet (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingPalletsPalletIdPackagesPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdShippingPalletsPalletIdPackagesPutRequest(
        $order_id,
        $pallet_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingPalletsPalletIdPackagesPut'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdShippingPalletsPalletIdPackagesPut'
            );
        }

        // verify the required parameter 'pallet_id' is set
        if ($pallet_id === null || (is_array($pallet_id) && count($pallet_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $pallet_id when calling restOrdersOrderIdShippingPalletsPalletIdPackagesPut'
            );
        }


        $resourcePath = '/rest/orders/{orderId}/shipping/pallets/{palletId}/packages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }
        // path params
        if ($pallet_id !== null) {
            $resourcePath = str_replace(
                '{' . 'palletId' . '}',
                ObjectSerializer::toPathValue($pallet_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdShippingRegisterShipmentPost
     *
     * Register a shipment
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingRegisterShipmentPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restOrdersOrderIdShippingRegisterShipmentPost(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingRegisterShipmentPost'][0]
    ): object
    {
        list($response) = $this->restOrdersOrderIdShippingRegisterShipmentPostWithHttpInfo($order_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdShippingRegisterShipmentPostWithHttpInfo
     *
     * Register a shipment
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingRegisterShipmentPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdShippingRegisterShipmentPostWithHttpInfo(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingRegisterShipmentPost'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdShippingRegisterShipmentPostRequest($order_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdShippingRegisterShipmentPostAsync
     *
     * Register a shipment
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingRegisterShipmentPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdShippingRegisterShipmentPostAsync(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingRegisterShipmentPost'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdShippingRegisterShipmentPostAsyncWithHttpInfo($order_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdShippingRegisterShipmentPostAsyncWithHttpInfo
     *
     * Register a shipment
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingRegisterShipmentPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdShippingRegisterShipmentPostAsyncWithHttpInfo(
        $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingRegisterShipmentPost'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restOrdersOrderIdShippingRegisterShipmentPostRequest($order_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdShippingRegisterShipmentPost'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingRegisterShipmentPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdShippingRegisterShipmentPostRequest(
        $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingRegisterShipmentPost'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdShippingRegisterShipmentPost'
            );
        }


        $resourcePath = '/rest/orders/{orderId}/shipping/register_shipment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdShippingShippingInformationAdditionalDataPut
     *
     * Update additional data of the shipping information
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingShippingInformationAdditionalDataPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ShippingInformation
     */
    public function restOrdersOrderIdShippingShippingInformationAdditionalDataPut(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingShippingInformationAdditionalDataPut'][0]
    ): \ck\Model\ShippingInformation
    {
        list($response) = $this->restOrdersOrderIdShippingShippingInformationAdditionalDataPutWithHttpInfo($order_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdShippingShippingInformationAdditionalDataPutWithHttpInfo
     *
     * Update additional data of the shipping information
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingShippingInformationAdditionalDataPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ShippingInformation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdShippingShippingInformationAdditionalDataPutWithHttpInfo(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingShippingInformationAdditionalDataPut'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdShippingShippingInformationAdditionalDataPutRequest($order_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ShippingInformation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ShippingInformation' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ShippingInformation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ShippingInformation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ShippingInformation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdShippingShippingInformationAdditionalDataPutAsync
     *
     * Update additional data of the shipping information
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingShippingInformationAdditionalDataPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdShippingShippingInformationAdditionalDataPutAsync(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingShippingInformationAdditionalDataPut'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdShippingShippingInformationAdditionalDataPutAsyncWithHttpInfo($order_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdShippingShippingInformationAdditionalDataPutAsyncWithHttpInfo
     *
     * Update additional data of the shipping information
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingShippingInformationAdditionalDataPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdShippingShippingInformationAdditionalDataPutAsyncWithHttpInfo(
        $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingShippingInformationAdditionalDataPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ShippingInformation';
        $request = $this->restOrdersOrderIdShippingShippingInformationAdditionalDataPutRequest($order_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdShippingShippingInformationAdditionalDataPut'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingShippingInformationAdditionalDataPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdShippingShippingInformationAdditionalDataPutRequest(
        $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingShippingInformationAdditionalDataPut'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdShippingShippingInformationAdditionalDataPut'
            );
        }


        $resourcePath = '/rest/orders/{orderId}/shipping/shipping_information/additional_data';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdShippingShippingInformationDelete
     *
     * Delete shipping information
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingShippingInformationDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ShippingInformation
     */
    public function restOrdersOrderIdShippingShippingInformationDelete(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingShippingInformationDelete'][0]
    ): \ck\Model\ShippingInformation
    {
        list($response) = $this->restOrdersOrderIdShippingShippingInformationDeleteWithHttpInfo($order_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdShippingShippingInformationDeleteWithHttpInfo
     *
     * Delete shipping information
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingShippingInformationDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ShippingInformation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdShippingShippingInformationDeleteWithHttpInfo(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingShippingInformationDelete'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdShippingShippingInformationDeleteRequest($order_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ShippingInformation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ShippingInformation' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ShippingInformation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ShippingInformation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ShippingInformation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdShippingShippingInformationDeleteAsync
     *
     * Delete shipping information
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingShippingInformationDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdShippingShippingInformationDeleteAsync(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingShippingInformationDelete'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdShippingShippingInformationDeleteAsyncWithHttpInfo($order_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdShippingShippingInformationDeleteAsyncWithHttpInfo
     *
     * Delete shipping information
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingShippingInformationDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdShippingShippingInformationDeleteAsyncWithHttpInfo(
        $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingShippingInformationDelete'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ShippingInformation';
        $request = $this->restOrdersOrderIdShippingShippingInformationDeleteRequest($order_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdShippingShippingInformationDelete'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingShippingInformationDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdShippingShippingInformationDeleteRequest(
        $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingShippingInformationDelete'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdShippingShippingInformationDelete'
            );
        }


        $resourcePath = '/rest/orders/{orderId}/shipping/shipping_information';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdShippingShippingInformationGet
     *
     * Get shipping information
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingShippingInformationGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ShippingInformation
     */
    public function restOrdersOrderIdShippingShippingInformationGet(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingShippingInformationGet'][0]
    ): \ck\Model\ShippingInformation
    {
        list($response) = $this->restOrdersOrderIdShippingShippingInformationGetWithHttpInfo($order_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdShippingShippingInformationGetWithHttpInfo
     *
     * Get shipping information
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingShippingInformationGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ShippingInformation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdShippingShippingInformationGetWithHttpInfo(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingShippingInformationGet'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdShippingShippingInformationGetRequest($order_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ShippingInformation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ShippingInformation' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ShippingInformation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ShippingInformation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ShippingInformation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdShippingShippingInformationGetAsync
     *
     * Get shipping information
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingShippingInformationGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdShippingShippingInformationGetAsync(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingShippingInformationGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdShippingShippingInformationGetAsyncWithHttpInfo($order_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdShippingShippingInformationGetAsyncWithHttpInfo
     *
     * Get shipping information
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingShippingInformationGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdShippingShippingInformationGetAsyncWithHttpInfo(
        $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingShippingInformationGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ShippingInformation';
        $request = $this->restOrdersOrderIdShippingShippingInformationGetRequest($order_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdShippingShippingInformationGet'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingShippingInformationGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdShippingShippingInformationGetRequest(
        $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingShippingInformationGet'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdShippingShippingInformationGet'
            );
        }


        $resourcePath = '/rest/orders/{orderId}/shipping/shipping_information';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdShippingShippingInformationStatusPut
     *
     * Update the shipping status of the shipping information
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingShippingInformationStatusPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ShippingInformation
     */
    public function restOrdersOrderIdShippingShippingInformationStatusPut(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingShippingInformationStatusPut'][0]
    ): \ck\Model\ShippingInformation
    {
        list($response) = $this->restOrdersOrderIdShippingShippingInformationStatusPutWithHttpInfo($order_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdShippingShippingInformationStatusPutWithHttpInfo
     *
     * Update the shipping status of the shipping information
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingShippingInformationStatusPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ShippingInformation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdShippingShippingInformationStatusPutWithHttpInfo(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingShippingInformationStatusPut'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdShippingShippingInformationStatusPutRequest($order_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ShippingInformation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ShippingInformation' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ShippingInformation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ShippingInformation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ShippingInformation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdShippingShippingInformationStatusPutAsync
     *
     * Update the shipping status of the shipping information
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingShippingInformationStatusPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdShippingShippingInformationStatusPutAsync(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingShippingInformationStatusPut'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdShippingShippingInformationStatusPutAsyncWithHttpInfo($order_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdShippingShippingInformationStatusPutAsyncWithHttpInfo
     *
     * Update the shipping status of the shipping information
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingShippingInformationStatusPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdShippingShippingInformationStatusPutAsyncWithHttpInfo(
        $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingShippingInformationStatusPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ShippingInformation';
        $request = $this->restOrdersOrderIdShippingShippingInformationStatusPutRequest($order_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdShippingShippingInformationStatusPut'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdShippingShippingInformationStatusPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdShippingShippingInformationStatusPutRequest(
        $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdShippingShippingInformationStatusPut'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdShippingShippingInformationStatusPut'
            );
        }


        $resourcePath = '/rest/orders/{orderId}/shipping/shipping_information/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdStatusHistoryGet
     *
     * Get the status history of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdStatusHistoryGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\StatusHistoryEntry[]
     */
    public function restOrdersOrderIdStatusHistoryGet(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdStatusHistoryGet'][0]
    ): array
    {
        list($response) = $this->restOrdersOrderIdStatusHistoryGetWithHttpInfo($order_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdStatusHistoryGetWithHttpInfo
     *
     * Get the status history of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdStatusHistoryGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\StatusHistoryEntry[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdStatusHistoryGetWithHttpInfo(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdStatusHistoryGet'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdStatusHistoryGetRequest($order_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\StatusHistoryEntry[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\StatusHistoryEntry[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\StatusHistoryEntry[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\StatusHistoryEntry[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\StatusHistoryEntry[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdStatusHistoryGetAsync
     *
     * Get the status history of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdStatusHistoryGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdStatusHistoryGetAsync(
        int $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdStatusHistoryGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdStatusHistoryGetAsyncWithHttpInfo($order_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdStatusHistoryGetAsyncWithHttpInfo
     *
     * Get the status history of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdStatusHistoryGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdStatusHistoryGetAsyncWithHttpInfo(
        $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdStatusHistoryGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\StatusHistoryEntry[]';
        $request = $this->restOrdersOrderIdStatusHistoryGetRequest($order_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdStatusHistoryGet'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdStatusHistoryGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdStatusHistoryGetRequest(
        $order_id,
        string $contentType = self::contentTypes['restOrdersOrderIdStatusHistoryGet'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdStatusHistoryGet'
            );
        }


        $resourcePath = '/rest/orders/{orderId}/status-history';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdTransactionsPost
     *
     * Create order item transactions for an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  \ck\Model\RestOrdersOrderIdTransactionsPostRequest|null $_rest_orders_order_id_transactions _rest_orders_order_id_transactions (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdTransactionsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\OrderItemTransaction[]
     */
    public function restOrdersOrderIdTransactionsPost(
        int $order_id,
        ?\ck\Model\RestOrdersOrderIdTransactionsPostRequest $_rest_orders_order_id_transactions = null,
        string $contentType = self::contentTypes['restOrdersOrderIdTransactionsPost'][0]
    ): array
    {
        list($response) = $this->restOrdersOrderIdTransactionsPostWithHttpInfo($order_id, $_rest_orders_order_id_transactions, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdTransactionsPostWithHttpInfo
     *
     * Create order item transactions for an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  \ck\Model\RestOrdersOrderIdTransactionsPostRequest|null $_rest_orders_order_id_transactions (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdTransactionsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\OrderItemTransaction[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdTransactionsPostWithHttpInfo(
        int $order_id,
        ?\ck\Model\RestOrdersOrderIdTransactionsPostRequest $_rest_orders_order_id_transactions = null,
        string $contentType = self::contentTypes['restOrdersOrderIdTransactionsPost'][0]
    ): array
    {
        $request = $this->restOrdersOrderIdTransactionsPostRequest($order_id, $_rest_orders_order_id_transactions, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\OrderItemTransaction[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\OrderItemTransaction[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\OrderItemTransaction[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\OrderItemTransaction[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\OrderItemTransaction[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdTransactionsPostAsync
     *
     * Create order item transactions for an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  \ck\Model\RestOrdersOrderIdTransactionsPostRequest|null $_rest_orders_order_id_transactions (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdTransactionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdTransactionsPostAsync(
        int $order_id,
        ?\ck\Model\RestOrdersOrderIdTransactionsPostRequest $_rest_orders_order_id_transactions = null,
        string $contentType = self::contentTypes['restOrdersOrderIdTransactionsPost'][0]
    ): PromiseInterface
    {
        return $this->restOrdersOrderIdTransactionsPostAsyncWithHttpInfo($order_id, $_rest_orders_order_id_transactions, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdTransactionsPostAsyncWithHttpInfo
     *
     * Create order item transactions for an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  \ck\Model\RestOrdersOrderIdTransactionsPostRequest|null $_rest_orders_order_id_transactions (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdTransactionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersOrderIdTransactionsPostAsyncWithHttpInfo(
        $order_id,
        $_rest_orders_order_id_transactions = null,
        string $contentType = self::contentTypes['restOrdersOrderIdTransactionsPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\OrderItemTransaction[]';
        $request = $this->restOrdersOrderIdTransactionsPostRequest($order_id, $_rest_orders_order_id_transactions, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdTransactionsPost'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  \ck\Model\RestOrdersOrderIdTransactionsPostRequest|null $_rest_orders_order_id_transactions (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersOrderIdTransactionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersOrderIdTransactionsPostRequest(
        $order_id,
        $_rest_orders_order_id_transactions = null,
        string $contentType = self::contentTypes['restOrdersOrderIdTransactionsPost'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdTransactionsPost'
            );
        }



        $resourcePath = '/rest/orders/{orderId}/transactions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_orders_order_id_transactions)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_orders_order_id_transactions));
            } else {
                $httpBody = $_rest_orders_order_id_transactions;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersPost
     *
     * Create an order
     *
     * @param  int|null $coupon One or multiple coupon code to be redeemed with order creation (optional)
     * @param  \ck\Model\RestOrdersPostRequest|null $_rest_orders _rest_orders (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Order
     */
    public function restOrdersPost(
        ?int $coupon = null,
        ?\ck\Model\RestOrdersPostRequest $_rest_orders = null,
        string $contentType = self::contentTypes['restOrdersPost'][0]
    ): \ck\Model\Order
    {
        list($response) = $this->restOrdersPostWithHttpInfo($coupon, $_rest_orders, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersPostWithHttpInfo
     *
     * Create an order
     *
     * @param  int|null $coupon One or multiple coupon code to be redeemed with order creation (optional)
     * @param  \ck\Model\RestOrdersPostRequest|null $_rest_orders (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Order, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersPostWithHttpInfo(
        ?int $coupon = null,
        ?\ck\Model\RestOrdersPostRequest $_rest_orders = null,
        string $contentType = self::contentTypes['restOrdersPost'][0]
    ): array
    {
        $request = $this->restOrdersPostRequest($coupon, $_rest_orders, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Order' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Order' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Order', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Order';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Order',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersPostAsync
     *
     * Create an order
     *
     * @param  int|null $coupon One or multiple coupon code to be redeemed with order creation (optional)
     * @param  \ck\Model\RestOrdersPostRequest|null $_rest_orders (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersPostAsync(
        ?int $coupon = null,
        ?\ck\Model\RestOrdersPostRequest $_rest_orders = null,
        string $contentType = self::contentTypes['restOrdersPost'][0]
    ): PromiseInterface
    {
        return $this->restOrdersPostAsyncWithHttpInfo($coupon, $_rest_orders, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersPostAsyncWithHttpInfo
     *
     * Create an order
     *
     * @param  int|null $coupon One or multiple coupon code to be redeemed with order creation (optional)
     * @param  \ck\Model\RestOrdersPostRequest|null $_rest_orders (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersPostAsyncWithHttpInfo(
        $coupon = null,
        $_rest_orders = null,
        string $contentType = self::contentTypes['restOrdersPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Order';
        $request = $this->restOrdersPostRequest($coupon, $_rest_orders, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersPost'
     *
     * @param  int|null $coupon One or multiple coupon code to be redeemed with order creation (optional)
     * @param  \ck\Model\RestOrdersPostRequest|null $_rest_orders (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersPostRequest(
        $coupon = null,
        $_rest_orders = null,
        string $contentType = self::contentTypes['restOrdersPost'][0]
    ): Request
    {




        $resourcePath = '/rest/orders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $coupon,
            'coupon', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_orders)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_orders));
            } else {
                $httpBody = $_rest_orders;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersPropertiesIdDelete
     *
     * Delete property of an order by property ID
     *
     * @param  int $id The ID of the property to be deleted. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersPropertiesIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restOrdersPropertiesIdDelete(
        int $id,
        string $contentType = self::contentTypes['restOrdersPropertiesIdDelete'][0]
    ): object
    {
        list($response) = $this->restOrdersPropertiesIdDeleteWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersPropertiesIdDeleteWithHttpInfo
     *
     * Delete property of an order by property ID
     *
     * @param  int $id The ID of the property to be deleted. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersPropertiesIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersPropertiesIdDeleteWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restOrdersPropertiesIdDelete'][0]
    ): array
    {
        $request = $this->restOrdersPropertiesIdDeleteRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersPropertiesIdDeleteAsync
     *
     * Delete property of an order by property ID
     *
     * @param  int $id The ID of the property to be deleted. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersPropertiesIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersPropertiesIdDeleteAsync(
        int $id,
        string $contentType = self::contentTypes['restOrdersPropertiesIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restOrdersPropertiesIdDeleteAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersPropertiesIdDeleteAsyncWithHttpInfo
     *
     * Delete property of an order by property ID
     *
     * @param  int $id The ID of the property to be deleted. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersPropertiesIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersPropertiesIdDeleteAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restOrdersPropertiesIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restOrdersPropertiesIdDeleteRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersPropertiesIdDelete'
     *
     * @param  int $id The ID of the property to be deleted. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersPropertiesIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersPropertiesIdDeleteRequest(
        $id,
        string $contentType = self::contentTypes['restOrdersPropertiesIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restOrdersPropertiesIdDelete'
            );
        }


        $resourcePath = '/rest/orders/properties/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersPropertiesIdPut
     *
     * Update property of an order by property ID
     *
     * @param  int $id id (required)
     * @param  \ck\Model\RestOrdersPropertiesIdPutRequest|null $_rest_orders_properties_id _rest_orders_properties_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersPropertiesIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\OrderProperty
     */
    public function restOrdersPropertiesIdPut(
        int $id,
        ?\ck\Model\RestOrdersPropertiesIdPutRequest $_rest_orders_properties_id = null,
        string $contentType = self::contentTypes['restOrdersPropertiesIdPut'][0]
    ): \ck\Model\OrderProperty
    {
        list($response) = $this->restOrdersPropertiesIdPutWithHttpInfo($id, $_rest_orders_properties_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersPropertiesIdPutWithHttpInfo
     *
     * Update property of an order by property ID
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestOrdersPropertiesIdPutRequest|null $_rest_orders_properties_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersPropertiesIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\OrderProperty, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersPropertiesIdPutWithHttpInfo(
        int $id,
        ?\ck\Model\RestOrdersPropertiesIdPutRequest $_rest_orders_properties_id = null,
        string $contentType = self::contentTypes['restOrdersPropertiesIdPut'][0]
    ): array
    {
        $request = $this->restOrdersPropertiesIdPutRequest($id, $_rest_orders_properties_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\OrderProperty' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\OrderProperty' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\OrderProperty', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\OrderProperty';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\OrderProperty',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersPropertiesIdPutAsync
     *
     * Update property of an order by property ID
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestOrdersPropertiesIdPutRequest|null $_rest_orders_properties_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersPropertiesIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersPropertiesIdPutAsync(
        int $id,
        ?\ck\Model\RestOrdersPropertiesIdPutRequest $_rest_orders_properties_id = null,
        string $contentType = self::contentTypes['restOrdersPropertiesIdPut'][0]
    ): PromiseInterface
    {
        return $this->restOrdersPropertiesIdPutAsyncWithHttpInfo($id, $_rest_orders_properties_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersPropertiesIdPutAsyncWithHttpInfo
     *
     * Update property of an order by property ID
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestOrdersPropertiesIdPutRequest|null $_rest_orders_properties_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersPropertiesIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersPropertiesIdPutAsyncWithHttpInfo(
        $id,
        $_rest_orders_properties_id = null,
        string $contentType = self::contentTypes['restOrdersPropertiesIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\OrderProperty';
        $request = $this->restOrdersPropertiesIdPutRequest($id, $_rest_orders_properties_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersPropertiesIdPut'
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestOrdersPropertiesIdPutRequest|null $_rest_orders_properties_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersPropertiesIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersPropertiesIdPutRequest(
        $id,
        $_rest_orders_properties_id = null,
        string $contentType = self::contentTypes['restOrdersPropertiesIdPut'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restOrdersPropertiesIdPut'
            );
        }



        $resourcePath = '/rest/orders/properties/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_orders_properties_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_orders_properties_id));
            } else {
                $httpBody = $_rest_orders_properties_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersPropertiesTypesGet
     *
     * List order property types
     *
     * @param  int|null $lang If no parameter is set here, all languages are loaded by default. Optionally, enter an arry containing the ISO codes of the desired languages. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersPropertiesTypesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\OrderPropertyType[]
     */
    public function restOrdersPropertiesTypesGet(
        ?int $lang = null,
        string $contentType = self::contentTypes['restOrdersPropertiesTypesGet'][0]
    ): array
    {
        list($response) = $this->restOrdersPropertiesTypesGetWithHttpInfo($lang, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersPropertiesTypesGetWithHttpInfo
     *
     * List order property types
     *
     * @param  int|null $lang If no parameter is set here, all languages are loaded by default. Optionally, enter an arry containing the ISO codes of the desired languages. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersPropertiesTypesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\OrderPropertyType[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersPropertiesTypesGetWithHttpInfo(
        ?int $lang = null,
        string $contentType = self::contentTypes['restOrdersPropertiesTypesGet'][0]
    ): array
    {
        $request = $this->restOrdersPropertiesTypesGetRequest($lang, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\OrderPropertyType[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\OrderPropertyType[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\OrderPropertyType[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\OrderPropertyType[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\OrderPropertyType[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersPropertiesTypesGetAsync
     *
     * List order property types
     *
     * @param  int|null $lang If no parameter is set here, all languages are loaded by default. Optionally, enter an arry containing the ISO codes of the desired languages. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersPropertiesTypesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersPropertiesTypesGetAsync(
        ?int $lang = null,
        string $contentType = self::contentTypes['restOrdersPropertiesTypesGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersPropertiesTypesGetAsyncWithHttpInfo($lang, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersPropertiesTypesGetAsyncWithHttpInfo
     *
     * List order property types
     *
     * @param  int|null $lang If no parameter is set here, all languages are loaded by default. Optionally, enter an arry containing the ISO codes of the desired languages. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersPropertiesTypesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersPropertiesTypesGetAsyncWithHttpInfo(
        $lang = null,
        string $contentType = self::contentTypes['restOrdersPropertiesTypesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\OrderPropertyType[]';
        $request = $this->restOrdersPropertiesTypesGetRequest($lang, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersPropertiesTypesGet'
     *
     * @param  int|null $lang If no parameter is set here, all languages are loaded by default. Optionally, enter an arry containing the ISO codes of the desired languages. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersPropertiesTypesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersPropertiesTypesGetRequest(
        $lang = null,
        string $contentType = self::contentTypes['restOrdersPropertiesTypesGet'][0]
    ): Request
    {



        $resourcePath = '/rest/orders/properties/types';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $lang,
            'lang', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersPropertiesTypesPost
     *
     * Create order property type
     *
     * @param  \ck\Model\RestOrdersPropertiesTypesPostRequest|null $_rest_orders_properties_types _rest_orders_properties_types (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersPropertiesTypesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\OrderPropertyType
     */
    public function restOrdersPropertiesTypesPost(
        ?\ck\Model\RestOrdersPropertiesTypesPostRequest $_rest_orders_properties_types = null,
        string $contentType = self::contentTypes['restOrdersPropertiesTypesPost'][0]
    ): \ck\Model\OrderPropertyType
    {
        list($response) = $this->restOrdersPropertiesTypesPostWithHttpInfo($_rest_orders_properties_types, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersPropertiesTypesPostWithHttpInfo
     *
     * Create order property type
     *
     * @param  \ck\Model\RestOrdersPropertiesTypesPostRequest|null $_rest_orders_properties_types (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersPropertiesTypesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\OrderPropertyType, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersPropertiesTypesPostWithHttpInfo(
        ?\ck\Model\RestOrdersPropertiesTypesPostRequest $_rest_orders_properties_types = null,
        string $contentType = self::contentTypes['restOrdersPropertiesTypesPost'][0]
    ): array
    {
        $request = $this->restOrdersPropertiesTypesPostRequest($_rest_orders_properties_types, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\OrderPropertyType' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\OrderPropertyType' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\OrderPropertyType', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\OrderPropertyType';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\OrderPropertyType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersPropertiesTypesPostAsync
     *
     * Create order property type
     *
     * @param  \ck\Model\RestOrdersPropertiesTypesPostRequest|null $_rest_orders_properties_types (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersPropertiesTypesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersPropertiesTypesPostAsync(
        ?\ck\Model\RestOrdersPropertiesTypesPostRequest $_rest_orders_properties_types = null,
        string $contentType = self::contentTypes['restOrdersPropertiesTypesPost'][0]
    ): PromiseInterface
    {
        return $this->restOrdersPropertiesTypesPostAsyncWithHttpInfo($_rest_orders_properties_types, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersPropertiesTypesPostAsyncWithHttpInfo
     *
     * Create order property type
     *
     * @param  \ck\Model\RestOrdersPropertiesTypesPostRequest|null $_rest_orders_properties_types (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersPropertiesTypesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersPropertiesTypesPostAsyncWithHttpInfo(
        $_rest_orders_properties_types = null,
        string $contentType = self::contentTypes['restOrdersPropertiesTypesPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\OrderPropertyType';
        $request = $this->restOrdersPropertiesTypesPostRequest($_rest_orders_properties_types, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersPropertiesTypesPost'
     *
     * @param  \ck\Model\RestOrdersPropertiesTypesPostRequest|null $_rest_orders_properties_types (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersPropertiesTypesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersPropertiesTypesPostRequest(
        $_rest_orders_properties_types = null,
        string $contentType = self::contentTypes['restOrdersPropertiesTypesPost'][0]
    ): Request
    {



        $resourcePath = '/rest/orders/properties/types';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_orders_properties_types)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_orders_properties_types));
            } else {
                $httpBody = $_rest_orders_properties_types;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersPropertiesTypesTypeIdDelete
     *
     * Delete property type
     *
     * @param  int $type_id The ID of the property type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersPropertiesTypesTypeIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restOrdersPropertiesTypesTypeIdDelete(
        int $type_id,
        string $contentType = self::contentTypes['restOrdersPropertiesTypesTypeIdDelete'][0]
    ): void
    {
        $this->restOrdersPropertiesTypesTypeIdDeleteWithHttpInfo($type_id, $contentType);
    }

    /**
     * Operation restOrdersPropertiesTypesTypeIdDeleteWithHttpInfo
     *
     * Delete property type
     *
     * @param  int $type_id The ID of the property type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersPropertiesTypesTypeIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersPropertiesTypesTypeIdDeleteWithHttpInfo(
        int $type_id,
        string $contentType = self::contentTypes['restOrdersPropertiesTypesTypeIdDelete'][0]
    ): array
    {
        $request = $this->restOrdersPropertiesTypesTypeIdDeleteRequest($type_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersPropertiesTypesTypeIdDeleteAsync
     *
     * Delete property type
     *
     * @param  int $type_id The ID of the property type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersPropertiesTypesTypeIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersPropertiesTypesTypeIdDeleteAsync(
        int $type_id,
        string $contentType = self::contentTypes['restOrdersPropertiesTypesTypeIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restOrdersPropertiesTypesTypeIdDeleteAsyncWithHttpInfo($type_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersPropertiesTypesTypeIdDeleteAsyncWithHttpInfo
     *
     * Delete property type
     *
     * @param  int $type_id The ID of the property type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersPropertiesTypesTypeIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersPropertiesTypesTypeIdDeleteAsyncWithHttpInfo(
        $type_id,
        string $contentType = self::contentTypes['restOrdersPropertiesTypesTypeIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restOrdersPropertiesTypesTypeIdDeleteRequest($type_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersPropertiesTypesTypeIdDelete'
     *
     * @param  int $type_id The ID of the property type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersPropertiesTypesTypeIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersPropertiesTypesTypeIdDeleteRequest(
        $type_id,
        string $contentType = self::contentTypes['restOrdersPropertiesTypesTypeIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'type_id' is set
        if ($type_id === null || (is_array($type_id) && count($type_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $type_id when calling restOrdersPropertiesTypesTypeIdDelete'
            );
        }


        $resourcePath = '/rest/orders/properties/types/{typeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'typeId' . '}',
                ObjectSerializer::toPathValue($type_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersPropertiesTypesTypeIdGet
     *
     * Get property type
     *
     * @param  int $type_id The ID of the type. (required)
     * @param  int|null $lang If no parameter is set here, all languages for the property are loaded by default. Optionally, enter an arry containing the ISO codes of the desired languages. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersPropertiesTypesTypeIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\OrderPropertyType
     */
    public function restOrdersPropertiesTypesTypeIdGet(
        int $type_id,
        ?int $lang = null,
        string $contentType = self::contentTypes['restOrdersPropertiesTypesTypeIdGet'][0]
    ): \ck\Model\OrderPropertyType
    {
        list($response) = $this->restOrdersPropertiesTypesTypeIdGetWithHttpInfo($type_id, $lang, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersPropertiesTypesTypeIdGetWithHttpInfo
     *
     * Get property type
     *
     * @param  int $type_id The ID of the type. (required)
     * @param  int|null $lang If no parameter is set here, all languages for the property are loaded by default. Optionally, enter an arry containing the ISO codes of the desired languages. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersPropertiesTypesTypeIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\OrderPropertyType, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersPropertiesTypesTypeIdGetWithHttpInfo(
        int $type_id,
        ?int $lang = null,
        string $contentType = self::contentTypes['restOrdersPropertiesTypesTypeIdGet'][0]
    ): array
    {
        $request = $this->restOrdersPropertiesTypesTypeIdGetRequest($type_id, $lang, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\OrderPropertyType' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\OrderPropertyType' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\OrderPropertyType', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\OrderPropertyType';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\OrderPropertyType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersPropertiesTypesTypeIdGetAsync
     *
     * Get property type
     *
     * @param  int $type_id The ID of the type. (required)
     * @param  int|null $lang If no parameter is set here, all languages for the property are loaded by default. Optionally, enter an arry containing the ISO codes of the desired languages. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersPropertiesTypesTypeIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersPropertiesTypesTypeIdGetAsync(
        int $type_id,
        ?int $lang = null,
        string $contentType = self::contentTypes['restOrdersPropertiesTypesTypeIdGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersPropertiesTypesTypeIdGetAsyncWithHttpInfo($type_id, $lang, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersPropertiesTypesTypeIdGetAsyncWithHttpInfo
     *
     * Get property type
     *
     * @param  int $type_id The ID of the type. (required)
     * @param  int|null $lang If no parameter is set here, all languages for the property are loaded by default. Optionally, enter an arry containing the ISO codes of the desired languages. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersPropertiesTypesTypeIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersPropertiesTypesTypeIdGetAsyncWithHttpInfo(
        $type_id,
        $lang = null,
        string $contentType = self::contentTypes['restOrdersPropertiesTypesTypeIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\OrderPropertyType';
        $request = $this->restOrdersPropertiesTypesTypeIdGetRequest($type_id, $lang, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersPropertiesTypesTypeIdGet'
     *
     * @param  int $type_id The ID of the type. (required)
     * @param  int|null $lang If no parameter is set here, all languages for the property are loaded by default. Optionally, enter an arry containing the ISO codes of the desired languages. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersPropertiesTypesTypeIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersPropertiesTypesTypeIdGetRequest(
        $type_id,
        $lang = null,
        string $contentType = self::contentTypes['restOrdersPropertiesTypesTypeIdGet'][0]
    ): Request
    {

        // verify the required parameter 'type_id' is set
        if ($type_id === null || (is_array($type_id) && count($type_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $type_id when calling restOrdersPropertiesTypesTypeIdGet'
            );
        }



        $resourcePath = '/rest/orders/properties/types/{typeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $lang,
            'lang', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'typeId' . '}',
                ObjectSerializer::toPathValue($type_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersPropertiesTypesTypeIdPut
     *
     * Update property type
     *
     * @param  int $type_id type_id (required)
     * @param  \ck\Model\RestOrdersPropertiesTypesTypeIdPutRequest|null $_rest_orders_properties_types_type_id _rest_orders_properties_types_type_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersPropertiesTypesTypeIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\OrderPropertyType
     */
    public function restOrdersPropertiesTypesTypeIdPut(
        int $type_id,
        ?\ck\Model\RestOrdersPropertiesTypesTypeIdPutRequest $_rest_orders_properties_types_type_id = null,
        string $contentType = self::contentTypes['restOrdersPropertiesTypesTypeIdPut'][0]
    ): \ck\Model\OrderPropertyType
    {
        list($response) = $this->restOrdersPropertiesTypesTypeIdPutWithHttpInfo($type_id, $_rest_orders_properties_types_type_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersPropertiesTypesTypeIdPutWithHttpInfo
     *
     * Update property type
     *
     * @param  int $type_id (required)
     * @param  \ck\Model\RestOrdersPropertiesTypesTypeIdPutRequest|null $_rest_orders_properties_types_type_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersPropertiesTypesTypeIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\OrderPropertyType, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersPropertiesTypesTypeIdPutWithHttpInfo(
        int $type_id,
        ?\ck\Model\RestOrdersPropertiesTypesTypeIdPutRequest $_rest_orders_properties_types_type_id = null,
        string $contentType = self::contentTypes['restOrdersPropertiesTypesTypeIdPut'][0]
    ): array
    {
        $request = $this->restOrdersPropertiesTypesTypeIdPutRequest($type_id, $_rest_orders_properties_types_type_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\OrderPropertyType' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\OrderPropertyType' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\OrderPropertyType', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\OrderPropertyType';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\OrderPropertyType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersPropertiesTypesTypeIdPutAsync
     *
     * Update property type
     *
     * @param  int $type_id (required)
     * @param  \ck\Model\RestOrdersPropertiesTypesTypeIdPutRequest|null $_rest_orders_properties_types_type_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersPropertiesTypesTypeIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersPropertiesTypesTypeIdPutAsync(
        int $type_id,
        ?\ck\Model\RestOrdersPropertiesTypesTypeIdPutRequest $_rest_orders_properties_types_type_id = null,
        string $contentType = self::contentTypes['restOrdersPropertiesTypesTypeIdPut'][0]
    ): PromiseInterface
    {
        return $this->restOrdersPropertiesTypesTypeIdPutAsyncWithHttpInfo($type_id, $_rest_orders_properties_types_type_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersPropertiesTypesTypeIdPutAsyncWithHttpInfo
     *
     * Update property type
     *
     * @param  int $type_id (required)
     * @param  \ck\Model\RestOrdersPropertiesTypesTypeIdPutRequest|null $_rest_orders_properties_types_type_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersPropertiesTypesTypeIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersPropertiesTypesTypeIdPutAsyncWithHttpInfo(
        $type_id,
        $_rest_orders_properties_types_type_id = null,
        string $contentType = self::contentTypes['restOrdersPropertiesTypesTypeIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\OrderPropertyType';
        $request = $this->restOrdersPropertiesTypesTypeIdPutRequest($type_id, $_rest_orders_properties_types_type_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersPropertiesTypesTypeIdPut'
     *
     * @param  int $type_id (required)
     * @param  \ck\Model\RestOrdersPropertiesTypesTypeIdPutRequest|null $_rest_orders_properties_types_type_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersPropertiesTypesTypeIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersPropertiesTypesTypeIdPutRequest(
        $type_id,
        $_rest_orders_properties_types_type_id = null,
        string $contentType = self::contentTypes['restOrdersPropertiesTypesTypeIdPut'][0]
    ): Request
    {

        // verify the required parameter 'type_id' is set
        if ($type_id === null || (is_array($type_id) && count($type_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $type_id when calling restOrdersPropertiesTypesTypeIdPut'
            );
        }



        $resourcePath = '/rest/orders/properties/types/{typeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'typeId' . '}',
                ObjectSerializer::toPathValue($type_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_orders_properties_types_type_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_orders_properties_types_type_id));
            } else {
                $httpBody = $_rest_orders_properties_types_type_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersReferrersGet
     *
     * List referrers
     *
     * @param  int|null $columns The desired columns/attributes of the order referrer to be loaded. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersReferrersGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\OrderReferrer[]
     */
    public function restOrdersReferrersGet(
        ?int $columns = null,
        string $contentType = self::contentTypes['restOrdersReferrersGet'][0]
    ): array
    {
        list($response) = $this->restOrdersReferrersGetWithHttpInfo($columns, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersReferrersGetWithHttpInfo
     *
     * List referrers
     *
     * @param  int|null $columns The desired columns/attributes of the order referrer to be loaded. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersReferrersGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\OrderReferrer[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersReferrersGetWithHttpInfo(
        ?int $columns = null,
        string $contentType = self::contentTypes['restOrdersReferrersGet'][0]
    ): array
    {
        $request = $this->restOrdersReferrersGetRequest($columns, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\OrderReferrer[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\OrderReferrer[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\OrderReferrer[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\OrderReferrer[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\OrderReferrer[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersReferrersGetAsync
     *
     * List referrers
     *
     * @param  int|null $columns The desired columns/attributes of the order referrer to be loaded. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersReferrersGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersReferrersGetAsync(
        ?int $columns = null,
        string $contentType = self::contentTypes['restOrdersReferrersGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersReferrersGetAsyncWithHttpInfo($columns, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersReferrersGetAsyncWithHttpInfo
     *
     * List referrers
     *
     * @param  int|null $columns The desired columns/attributes of the order referrer to be loaded. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersReferrersGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersReferrersGetAsyncWithHttpInfo(
        $columns = null,
        string $contentType = self::contentTypes['restOrdersReferrersGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\OrderReferrer[]';
        $request = $this->restOrdersReferrersGetRequest($columns, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersReferrersGet'
     *
     * @param  int|null $columns The desired columns/attributes of the order referrer to be loaded. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersReferrersGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersReferrersGetRequest(
        $columns = null,
        string $contentType = self::contentTypes['restOrdersReferrersGet'][0]
    ): Request
    {



        $resourcePath = '/rest/orders/referrers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $columns,
            'columns', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersShippingCountriesGet
     *
     * List shipping countries
     *
     * @param  int|null $active Returns only the active shipping countries. (optional)
     * @param  int|null $with The relations to be loaded. Possible values are &#39;states&#39; and &#39;names&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingCountriesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restOrdersShippingCountriesGet(
        ?int $active = null,
        ?int $with = null,
        string $contentType = self::contentTypes['restOrdersShippingCountriesGet'][0]
    ): object
    {
        list($response) = $this->restOrdersShippingCountriesGetWithHttpInfo($active, $with, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersShippingCountriesGetWithHttpInfo
     *
     * List shipping countries
     *
     * @param  int|null $active Returns only the active shipping countries. (optional)
     * @param  int|null $with The relations to be loaded. Possible values are &#39;states&#39; and &#39;names&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingCountriesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersShippingCountriesGetWithHttpInfo(
        ?int $active = null,
        ?int $with = null,
        string $contentType = self::contentTypes['restOrdersShippingCountriesGet'][0]
    ): array
    {
        $request = $this->restOrdersShippingCountriesGetRequest($active, $with, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersShippingCountriesGetAsync
     *
     * List shipping countries
     *
     * @param  int|null $active Returns only the active shipping countries. (optional)
     * @param  int|null $with The relations to be loaded. Possible values are &#39;states&#39; and &#39;names&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingCountriesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersShippingCountriesGetAsync(
        ?int $active = null,
        ?int $with = null,
        string $contentType = self::contentTypes['restOrdersShippingCountriesGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersShippingCountriesGetAsyncWithHttpInfo($active, $with, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersShippingCountriesGetAsyncWithHttpInfo
     *
     * List shipping countries
     *
     * @param  int|null $active Returns only the active shipping countries. (optional)
     * @param  int|null $with The relations to be loaded. Possible values are &#39;states&#39; and &#39;names&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingCountriesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersShippingCountriesGetAsyncWithHttpInfo(
        $active = null,
        $with = null,
        string $contentType = self::contentTypes['restOrdersShippingCountriesGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restOrdersShippingCountriesGetRequest($active, $with, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersShippingCountriesGet'
     *
     * @param  int|null $active Returns only the active shipping countries. (optional)
     * @param  int|null $with The relations to be loaded. Possible values are &#39;states&#39; and &#39;names&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingCountriesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersShippingCountriesGetRequest(
        $active = null,
        $with = null,
        string $contentType = self::contentTypes['restOrdersShippingCountriesGet'][0]
    ): Request
    {




        $resourcePath = '/rest/orders/shipping/countries';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $active,
            'active', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersShippingPackageTypesGet
     *
     * List shipping package types
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPackageTypesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ShippingPackageType[]
     */
    public function restOrdersShippingPackageTypesGet(
        string $contentType = self::contentTypes['restOrdersShippingPackageTypesGet'][0]
    ): array
    {
        list($response) = $this->restOrdersShippingPackageTypesGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restOrdersShippingPackageTypesGetWithHttpInfo
     *
     * List shipping package types
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPackageTypesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ShippingPackageType[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersShippingPackageTypesGetWithHttpInfo(
        string $contentType = self::contentTypes['restOrdersShippingPackageTypesGet'][0]
    ): array
    {
        $request = $this->restOrdersShippingPackageTypesGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ShippingPackageType[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ShippingPackageType[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ShippingPackageType[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ShippingPackageType[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ShippingPackageType[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersShippingPackageTypesGetAsync
     *
     * List shipping package types
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPackageTypesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersShippingPackageTypesGetAsync(
        string $contentType = self::contentTypes['restOrdersShippingPackageTypesGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersShippingPackageTypesGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersShippingPackageTypesGetAsyncWithHttpInfo
     *
     * List shipping package types
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPackageTypesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersShippingPackageTypesGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restOrdersShippingPackageTypesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ShippingPackageType[]';
        $request = $this->restOrdersShippingPackageTypesGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersShippingPackageTypesGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPackageTypesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersShippingPackageTypesGetRequest(
        string $contentType = self::contentTypes['restOrdersShippingPackageTypesGet'][0]
    ): Request
    {


        $resourcePath = '/rest/orders/shipping/package_types';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersShippingPackageTypesShippingPackageTypeIdGet
     *
     * Get a shipping package type
     *
     * @param  int $shipping_package_type_id The ID of the shipping package type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPackageTypesShippingPackageTypeIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ShippingPackageType
     */
    public function restOrdersShippingPackageTypesShippingPackageTypeIdGet(
        int $shipping_package_type_id,
        string $contentType = self::contentTypes['restOrdersShippingPackageTypesShippingPackageTypeIdGet'][0]
    ): \ck\Model\ShippingPackageType
    {
        list($response) = $this->restOrdersShippingPackageTypesShippingPackageTypeIdGetWithHttpInfo($shipping_package_type_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersShippingPackageTypesShippingPackageTypeIdGetWithHttpInfo
     *
     * Get a shipping package type
     *
     * @param  int $shipping_package_type_id The ID of the shipping package type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPackageTypesShippingPackageTypeIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ShippingPackageType, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersShippingPackageTypesShippingPackageTypeIdGetWithHttpInfo(
        int $shipping_package_type_id,
        string $contentType = self::contentTypes['restOrdersShippingPackageTypesShippingPackageTypeIdGet'][0]
    ): array
    {
        $request = $this->restOrdersShippingPackageTypesShippingPackageTypeIdGetRequest($shipping_package_type_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ShippingPackageType' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ShippingPackageType' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ShippingPackageType', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ShippingPackageType';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ShippingPackageType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersShippingPackageTypesShippingPackageTypeIdGetAsync
     *
     * Get a shipping package type
     *
     * @param  int $shipping_package_type_id The ID of the shipping package type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPackageTypesShippingPackageTypeIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersShippingPackageTypesShippingPackageTypeIdGetAsync(
        int $shipping_package_type_id,
        string $contentType = self::contentTypes['restOrdersShippingPackageTypesShippingPackageTypeIdGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersShippingPackageTypesShippingPackageTypeIdGetAsyncWithHttpInfo($shipping_package_type_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersShippingPackageTypesShippingPackageTypeIdGetAsyncWithHttpInfo
     *
     * Get a shipping package type
     *
     * @param  int $shipping_package_type_id The ID of the shipping package type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPackageTypesShippingPackageTypeIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersShippingPackageTypesShippingPackageTypeIdGetAsyncWithHttpInfo(
        $shipping_package_type_id,
        string $contentType = self::contentTypes['restOrdersShippingPackageTypesShippingPackageTypeIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ShippingPackageType';
        $request = $this->restOrdersShippingPackageTypesShippingPackageTypeIdGetRequest($shipping_package_type_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersShippingPackageTypesShippingPackageTypeIdGet'
     *
     * @param  int $shipping_package_type_id The ID of the shipping package type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPackageTypesShippingPackageTypeIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersShippingPackageTypesShippingPackageTypeIdGetRequest(
        $shipping_package_type_id,
        string $contentType = self::contentTypes['restOrdersShippingPackageTypesShippingPackageTypeIdGet'][0]
    ): Request
    {

        // verify the required parameter 'shipping_package_type_id' is set
        if ($shipping_package_type_id === null || (is_array($shipping_package_type_id) && count($shipping_package_type_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $shipping_package_type_id when calling restOrdersShippingPackageTypesShippingPackageTypeIdGet'
            );
        }


        $resourcePath = '/rest/orders/shipping/package_types/{shippingPackageTypeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($shipping_package_type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'shippingPackageTypeId' . '}',
                ObjectSerializer::toPathValue($shipping_package_type_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersShippingPackagesItemsIdDelete
     *
     * Delete package, variation or quantity for an order
     *
     * @param  int $id The ID of the order package item variation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPackagesItemsIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restOrdersShippingPackagesItemsIdDelete(
        int $id,
        string $contentType = self::contentTypes['restOrdersShippingPackagesItemsIdDelete'][0]
    ): object
    {
        list($response) = $this->restOrdersShippingPackagesItemsIdDeleteWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersShippingPackagesItemsIdDeleteWithHttpInfo
     *
     * Delete package, variation or quantity for an order
     *
     * @param  int $id The ID of the order package item variation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPackagesItemsIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersShippingPackagesItemsIdDeleteWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restOrdersShippingPackagesItemsIdDelete'][0]
    ): array
    {
        $request = $this->restOrdersShippingPackagesItemsIdDeleteRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersShippingPackagesItemsIdDeleteAsync
     *
     * Delete package, variation or quantity for an order
     *
     * @param  int $id The ID of the order package item variation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPackagesItemsIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersShippingPackagesItemsIdDeleteAsync(
        int $id,
        string $contentType = self::contentTypes['restOrdersShippingPackagesItemsIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restOrdersShippingPackagesItemsIdDeleteAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersShippingPackagesItemsIdDeleteAsyncWithHttpInfo
     *
     * Delete package, variation or quantity for an order
     *
     * @param  int $id The ID of the order package item variation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPackagesItemsIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersShippingPackagesItemsIdDeleteAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restOrdersShippingPackagesItemsIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restOrdersShippingPackagesItemsIdDeleteRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersShippingPackagesItemsIdDelete'
     *
     * @param  int $id The ID of the order package item variation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPackagesItemsIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersShippingPackagesItemsIdDeleteRequest(
        $id,
        string $contentType = self::contentTypes['restOrdersShippingPackagesItemsIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restOrdersShippingPackagesItemsIdDelete'
            );
        }


        $resourcePath = '/rest/orders/shipping/packages/items/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersShippingPackagesItemsIdPut
     *
     * Update package, variation or quantity for an order
     *
     * @param  int $id The ID of the order package item variation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPackagesItemsIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restOrdersShippingPackagesItemsIdPut(
        int $id,
        string $contentType = self::contentTypes['restOrdersShippingPackagesItemsIdPut'][0]
    ): object
    {
        list($response) = $this->restOrdersShippingPackagesItemsIdPutWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersShippingPackagesItemsIdPutWithHttpInfo
     *
     * Update package, variation or quantity for an order
     *
     * @param  int $id The ID of the order package item variation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPackagesItemsIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersShippingPackagesItemsIdPutWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restOrdersShippingPackagesItemsIdPut'][0]
    ): array
    {
        $request = $this->restOrdersShippingPackagesItemsIdPutRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersShippingPackagesItemsIdPutAsync
     *
     * Update package, variation or quantity for an order
     *
     * @param  int $id The ID of the order package item variation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPackagesItemsIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersShippingPackagesItemsIdPutAsync(
        int $id,
        string $contentType = self::contentTypes['restOrdersShippingPackagesItemsIdPut'][0]
    ): PromiseInterface
    {
        return $this->restOrdersShippingPackagesItemsIdPutAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersShippingPackagesItemsIdPutAsyncWithHttpInfo
     *
     * Update package, variation or quantity for an order
     *
     * @param  int $id The ID of the order package item variation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPackagesItemsIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersShippingPackagesItemsIdPutAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restOrdersShippingPackagesItemsIdPut'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restOrdersShippingPackagesItemsIdPutRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersShippingPackagesItemsIdPut'
     *
     * @param  int $id The ID of the order package item variation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPackagesItemsIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersShippingPackagesItemsIdPutRequest(
        $id,
        string $contentType = self::contentTypes['restOrdersShippingPackagesItemsIdPut'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restOrdersShippingPackagesItemsIdPut'
            );
        }


        $resourcePath = '/rest/orders/shipping/packages/items/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersShippingPackagesItemsPackageIdItemIdVariationIdDelete
     *
     * Delete items of an order package
     *
     * @param  int $package_id The ID of the package (required)
     * @param  int $item_id The ID of the item (required)
     * @param  int $variation_id The ID of the variation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPackagesItemsPackageIdItemIdVariationIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restOrdersShippingPackagesItemsPackageIdItemIdVariationIdDelete(
        int $package_id,
        int $item_id,
        int $variation_id,
        string $contentType = self::contentTypes['restOrdersShippingPackagesItemsPackageIdItemIdVariationIdDelete'][0]
    ): object
    {
        list($response) = $this->restOrdersShippingPackagesItemsPackageIdItemIdVariationIdDeleteWithHttpInfo($package_id, $item_id, $variation_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersShippingPackagesItemsPackageIdItemIdVariationIdDeleteWithHttpInfo
     *
     * Delete items of an order package
     *
     * @param  int $package_id The ID of the package (required)
     * @param  int $item_id The ID of the item (required)
     * @param  int $variation_id The ID of the variation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPackagesItemsPackageIdItemIdVariationIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersShippingPackagesItemsPackageIdItemIdVariationIdDeleteWithHttpInfo(
        int $package_id,
        int $item_id,
        int $variation_id,
        string $contentType = self::contentTypes['restOrdersShippingPackagesItemsPackageIdItemIdVariationIdDelete'][0]
    ): array
    {
        $request = $this->restOrdersShippingPackagesItemsPackageIdItemIdVariationIdDeleteRequest($package_id, $item_id, $variation_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersShippingPackagesItemsPackageIdItemIdVariationIdDeleteAsync
     *
     * Delete items of an order package
     *
     * @param  int $package_id The ID of the package (required)
     * @param  int $item_id The ID of the item (required)
     * @param  int $variation_id The ID of the variation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPackagesItemsPackageIdItemIdVariationIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersShippingPackagesItemsPackageIdItemIdVariationIdDeleteAsync(
        int $package_id,
        int $item_id,
        int $variation_id,
        string $contentType = self::contentTypes['restOrdersShippingPackagesItemsPackageIdItemIdVariationIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restOrdersShippingPackagesItemsPackageIdItemIdVariationIdDeleteAsyncWithHttpInfo($package_id, $item_id, $variation_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersShippingPackagesItemsPackageIdItemIdVariationIdDeleteAsyncWithHttpInfo
     *
     * Delete items of an order package
     *
     * @param  int $package_id The ID of the package (required)
     * @param  int $item_id The ID of the item (required)
     * @param  int $variation_id The ID of the variation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPackagesItemsPackageIdItemIdVariationIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersShippingPackagesItemsPackageIdItemIdVariationIdDeleteAsyncWithHttpInfo(
        $package_id,
        $item_id,
        $variation_id,
        string $contentType = self::contentTypes['restOrdersShippingPackagesItemsPackageIdItemIdVariationIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restOrdersShippingPackagesItemsPackageIdItemIdVariationIdDeleteRequest($package_id, $item_id, $variation_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersShippingPackagesItemsPackageIdItemIdVariationIdDelete'
     *
     * @param  int $package_id The ID of the package (required)
     * @param  int $item_id The ID of the item (required)
     * @param  int $variation_id The ID of the variation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPackagesItemsPackageIdItemIdVariationIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersShippingPackagesItemsPackageIdItemIdVariationIdDeleteRequest(
        $package_id,
        $item_id,
        $variation_id,
        string $contentType = self::contentTypes['restOrdersShippingPackagesItemsPackageIdItemIdVariationIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'package_id' is set
        if ($package_id === null || (is_array($package_id) && count($package_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $package_id when calling restOrdersShippingPackagesItemsPackageIdItemIdVariationIdDelete'
            );
        }

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $item_id when calling restOrdersShippingPackagesItemsPackageIdItemIdVariationIdDelete'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restOrdersShippingPackagesItemsPackageIdItemIdVariationIdDelete'
            );
        }


        $resourcePath = '/rest/orders/shipping/packages/items/{packageId}/{itemId}/{variationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($package_id !== null) {
            $resourcePath = str_replace(
                '{' . 'packageId' . '}',
                ObjectSerializer::toPathValue($package_id),
                $resourcePath
            );
        }
        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersShippingPackagesItemsPackageIdItemIdVariationIdPut
     *
     * Update items of an order package
     *
     * @param  int $package_id The ID of the package (required)
     * @param  int $item_id The ID of the item (required)
     * @param  int $variation_id The ID of the variation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPackagesItemsPackageIdItemIdVariationIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restOrdersShippingPackagesItemsPackageIdItemIdVariationIdPut(
        int $package_id,
        int $item_id,
        int $variation_id,
        string $contentType = self::contentTypes['restOrdersShippingPackagesItemsPackageIdItemIdVariationIdPut'][0]
    ): object
    {
        list($response) = $this->restOrdersShippingPackagesItemsPackageIdItemIdVariationIdPutWithHttpInfo($package_id, $item_id, $variation_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersShippingPackagesItemsPackageIdItemIdVariationIdPutWithHttpInfo
     *
     * Update items of an order package
     *
     * @param  int $package_id The ID of the package (required)
     * @param  int $item_id The ID of the item (required)
     * @param  int $variation_id The ID of the variation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPackagesItemsPackageIdItemIdVariationIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersShippingPackagesItemsPackageIdItemIdVariationIdPutWithHttpInfo(
        int $package_id,
        int $item_id,
        int $variation_id,
        string $contentType = self::contentTypes['restOrdersShippingPackagesItemsPackageIdItemIdVariationIdPut'][0]
    ): array
    {
        $request = $this->restOrdersShippingPackagesItemsPackageIdItemIdVariationIdPutRequest($package_id, $item_id, $variation_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersShippingPackagesItemsPackageIdItemIdVariationIdPutAsync
     *
     * Update items of an order package
     *
     * @param  int $package_id The ID of the package (required)
     * @param  int $item_id The ID of the item (required)
     * @param  int $variation_id The ID of the variation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPackagesItemsPackageIdItemIdVariationIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersShippingPackagesItemsPackageIdItemIdVariationIdPutAsync(
        int $package_id,
        int $item_id,
        int $variation_id,
        string $contentType = self::contentTypes['restOrdersShippingPackagesItemsPackageIdItemIdVariationIdPut'][0]
    ): PromiseInterface
    {
        return $this->restOrdersShippingPackagesItemsPackageIdItemIdVariationIdPutAsyncWithHttpInfo($package_id, $item_id, $variation_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersShippingPackagesItemsPackageIdItemIdVariationIdPutAsyncWithHttpInfo
     *
     * Update items of an order package
     *
     * @param  int $package_id The ID of the package (required)
     * @param  int $item_id The ID of the item (required)
     * @param  int $variation_id The ID of the variation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPackagesItemsPackageIdItemIdVariationIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersShippingPackagesItemsPackageIdItemIdVariationIdPutAsyncWithHttpInfo(
        $package_id,
        $item_id,
        $variation_id,
        string $contentType = self::contentTypes['restOrdersShippingPackagesItemsPackageIdItemIdVariationIdPut'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restOrdersShippingPackagesItemsPackageIdItemIdVariationIdPutRequest($package_id, $item_id, $variation_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersShippingPackagesItemsPackageIdItemIdVariationIdPut'
     *
     * @param  int $package_id The ID of the package (required)
     * @param  int $item_id The ID of the item (required)
     * @param  int $variation_id The ID of the variation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPackagesItemsPackageIdItemIdVariationIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersShippingPackagesItemsPackageIdItemIdVariationIdPutRequest(
        $package_id,
        $item_id,
        $variation_id,
        string $contentType = self::contentTypes['restOrdersShippingPackagesItemsPackageIdItemIdVariationIdPut'][0]
    ): Request
    {

        // verify the required parameter 'package_id' is set
        if ($package_id === null || (is_array($package_id) && count($package_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $package_id when calling restOrdersShippingPackagesItemsPackageIdItemIdVariationIdPut'
            );
        }

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $item_id when calling restOrdersShippingPackagesItemsPackageIdItemIdVariationIdPut'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restOrdersShippingPackagesItemsPackageIdItemIdVariationIdPut'
            );
        }


        $resourcePath = '/rest/orders/shipping/packages/items/{packageId}/{itemId}/{variationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($package_id !== null) {
            $resourcePath = str_replace(
                '{' . 'packageId' . '}',
                ObjectSerializer::toPathValue($package_id),
                $resourcePath
            );
        }
        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersShippingPackagesPackageIdItemsGet
     *
     * List items of an order package
     *
     * @param  int $package_id The ID of the order package (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPackagesPackageIdItemsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\OrderShippingPackageItems
     */
    public function restOrdersShippingPackagesPackageIdItemsGet(
        int $package_id,
        string $contentType = self::contentTypes['restOrdersShippingPackagesPackageIdItemsGet'][0]
    ): \ck\Model\OrderShippingPackageItems
    {
        list($response) = $this->restOrdersShippingPackagesPackageIdItemsGetWithHttpInfo($package_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersShippingPackagesPackageIdItemsGetWithHttpInfo
     *
     * List items of an order package
     *
     * @param  int $package_id The ID of the order package (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPackagesPackageIdItemsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\OrderShippingPackageItems, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersShippingPackagesPackageIdItemsGetWithHttpInfo(
        int $package_id,
        string $contentType = self::contentTypes['restOrdersShippingPackagesPackageIdItemsGet'][0]
    ): array
    {
        $request = $this->restOrdersShippingPackagesPackageIdItemsGetRequest($package_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\OrderShippingPackageItems' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\OrderShippingPackageItems' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\OrderShippingPackageItems', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\OrderShippingPackageItems';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\OrderShippingPackageItems',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersShippingPackagesPackageIdItemsGetAsync
     *
     * List items of an order package
     *
     * @param  int $package_id The ID of the order package (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPackagesPackageIdItemsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersShippingPackagesPackageIdItemsGetAsync(
        int $package_id,
        string $contentType = self::contentTypes['restOrdersShippingPackagesPackageIdItemsGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersShippingPackagesPackageIdItemsGetAsyncWithHttpInfo($package_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersShippingPackagesPackageIdItemsGetAsyncWithHttpInfo
     *
     * List items of an order package
     *
     * @param  int $package_id The ID of the order package (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPackagesPackageIdItemsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersShippingPackagesPackageIdItemsGetAsyncWithHttpInfo(
        $package_id,
        string $contentType = self::contentTypes['restOrdersShippingPackagesPackageIdItemsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\OrderShippingPackageItems';
        $request = $this->restOrdersShippingPackagesPackageIdItemsGetRequest($package_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersShippingPackagesPackageIdItemsGet'
     *
     * @param  int $package_id The ID of the order package (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPackagesPackageIdItemsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersShippingPackagesPackageIdItemsGetRequest(
        $package_id,
        string $contentType = self::contentTypes['restOrdersShippingPackagesPackageIdItemsGet'][0]
    ): Request
    {

        // verify the required parameter 'package_id' is set
        if ($package_id === null || (is_array($package_id) && count($package_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $package_id when calling restOrdersShippingPackagesPackageIdItemsGet'
            );
        }


        $resourcePath = '/rest/orders/shipping/packages/{packageId}/items';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($package_id !== null) {
            $resourcePath = str_replace(
                '{' . 'packageId' . '}',
                ObjectSerializer::toPathValue($package_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersShippingPackagesPackageIdItemsPost
     *
     * Create package, variation or quantity for an order
     *
     * @param  int $package_id The ID of the order package (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPackagesPackageIdItemsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object[]
     */
    public function restOrdersShippingPackagesPackageIdItemsPost(
        int $package_id,
        string $contentType = self::contentTypes['restOrdersShippingPackagesPackageIdItemsPost'][0]
    ): array
    {
        list($response) = $this->restOrdersShippingPackagesPackageIdItemsPostWithHttpInfo($package_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersShippingPackagesPackageIdItemsPostWithHttpInfo
     *
     * Create package, variation or quantity for an order
     *
     * @param  int $package_id The ID of the order package (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPackagesPackageIdItemsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersShippingPackagesPackageIdItemsPostWithHttpInfo(
        int $package_id,
        string $contentType = self::contentTypes['restOrdersShippingPackagesPackageIdItemsPost'][0]
    ): array
    {
        $request = $this->restOrdersShippingPackagesPackageIdItemsPostRequest($package_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersShippingPackagesPackageIdItemsPostAsync
     *
     * Create package, variation or quantity for an order
     *
     * @param  int $package_id The ID of the order package (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPackagesPackageIdItemsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersShippingPackagesPackageIdItemsPostAsync(
        int $package_id,
        string $contentType = self::contentTypes['restOrdersShippingPackagesPackageIdItemsPost'][0]
    ): PromiseInterface
    {
        return $this->restOrdersShippingPackagesPackageIdItemsPostAsyncWithHttpInfo($package_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersShippingPackagesPackageIdItemsPostAsyncWithHttpInfo
     *
     * Create package, variation or quantity for an order
     *
     * @param  int $package_id The ID of the order package (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPackagesPackageIdItemsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersShippingPackagesPackageIdItemsPostAsyncWithHttpInfo(
        $package_id,
        string $contentType = self::contentTypes['restOrdersShippingPackagesPackageIdItemsPost'][0]
    ): PromiseInterface
    {
        $returnType = 'object[]';
        $request = $this->restOrdersShippingPackagesPackageIdItemsPostRequest($package_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersShippingPackagesPackageIdItemsPost'
     *
     * @param  int $package_id The ID of the order package (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPackagesPackageIdItemsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersShippingPackagesPackageIdItemsPostRequest(
        $package_id,
        string $contentType = self::contentTypes['restOrdersShippingPackagesPackageIdItemsPost'][0]
    ): Request
    {

        // verify the required parameter 'package_id' is set
        if ($package_id === null || (is_array($package_id) && count($package_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $package_id when calling restOrdersShippingPackagesPackageIdItemsPost'
            );
        }


        $resourcePath = '/rest/orders/shipping/packages/{packageId}/items';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($package_id !== null) {
            $resourcePath = str_replace(
                '{' . 'packageId' . '}',
                ObjectSerializer::toPathValue($package_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersShippingPalletsGet
     *
     * List order shipping pallets
     *
     * @param  string $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPalletsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\OrderShippingPallet[]
     */
    public function restOrdersShippingPalletsGet(
        string $order_id,
        string $contentType = self::contentTypes['restOrdersShippingPalletsGet'][0]
    ): array
    {
        list($response) = $this->restOrdersShippingPalletsGetWithHttpInfo($order_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersShippingPalletsGetWithHttpInfo
     *
     * List order shipping pallets
     *
     * @param  string $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPalletsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\OrderShippingPallet[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersShippingPalletsGetWithHttpInfo(
        string $order_id,
        string $contentType = self::contentTypes['restOrdersShippingPalletsGet'][0]
    ): array
    {
        $request = $this->restOrdersShippingPalletsGetRequest($order_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\OrderShippingPallet[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\OrderShippingPallet[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\OrderShippingPallet[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\OrderShippingPallet[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\OrderShippingPallet[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersShippingPalletsGetAsync
     *
     * List order shipping pallets
     *
     * @param  string $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPalletsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersShippingPalletsGetAsync(
        string $order_id,
        string $contentType = self::contentTypes['restOrdersShippingPalletsGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersShippingPalletsGetAsyncWithHttpInfo($order_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersShippingPalletsGetAsyncWithHttpInfo
     *
     * List order shipping pallets
     *
     * @param  string $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPalletsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersShippingPalletsGetAsyncWithHttpInfo(
        $order_id,
        string $contentType = self::contentTypes['restOrdersShippingPalletsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\OrderShippingPallet[]';
        $request = $this->restOrdersShippingPalletsGetRequest($order_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersShippingPalletsGet'
     *
     * @param  string $order_id The ID of the order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPalletsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersShippingPalletsGetRequest(
        $order_id,
        string $contentType = self::contentTypes['restOrdersShippingPalletsGet'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersShippingPalletsGet'
            );
        }


        $resourcePath = '/rest/orders/shipping/pallets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order_id,
            'orderId', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersShippingPalletsPalletIdDelete
     *
     * Delete all pallets of an order
     *
     * @param  int $pallet_id The ID of the pallet (required)
     * @param  \ck\Model\RestOrdersShippingPalletsPalletIdDeleteRequest|null $_rest_orders_shipping_pallets_pallet_id _rest_orders_shipping_pallets_pallet_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPalletsPalletIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\OrderShippingPallet
     */
    public function restOrdersShippingPalletsPalletIdDelete(
        int $pallet_id,
        ?\ck\Model\RestOrdersShippingPalletsPalletIdDeleteRequest $_rest_orders_shipping_pallets_pallet_id = null,
        string $contentType = self::contentTypes['restOrdersShippingPalletsPalletIdDelete'][0]
    ): \ck\Model\OrderShippingPallet
    {
        list($response) = $this->restOrdersShippingPalletsPalletIdDeleteWithHttpInfo($pallet_id, $_rest_orders_shipping_pallets_pallet_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersShippingPalletsPalletIdDeleteWithHttpInfo
     *
     * Delete all pallets of an order
     *
     * @param  int $pallet_id The ID of the pallet (required)
     * @param  \ck\Model\RestOrdersShippingPalletsPalletIdDeleteRequest|null $_rest_orders_shipping_pallets_pallet_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPalletsPalletIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\OrderShippingPallet, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersShippingPalletsPalletIdDeleteWithHttpInfo(
        int $pallet_id,
        ?\ck\Model\RestOrdersShippingPalletsPalletIdDeleteRequest $_rest_orders_shipping_pallets_pallet_id = null,
        string $contentType = self::contentTypes['restOrdersShippingPalletsPalletIdDelete'][0]
    ): array
    {
        $request = $this->restOrdersShippingPalletsPalletIdDeleteRequest($pallet_id, $_rest_orders_shipping_pallets_pallet_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\OrderShippingPallet' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\OrderShippingPallet' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\OrderShippingPallet', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\OrderShippingPallet';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\OrderShippingPallet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersShippingPalletsPalletIdDeleteAsync
     *
     * Delete all pallets of an order
     *
     * @param  int $pallet_id The ID of the pallet (required)
     * @param  \ck\Model\RestOrdersShippingPalletsPalletIdDeleteRequest|null $_rest_orders_shipping_pallets_pallet_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPalletsPalletIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersShippingPalletsPalletIdDeleteAsync(
        int $pallet_id,
        ?\ck\Model\RestOrdersShippingPalletsPalletIdDeleteRequest $_rest_orders_shipping_pallets_pallet_id = null,
        string $contentType = self::contentTypes['restOrdersShippingPalletsPalletIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restOrdersShippingPalletsPalletIdDeleteAsyncWithHttpInfo($pallet_id, $_rest_orders_shipping_pallets_pallet_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersShippingPalletsPalletIdDeleteAsyncWithHttpInfo
     *
     * Delete all pallets of an order
     *
     * @param  int $pallet_id The ID of the pallet (required)
     * @param  \ck\Model\RestOrdersShippingPalletsPalletIdDeleteRequest|null $_rest_orders_shipping_pallets_pallet_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPalletsPalletIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersShippingPalletsPalletIdDeleteAsyncWithHttpInfo(
        $pallet_id,
        $_rest_orders_shipping_pallets_pallet_id = null,
        string $contentType = self::contentTypes['restOrdersShippingPalletsPalletIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\OrderShippingPallet';
        $request = $this->restOrdersShippingPalletsPalletIdDeleteRequest($pallet_id, $_rest_orders_shipping_pallets_pallet_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersShippingPalletsPalletIdDelete'
     *
     * @param  int $pallet_id The ID of the pallet (required)
     * @param  \ck\Model\RestOrdersShippingPalletsPalletIdDeleteRequest|null $_rest_orders_shipping_pallets_pallet_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPalletsPalletIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersShippingPalletsPalletIdDeleteRequest(
        $pallet_id,
        $_rest_orders_shipping_pallets_pallet_id = null,
        string $contentType = self::contentTypes['restOrdersShippingPalletsPalletIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'pallet_id' is set
        if ($pallet_id === null || (is_array($pallet_id) && count($pallet_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $pallet_id when calling restOrdersShippingPalletsPalletIdDelete'
            );
        }



        $resourcePath = '/rest/orders/shipping/pallets/{palletId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($pallet_id !== null) {
            $resourcePath = str_replace(
                '{' . 'palletId' . '}',
                ObjectSerializer::toPathValue($pallet_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_orders_shipping_pallets_pallet_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_orders_shipping_pallets_pallet_id));
            } else {
                $httpBody = $_rest_orders_shipping_pallets_pallet_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersShippingPalletsPalletIdGet
     *
     * List all pallets of an order
     *
     * @param  int $pallet_id The ID of the pallet (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPalletsPalletIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\OrderShippingPallet
     */
    public function restOrdersShippingPalletsPalletIdGet(
        int $pallet_id,
        string $contentType = self::contentTypes['restOrdersShippingPalletsPalletIdGet'][0]
    ): \ck\Model\OrderShippingPallet
    {
        list($response) = $this->restOrdersShippingPalletsPalletIdGetWithHttpInfo($pallet_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersShippingPalletsPalletIdGetWithHttpInfo
     *
     * List all pallets of an order
     *
     * @param  int $pallet_id The ID of the pallet (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPalletsPalletIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\OrderShippingPallet, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersShippingPalletsPalletIdGetWithHttpInfo(
        int $pallet_id,
        string $contentType = self::contentTypes['restOrdersShippingPalletsPalletIdGet'][0]
    ): array
    {
        $request = $this->restOrdersShippingPalletsPalletIdGetRequest($pallet_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\OrderShippingPallet' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\OrderShippingPallet' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\OrderShippingPallet', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\OrderShippingPallet';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\OrderShippingPallet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersShippingPalletsPalletIdGetAsync
     *
     * List all pallets of an order
     *
     * @param  int $pallet_id The ID of the pallet (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPalletsPalletIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersShippingPalletsPalletIdGetAsync(
        int $pallet_id,
        string $contentType = self::contentTypes['restOrdersShippingPalletsPalletIdGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersShippingPalletsPalletIdGetAsyncWithHttpInfo($pallet_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersShippingPalletsPalletIdGetAsyncWithHttpInfo
     *
     * List all pallets of an order
     *
     * @param  int $pallet_id The ID of the pallet (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPalletsPalletIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersShippingPalletsPalletIdGetAsyncWithHttpInfo(
        $pallet_id,
        string $contentType = self::contentTypes['restOrdersShippingPalletsPalletIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\OrderShippingPallet';
        $request = $this->restOrdersShippingPalletsPalletIdGetRequest($pallet_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersShippingPalletsPalletIdGet'
     *
     * @param  int $pallet_id The ID of the pallet (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPalletsPalletIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersShippingPalletsPalletIdGetRequest(
        $pallet_id,
        string $contentType = self::contentTypes['restOrdersShippingPalletsPalletIdGet'][0]
    ): Request
    {

        // verify the required parameter 'pallet_id' is set
        if ($pallet_id === null || (is_array($pallet_id) && count($pallet_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $pallet_id when calling restOrdersShippingPalletsPalletIdGet'
            );
        }


        $resourcePath = '/rest/orders/shipping/pallets/{palletId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($pallet_id !== null) {
            $resourcePath = str_replace(
                '{' . 'palletId' . '}',
                ObjectSerializer::toPathValue($pallet_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersShippingPalletsPalletIdPut
     *
     * Update all pallets of an order
     *
     * @param  int $pallet_id The ID of the pallet (required)
     * @param  \ck\Model\RestOrdersShippingPalletsPostRequest|null $_rest_orders_shipping_pallets_pallet_id _rest_orders_shipping_pallets_pallet_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPalletsPalletIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\OrderShippingPallet
     */
    public function restOrdersShippingPalletsPalletIdPut(
        int $pallet_id,
        ?\ck\Model\RestOrdersShippingPalletsPostRequest $_rest_orders_shipping_pallets_pallet_id = null,
        string $contentType = self::contentTypes['restOrdersShippingPalletsPalletIdPut'][0]
    ): \ck\Model\OrderShippingPallet
    {
        list($response) = $this->restOrdersShippingPalletsPalletIdPutWithHttpInfo($pallet_id, $_rest_orders_shipping_pallets_pallet_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersShippingPalletsPalletIdPutWithHttpInfo
     *
     * Update all pallets of an order
     *
     * @param  int $pallet_id The ID of the pallet (required)
     * @param  \ck\Model\RestOrdersShippingPalletsPostRequest|null $_rest_orders_shipping_pallets_pallet_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPalletsPalletIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\OrderShippingPallet, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersShippingPalletsPalletIdPutWithHttpInfo(
        int $pallet_id,
        ?\ck\Model\RestOrdersShippingPalletsPostRequest $_rest_orders_shipping_pallets_pallet_id = null,
        string $contentType = self::contentTypes['restOrdersShippingPalletsPalletIdPut'][0]
    ): array
    {
        $request = $this->restOrdersShippingPalletsPalletIdPutRequest($pallet_id, $_rest_orders_shipping_pallets_pallet_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\OrderShippingPallet' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\OrderShippingPallet' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\OrderShippingPallet', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\OrderShippingPallet';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\OrderShippingPallet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersShippingPalletsPalletIdPutAsync
     *
     * Update all pallets of an order
     *
     * @param  int $pallet_id The ID of the pallet (required)
     * @param  \ck\Model\RestOrdersShippingPalletsPostRequest|null $_rest_orders_shipping_pallets_pallet_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPalletsPalletIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersShippingPalletsPalletIdPutAsync(
        int $pallet_id,
        ?\ck\Model\RestOrdersShippingPalletsPostRequest $_rest_orders_shipping_pallets_pallet_id = null,
        string $contentType = self::contentTypes['restOrdersShippingPalletsPalletIdPut'][0]
    ): PromiseInterface
    {
        return $this->restOrdersShippingPalletsPalletIdPutAsyncWithHttpInfo($pallet_id, $_rest_orders_shipping_pallets_pallet_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersShippingPalletsPalletIdPutAsyncWithHttpInfo
     *
     * Update all pallets of an order
     *
     * @param  int $pallet_id The ID of the pallet (required)
     * @param  \ck\Model\RestOrdersShippingPalletsPostRequest|null $_rest_orders_shipping_pallets_pallet_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPalletsPalletIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersShippingPalletsPalletIdPutAsyncWithHttpInfo(
        $pallet_id,
        $_rest_orders_shipping_pallets_pallet_id = null,
        string $contentType = self::contentTypes['restOrdersShippingPalletsPalletIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\OrderShippingPallet';
        $request = $this->restOrdersShippingPalletsPalletIdPutRequest($pallet_id, $_rest_orders_shipping_pallets_pallet_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersShippingPalletsPalletIdPut'
     *
     * @param  int $pallet_id The ID of the pallet (required)
     * @param  \ck\Model\RestOrdersShippingPalletsPostRequest|null $_rest_orders_shipping_pallets_pallet_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPalletsPalletIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersShippingPalletsPalletIdPutRequest(
        $pallet_id,
        $_rest_orders_shipping_pallets_pallet_id = null,
        string $contentType = self::contentTypes['restOrdersShippingPalletsPalletIdPut'][0]
    ): Request
    {

        // verify the required parameter 'pallet_id' is set
        if ($pallet_id === null || (is_array($pallet_id) && count($pallet_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $pallet_id when calling restOrdersShippingPalletsPalletIdPut'
            );
        }



        $resourcePath = '/rest/orders/shipping/pallets/{palletId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($pallet_id !== null) {
            $resourcePath = str_replace(
                '{' . 'palletId' . '}',
                ObjectSerializer::toPathValue($pallet_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_orders_shipping_pallets_pallet_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_orders_shipping_pallets_pallet_id));
            } else {
                $httpBody = $_rest_orders_shipping_pallets_pallet_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersShippingPalletsPost
     *
     * Create order shipping pallets
     *
     * @param  \ck\Model\RestOrdersShippingPalletsPostRequest|null $_rest_orders_shipping_pallets _rest_orders_shipping_pallets (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPalletsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\OrderShippingPallet
     */
    public function restOrdersShippingPalletsPost(
        ?\ck\Model\RestOrdersShippingPalletsPostRequest $_rest_orders_shipping_pallets = null,
        string $contentType = self::contentTypes['restOrdersShippingPalletsPost'][0]
    ): \ck\Model\OrderShippingPallet
    {
        list($response) = $this->restOrdersShippingPalletsPostWithHttpInfo($_rest_orders_shipping_pallets, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersShippingPalletsPostWithHttpInfo
     *
     * Create order shipping pallets
     *
     * @param  \ck\Model\RestOrdersShippingPalletsPostRequest|null $_rest_orders_shipping_pallets (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPalletsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\OrderShippingPallet, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersShippingPalletsPostWithHttpInfo(
        ?\ck\Model\RestOrdersShippingPalletsPostRequest $_rest_orders_shipping_pallets = null,
        string $contentType = self::contentTypes['restOrdersShippingPalletsPost'][0]
    ): array
    {
        $request = $this->restOrdersShippingPalletsPostRequest($_rest_orders_shipping_pallets, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\OrderShippingPallet' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\OrderShippingPallet' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\OrderShippingPallet', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\OrderShippingPallet';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\OrderShippingPallet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersShippingPalletsPostAsync
     *
     * Create order shipping pallets
     *
     * @param  \ck\Model\RestOrdersShippingPalletsPostRequest|null $_rest_orders_shipping_pallets (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPalletsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersShippingPalletsPostAsync(
        ?\ck\Model\RestOrdersShippingPalletsPostRequest $_rest_orders_shipping_pallets = null,
        string $contentType = self::contentTypes['restOrdersShippingPalletsPost'][0]
    ): PromiseInterface
    {
        return $this->restOrdersShippingPalletsPostAsyncWithHttpInfo($_rest_orders_shipping_pallets, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersShippingPalletsPostAsyncWithHttpInfo
     *
     * Create order shipping pallets
     *
     * @param  \ck\Model\RestOrdersShippingPalletsPostRequest|null $_rest_orders_shipping_pallets (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPalletsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersShippingPalletsPostAsyncWithHttpInfo(
        $_rest_orders_shipping_pallets = null,
        string $contentType = self::contentTypes['restOrdersShippingPalletsPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\OrderShippingPallet';
        $request = $this->restOrdersShippingPalletsPostRequest($_rest_orders_shipping_pallets, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersShippingPalletsPost'
     *
     * @param  \ck\Model\RestOrdersShippingPalletsPostRequest|null $_rest_orders_shipping_pallets (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPalletsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersShippingPalletsPostRequest(
        $_rest_orders_shipping_pallets = null,
        string $contentType = self::contentTypes['restOrdersShippingPalletsPost'][0]
    ): Request
    {



        $resourcePath = '/rest/orders/shipping/pallets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_orders_shipping_pallets)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_orders_shipping_pallets));
            } else {
                $httpBody = $_rest_orders_shipping_pallets;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersShippingParcelServiceRegionsParcelServiceRegionIdGet
     *
     * Get an  order parcel service region
     *
     * @param  int $parcel_service_region_id The ID of the parcel service region (required)
     * @param  int|null $columns The properties to be loaded (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingParcelServiceRegionsParcelServiceRegionIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ParcelServiceRegion
     */
    public function restOrdersShippingParcelServiceRegionsParcelServiceRegionIdGet(
        int $parcel_service_region_id,
        ?int $columns = null,
        string $contentType = self::contentTypes['restOrdersShippingParcelServiceRegionsParcelServiceRegionIdGet'][0]
    ): \ck\Model\ParcelServiceRegion
    {
        list($response) = $this->restOrdersShippingParcelServiceRegionsParcelServiceRegionIdGetWithHttpInfo($parcel_service_region_id, $columns, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersShippingParcelServiceRegionsParcelServiceRegionIdGetWithHttpInfo
     *
     * Get an  order parcel service region
     *
     * @param  int $parcel_service_region_id The ID of the parcel service region (required)
     * @param  int|null $columns The properties to be loaded (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingParcelServiceRegionsParcelServiceRegionIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ParcelServiceRegion, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersShippingParcelServiceRegionsParcelServiceRegionIdGetWithHttpInfo(
        int $parcel_service_region_id,
        ?int $columns = null,
        string $contentType = self::contentTypes['restOrdersShippingParcelServiceRegionsParcelServiceRegionIdGet'][0]
    ): array
    {
        $request = $this->restOrdersShippingParcelServiceRegionsParcelServiceRegionIdGetRequest($parcel_service_region_id, $columns, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ParcelServiceRegion' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ParcelServiceRegion' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ParcelServiceRegion', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ParcelServiceRegion';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ParcelServiceRegion',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersShippingParcelServiceRegionsParcelServiceRegionIdGetAsync
     *
     * Get an  order parcel service region
     *
     * @param  int $parcel_service_region_id The ID of the parcel service region (required)
     * @param  int|null $columns The properties to be loaded (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingParcelServiceRegionsParcelServiceRegionIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersShippingParcelServiceRegionsParcelServiceRegionIdGetAsync(
        int $parcel_service_region_id,
        ?int $columns = null,
        string $contentType = self::contentTypes['restOrdersShippingParcelServiceRegionsParcelServiceRegionIdGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersShippingParcelServiceRegionsParcelServiceRegionIdGetAsyncWithHttpInfo($parcel_service_region_id, $columns, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersShippingParcelServiceRegionsParcelServiceRegionIdGetAsyncWithHttpInfo
     *
     * Get an  order parcel service region
     *
     * @param  int $parcel_service_region_id The ID of the parcel service region (required)
     * @param  int|null $columns The properties to be loaded (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingParcelServiceRegionsParcelServiceRegionIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersShippingParcelServiceRegionsParcelServiceRegionIdGetAsyncWithHttpInfo(
        $parcel_service_region_id,
        $columns = null,
        string $contentType = self::contentTypes['restOrdersShippingParcelServiceRegionsParcelServiceRegionIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ParcelServiceRegion';
        $request = $this->restOrdersShippingParcelServiceRegionsParcelServiceRegionIdGetRequest($parcel_service_region_id, $columns, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersShippingParcelServiceRegionsParcelServiceRegionIdGet'
     *
     * @param  int $parcel_service_region_id The ID of the parcel service region (required)
     * @param  int|null $columns The properties to be loaded (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingParcelServiceRegionsParcelServiceRegionIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersShippingParcelServiceRegionsParcelServiceRegionIdGetRequest(
        $parcel_service_region_id,
        $columns = null,
        string $contentType = self::contentTypes['restOrdersShippingParcelServiceRegionsParcelServiceRegionIdGet'][0]
    ): Request
    {

        // verify the required parameter 'parcel_service_region_id' is set
        if ($parcel_service_region_id === null || (is_array($parcel_service_region_id) && count($parcel_service_region_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $parcel_service_region_id when calling restOrdersShippingParcelServiceRegionsParcelServiceRegionIdGet'
            );
        }



        $resourcePath = '/rest/orders/shipping/parcel_service_regions/{parcelServiceRegionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $columns,
            'columns', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($parcel_service_region_id !== null) {
            $resourcePath = str_replace(
                '{' . 'parcelServiceRegionId' . '}',
                ObjectSerializer::toPathValue($parcel_service_region_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersShippingPresetsGet
     *
     * List shipping profiles
     *
     * @param  int|null $columns The attributes to be loaded in the shipping profile (optional)
     * @param  string|null $parcel_service_name Filter that restricts the search result to parcel service presets with a specified service name (e.g. &#39;DHL&#39; for DHL) (optional)
     * @param  string|null $shipping_service_provider Filter that restricts the search result to a shipping service provider (optional)
     * @param  string|null $with The name of an relation to the preset. The following parameter is available: parcelServiceRegion, parcelServiceRegionConstraint, parcelServicePresetNames and parcelServiceNames. (optional)
     * @param  string|null $updated_at_before Filter that restricts the search result to presets that were updated before a specific date. Possible formats: yyyy-mm-dd or yyyy-mm-dd hh:mm:ss (optional)
     * @param  string|null $updated_at_after Filter that restricts the search result to presets that were updated after a specific date. Possible formats: yyyy-mm-dd or yyyy-mm-dd hh:mm:ss (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPresetsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ParcelServicePreset[]
     */
    public function restOrdersShippingPresetsGet(
        ?int $columns = null,
        ?string $parcel_service_name = null,
        ?string $shipping_service_provider = null,
        ?string $with = null,
        ?string $updated_at_before = null,
        ?string $updated_at_after = null,
        string $contentType = self::contentTypes['restOrdersShippingPresetsGet'][0]
    ): array
    {
        list($response) = $this->restOrdersShippingPresetsGetWithHttpInfo($columns, $parcel_service_name, $shipping_service_provider, $with, $updated_at_before, $updated_at_after, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersShippingPresetsGetWithHttpInfo
     *
     * List shipping profiles
     *
     * @param  int|null $columns The attributes to be loaded in the shipping profile (optional)
     * @param  string|null $parcel_service_name Filter that restricts the search result to parcel service presets with a specified service name (e.g. &#39;DHL&#39; for DHL) (optional)
     * @param  string|null $shipping_service_provider Filter that restricts the search result to a shipping service provider (optional)
     * @param  string|null $with The name of an relation to the preset. The following parameter is available: parcelServiceRegion, parcelServiceRegionConstraint, parcelServicePresetNames and parcelServiceNames. (optional)
     * @param  string|null $updated_at_before Filter that restricts the search result to presets that were updated before a specific date. Possible formats: yyyy-mm-dd or yyyy-mm-dd hh:mm:ss (optional)
     * @param  string|null $updated_at_after Filter that restricts the search result to presets that were updated after a specific date. Possible formats: yyyy-mm-dd or yyyy-mm-dd hh:mm:ss (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPresetsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ParcelServicePreset[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersShippingPresetsGetWithHttpInfo(
        ?int $columns = null,
        ?string $parcel_service_name = null,
        ?string $shipping_service_provider = null,
        ?string $with = null,
        ?string $updated_at_before = null,
        ?string $updated_at_after = null,
        string $contentType = self::contentTypes['restOrdersShippingPresetsGet'][0]
    ): array
    {
        $request = $this->restOrdersShippingPresetsGetRequest($columns, $parcel_service_name, $shipping_service_provider, $with, $updated_at_before, $updated_at_after, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ParcelServicePreset[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ParcelServicePreset[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ParcelServicePreset[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ParcelServicePreset[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ParcelServicePreset[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersShippingPresetsGetAsync
     *
     * List shipping profiles
     *
     * @param  int|null $columns The attributes to be loaded in the shipping profile (optional)
     * @param  string|null $parcel_service_name Filter that restricts the search result to parcel service presets with a specified service name (e.g. &#39;DHL&#39; for DHL) (optional)
     * @param  string|null $shipping_service_provider Filter that restricts the search result to a shipping service provider (optional)
     * @param  string|null $with The name of an relation to the preset. The following parameter is available: parcelServiceRegion, parcelServiceRegionConstraint, parcelServicePresetNames and parcelServiceNames. (optional)
     * @param  string|null $updated_at_before Filter that restricts the search result to presets that were updated before a specific date. Possible formats: yyyy-mm-dd or yyyy-mm-dd hh:mm:ss (optional)
     * @param  string|null $updated_at_after Filter that restricts the search result to presets that were updated after a specific date. Possible formats: yyyy-mm-dd or yyyy-mm-dd hh:mm:ss (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPresetsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersShippingPresetsGetAsync(
        ?int $columns = null,
        ?string $parcel_service_name = null,
        ?string $shipping_service_provider = null,
        ?string $with = null,
        ?string $updated_at_before = null,
        ?string $updated_at_after = null,
        string $contentType = self::contentTypes['restOrdersShippingPresetsGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersShippingPresetsGetAsyncWithHttpInfo($columns, $parcel_service_name, $shipping_service_provider, $with, $updated_at_before, $updated_at_after, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersShippingPresetsGetAsyncWithHttpInfo
     *
     * List shipping profiles
     *
     * @param  int|null $columns The attributes to be loaded in the shipping profile (optional)
     * @param  string|null $parcel_service_name Filter that restricts the search result to parcel service presets with a specified service name (e.g. &#39;DHL&#39; for DHL) (optional)
     * @param  string|null $shipping_service_provider Filter that restricts the search result to a shipping service provider (optional)
     * @param  string|null $with The name of an relation to the preset. The following parameter is available: parcelServiceRegion, parcelServiceRegionConstraint, parcelServicePresetNames and parcelServiceNames. (optional)
     * @param  string|null $updated_at_before Filter that restricts the search result to presets that were updated before a specific date. Possible formats: yyyy-mm-dd or yyyy-mm-dd hh:mm:ss (optional)
     * @param  string|null $updated_at_after Filter that restricts the search result to presets that were updated after a specific date. Possible formats: yyyy-mm-dd or yyyy-mm-dd hh:mm:ss (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPresetsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersShippingPresetsGetAsyncWithHttpInfo(
        $columns = null,
        $parcel_service_name = null,
        $shipping_service_provider = null,
        $with = null,
        $updated_at_before = null,
        $updated_at_after = null,
        string $contentType = self::contentTypes['restOrdersShippingPresetsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ParcelServicePreset[]';
        $request = $this->restOrdersShippingPresetsGetRequest($columns, $parcel_service_name, $shipping_service_provider, $with, $updated_at_before, $updated_at_after, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersShippingPresetsGet'
     *
     * @param  int|null $columns The attributes to be loaded in the shipping profile (optional)
     * @param  string|null $parcel_service_name Filter that restricts the search result to parcel service presets with a specified service name (e.g. &#39;DHL&#39; for DHL) (optional)
     * @param  string|null $shipping_service_provider Filter that restricts the search result to a shipping service provider (optional)
     * @param  string|null $with The name of an relation to the preset. The following parameter is available: parcelServiceRegion, parcelServiceRegionConstraint, parcelServicePresetNames and parcelServiceNames. (optional)
     * @param  string|null $updated_at_before Filter that restricts the search result to presets that were updated before a specific date. Possible formats: yyyy-mm-dd or yyyy-mm-dd hh:mm:ss (optional)
     * @param  string|null $updated_at_after Filter that restricts the search result to presets that were updated after a specific date. Possible formats: yyyy-mm-dd or yyyy-mm-dd hh:mm:ss (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPresetsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersShippingPresetsGetRequest(
        $columns = null,
        $parcel_service_name = null,
        $shipping_service_provider = null,
        $with = null,
        $updated_at_before = null,
        $updated_at_after = null,
        string $contentType = self::contentTypes['restOrdersShippingPresetsGet'][0]
    ): Request
    {








        $resourcePath = '/rest/orders/shipping/presets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $columns,
            'columns', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $parcel_service_name,
            'parcelServiceName', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $shipping_service_provider,
            'shippingServiceProvider', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_at_before,
            'updatedAtBefore', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_at_after,
            'updatedAtAfter', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersShippingPresetsPresetIdGet
     *
     * Get a shipping profile
     *
     * @param  int $preset_id The ID of the shipping profile (required)
     * @param  int|null $columns The attributes to be loaded in the shipping profile (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPresetsPresetIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ParcelServicePreset
     */
    public function restOrdersShippingPresetsPresetIdGet(
        int $preset_id,
        ?int $columns = null,
        string $contentType = self::contentTypes['restOrdersShippingPresetsPresetIdGet'][0]
    ): \ck\Model\ParcelServicePreset
    {
        list($response) = $this->restOrdersShippingPresetsPresetIdGetWithHttpInfo($preset_id, $columns, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersShippingPresetsPresetIdGetWithHttpInfo
     *
     * Get a shipping profile
     *
     * @param  int $preset_id The ID of the shipping profile (required)
     * @param  int|null $columns The attributes to be loaded in the shipping profile (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPresetsPresetIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ParcelServicePreset, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersShippingPresetsPresetIdGetWithHttpInfo(
        int $preset_id,
        ?int $columns = null,
        string $contentType = self::contentTypes['restOrdersShippingPresetsPresetIdGet'][0]
    ): array
    {
        $request = $this->restOrdersShippingPresetsPresetIdGetRequest($preset_id, $columns, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ParcelServicePreset' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ParcelServicePreset' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ParcelServicePreset', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ParcelServicePreset';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ParcelServicePreset',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersShippingPresetsPresetIdGetAsync
     *
     * Get a shipping profile
     *
     * @param  int $preset_id The ID of the shipping profile (required)
     * @param  int|null $columns The attributes to be loaded in the shipping profile (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPresetsPresetIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersShippingPresetsPresetIdGetAsync(
        int $preset_id,
        ?int $columns = null,
        string $contentType = self::contentTypes['restOrdersShippingPresetsPresetIdGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersShippingPresetsPresetIdGetAsyncWithHttpInfo($preset_id, $columns, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersShippingPresetsPresetIdGetAsyncWithHttpInfo
     *
     * Get a shipping profile
     *
     * @param  int $preset_id The ID of the shipping profile (required)
     * @param  int|null $columns The attributes to be loaded in the shipping profile (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPresetsPresetIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersShippingPresetsPresetIdGetAsyncWithHttpInfo(
        $preset_id,
        $columns = null,
        string $contentType = self::contentTypes['restOrdersShippingPresetsPresetIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ParcelServicePreset';
        $request = $this->restOrdersShippingPresetsPresetIdGetRequest($preset_id, $columns, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersShippingPresetsPresetIdGet'
     *
     * @param  int $preset_id The ID of the shipping profile (required)
     * @param  int|null $columns The attributes to be loaded in the shipping profile (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPresetsPresetIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersShippingPresetsPresetIdGetRequest(
        $preset_id,
        $columns = null,
        string $contentType = self::contentTypes['restOrdersShippingPresetsPresetIdGet'][0]
    ): Request
    {

        // verify the required parameter 'preset_id' is set
        if ($preset_id === null || (is_array($preset_id) && count($preset_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $preset_id when calling restOrdersShippingPresetsPresetIdGet'
            );
        }



        $resourcePath = '/rest/orders/shipping/presets/{presetId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $columns,
            'columns', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($preset_id !== null) {
            $resourcePath = str_replace(
                '{' . 'presetId' . '}',
                ObjectSerializer::toPathValue($preset_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersShippingPresetsPresetIdParcelServiceRegionsGet
     *
     * List parcel service regions by parcel service preset ID
     *
     * @param  int $preset_id The ID of the preset (required)
     * @param  int|null $columns The properties to be loaded (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPresetsPresetIdParcelServiceRegionsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ParcelServiceRegion[]
     */
    public function restOrdersShippingPresetsPresetIdParcelServiceRegionsGet(
        int $preset_id,
        ?int $columns = null,
        string $contentType = self::contentTypes['restOrdersShippingPresetsPresetIdParcelServiceRegionsGet'][0]
    ): array
    {
        list($response) = $this->restOrdersShippingPresetsPresetIdParcelServiceRegionsGetWithHttpInfo($preset_id, $columns, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersShippingPresetsPresetIdParcelServiceRegionsGetWithHttpInfo
     *
     * List parcel service regions by parcel service preset ID
     *
     * @param  int $preset_id The ID of the preset (required)
     * @param  int|null $columns The properties to be loaded (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPresetsPresetIdParcelServiceRegionsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ParcelServiceRegion[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersShippingPresetsPresetIdParcelServiceRegionsGetWithHttpInfo(
        int $preset_id,
        ?int $columns = null,
        string $contentType = self::contentTypes['restOrdersShippingPresetsPresetIdParcelServiceRegionsGet'][0]
    ): array
    {
        $request = $this->restOrdersShippingPresetsPresetIdParcelServiceRegionsGetRequest($preset_id, $columns, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ParcelServiceRegion[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ParcelServiceRegion[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ParcelServiceRegion[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ParcelServiceRegion[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ParcelServiceRegion[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersShippingPresetsPresetIdParcelServiceRegionsGetAsync
     *
     * List parcel service regions by parcel service preset ID
     *
     * @param  int $preset_id The ID of the preset (required)
     * @param  int|null $columns The properties to be loaded (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPresetsPresetIdParcelServiceRegionsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersShippingPresetsPresetIdParcelServiceRegionsGetAsync(
        int $preset_id,
        ?int $columns = null,
        string $contentType = self::contentTypes['restOrdersShippingPresetsPresetIdParcelServiceRegionsGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersShippingPresetsPresetIdParcelServiceRegionsGetAsyncWithHttpInfo($preset_id, $columns, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersShippingPresetsPresetIdParcelServiceRegionsGetAsyncWithHttpInfo
     *
     * List parcel service regions by parcel service preset ID
     *
     * @param  int $preset_id The ID of the preset (required)
     * @param  int|null $columns The properties to be loaded (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPresetsPresetIdParcelServiceRegionsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersShippingPresetsPresetIdParcelServiceRegionsGetAsyncWithHttpInfo(
        $preset_id,
        $columns = null,
        string $contentType = self::contentTypes['restOrdersShippingPresetsPresetIdParcelServiceRegionsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ParcelServiceRegion[]';
        $request = $this->restOrdersShippingPresetsPresetIdParcelServiceRegionsGetRequest($preset_id, $columns, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersShippingPresetsPresetIdParcelServiceRegionsGet'
     *
     * @param  int $preset_id The ID of the preset (required)
     * @param  int|null $columns The properties to be loaded (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingPresetsPresetIdParcelServiceRegionsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersShippingPresetsPresetIdParcelServiceRegionsGetRequest(
        $preset_id,
        $columns = null,
        string $contentType = self::contentTypes['restOrdersShippingPresetsPresetIdParcelServiceRegionsGet'][0]
    ): Request
    {

        // verify the required parameter 'preset_id' is set
        if ($preset_id === null || (is_array($preset_id) && count($preset_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $preset_id when calling restOrdersShippingPresetsPresetIdParcelServiceRegionsGet'
            );
        }



        $resourcePath = '/rest/orders/shipping/presets/{presetId}/parcel_service_regions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $columns,
            'columns', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($preset_id !== null) {
            $resourcePath = str_replace(
                '{' . 'presetId' . '}',
                ObjectSerializer::toPathValue($preset_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersShippingReturnsReturnsServiceProvidersGet
     *
     * List returns service providers
     *
     * @param  int|null $is_plugin Possible values are 1 (true) and 0 (false). (optional)
     * @param  int|null $plugin_id The ID of the plugin (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingReturnsReturnsServiceProvidersGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestOrdersShippingReturnsReturnsServiceProvidersGet200Response
     */
    public function restOrdersShippingReturnsReturnsServiceProvidersGet(
        ?int $is_plugin = null,
        ?int $plugin_id = null,
        string $contentType = self::contentTypes['restOrdersShippingReturnsReturnsServiceProvidersGet'][0]
    ): \ck\Model\RestOrdersShippingReturnsReturnsServiceProvidersGet200Response
    {
        list($response) = $this->restOrdersShippingReturnsReturnsServiceProvidersGetWithHttpInfo($is_plugin, $plugin_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersShippingReturnsReturnsServiceProvidersGetWithHttpInfo
     *
     * List returns service providers
     *
     * @param  int|null $is_plugin Possible values are 1 (true) and 0 (false). (optional)
     * @param  int|null $plugin_id The ID of the plugin (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingReturnsReturnsServiceProvidersGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestOrdersShippingReturnsReturnsServiceProvidersGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersShippingReturnsReturnsServiceProvidersGetWithHttpInfo(
        ?int $is_plugin = null,
        ?int $plugin_id = null,
        string $contentType = self::contentTypes['restOrdersShippingReturnsReturnsServiceProvidersGet'][0]
    ): array
    {
        $request = $this->restOrdersShippingReturnsReturnsServiceProvidersGetRequest($is_plugin, $plugin_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestOrdersShippingReturnsReturnsServiceProvidersGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestOrdersShippingReturnsReturnsServiceProvidersGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestOrdersShippingReturnsReturnsServiceProvidersGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestOrdersShippingReturnsReturnsServiceProvidersGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestOrdersShippingReturnsReturnsServiceProvidersGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersShippingReturnsReturnsServiceProvidersGetAsync
     *
     * List returns service providers
     *
     * @param  int|null $is_plugin Possible values are 1 (true) and 0 (false). (optional)
     * @param  int|null $plugin_id The ID of the plugin (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingReturnsReturnsServiceProvidersGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersShippingReturnsReturnsServiceProvidersGetAsync(
        ?int $is_plugin = null,
        ?int $plugin_id = null,
        string $contentType = self::contentTypes['restOrdersShippingReturnsReturnsServiceProvidersGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersShippingReturnsReturnsServiceProvidersGetAsyncWithHttpInfo($is_plugin, $plugin_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersShippingReturnsReturnsServiceProvidersGetAsyncWithHttpInfo
     *
     * List returns service providers
     *
     * @param  int|null $is_plugin Possible values are 1 (true) and 0 (false). (optional)
     * @param  int|null $plugin_id The ID of the plugin (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingReturnsReturnsServiceProvidersGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersShippingReturnsReturnsServiceProvidersGetAsyncWithHttpInfo(
        $is_plugin = null,
        $plugin_id = null,
        string $contentType = self::contentTypes['restOrdersShippingReturnsReturnsServiceProvidersGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestOrdersShippingReturnsReturnsServiceProvidersGet200Response';
        $request = $this->restOrdersShippingReturnsReturnsServiceProvidersGetRequest($is_plugin, $plugin_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersShippingReturnsReturnsServiceProvidersGet'
     *
     * @param  int|null $is_plugin Possible values are 1 (true) and 0 (false). (optional)
     * @param  int|null $plugin_id The ID of the plugin (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingReturnsReturnsServiceProvidersGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersShippingReturnsReturnsServiceProvidersGetRequest(
        $is_plugin = null,
        $plugin_id = null,
        string $contentType = self::contentTypes['restOrdersShippingReturnsReturnsServiceProvidersGet'][0]
    ): Request
    {




        $resourcePath = '/rest/orders/shipping/returns/returns_service_providers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_plugin,
            'isPlugin', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $plugin_id,
            'pluginId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersShippingReturnsReturnsServiceProvidersPluginsGet
     *
     * List returns service provider plugins
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingReturnsReturnsServiceProvidersPluginsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object[]
     */
    public function restOrdersShippingReturnsReturnsServiceProvidersPluginsGet(
        string $contentType = self::contentTypes['restOrdersShippingReturnsReturnsServiceProvidersPluginsGet'][0]
    ): array
    {
        list($response) = $this->restOrdersShippingReturnsReturnsServiceProvidersPluginsGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restOrdersShippingReturnsReturnsServiceProvidersPluginsGetWithHttpInfo
     *
     * List returns service provider plugins
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingReturnsReturnsServiceProvidersPluginsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersShippingReturnsReturnsServiceProvidersPluginsGetWithHttpInfo(
        string $contentType = self::contentTypes['restOrdersShippingReturnsReturnsServiceProvidersPluginsGet'][0]
    ): array
    {
        $request = $this->restOrdersShippingReturnsReturnsServiceProvidersPluginsGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersShippingReturnsReturnsServiceProvidersPluginsGetAsync
     *
     * List returns service provider plugins
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingReturnsReturnsServiceProvidersPluginsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersShippingReturnsReturnsServiceProvidersPluginsGetAsync(
        string $contentType = self::contentTypes['restOrdersShippingReturnsReturnsServiceProvidersPluginsGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersShippingReturnsReturnsServiceProvidersPluginsGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersShippingReturnsReturnsServiceProvidersPluginsGetAsyncWithHttpInfo
     *
     * List returns service provider plugins
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingReturnsReturnsServiceProvidersPluginsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersShippingReturnsReturnsServiceProvidersPluginsGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restOrdersShippingReturnsReturnsServiceProvidersPluginsGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object[]';
        $request = $this->restOrdersShippingReturnsReturnsServiceProvidersPluginsGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersShippingReturnsReturnsServiceProvidersPluginsGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingReturnsReturnsServiceProvidersPluginsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersShippingReturnsReturnsServiceProvidersPluginsGetRequest(
        string $contentType = self::contentTypes['restOrdersShippingReturnsReturnsServiceProvidersPluginsGet'][0]
    ): Request
    {


        $resourcePath = '/rest/orders/shipping/returns/returns_service_providers/plugins';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersShippingReturnsReturnsServiceProvidersProviderIdGet
     *
     * Get returns service provider by the ID
     *
     * @param  int $provider_id The ID of the returns service provider (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingReturnsReturnsServiceProvidersProviderIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ReturnsServiceProvider
     */
    public function restOrdersShippingReturnsReturnsServiceProvidersProviderIdGet(
        int $provider_id,
        string $contentType = self::contentTypes['restOrdersShippingReturnsReturnsServiceProvidersProviderIdGet'][0]
    ): \ck\Model\ReturnsServiceProvider
    {
        list($response) = $this->restOrdersShippingReturnsReturnsServiceProvidersProviderIdGetWithHttpInfo($provider_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersShippingReturnsReturnsServiceProvidersProviderIdGetWithHttpInfo
     *
     * Get returns service provider by the ID
     *
     * @param  int $provider_id The ID of the returns service provider (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingReturnsReturnsServiceProvidersProviderIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ReturnsServiceProvider, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersShippingReturnsReturnsServiceProvidersProviderIdGetWithHttpInfo(
        int $provider_id,
        string $contentType = self::contentTypes['restOrdersShippingReturnsReturnsServiceProvidersProviderIdGet'][0]
    ): array
    {
        $request = $this->restOrdersShippingReturnsReturnsServiceProvidersProviderIdGetRequest($provider_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ReturnsServiceProvider' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ReturnsServiceProvider' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ReturnsServiceProvider', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ReturnsServiceProvider';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ReturnsServiceProvider',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersShippingReturnsReturnsServiceProvidersProviderIdGetAsync
     *
     * Get returns service provider by the ID
     *
     * @param  int $provider_id The ID of the returns service provider (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingReturnsReturnsServiceProvidersProviderIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersShippingReturnsReturnsServiceProvidersProviderIdGetAsync(
        int $provider_id,
        string $contentType = self::contentTypes['restOrdersShippingReturnsReturnsServiceProvidersProviderIdGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersShippingReturnsReturnsServiceProvidersProviderIdGetAsyncWithHttpInfo($provider_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersShippingReturnsReturnsServiceProvidersProviderIdGetAsyncWithHttpInfo
     *
     * Get returns service provider by the ID
     *
     * @param  int $provider_id The ID of the returns service provider (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingReturnsReturnsServiceProvidersProviderIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersShippingReturnsReturnsServiceProvidersProviderIdGetAsyncWithHttpInfo(
        $provider_id,
        string $contentType = self::contentTypes['restOrdersShippingReturnsReturnsServiceProvidersProviderIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ReturnsServiceProvider';
        $request = $this->restOrdersShippingReturnsReturnsServiceProvidersProviderIdGetRequest($provider_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersShippingReturnsReturnsServiceProvidersProviderIdGet'
     *
     * @param  int $provider_id The ID of the returns service provider (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingReturnsReturnsServiceProvidersProviderIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersShippingReturnsReturnsServiceProvidersProviderIdGetRequest(
        $provider_id,
        string $contentType = self::contentTypes['restOrdersShippingReturnsReturnsServiceProvidersProviderIdGet'][0]
    ): Request
    {

        // verify the required parameter 'provider_id' is set
        if ($provider_id === null || (is_array($provider_id) && count($provider_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $provider_id when calling restOrdersShippingReturnsReturnsServiceProvidersProviderIdGet'
            );
        }


        $resourcePath = '/rest/orders/shipping/returns/returns_service_providers/{providerId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($provider_id !== null) {
            $resourcePath = str_replace(
                '{' . 'providerId' . '}',
                ObjectSerializer::toPathValue($provider_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersShippingShippingInformationGet
     *
     * List orders with shipping information
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingShippingInformationGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object[]
     */
    public function restOrdersShippingShippingInformationGet(
        string $contentType = self::contentTypes['restOrdersShippingShippingInformationGet'][0]
    ): array
    {
        list($response) = $this->restOrdersShippingShippingInformationGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restOrdersShippingShippingInformationGetWithHttpInfo
     *
     * List orders with shipping information
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingShippingInformationGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersShippingShippingInformationGetWithHttpInfo(
        string $contentType = self::contentTypes['restOrdersShippingShippingInformationGet'][0]
    ): array
    {
        $request = $this->restOrdersShippingShippingInformationGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersShippingShippingInformationGetAsync
     *
     * List orders with shipping information
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingShippingInformationGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersShippingShippingInformationGetAsync(
        string $contentType = self::contentTypes['restOrdersShippingShippingInformationGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersShippingShippingInformationGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersShippingShippingInformationGetAsyncWithHttpInfo
     *
     * List orders with shipping information
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingShippingInformationGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersShippingShippingInformationGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restOrdersShippingShippingInformationGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object[]';
        $request = $this->restOrdersShippingShippingInformationGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersShippingShippingInformationGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingShippingInformationGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersShippingShippingInformationGetRequest(
        string $contentType = self::contentTypes['restOrdersShippingShippingInformationGet'][0]
    ): Request
    {


        $resourcePath = '/rest/orders/shipping/shipping_information';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersShippingShippingInformationPost
     *
     * Create shipping information
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingShippingInformationPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ShippingInformation
     */
    public function restOrdersShippingShippingInformationPost(
        string $contentType = self::contentTypes['restOrdersShippingShippingInformationPost'][0]
    ): \ck\Model\ShippingInformation
    {
        list($response) = $this->restOrdersShippingShippingInformationPostWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restOrdersShippingShippingInformationPostWithHttpInfo
     *
     * Create shipping information
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingShippingInformationPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ShippingInformation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersShippingShippingInformationPostWithHttpInfo(
        string $contentType = self::contentTypes['restOrdersShippingShippingInformationPost'][0]
    ): array
    {
        $request = $this->restOrdersShippingShippingInformationPostRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ShippingInformation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ShippingInformation' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ShippingInformation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ShippingInformation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ShippingInformation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersShippingShippingInformationPostAsync
     *
     * Create shipping information
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingShippingInformationPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersShippingShippingInformationPostAsync(
        string $contentType = self::contentTypes['restOrdersShippingShippingInformationPost'][0]
    ): PromiseInterface
    {
        return $this->restOrdersShippingShippingInformationPostAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersShippingShippingInformationPostAsyncWithHttpInfo
     *
     * Create shipping information
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingShippingInformationPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersShippingShippingInformationPostAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restOrdersShippingShippingInformationPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ShippingInformation';
        $request = $this->restOrdersShippingShippingInformationPostRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersShippingShippingInformationPost'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingShippingInformationPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersShippingShippingInformationPostRequest(
        string $contentType = self::contentTypes['restOrdersShippingShippingInformationPost'][0]
    ): Request
    {


        $resourcePath = '/rest/orders/shipping/shipping_information';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersShippingShippingServiceProvidersGet
     *
     * List shipping service providers
     *
     * @param  string|null $updated_at_before Filter that restricts the search result to shipping providers that were updated before a specific date. Possible formats: yyyy-mm-dd or yyyy-mm-dd hh:mm:ss (optional)
     * @param  string|null $updated_at_after Filter that restricts the search result to shipping providers that were updated after a specific date. Possible formats: yyyy-mm-dd or yyyy-mm-dd hh:mm:ss (optional)
     * @param  string|null $with The name of an relation to the shipping provider. The following parameter is available: ownShippingServiceProviders. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingShippingServiceProvidersGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestOrdersShippingShippingServiceProvidersGet200Response
     */
    public function restOrdersShippingShippingServiceProvidersGet(
        ?string $updated_at_before = null,
        ?string $updated_at_after = null,
        ?string $with = null,
        string $contentType = self::contentTypes['restOrdersShippingShippingServiceProvidersGet'][0]
    ): \ck\Model\RestOrdersShippingShippingServiceProvidersGet200Response
    {
        list($response) = $this->restOrdersShippingShippingServiceProvidersGetWithHttpInfo($updated_at_before, $updated_at_after, $with, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersShippingShippingServiceProvidersGetWithHttpInfo
     *
     * List shipping service providers
     *
     * @param  string|null $updated_at_before Filter that restricts the search result to shipping providers that were updated before a specific date. Possible formats: yyyy-mm-dd or yyyy-mm-dd hh:mm:ss (optional)
     * @param  string|null $updated_at_after Filter that restricts the search result to shipping providers that were updated after a specific date. Possible formats: yyyy-mm-dd or yyyy-mm-dd hh:mm:ss (optional)
     * @param  string|null $with The name of an relation to the shipping provider. The following parameter is available: ownShippingServiceProviders. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingShippingServiceProvidersGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestOrdersShippingShippingServiceProvidersGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersShippingShippingServiceProvidersGetWithHttpInfo(
        ?string $updated_at_before = null,
        ?string $updated_at_after = null,
        ?string $with = null,
        string $contentType = self::contentTypes['restOrdersShippingShippingServiceProvidersGet'][0]
    ): array
    {
        $request = $this->restOrdersShippingShippingServiceProvidersGetRequest($updated_at_before, $updated_at_after, $with, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestOrdersShippingShippingServiceProvidersGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestOrdersShippingShippingServiceProvidersGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestOrdersShippingShippingServiceProvidersGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestOrdersShippingShippingServiceProvidersGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestOrdersShippingShippingServiceProvidersGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersShippingShippingServiceProvidersGetAsync
     *
     * List shipping service providers
     *
     * @param  string|null $updated_at_before Filter that restricts the search result to shipping providers that were updated before a specific date. Possible formats: yyyy-mm-dd or yyyy-mm-dd hh:mm:ss (optional)
     * @param  string|null $updated_at_after Filter that restricts the search result to shipping providers that were updated after a specific date. Possible formats: yyyy-mm-dd or yyyy-mm-dd hh:mm:ss (optional)
     * @param  string|null $with The name of an relation to the shipping provider. The following parameter is available: ownShippingServiceProviders. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingShippingServiceProvidersGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersShippingShippingServiceProvidersGetAsync(
        ?string $updated_at_before = null,
        ?string $updated_at_after = null,
        ?string $with = null,
        string $contentType = self::contentTypes['restOrdersShippingShippingServiceProvidersGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersShippingShippingServiceProvidersGetAsyncWithHttpInfo($updated_at_before, $updated_at_after, $with, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersShippingShippingServiceProvidersGetAsyncWithHttpInfo
     *
     * List shipping service providers
     *
     * @param  string|null $updated_at_before Filter that restricts the search result to shipping providers that were updated before a specific date. Possible formats: yyyy-mm-dd or yyyy-mm-dd hh:mm:ss (optional)
     * @param  string|null $updated_at_after Filter that restricts the search result to shipping providers that were updated after a specific date. Possible formats: yyyy-mm-dd or yyyy-mm-dd hh:mm:ss (optional)
     * @param  string|null $with The name of an relation to the shipping provider. The following parameter is available: ownShippingServiceProviders. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingShippingServiceProvidersGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersShippingShippingServiceProvidersGetAsyncWithHttpInfo(
        $updated_at_before = null,
        $updated_at_after = null,
        $with = null,
        string $contentType = self::contentTypes['restOrdersShippingShippingServiceProvidersGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestOrdersShippingShippingServiceProvidersGet200Response';
        $request = $this->restOrdersShippingShippingServiceProvidersGetRequest($updated_at_before, $updated_at_after, $with, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersShippingShippingServiceProvidersGet'
     *
     * @param  string|null $updated_at_before Filter that restricts the search result to shipping providers that were updated before a specific date. Possible formats: yyyy-mm-dd or yyyy-mm-dd hh:mm:ss (optional)
     * @param  string|null $updated_at_after Filter that restricts the search result to shipping providers that were updated after a specific date. Possible formats: yyyy-mm-dd or yyyy-mm-dd hh:mm:ss (optional)
     * @param  string|null $with The name of an relation to the shipping provider. The following parameter is available: ownShippingServiceProviders. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingShippingServiceProvidersGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersShippingShippingServiceProvidersGetRequest(
        $updated_at_before = null,
        $updated_at_after = null,
        $with = null,
        string $contentType = self::contentTypes['restOrdersShippingShippingServiceProvidersGet'][0]
    ): Request
    {





        $resourcePath = '/rest/orders/shipping/shipping_service_providers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_at_before,
            'updatedAtBefore', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_at_after,
            'updatedAtAfter', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersShippingShippingServiceProvidersPluginsGet
     *
     * List shipping service provider plugins
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingShippingServiceProvidersPluginsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object[]
     */
    public function restOrdersShippingShippingServiceProvidersPluginsGet(
        string $contentType = self::contentTypes['restOrdersShippingShippingServiceProvidersPluginsGet'][0]
    ): array
    {
        list($response) = $this->restOrdersShippingShippingServiceProvidersPluginsGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restOrdersShippingShippingServiceProvidersPluginsGetWithHttpInfo
     *
     * List shipping service provider plugins
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingShippingServiceProvidersPluginsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersShippingShippingServiceProvidersPluginsGetWithHttpInfo(
        string $contentType = self::contentTypes['restOrdersShippingShippingServiceProvidersPluginsGet'][0]
    ): array
    {
        $request = $this->restOrdersShippingShippingServiceProvidersPluginsGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersShippingShippingServiceProvidersPluginsGetAsync
     *
     * List shipping service provider plugins
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingShippingServiceProvidersPluginsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersShippingShippingServiceProvidersPluginsGetAsync(
        string $contentType = self::contentTypes['restOrdersShippingShippingServiceProvidersPluginsGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersShippingShippingServiceProvidersPluginsGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersShippingShippingServiceProvidersPluginsGetAsyncWithHttpInfo
     *
     * List shipping service provider plugins
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingShippingServiceProvidersPluginsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersShippingShippingServiceProvidersPluginsGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restOrdersShippingShippingServiceProvidersPluginsGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object[]';
        $request = $this->restOrdersShippingShippingServiceProvidersPluginsGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersShippingShippingServiceProvidersPluginsGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingShippingServiceProvidersPluginsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersShippingShippingServiceProvidersPluginsGetRequest(
        string $contentType = self::contentTypes['restOrdersShippingShippingServiceProvidersPluginsGet'][0]
    ): Request
    {


        $resourcePath = '/rest/orders/shipping/shipping_service_providers/plugins';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersShippingShippingServiceProvidersPost
     *
     * Save a shipping service provider
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingShippingServiceProvidersPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ShippingServiceProvider
     */
    public function restOrdersShippingShippingServiceProvidersPost(
        string $contentType = self::contentTypes['restOrdersShippingShippingServiceProvidersPost'][0]
    ): \ck\Model\ShippingServiceProvider
    {
        list($response) = $this->restOrdersShippingShippingServiceProvidersPostWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restOrdersShippingShippingServiceProvidersPostWithHttpInfo
     *
     * Save a shipping service provider
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingShippingServiceProvidersPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ShippingServiceProvider, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersShippingShippingServiceProvidersPostWithHttpInfo(
        string $contentType = self::contentTypes['restOrdersShippingShippingServiceProvidersPost'][0]
    ): array
    {
        $request = $this->restOrdersShippingShippingServiceProvidersPostRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ShippingServiceProvider' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ShippingServiceProvider' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ShippingServiceProvider', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ShippingServiceProvider';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ShippingServiceProvider',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersShippingShippingServiceProvidersPostAsync
     *
     * Save a shipping service provider
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingShippingServiceProvidersPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersShippingShippingServiceProvidersPostAsync(
        string $contentType = self::contentTypes['restOrdersShippingShippingServiceProvidersPost'][0]
    ): PromiseInterface
    {
        return $this->restOrdersShippingShippingServiceProvidersPostAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersShippingShippingServiceProvidersPostAsyncWithHttpInfo
     *
     * Save a shipping service provider
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingShippingServiceProvidersPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersShippingShippingServiceProvidersPostAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restOrdersShippingShippingServiceProvidersPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ShippingServiceProvider';
        $request = $this->restOrdersShippingShippingServiceProvidersPostRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersShippingShippingServiceProvidersPost'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingShippingServiceProvidersPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersShippingShippingServiceProvidersPostRequest(
        string $contentType = self::contentTypes['restOrdersShippingShippingServiceProvidersPost'][0]
    ): Request
    {


        $resourcePath = '/rest/orders/shipping/shipping_service_providers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersShippingShippingServiceProvidersShippingServiceProviderIdGet
     *
     * Get a shipping service provider
     *
     * @param  int $shipping_service_provider_id The ID of the shipping service provider (required)
     * @param  int $shipping_service_provider_id2 shipping_service_provider_id2 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingShippingServiceProvidersShippingServiceProviderIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ShippingServiceProvider
     */
    public function restOrdersShippingShippingServiceProvidersShippingServiceProviderIdGet(
        int $shipping_service_provider_id,
        int $shipping_service_provider_id2,
        string $contentType = self::contentTypes['restOrdersShippingShippingServiceProvidersShippingServiceProviderIdGet'][0]
    ): \ck\Model\ShippingServiceProvider
    {
        list($response) = $this->restOrdersShippingShippingServiceProvidersShippingServiceProviderIdGetWithHttpInfo($shipping_service_provider_id, $shipping_service_provider_id2, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersShippingShippingServiceProvidersShippingServiceProviderIdGetWithHttpInfo
     *
     * Get a shipping service provider
     *
     * @param  int $shipping_service_provider_id The ID of the shipping service provider (required)
     * @param  int $shipping_service_provider_id2 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingShippingServiceProvidersShippingServiceProviderIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ShippingServiceProvider, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersShippingShippingServiceProvidersShippingServiceProviderIdGetWithHttpInfo(
        int $shipping_service_provider_id,
        int $shipping_service_provider_id2,
        string $contentType = self::contentTypes['restOrdersShippingShippingServiceProvidersShippingServiceProviderIdGet'][0]
    ): array
    {
        $request = $this->restOrdersShippingShippingServiceProvidersShippingServiceProviderIdGetRequest($shipping_service_provider_id, $shipping_service_provider_id2, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ShippingServiceProvider' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ShippingServiceProvider' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ShippingServiceProvider', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ShippingServiceProvider';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ShippingServiceProvider',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersShippingShippingServiceProvidersShippingServiceProviderIdGetAsync
     *
     * Get a shipping service provider
     *
     * @param  int $shipping_service_provider_id The ID of the shipping service provider (required)
     * @param  int $shipping_service_provider_id2 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingShippingServiceProvidersShippingServiceProviderIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersShippingShippingServiceProvidersShippingServiceProviderIdGetAsync(
        int $shipping_service_provider_id,
        int $shipping_service_provider_id2,
        string $contentType = self::contentTypes['restOrdersShippingShippingServiceProvidersShippingServiceProviderIdGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersShippingShippingServiceProvidersShippingServiceProviderIdGetAsyncWithHttpInfo($shipping_service_provider_id, $shipping_service_provider_id2, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersShippingShippingServiceProvidersShippingServiceProviderIdGetAsyncWithHttpInfo
     *
     * Get a shipping service provider
     *
     * @param  int $shipping_service_provider_id The ID of the shipping service provider (required)
     * @param  int $shipping_service_provider_id2 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingShippingServiceProvidersShippingServiceProviderIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersShippingShippingServiceProvidersShippingServiceProviderIdGetAsyncWithHttpInfo(
        $shipping_service_provider_id,
        $shipping_service_provider_id2,
        string $contentType = self::contentTypes['restOrdersShippingShippingServiceProvidersShippingServiceProviderIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ShippingServiceProvider';
        $request = $this->restOrdersShippingShippingServiceProvidersShippingServiceProviderIdGetRequest($shipping_service_provider_id, $shipping_service_provider_id2, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersShippingShippingServiceProvidersShippingServiceProviderIdGet'
     *
     * @param  int $shipping_service_provider_id The ID of the shipping service provider (required)
     * @param  int $shipping_service_provider_id2 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersShippingShippingServiceProvidersShippingServiceProviderIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersShippingShippingServiceProvidersShippingServiceProviderIdGetRequest(
        $shipping_service_provider_id,
        $shipping_service_provider_id2,
        string $contentType = self::contentTypes['restOrdersShippingShippingServiceProvidersShippingServiceProviderIdGet'][0]
    ): Request
    {

        // verify the required parameter 'shipping_service_provider_id' is set
        if ($shipping_service_provider_id === null || (is_array($shipping_service_provider_id) && count($shipping_service_provider_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $shipping_service_provider_id when calling restOrdersShippingShippingServiceProvidersShippingServiceProviderIdGet'
            );
        }

        // verify the required parameter 'shipping_service_provider_id2' is set
        if ($shipping_service_provider_id2 === null || (is_array($shipping_service_provider_id2) && count($shipping_service_provider_id2) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $shipping_service_provider_id2 when calling restOrdersShippingShippingServiceProvidersShippingServiceProviderIdGet'
            );
        }


        $resourcePath = '/rest/orders/shipping/shipping_service_providers/{shipping_service_provider_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $shipping_service_provider_id,
            'shippingServiceProviderId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);


        // path params
        if ($shipping_service_provider_id2 !== null) {
            $resourcePath = str_replace(
                '{' . 'shipping_service_provider_id' . '}',
                ObjectSerializer::toPathValue($shipping_service_provider_id2),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersStatusHistoryGet
     *
     * List status histories of orders
     *
     * @param  int|null $order_id The ID of the order (optional)
     * @param  float|null $status_id The ID of the status (optional)
     * @param  string|null $created_at_from Set a start date to get status history entries beginning with this date (optional)
     * @param  string|null $created_at_to Set an end date to get status history entries up to this date (optional)
     * @param  string|null $user_id The ID of the user (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersStatusHistoryGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestOrdersStatusHistoryGet200Response
     */
    public function restOrdersStatusHistoryGet(
        ?int $order_id = null,
        ?float $status_id = null,
        ?string $created_at_from = null,
        ?string $created_at_to = null,
        ?string $user_id = null,
        string $contentType = self::contentTypes['restOrdersStatusHistoryGet'][0]
    ): \ck\Model\RestOrdersStatusHistoryGet200Response
    {
        list($response) = $this->restOrdersStatusHistoryGetWithHttpInfo($order_id, $status_id, $created_at_from, $created_at_to, $user_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersStatusHistoryGetWithHttpInfo
     *
     * List status histories of orders
     *
     * @param  int|null $order_id The ID of the order (optional)
     * @param  float|null $status_id The ID of the status (optional)
     * @param  string|null $created_at_from Set a start date to get status history entries beginning with this date (optional)
     * @param  string|null $created_at_to Set an end date to get status history entries up to this date (optional)
     * @param  string|null $user_id The ID of the user (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersStatusHistoryGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestOrdersStatusHistoryGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersStatusHistoryGetWithHttpInfo(
        ?int $order_id = null,
        ?float $status_id = null,
        ?string $created_at_from = null,
        ?string $created_at_to = null,
        ?string $user_id = null,
        string $contentType = self::contentTypes['restOrdersStatusHistoryGet'][0]
    ): array
    {
        $request = $this->restOrdersStatusHistoryGetRequest($order_id, $status_id, $created_at_from, $created_at_to, $user_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestOrdersStatusHistoryGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestOrdersStatusHistoryGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestOrdersStatusHistoryGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestOrdersStatusHistoryGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestOrdersStatusHistoryGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersStatusHistoryGetAsync
     *
     * List status histories of orders
     *
     * @param  int|null $order_id The ID of the order (optional)
     * @param  float|null $status_id The ID of the status (optional)
     * @param  string|null $created_at_from Set a start date to get status history entries beginning with this date (optional)
     * @param  string|null $created_at_to Set an end date to get status history entries up to this date (optional)
     * @param  string|null $user_id The ID of the user (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersStatusHistoryGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersStatusHistoryGetAsync(
        ?int $order_id = null,
        ?float $status_id = null,
        ?string $created_at_from = null,
        ?string $created_at_to = null,
        ?string $user_id = null,
        string $contentType = self::contentTypes['restOrdersStatusHistoryGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersStatusHistoryGetAsyncWithHttpInfo($order_id, $status_id, $created_at_from, $created_at_to, $user_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersStatusHistoryGetAsyncWithHttpInfo
     *
     * List status histories of orders
     *
     * @param  int|null $order_id The ID of the order (optional)
     * @param  float|null $status_id The ID of the status (optional)
     * @param  string|null $created_at_from Set a start date to get status history entries beginning with this date (optional)
     * @param  string|null $created_at_to Set an end date to get status history entries up to this date (optional)
     * @param  string|null $user_id The ID of the user (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersStatusHistoryGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersStatusHistoryGetAsyncWithHttpInfo(
        $order_id = null,
        $status_id = null,
        $created_at_from = null,
        $created_at_to = null,
        $user_id = null,
        string $contentType = self::contentTypes['restOrdersStatusHistoryGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestOrdersStatusHistoryGet200Response';
        $request = $this->restOrdersStatusHistoryGetRequest($order_id, $status_id, $created_at_from, $created_at_to, $user_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersStatusHistoryGet'
     *
     * @param  int|null $order_id The ID of the order (optional)
     * @param  float|null $status_id The ID of the status (optional)
     * @param  string|null $created_at_from Set a start date to get status history entries beginning with this date (optional)
     * @param  string|null $created_at_to Set an end date to get status history entries up to this date (optional)
     * @param  string|null $user_id The ID of the user (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersStatusHistoryGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersStatusHistoryGetRequest(
        $order_id = null,
        $status_id = null,
        $created_at_from = null,
        $created_at_to = null,
        $user_id = null,
        string $contentType = self::contentTypes['restOrdersStatusHistoryGet'][0]
    ): Request
    {







        $resourcePath = '/rest/orders/status-history';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order_id,
            'orderId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status_id,
            'statusId', // param base name
            'number', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_at_from,
            'createdAtFrom', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_at_to,
            'createdAtTo', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_id,
            'userId', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersStatusesAllGet
     *
     * Get all order statuses
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersStatusesAllGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restOrdersStatusesAllGet(
        string $contentType = self::contentTypes['restOrdersStatusesAllGet'][0]
    ): object
    {
        list($response) = $this->restOrdersStatusesAllGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restOrdersStatusesAllGetWithHttpInfo
     *
     * Get all order statuses
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersStatusesAllGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersStatusesAllGetWithHttpInfo(
        string $contentType = self::contentTypes['restOrdersStatusesAllGet'][0]
    ): array
    {
        $request = $this->restOrdersStatusesAllGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersStatusesAllGetAsync
     *
     * Get all order statuses
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersStatusesAllGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersStatusesAllGetAsync(
        string $contentType = self::contentTypes['restOrdersStatusesAllGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersStatusesAllGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersStatusesAllGetAsyncWithHttpInfo
     *
     * Get all order statuses
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersStatusesAllGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersStatusesAllGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restOrdersStatusesAllGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restOrdersStatusesAllGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersStatusesAllGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersStatusesAllGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersStatusesAllGetRequest(
        string $contentType = self::contentTypes['restOrdersStatusesAllGet'][0]
    ): Request
    {


        $resourcePath = '/rest/orders/statuses/all';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersStatusesGet
     *
     * Searches for order statuses
     *
     * @param  float|null $status_id_from Define an ID as a start value for the filter. Filter that restricts the search for order statuses to IDs from a defined value. (optional)
     * @param  float|null $status_id_to Define an ID as an end value for the filter. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersStatusesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestOrdersStatusesGet200Response
     */
    public function restOrdersStatusesGet(
        ?float $status_id_from = null,
        ?float $status_id_to = null,
        string $contentType = self::contentTypes['restOrdersStatusesGet'][0]
    ): \ck\Model\RestOrdersStatusesGet200Response
    {
        list($response) = $this->restOrdersStatusesGetWithHttpInfo($status_id_from, $status_id_to, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersStatusesGetWithHttpInfo
     *
     * Searches for order statuses
     *
     * @param  float|null $status_id_from Define an ID as a start value for the filter. Filter that restricts the search for order statuses to IDs from a defined value. (optional)
     * @param  float|null $status_id_to Define an ID as an end value for the filter. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersStatusesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestOrdersStatusesGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersStatusesGetWithHttpInfo(
        ?float $status_id_from = null,
        ?float $status_id_to = null,
        string $contentType = self::contentTypes['restOrdersStatusesGet'][0]
    ): array
    {
        $request = $this->restOrdersStatusesGetRequest($status_id_from, $status_id_to, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestOrdersStatusesGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestOrdersStatusesGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestOrdersStatusesGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestOrdersStatusesGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestOrdersStatusesGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersStatusesGetAsync
     *
     * Searches for order statuses
     *
     * @param  float|null $status_id_from Define an ID as a start value for the filter. Filter that restricts the search for order statuses to IDs from a defined value. (optional)
     * @param  float|null $status_id_to Define an ID as an end value for the filter. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersStatusesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersStatusesGetAsync(
        ?float $status_id_from = null,
        ?float $status_id_to = null,
        string $contentType = self::contentTypes['restOrdersStatusesGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersStatusesGetAsyncWithHttpInfo($status_id_from, $status_id_to, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersStatusesGetAsyncWithHttpInfo
     *
     * Searches for order statuses
     *
     * @param  float|null $status_id_from Define an ID as a start value for the filter. Filter that restricts the search for order statuses to IDs from a defined value. (optional)
     * @param  float|null $status_id_to Define an ID as an end value for the filter. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersStatusesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersStatusesGetAsyncWithHttpInfo(
        $status_id_from = null,
        $status_id_to = null,
        string $contentType = self::contentTypes['restOrdersStatusesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestOrdersStatusesGet200Response';
        $request = $this->restOrdersStatusesGetRequest($status_id_from, $status_id_to, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersStatusesGet'
     *
     * @param  float|null $status_id_from Define an ID as a start value for the filter. Filter that restricts the search for order statuses to IDs from a defined value. (optional)
     * @param  float|null $status_id_to Define an ID as an end value for the filter. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersStatusesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersStatusesGetRequest(
        $status_id_from = null,
        $status_id_to = null,
        string $contentType = self::contentTypes['restOrdersStatusesGet'][0]
    ): Request
    {




        $resourcePath = '/rest/orders/statuses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status_id_from,
            'statusIdFrom', // param base name
            'number', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status_id_to,
            'statusIdTo', // param base name
            'number', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersStatusesGroupFunctionsPost
     *
     * Change order status properties
     *
     * @param  int $new_status_values Set an array of new order status properties consisting of one key and one value for each property. The status colour must be set as a hexadecimal code. All other properties must be specified either by value 0 (inactive) or 1 (active). (required)
     * @param  int $selected_status_list Set a list with the IDs of the order statuses that should be changed. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersStatusesGroupFunctionsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restOrdersStatusesGroupFunctionsPost(
        int $new_status_values,
        int $selected_status_list,
        string $contentType = self::contentTypes['restOrdersStatusesGroupFunctionsPost'][0]
    ): void
    {
        $this->restOrdersStatusesGroupFunctionsPostWithHttpInfo($new_status_values, $selected_status_list, $contentType);
    }

    /**
     * Operation restOrdersStatusesGroupFunctionsPostWithHttpInfo
     *
     * Change order status properties
     *
     * @param  int $new_status_values Set an array of new order status properties consisting of one key and one value for each property. The status colour must be set as a hexadecimal code. All other properties must be specified either by value 0 (inactive) or 1 (active). (required)
     * @param  int $selected_status_list Set a list with the IDs of the order statuses that should be changed. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersStatusesGroupFunctionsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersStatusesGroupFunctionsPostWithHttpInfo(
        int $new_status_values,
        int $selected_status_list,
        string $contentType = self::contentTypes['restOrdersStatusesGroupFunctionsPost'][0]
    ): array
    {
        $request = $this->restOrdersStatusesGroupFunctionsPostRequest($new_status_values, $selected_status_list, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersStatusesGroupFunctionsPostAsync
     *
     * Change order status properties
     *
     * @param  int $new_status_values Set an array of new order status properties consisting of one key and one value for each property. The status colour must be set as a hexadecimal code. All other properties must be specified either by value 0 (inactive) or 1 (active). (required)
     * @param  int $selected_status_list Set a list with the IDs of the order statuses that should be changed. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersStatusesGroupFunctionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersStatusesGroupFunctionsPostAsync(
        int $new_status_values,
        int $selected_status_list,
        string $contentType = self::contentTypes['restOrdersStatusesGroupFunctionsPost'][0]
    ): PromiseInterface
    {
        return $this->restOrdersStatusesGroupFunctionsPostAsyncWithHttpInfo($new_status_values, $selected_status_list, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersStatusesGroupFunctionsPostAsyncWithHttpInfo
     *
     * Change order status properties
     *
     * @param  int $new_status_values Set an array of new order status properties consisting of one key and one value for each property. The status colour must be set as a hexadecimal code. All other properties must be specified either by value 0 (inactive) or 1 (active). (required)
     * @param  int $selected_status_list Set a list with the IDs of the order statuses that should be changed. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersStatusesGroupFunctionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersStatusesGroupFunctionsPostAsyncWithHttpInfo(
        $new_status_values,
        $selected_status_list,
        string $contentType = self::contentTypes['restOrdersStatusesGroupFunctionsPost'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restOrdersStatusesGroupFunctionsPostRequest($new_status_values, $selected_status_list, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersStatusesGroupFunctionsPost'
     *
     * @param  int $new_status_values Set an array of new order status properties consisting of one key and one value for each property. The status colour must be set as a hexadecimal code. All other properties must be specified either by value 0 (inactive) or 1 (active). (required)
     * @param  int $selected_status_list Set a list with the IDs of the order statuses that should be changed. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersStatusesGroupFunctionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersStatusesGroupFunctionsPostRequest(
        $new_status_values,
        $selected_status_list,
        string $contentType = self::contentTypes['restOrdersStatusesGroupFunctionsPost'][0]
    ): Request
    {

        // verify the required parameter 'new_status_values' is set
        if ($new_status_values === null || (is_array($new_status_values) && count($new_status_values) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $new_status_values when calling restOrdersStatusesGroupFunctionsPost'
            );
        }

        // verify the required parameter 'selected_status_list' is set
        if ($selected_status_list === null || (is_array($selected_status_list) && count($selected_status_list) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $selected_status_list when calling restOrdersStatusesGroupFunctionsPost'
            );
        }


        $resourcePath = '/rest/orders/statuses/group_functions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $new_status_values,
            'newStatusValues', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $selected_status_list,
            'selectedStatusList', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersStatusesPost
     *
     * Creates an order status.
     *
     * @param  \ck\Model\RestOrdersStatusesPostRequest|null $_rest_orders_statuses _rest_orders_statuses (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersStatusesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\OrderStatus
     */
    public function restOrdersStatusesPost(
        ?\ck\Model\RestOrdersStatusesPostRequest $_rest_orders_statuses = null,
        string $contentType = self::contentTypes['restOrdersStatusesPost'][0]
    ): \ck\Model\OrderStatus
    {
        list($response) = $this->restOrdersStatusesPostWithHttpInfo($_rest_orders_statuses, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersStatusesPostWithHttpInfo
     *
     * Creates an order status.
     *
     * @param  \ck\Model\RestOrdersStatusesPostRequest|null $_rest_orders_statuses (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersStatusesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\OrderStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersStatusesPostWithHttpInfo(
        ?\ck\Model\RestOrdersStatusesPostRequest $_rest_orders_statuses = null,
        string $contentType = self::contentTypes['restOrdersStatusesPost'][0]
    ): array
    {
        $request = $this->restOrdersStatusesPostRequest($_rest_orders_statuses, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\OrderStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\OrderStatus' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\OrderStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\OrderStatus';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\OrderStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersStatusesPostAsync
     *
     * Creates an order status.
     *
     * @param  \ck\Model\RestOrdersStatusesPostRequest|null $_rest_orders_statuses (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersStatusesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersStatusesPostAsync(
        ?\ck\Model\RestOrdersStatusesPostRequest $_rest_orders_statuses = null,
        string $contentType = self::contentTypes['restOrdersStatusesPost'][0]
    ): PromiseInterface
    {
        return $this->restOrdersStatusesPostAsyncWithHttpInfo($_rest_orders_statuses, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersStatusesPostAsyncWithHttpInfo
     *
     * Creates an order status.
     *
     * @param  \ck\Model\RestOrdersStatusesPostRequest|null $_rest_orders_statuses (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersStatusesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersStatusesPostAsyncWithHttpInfo(
        $_rest_orders_statuses = null,
        string $contentType = self::contentTypes['restOrdersStatusesPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\OrderStatus';
        $request = $this->restOrdersStatusesPostRequest($_rest_orders_statuses, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersStatusesPost'
     *
     * @param  \ck\Model\RestOrdersStatusesPostRequest|null $_rest_orders_statuses (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersStatusesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersStatusesPostRequest(
        $_rest_orders_statuses = null,
        string $contentType = self::contentTypes['restOrdersStatusesPost'][0]
    ): Request
    {



        $resourcePath = '/rest/orders/statuses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_orders_statuses)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_orders_statuses));
            } else {
                $httpBody = $_rest_orders_statuses;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersStatusesStatusIdDelete
     *
     * Delete an order status
     *
     * @param  float $status_id The ID of the status, which shall be deleted. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersStatusesStatusIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restOrdersStatusesStatusIdDelete(
        float $status_id,
        string $contentType = self::contentTypes['restOrdersStatusesStatusIdDelete'][0]
    ): void
    {
        $this->restOrdersStatusesStatusIdDeleteWithHttpInfo($status_id, $contentType);
    }

    /**
     * Operation restOrdersStatusesStatusIdDeleteWithHttpInfo
     *
     * Delete an order status
     *
     * @param  float $status_id The ID of the status, which shall be deleted. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersStatusesStatusIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersStatusesStatusIdDeleteWithHttpInfo(
        float $status_id,
        string $contentType = self::contentTypes['restOrdersStatusesStatusIdDelete'][0]
    ): array
    {
        $request = $this->restOrdersStatusesStatusIdDeleteRequest($status_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersStatusesStatusIdDeleteAsync
     *
     * Delete an order status
     *
     * @param  float $status_id The ID of the status, which shall be deleted. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersStatusesStatusIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersStatusesStatusIdDeleteAsync(
        float $status_id,
        string $contentType = self::contentTypes['restOrdersStatusesStatusIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restOrdersStatusesStatusIdDeleteAsyncWithHttpInfo($status_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersStatusesStatusIdDeleteAsyncWithHttpInfo
     *
     * Delete an order status
     *
     * @param  float $status_id The ID of the status, which shall be deleted. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersStatusesStatusIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersStatusesStatusIdDeleteAsyncWithHttpInfo(
        $status_id,
        string $contentType = self::contentTypes['restOrdersStatusesStatusIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restOrdersStatusesStatusIdDeleteRequest($status_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersStatusesStatusIdDelete'
     *
     * @param  float $status_id The ID of the status, which shall be deleted. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersStatusesStatusIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersStatusesStatusIdDeleteRequest(
        $status_id,
        string $contentType = self::contentTypes['restOrdersStatusesStatusIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'status_id' is set
        if ($status_id === null || (is_array($status_id) && count($status_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $status_id when calling restOrdersStatusesStatusIdDelete'
            );
        }


        $resourcePath = '/rest/orders/statuses/{statusId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($status_id !== null) {
            $resourcePath = str_replace(
                '{' . 'statusId' . '}',
                ObjectSerializer::toPathValue($status_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersStatusesStatusIdGet
     *
     * Get an order status
     *
     * @param  float $status_id The ID of the order status. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersStatusesStatusIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\OrderStatus
     */
    public function restOrdersStatusesStatusIdGet(
        float $status_id,
        string $contentType = self::contentTypes['restOrdersStatusesStatusIdGet'][0]
    ): \ck\Model\OrderStatus
    {
        list($response) = $this->restOrdersStatusesStatusIdGetWithHttpInfo($status_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersStatusesStatusIdGetWithHttpInfo
     *
     * Get an order status
     *
     * @param  float $status_id The ID of the order status. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersStatusesStatusIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\OrderStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersStatusesStatusIdGetWithHttpInfo(
        float $status_id,
        string $contentType = self::contentTypes['restOrdersStatusesStatusIdGet'][0]
    ): array
    {
        $request = $this->restOrdersStatusesStatusIdGetRequest($status_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\OrderStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\OrderStatus' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\OrderStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\OrderStatus';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\OrderStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersStatusesStatusIdGetAsync
     *
     * Get an order status
     *
     * @param  float $status_id The ID of the order status. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersStatusesStatusIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersStatusesStatusIdGetAsync(
        float $status_id,
        string $contentType = self::contentTypes['restOrdersStatusesStatusIdGet'][0]
    ): PromiseInterface
    {
        return $this->restOrdersStatusesStatusIdGetAsyncWithHttpInfo($status_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersStatusesStatusIdGetAsyncWithHttpInfo
     *
     * Get an order status
     *
     * @param  float $status_id The ID of the order status. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersStatusesStatusIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersStatusesStatusIdGetAsyncWithHttpInfo(
        $status_id,
        string $contentType = self::contentTypes['restOrdersStatusesStatusIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\OrderStatus';
        $request = $this->restOrdersStatusesStatusIdGetRequest($status_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersStatusesStatusIdGet'
     *
     * @param  float $status_id The ID of the order status. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersStatusesStatusIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersStatusesStatusIdGetRequest(
        $status_id,
        string $contentType = self::contentTypes['restOrdersStatusesStatusIdGet'][0]
    ): Request
    {

        // verify the required parameter 'status_id' is set
        if ($status_id === null || (is_array($status_id) && count($status_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $status_id when calling restOrdersStatusesStatusIdGet'
            );
        }


        $resourcePath = '/rest/orders/statuses/{statusId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($status_id !== null) {
            $resourcePath = str_replace(
                '{' . 'statusId' . '}',
                ObjectSerializer::toPathValue($status_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersStatusesStatusIdPut
     *
     * Update an order status
     *
     * @param  float $status_id The ID of the order status that should be updated. (required)
     * @param  \ck\Model\RestOrdersStatusesStatusIdPutRequest|null $_rest_orders_statuses_status_id _rest_orders_statuses_status_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersStatusesStatusIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\OrderStatus
     */
    public function restOrdersStatusesStatusIdPut(
        float $status_id,
        ?\ck\Model\RestOrdersStatusesStatusIdPutRequest $_rest_orders_statuses_status_id = null,
        string $contentType = self::contentTypes['restOrdersStatusesStatusIdPut'][0]
    ): \ck\Model\OrderStatus
    {
        list($response) = $this->restOrdersStatusesStatusIdPutWithHttpInfo($status_id, $_rest_orders_statuses_status_id, $contentType);
        return $response;
    }

    /**
     * Operation restOrdersStatusesStatusIdPutWithHttpInfo
     *
     * Update an order status
     *
     * @param  float $status_id The ID of the order status that should be updated. (required)
     * @param  \ck\Model\RestOrdersStatusesStatusIdPutRequest|null $_rest_orders_statuses_status_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersStatusesStatusIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\OrderStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersStatusesStatusIdPutWithHttpInfo(
        float $status_id,
        ?\ck\Model\RestOrdersStatusesStatusIdPutRequest $_rest_orders_statuses_status_id = null,
        string $contentType = self::contentTypes['restOrdersStatusesStatusIdPut'][0]
    ): array
    {
        $request = $this->restOrdersStatusesStatusIdPutRequest($status_id, $_rest_orders_statuses_status_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\OrderStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\OrderStatus' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\OrderStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\OrderStatus';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\OrderStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersStatusesStatusIdPutAsync
     *
     * Update an order status
     *
     * @param  float $status_id The ID of the order status that should be updated. (required)
     * @param  \ck\Model\RestOrdersStatusesStatusIdPutRequest|null $_rest_orders_statuses_status_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersStatusesStatusIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersStatusesStatusIdPutAsync(
        float $status_id,
        ?\ck\Model\RestOrdersStatusesStatusIdPutRequest $_rest_orders_statuses_status_id = null,
        string $contentType = self::contentTypes['restOrdersStatusesStatusIdPut'][0]
    ): PromiseInterface
    {
        return $this->restOrdersStatusesStatusIdPutAsyncWithHttpInfo($status_id, $_rest_orders_statuses_status_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersStatusesStatusIdPutAsyncWithHttpInfo
     *
     * Update an order status
     *
     * @param  float $status_id The ID of the order status that should be updated. (required)
     * @param  \ck\Model\RestOrdersStatusesStatusIdPutRequest|null $_rest_orders_statuses_status_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersStatusesStatusIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersStatusesStatusIdPutAsyncWithHttpInfo(
        $status_id,
        $_rest_orders_statuses_status_id = null,
        string $contentType = self::contentTypes['restOrdersStatusesStatusIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\OrderStatus';
        $request = $this->restOrdersStatusesStatusIdPutRequest($status_id, $_rest_orders_statuses_status_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersStatusesStatusIdPut'
     *
     * @param  float $status_id The ID of the order status that should be updated. (required)
     * @param  \ck\Model\RestOrdersStatusesStatusIdPutRequest|null $_rest_orders_statuses_status_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersStatusesStatusIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersStatusesStatusIdPutRequest(
        $status_id,
        $_rest_orders_statuses_status_id = null,
        string $contentType = self::contentTypes['restOrdersStatusesStatusIdPut'][0]
    ): Request
    {

        // verify the required parameter 'status_id' is set
        if ($status_id === null || (is_array($status_id) && count($status_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $status_id when calling restOrdersStatusesStatusIdPut'
            );
        }



        $resourcePath = '/rest/orders/statuses/{statusId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($status_id !== null) {
            $resourcePath = str_replace(
                '{' . 'statusId' . '}',
                ObjectSerializer::toPathValue($status_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_orders_statuses_status_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_orders_statuses_status_id));
            } else {
                $httpBody = $_rest_orders_statuses_status_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restRedistributionsOrderIdDelete
     *
     * Delete a redistribution
     *
     * @param  int $order_id order_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restRedistributionsOrderIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restRedistributionsOrderIdDelete(
        int $order_id,
        string $contentType = self::contentTypes['restRedistributionsOrderIdDelete'][0]
    ): object
    {
        list($response) = $this->restRedistributionsOrderIdDeleteWithHttpInfo($order_id, $contentType);
        return $response;
    }

    /**
     * Operation restRedistributionsOrderIdDeleteWithHttpInfo
     *
     * Delete a redistribution
     *
     * @param  int $order_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restRedistributionsOrderIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restRedistributionsOrderIdDeleteWithHttpInfo(
        int $order_id,
        string $contentType = self::contentTypes['restRedistributionsOrderIdDelete'][0]
    ): array
    {
        $request = $this->restRedistributionsOrderIdDeleteRequest($order_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restRedistributionsOrderIdDeleteAsync
     *
     * Delete a redistribution
     *
     * @param  int $order_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restRedistributionsOrderIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restRedistributionsOrderIdDeleteAsync(
        int $order_id,
        string $contentType = self::contentTypes['restRedistributionsOrderIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restRedistributionsOrderIdDeleteAsyncWithHttpInfo($order_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restRedistributionsOrderIdDeleteAsyncWithHttpInfo
     *
     * Delete a redistribution
     *
     * @param  int $order_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restRedistributionsOrderIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restRedistributionsOrderIdDeleteAsyncWithHttpInfo(
        $order_id,
        string $contentType = self::contentTypes['restRedistributionsOrderIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restRedistributionsOrderIdDeleteRequest($order_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restRedistributionsOrderIdDelete'
     *
     * @param  int $order_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restRedistributionsOrderIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restRedistributionsOrderIdDeleteRequest(
        $order_id,
        string $contentType = self::contentTypes['restRedistributionsOrderIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restRedistributionsOrderIdDelete'
            );
        }


        $resourcePath = '/rest/redistributions/{orderId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restRedistributionsOrderIdPut
     *
     * Update a redistribution
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  \ck\Model\RestRedistributionsPostRequest|null $_rest_redistributions_order_id _rest_redistributions_order_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restRedistributionsOrderIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Order
     */
    public function restRedistributionsOrderIdPut(
        int $order_id,
        ?\ck\Model\RestRedistributionsPostRequest $_rest_redistributions_order_id = null,
        string $contentType = self::contentTypes['restRedistributionsOrderIdPut'][0]
    ): \ck\Model\Order
    {
        list($response) = $this->restRedistributionsOrderIdPutWithHttpInfo($order_id, $_rest_redistributions_order_id, $contentType);
        return $response;
    }

    /**
     * Operation restRedistributionsOrderIdPutWithHttpInfo
     *
     * Update a redistribution
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  \ck\Model\RestRedistributionsPostRequest|null $_rest_redistributions_order_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restRedistributionsOrderIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Order, HTTP status code, HTTP response headers (array of strings)
     */
    public function restRedistributionsOrderIdPutWithHttpInfo(
        int $order_id,
        ?\ck\Model\RestRedistributionsPostRequest $_rest_redistributions_order_id = null,
        string $contentType = self::contentTypes['restRedistributionsOrderIdPut'][0]
    ): array
    {
        $request = $this->restRedistributionsOrderIdPutRequest($order_id, $_rest_redistributions_order_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Order' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Order' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Order', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Order';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Order',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restRedistributionsOrderIdPutAsync
     *
     * Update a redistribution
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  \ck\Model\RestRedistributionsPostRequest|null $_rest_redistributions_order_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restRedistributionsOrderIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restRedistributionsOrderIdPutAsync(
        int $order_id,
        ?\ck\Model\RestRedistributionsPostRequest $_rest_redistributions_order_id = null,
        string $contentType = self::contentTypes['restRedistributionsOrderIdPut'][0]
    ): PromiseInterface
    {
        return $this->restRedistributionsOrderIdPutAsyncWithHttpInfo($order_id, $_rest_redistributions_order_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restRedistributionsOrderIdPutAsyncWithHttpInfo
     *
     * Update a redistribution
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  \ck\Model\RestRedistributionsPostRequest|null $_rest_redistributions_order_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restRedistributionsOrderIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restRedistributionsOrderIdPutAsyncWithHttpInfo(
        $order_id,
        $_rest_redistributions_order_id = null,
        string $contentType = self::contentTypes['restRedistributionsOrderIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Order';
        $request = $this->restRedistributionsOrderIdPutRequest($order_id, $_rest_redistributions_order_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restRedistributionsOrderIdPut'
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  \ck\Model\RestRedistributionsPostRequest|null $_rest_redistributions_order_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restRedistributionsOrderIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restRedistributionsOrderIdPutRequest(
        $order_id,
        $_rest_redistributions_order_id = null,
        string $contentType = self::contentTypes['restRedistributionsOrderIdPut'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restRedistributionsOrderIdPut'
            );
        }



        $resourcePath = '/rest/redistributions/{orderId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_redistributions_order_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_redistributions_order_id));
            } else {
                $httpBody = $_rest_redistributions_order_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restRedistributionsPost
     *
     * Create a redistribution
     *
     * @param  \ck\Model\RestRedistributionsPostRequest|null $_rest_redistributions _rest_redistributions (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restRedistributionsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Order
     */
    public function restRedistributionsPost(
        ?\ck\Model\RestRedistributionsPostRequest $_rest_redistributions = null,
        string $contentType = self::contentTypes['restRedistributionsPost'][0]
    ): \ck\Model\Order
    {
        list($response) = $this->restRedistributionsPostWithHttpInfo($_rest_redistributions, $contentType);
        return $response;
    }

    /**
     * Operation restRedistributionsPostWithHttpInfo
     *
     * Create a redistribution
     *
     * @param  \ck\Model\RestRedistributionsPostRequest|null $_rest_redistributions (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restRedistributionsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Order, HTTP status code, HTTP response headers (array of strings)
     */
    public function restRedistributionsPostWithHttpInfo(
        ?\ck\Model\RestRedistributionsPostRequest $_rest_redistributions = null,
        string $contentType = self::contentTypes['restRedistributionsPost'][0]
    ): array
    {
        $request = $this->restRedistributionsPostRequest($_rest_redistributions, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Order' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Order' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Order', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Order';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Order',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restRedistributionsPostAsync
     *
     * Create a redistribution
     *
     * @param  \ck\Model\RestRedistributionsPostRequest|null $_rest_redistributions (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restRedistributionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restRedistributionsPostAsync(
        ?\ck\Model\RestRedistributionsPostRequest $_rest_redistributions = null,
        string $contentType = self::contentTypes['restRedistributionsPost'][0]
    ): PromiseInterface
    {
        return $this->restRedistributionsPostAsyncWithHttpInfo($_rest_redistributions, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restRedistributionsPostAsyncWithHttpInfo
     *
     * Create a redistribution
     *
     * @param  \ck\Model\RestRedistributionsPostRequest|null $_rest_redistributions (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restRedistributionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restRedistributionsPostAsyncWithHttpInfo(
        $_rest_redistributions = null,
        string $contentType = self::contentTypes['restRedistributionsPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Order';
        $request = $this->restRedistributionsPostRequest($_rest_redistributions, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restRedistributionsPost'
     *
     * @param  \ck\Model\RestRedistributionsPostRequest|null $_rest_redistributions (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restRedistributionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restRedistributionsPostRequest(
        $_rest_redistributions = null,
        string $contentType = self::contentTypes['restRedistributionsPost'][0]
    ): Request
    {



        $resourcePath = '/rest/redistributions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_redistributions)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_redistributions));
            } else {
                $httpBody = $_rest_redistributions;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restReordersOrderIdCurrencyPut
     *
     * Update the currency
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restReordersOrderIdCurrencyPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Order
     */
    public function restReordersOrderIdCurrencyPut(
        int $order_id,
        string $contentType = self::contentTypes['restReordersOrderIdCurrencyPut'][0]
    ): \ck\Model\Order
    {
        list($response) = $this->restReordersOrderIdCurrencyPutWithHttpInfo($order_id, $contentType);
        return $response;
    }

    /**
     * Operation restReordersOrderIdCurrencyPutWithHttpInfo
     *
     * Update the currency
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restReordersOrderIdCurrencyPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Order, HTTP status code, HTTP response headers (array of strings)
     */
    public function restReordersOrderIdCurrencyPutWithHttpInfo(
        int $order_id,
        string $contentType = self::contentTypes['restReordersOrderIdCurrencyPut'][0]
    ): array
    {
        $request = $this->restReordersOrderIdCurrencyPutRequest($order_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Order' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Order' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Order', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Order';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Order',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restReordersOrderIdCurrencyPutAsync
     *
     * Update the currency
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restReordersOrderIdCurrencyPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restReordersOrderIdCurrencyPutAsync(
        int $order_id,
        string $contentType = self::contentTypes['restReordersOrderIdCurrencyPut'][0]
    ): PromiseInterface
    {
        return $this->restReordersOrderIdCurrencyPutAsyncWithHttpInfo($order_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restReordersOrderIdCurrencyPutAsyncWithHttpInfo
     *
     * Update the currency
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restReordersOrderIdCurrencyPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restReordersOrderIdCurrencyPutAsyncWithHttpInfo(
        $order_id,
        string $contentType = self::contentTypes['restReordersOrderIdCurrencyPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Order';
        $request = $this->restReordersOrderIdCurrencyPutRequest($order_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restReordersOrderIdCurrencyPut'
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restReordersOrderIdCurrencyPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restReordersOrderIdCurrencyPutRequest(
        $order_id,
        string $contentType = self::contentTypes['restReordersOrderIdCurrencyPut'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restReordersOrderIdCurrencyPut'
            );
        }


        $resourcePath = '/rest/reorders/{orderId}/currency';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restReordersOrderIdDelete
     *
     * Delete a reorder
     *
     * @param  int $order_id order_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restReordersOrderIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restReordersOrderIdDelete(
        int $order_id,
        string $contentType = self::contentTypes['restReordersOrderIdDelete'][0]
    ): object
    {
        list($response) = $this->restReordersOrderIdDeleteWithHttpInfo($order_id, $contentType);
        return $response;
    }

    /**
     * Operation restReordersOrderIdDeleteWithHttpInfo
     *
     * Delete a reorder
     *
     * @param  int $order_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restReordersOrderIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restReordersOrderIdDeleteWithHttpInfo(
        int $order_id,
        string $contentType = self::contentTypes['restReordersOrderIdDelete'][0]
    ): array
    {
        $request = $this->restReordersOrderIdDeleteRequest($order_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restReordersOrderIdDeleteAsync
     *
     * Delete a reorder
     *
     * @param  int $order_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restReordersOrderIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restReordersOrderIdDeleteAsync(
        int $order_id,
        string $contentType = self::contentTypes['restReordersOrderIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restReordersOrderIdDeleteAsyncWithHttpInfo($order_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restReordersOrderIdDeleteAsyncWithHttpInfo
     *
     * Delete a reorder
     *
     * @param  int $order_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restReordersOrderIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restReordersOrderIdDeleteAsyncWithHttpInfo(
        $order_id,
        string $contentType = self::contentTypes['restReordersOrderIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restReordersOrderIdDeleteRequest($order_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restReordersOrderIdDelete'
     *
     * @param  int $order_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restReordersOrderIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restReordersOrderIdDeleteRequest(
        $order_id,
        string $contentType = self::contentTypes['restReordersOrderIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restReordersOrderIdDelete'
            );
        }


        $resourcePath = '/rest/reorders/{orderId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restReordersOrderIdDeliveryDateGet
     *
     * Get the delivery date
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restReordersOrderIdDeliveryDateGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restReordersOrderIdDeliveryDateGet(
        int $order_id,
        string $contentType = self::contentTypes['restReordersOrderIdDeliveryDateGet'][0]
    ): object
    {
        list($response) = $this->restReordersOrderIdDeliveryDateGetWithHttpInfo($order_id, $contentType);
        return $response;
    }

    /**
     * Operation restReordersOrderIdDeliveryDateGetWithHttpInfo
     *
     * Get the delivery date
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restReordersOrderIdDeliveryDateGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restReordersOrderIdDeliveryDateGetWithHttpInfo(
        int $order_id,
        string $contentType = self::contentTypes['restReordersOrderIdDeliveryDateGet'][0]
    ): array
    {
        $request = $this->restReordersOrderIdDeliveryDateGetRequest($order_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restReordersOrderIdDeliveryDateGetAsync
     *
     * Get the delivery date
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restReordersOrderIdDeliveryDateGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restReordersOrderIdDeliveryDateGetAsync(
        int $order_id,
        string $contentType = self::contentTypes['restReordersOrderIdDeliveryDateGet'][0]
    ): PromiseInterface
    {
        return $this->restReordersOrderIdDeliveryDateGetAsyncWithHttpInfo($order_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restReordersOrderIdDeliveryDateGetAsyncWithHttpInfo
     *
     * Get the delivery date
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restReordersOrderIdDeliveryDateGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restReordersOrderIdDeliveryDateGetAsyncWithHttpInfo(
        $order_id,
        string $contentType = self::contentTypes['restReordersOrderIdDeliveryDateGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restReordersOrderIdDeliveryDateGetRequest($order_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restReordersOrderIdDeliveryDateGet'
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restReordersOrderIdDeliveryDateGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restReordersOrderIdDeliveryDateGetRequest(
        $order_id,
        string $contentType = self::contentTypes['restReordersOrderIdDeliveryDateGet'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restReordersOrderIdDeliveryDateGet'
            );
        }


        $resourcePath = '/rest/reorders/{orderId}/delivery_date';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restReordersOrderIdDeliveryDatesPut
     *
     * Calculate and save the delivery dates
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restReordersOrderIdDeliveryDatesPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Order
     */
    public function restReordersOrderIdDeliveryDatesPut(
        int $order_id,
        string $contentType = self::contentTypes['restReordersOrderIdDeliveryDatesPut'][0]
    ): \ck\Model\Order
    {
        list($response) = $this->restReordersOrderIdDeliveryDatesPutWithHttpInfo($order_id, $contentType);
        return $response;
    }

    /**
     * Operation restReordersOrderIdDeliveryDatesPutWithHttpInfo
     *
     * Calculate and save the delivery dates
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restReordersOrderIdDeliveryDatesPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Order, HTTP status code, HTTP response headers (array of strings)
     */
    public function restReordersOrderIdDeliveryDatesPutWithHttpInfo(
        int $order_id,
        string $contentType = self::contentTypes['restReordersOrderIdDeliveryDatesPut'][0]
    ): array
    {
        $request = $this->restReordersOrderIdDeliveryDatesPutRequest($order_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Order' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Order' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Order', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Order';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Order',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restReordersOrderIdDeliveryDatesPutAsync
     *
     * Calculate and save the delivery dates
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restReordersOrderIdDeliveryDatesPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restReordersOrderIdDeliveryDatesPutAsync(
        int $order_id,
        string $contentType = self::contentTypes['restReordersOrderIdDeliveryDatesPut'][0]
    ): PromiseInterface
    {
        return $this->restReordersOrderIdDeliveryDatesPutAsyncWithHttpInfo($order_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restReordersOrderIdDeliveryDatesPutAsyncWithHttpInfo
     *
     * Calculate and save the delivery dates
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restReordersOrderIdDeliveryDatesPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restReordersOrderIdDeliveryDatesPutAsyncWithHttpInfo(
        $order_id,
        string $contentType = self::contentTypes['restReordersOrderIdDeliveryDatesPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Order';
        $request = $this->restReordersOrderIdDeliveryDatesPutRequest($order_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restReordersOrderIdDeliveryDatesPut'
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restReordersOrderIdDeliveryDatesPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restReordersOrderIdDeliveryDatesPutRequest(
        $order_id,
        string $contentType = self::contentTypes['restReordersOrderIdDeliveryDatesPut'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restReordersOrderIdDeliveryDatesPut'
            );
        }


        $resourcePath = '/rest/reorders/{orderId}/delivery_dates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restReordersOrderIdPut
     *
     * Update a reorder
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  \ck\Model\RestReordersPostRequest|null $_rest_reorders_order_id _rest_reorders_order_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restReordersOrderIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Order
     */
    public function restReordersOrderIdPut(
        int $order_id,
        ?\ck\Model\RestReordersPostRequest $_rest_reorders_order_id = null,
        string $contentType = self::contentTypes['restReordersOrderIdPut'][0]
    ): \ck\Model\Order
    {
        list($response) = $this->restReordersOrderIdPutWithHttpInfo($order_id, $_rest_reorders_order_id, $contentType);
        return $response;
    }

    /**
     * Operation restReordersOrderIdPutWithHttpInfo
     *
     * Update a reorder
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  \ck\Model\RestReordersPostRequest|null $_rest_reorders_order_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restReordersOrderIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Order, HTTP status code, HTTP response headers (array of strings)
     */
    public function restReordersOrderIdPutWithHttpInfo(
        int $order_id,
        ?\ck\Model\RestReordersPostRequest $_rest_reorders_order_id = null,
        string $contentType = self::contentTypes['restReordersOrderIdPut'][0]
    ): array
    {
        $request = $this->restReordersOrderIdPutRequest($order_id, $_rest_reorders_order_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Order' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Order' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Order', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Order';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Order',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restReordersOrderIdPutAsync
     *
     * Update a reorder
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  \ck\Model\RestReordersPostRequest|null $_rest_reorders_order_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restReordersOrderIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restReordersOrderIdPutAsync(
        int $order_id,
        ?\ck\Model\RestReordersPostRequest $_rest_reorders_order_id = null,
        string $contentType = self::contentTypes['restReordersOrderIdPut'][0]
    ): PromiseInterface
    {
        return $this->restReordersOrderIdPutAsyncWithHttpInfo($order_id, $_rest_reorders_order_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restReordersOrderIdPutAsyncWithHttpInfo
     *
     * Update a reorder
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  \ck\Model\RestReordersPostRequest|null $_rest_reorders_order_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restReordersOrderIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restReordersOrderIdPutAsyncWithHttpInfo(
        $order_id,
        $_rest_reorders_order_id = null,
        string $contentType = self::contentTypes['restReordersOrderIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Order';
        $request = $this->restReordersOrderIdPutRequest($order_id, $_rest_reorders_order_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restReordersOrderIdPut'
     *
     * @param  int $order_id The ID of the order. (required)
     * @param  \ck\Model\RestReordersPostRequest|null $_rest_reorders_order_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restReordersOrderIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restReordersOrderIdPutRequest(
        $order_id,
        $_rest_reorders_order_id = null,
        string $contentType = self::contentTypes['restReordersOrderIdPut'][0]
    ): Request
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $order_id when calling restReordersOrderIdPut'
            );
        }



        $resourcePath = '/rest/reorders/{orderId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_reorders_order_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_reorders_order_id));
            } else {
                $httpBody = $_rest_reorders_order_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restReordersPost
     *
     * Create a reorder
     *
     * @param  \ck\Model\RestReordersPostRequest|null $_rest_reorders _rest_reorders (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restReordersPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Order
     */
    public function restReordersPost(
        ?\ck\Model\RestReordersPostRequest $_rest_reorders = null,
        string $contentType = self::contentTypes['restReordersPost'][0]
    ): \ck\Model\Order
    {
        list($response) = $this->restReordersPostWithHttpInfo($_rest_reorders, $contentType);
        return $response;
    }

    /**
     * Operation restReordersPostWithHttpInfo
     *
     * Create a reorder
     *
     * @param  \ck\Model\RestReordersPostRequest|null $_rest_reorders (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restReordersPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Order, HTTP status code, HTTP response headers (array of strings)
     */
    public function restReordersPostWithHttpInfo(
        ?\ck\Model\RestReordersPostRequest $_rest_reorders = null,
        string $contentType = self::contentTypes['restReordersPost'][0]
    ): array
    {
        $request = $this->restReordersPostRequest($_rest_reorders, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Order' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Order' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Order', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Order';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Order',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restReordersPostAsync
     *
     * Create a reorder
     *
     * @param  \ck\Model\RestReordersPostRequest|null $_rest_reorders (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restReordersPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restReordersPostAsync(
        ?\ck\Model\RestReordersPostRequest $_rest_reorders = null,
        string $contentType = self::contentTypes['restReordersPost'][0]
    ): PromiseInterface
    {
        return $this->restReordersPostAsyncWithHttpInfo($_rest_reorders, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restReordersPostAsyncWithHttpInfo
     *
     * Create a reorder
     *
     * @param  \ck\Model\RestReordersPostRequest|null $_rest_reorders (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restReordersPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restReordersPostAsyncWithHttpInfo(
        $_rest_reorders = null,
        string $contentType = self::contentTypes['restReordersPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Order';
        $request = $this->restReordersPostRequest($_rest_reorders, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restReordersPost'
     *
     * @param  \ck\Model\RestReordersPostRequest|null $_rest_reorders (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restReordersPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restReordersPostRequest(
        $_rest_reorders = null,
        string $contentType = self::contentTypes['restReordersPost'][0]
    ): Request
    {



        $resourcePath = '/rest/reorders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_reorders)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_reorders));
            } else {
                $httpBody = $_rest_reorders;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restSystemSettingsTaricVatAssignmentGet
     *
     * List taric vat assignments
     *
     * @param  int|null $page The requested page of results (optional)
     * @param  int|null $items_per_page The number of results per page (optional)
     * @param  int|null $country_id The country ID of the taric vat assignments (optional)
     * @param  int|null $taric_code The taric code of the taric vat assignments (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restSystemSettingsTaricVatAssignmentGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestSystemSettingsTaricVatAssignmentGet200Response
     */
    public function restSystemSettingsTaricVatAssignmentGet(
        ?int $page = null,
        ?int $items_per_page = null,
        ?int $country_id = null,
        ?int $taric_code = null,
        string $contentType = self::contentTypes['restSystemSettingsTaricVatAssignmentGet'][0]
    ): \ck\Model\RestSystemSettingsTaricVatAssignmentGet200Response
    {
        list($response) = $this->restSystemSettingsTaricVatAssignmentGetWithHttpInfo($page, $items_per_page, $country_id, $taric_code, $contentType);
        return $response;
    }

    /**
     * Operation restSystemSettingsTaricVatAssignmentGetWithHttpInfo
     *
     * List taric vat assignments
     *
     * @param  int|null $page The requested page of results (optional)
     * @param  int|null $items_per_page The number of results per page (optional)
     * @param  int|null $country_id The country ID of the taric vat assignments (optional)
     * @param  int|null $taric_code The taric code of the taric vat assignments (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restSystemSettingsTaricVatAssignmentGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestSystemSettingsTaricVatAssignmentGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restSystemSettingsTaricVatAssignmentGetWithHttpInfo(
        ?int $page = null,
        ?int $items_per_page = null,
        ?int $country_id = null,
        ?int $taric_code = null,
        string $contentType = self::contentTypes['restSystemSettingsTaricVatAssignmentGet'][0]
    ): array
    {
        $request = $this->restSystemSettingsTaricVatAssignmentGetRequest($page, $items_per_page, $country_id, $taric_code, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestSystemSettingsTaricVatAssignmentGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestSystemSettingsTaricVatAssignmentGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestSystemSettingsTaricVatAssignmentGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestSystemSettingsTaricVatAssignmentGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestSystemSettingsTaricVatAssignmentGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restSystemSettingsTaricVatAssignmentGetAsync
     *
     * List taric vat assignments
     *
     * @param  int|null $page The requested page of results (optional)
     * @param  int|null $items_per_page The number of results per page (optional)
     * @param  int|null $country_id The country ID of the taric vat assignments (optional)
     * @param  int|null $taric_code The taric code of the taric vat assignments (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restSystemSettingsTaricVatAssignmentGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restSystemSettingsTaricVatAssignmentGetAsync(
        ?int $page = null,
        ?int $items_per_page = null,
        ?int $country_id = null,
        ?int $taric_code = null,
        string $contentType = self::contentTypes['restSystemSettingsTaricVatAssignmentGet'][0]
    ): PromiseInterface
    {
        return $this->restSystemSettingsTaricVatAssignmentGetAsyncWithHttpInfo($page, $items_per_page, $country_id, $taric_code, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restSystemSettingsTaricVatAssignmentGetAsyncWithHttpInfo
     *
     * List taric vat assignments
     *
     * @param  int|null $page The requested page of results (optional)
     * @param  int|null $items_per_page The number of results per page (optional)
     * @param  int|null $country_id The country ID of the taric vat assignments (optional)
     * @param  int|null $taric_code The taric code of the taric vat assignments (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restSystemSettingsTaricVatAssignmentGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restSystemSettingsTaricVatAssignmentGetAsyncWithHttpInfo(
        $page = null,
        $items_per_page = null,
        $country_id = null,
        $taric_code = null,
        string $contentType = self::contentTypes['restSystemSettingsTaricVatAssignmentGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestSystemSettingsTaricVatAssignmentGet200Response';
        $request = $this->restSystemSettingsTaricVatAssignmentGetRequest($page, $items_per_page, $country_id, $taric_code, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restSystemSettingsTaricVatAssignmentGet'
     *
     * @param  int|null $page The requested page of results (optional)
     * @param  int|null $items_per_page The number of results per page (optional)
     * @param  int|null $country_id The country ID of the taric vat assignments (optional)
     * @param  int|null $taric_code The taric code of the taric vat assignments (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restSystemSettingsTaricVatAssignmentGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restSystemSettingsTaricVatAssignmentGetRequest(
        $page = null,
        $items_per_page = null,
        $country_id = null,
        $taric_code = null,
        string $contentType = self::contentTypes['restSystemSettingsTaricVatAssignmentGet'][0]
    ): Request
    {






        $resourcePath = '/rest/system/settings/taric_vat_assignment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $items_per_page,
            'itemsPerPage', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $country_id,
            'countryId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $taric_code,
            'taricCode', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restSystemSettingsTaricVatAssignmentTaricCodeCountryIdDelete
     *
     * Delete taric vat assignment
     *
     * @param  string $taric_code The taric code. (required)
     * @param  int $country_id The country id. (required)
     * @param  \ck\Model\RestSystemSettingsTaricVatAssignmentTaricCodeCountryIdDeleteRequest|null $_rest_system_settings_taric_vat_assignment_taric_code_country_id _rest_system_settings_taric_vat_assignment_taric_code_country_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restSystemSettingsTaricVatAssignmentTaricCodeCountryIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restSystemSettingsTaricVatAssignmentTaricCodeCountryIdDelete(
        string $taric_code,
        int $country_id,
        ?\ck\Model\RestSystemSettingsTaricVatAssignmentTaricCodeCountryIdDeleteRequest $_rest_system_settings_taric_vat_assignment_taric_code_country_id = null,
        string $contentType = self::contentTypes['restSystemSettingsTaricVatAssignmentTaricCodeCountryIdDelete'][0]
    ): object
    {
        list($response) = $this->restSystemSettingsTaricVatAssignmentTaricCodeCountryIdDeleteWithHttpInfo($taric_code, $country_id, $_rest_system_settings_taric_vat_assignment_taric_code_country_id, $contentType);
        return $response;
    }

    /**
     * Operation restSystemSettingsTaricVatAssignmentTaricCodeCountryIdDeleteWithHttpInfo
     *
     * Delete taric vat assignment
     *
     * @param  string $taric_code The taric code. (required)
     * @param  int $country_id The country id. (required)
     * @param  \ck\Model\RestSystemSettingsTaricVatAssignmentTaricCodeCountryIdDeleteRequest|null $_rest_system_settings_taric_vat_assignment_taric_code_country_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restSystemSettingsTaricVatAssignmentTaricCodeCountryIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restSystemSettingsTaricVatAssignmentTaricCodeCountryIdDeleteWithHttpInfo(
        string $taric_code,
        int $country_id,
        ?\ck\Model\RestSystemSettingsTaricVatAssignmentTaricCodeCountryIdDeleteRequest $_rest_system_settings_taric_vat_assignment_taric_code_country_id = null,
        string $contentType = self::contentTypes['restSystemSettingsTaricVatAssignmentTaricCodeCountryIdDelete'][0]
    ): array
    {
        $request = $this->restSystemSettingsTaricVatAssignmentTaricCodeCountryIdDeleteRequest($taric_code, $country_id, $_rest_system_settings_taric_vat_assignment_taric_code_country_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restSystemSettingsTaricVatAssignmentTaricCodeCountryIdDeleteAsync
     *
     * Delete taric vat assignment
     *
     * @param  string $taric_code The taric code. (required)
     * @param  int $country_id The country id. (required)
     * @param  \ck\Model\RestSystemSettingsTaricVatAssignmentTaricCodeCountryIdDeleteRequest|null $_rest_system_settings_taric_vat_assignment_taric_code_country_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restSystemSettingsTaricVatAssignmentTaricCodeCountryIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restSystemSettingsTaricVatAssignmentTaricCodeCountryIdDeleteAsync(
        string $taric_code,
        int $country_id,
        ?\ck\Model\RestSystemSettingsTaricVatAssignmentTaricCodeCountryIdDeleteRequest $_rest_system_settings_taric_vat_assignment_taric_code_country_id = null,
        string $contentType = self::contentTypes['restSystemSettingsTaricVatAssignmentTaricCodeCountryIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restSystemSettingsTaricVatAssignmentTaricCodeCountryIdDeleteAsyncWithHttpInfo($taric_code, $country_id, $_rest_system_settings_taric_vat_assignment_taric_code_country_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restSystemSettingsTaricVatAssignmentTaricCodeCountryIdDeleteAsyncWithHttpInfo
     *
     * Delete taric vat assignment
     *
     * @param  string $taric_code The taric code. (required)
     * @param  int $country_id The country id. (required)
     * @param  \ck\Model\RestSystemSettingsTaricVatAssignmentTaricCodeCountryIdDeleteRequest|null $_rest_system_settings_taric_vat_assignment_taric_code_country_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restSystemSettingsTaricVatAssignmentTaricCodeCountryIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restSystemSettingsTaricVatAssignmentTaricCodeCountryIdDeleteAsyncWithHttpInfo(
        $taric_code,
        $country_id,
        $_rest_system_settings_taric_vat_assignment_taric_code_country_id = null,
        string $contentType = self::contentTypes['restSystemSettingsTaricVatAssignmentTaricCodeCountryIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restSystemSettingsTaricVatAssignmentTaricCodeCountryIdDeleteRequest($taric_code, $country_id, $_rest_system_settings_taric_vat_assignment_taric_code_country_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restSystemSettingsTaricVatAssignmentTaricCodeCountryIdDelete'
     *
     * @param  string $taric_code The taric code. (required)
     * @param  int $country_id The country id. (required)
     * @param  \ck\Model\RestSystemSettingsTaricVatAssignmentTaricCodeCountryIdDeleteRequest|null $_rest_system_settings_taric_vat_assignment_taric_code_country_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restSystemSettingsTaricVatAssignmentTaricCodeCountryIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restSystemSettingsTaricVatAssignmentTaricCodeCountryIdDeleteRequest(
        $taric_code,
        $country_id,
        $_rest_system_settings_taric_vat_assignment_taric_code_country_id = null,
        string $contentType = self::contentTypes['restSystemSettingsTaricVatAssignmentTaricCodeCountryIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'taric_code' is set
        if ($taric_code === null || (is_array($taric_code) && count($taric_code) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $taric_code when calling restSystemSettingsTaricVatAssignmentTaricCodeCountryIdDelete'
            );
        }

        // verify the required parameter 'country_id' is set
        if ($country_id === null || (is_array($country_id) && count($country_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $country_id when calling restSystemSettingsTaricVatAssignmentTaricCodeCountryIdDelete'
            );
        }



        $resourcePath = '/rest/system/settings/taric_vat_assignment/{taricCode}/{countryId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($taric_code !== null) {
            $resourcePath = str_replace(
                '{' . 'taricCode' . '}',
                ObjectSerializer::toPathValue($taric_code),
                $resourcePath
            );
        }
        // path params
        if ($country_id !== null) {
            $resourcePath = str_replace(
                '{' . 'countryId' . '}',
                ObjectSerializer::toPathValue($country_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_system_settings_taric_vat_assignment_taric_code_country_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_system_settings_taric_vat_assignment_taric_code_country_id));
            } else {
                $httpBody = $_rest_system_settings_taric_vat_assignment_taric_code_country_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restSystemSettingsTaricVatAssignmentTaricCodeCountryIdGet
     *
     * Get taric vat assignment
     *
     * @param  string $taric_code The taric code. (required)
     * @param  int $country_id The country id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restSystemSettingsTaricVatAssignmentTaricCodeCountryIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\TaricVatAssignment
     */
    public function restSystemSettingsTaricVatAssignmentTaricCodeCountryIdGet(
        string $taric_code,
        int $country_id,
        string $contentType = self::contentTypes['restSystemSettingsTaricVatAssignmentTaricCodeCountryIdGet'][0]
    ): \ck\Model\TaricVatAssignment
    {
        list($response) = $this->restSystemSettingsTaricVatAssignmentTaricCodeCountryIdGetWithHttpInfo($taric_code, $country_id, $contentType);
        return $response;
    }

    /**
     * Operation restSystemSettingsTaricVatAssignmentTaricCodeCountryIdGetWithHttpInfo
     *
     * Get taric vat assignment
     *
     * @param  string $taric_code The taric code. (required)
     * @param  int $country_id The country id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restSystemSettingsTaricVatAssignmentTaricCodeCountryIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\TaricVatAssignment, HTTP status code, HTTP response headers (array of strings)
     */
    public function restSystemSettingsTaricVatAssignmentTaricCodeCountryIdGetWithHttpInfo(
        string $taric_code,
        int $country_id,
        string $contentType = self::contentTypes['restSystemSettingsTaricVatAssignmentTaricCodeCountryIdGet'][0]
    ): array
    {
        $request = $this->restSystemSettingsTaricVatAssignmentTaricCodeCountryIdGetRequest($taric_code, $country_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\TaricVatAssignment' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\TaricVatAssignment' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\TaricVatAssignment', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\TaricVatAssignment';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\TaricVatAssignment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restSystemSettingsTaricVatAssignmentTaricCodeCountryIdGetAsync
     *
     * Get taric vat assignment
     *
     * @param  string $taric_code The taric code. (required)
     * @param  int $country_id The country id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restSystemSettingsTaricVatAssignmentTaricCodeCountryIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restSystemSettingsTaricVatAssignmentTaricCodeCountryIdGetAsync(
        string $taric_code,
        int $country_id,
        string $contentType = self::contentTypes['restSystemSettingsTaricVatAssignmentTaricCodeCountryIdGet'][0]
    ): PromiseInterface
    {
        return $this->restSystemSettingsTaricVatAssignmentTaricCodeCountryIdGetAsyncWithHttpInfo($taric_code, $country_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restSystemSettingsTaricVatAssignmentTaricCodeCountryIdGetAsyncWithHttpInfo
     *
     * Get taric vat assignment
     *
     * @param  string $taric_code The taric code. (required)
     * @param  int $country_id The country id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restSystemSettingsTaricVatAssignmentTaricCodeCountryIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restSystemSettingsTaricVatAssignmentTaricCodeCountryIdGetAsyncWithHttpInfo(
        $taric_code,
        $country_id,
        string $contentType = self::contentTypes['restSystemSettingsTaricVatAssignmentTaricCodeCountryIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\TaricVatAssignment';
        $request = $this->restSystemSettingsTaricVatAssignmentTaricCodeCountryIdGetRequest($taric_code, $country_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restSystemSettingsTaricVatAssignmentTaricCodeCountryIdGet'
     *
     * @param  string $taric_code The taric code. (required)
     * @param  int $country_id The country id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restSystemSettingsTaricVatAssignmentTaricCodeCountryIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restSystemSettingsTaricVatAssignmentTaricCodeCountryIdGetRequest(
        $taric_code,
        $country_id,
        string $contentType = self::contentTypes['restSystemSettingsTaricVatAssignmentTaricCodeCountryIdGet'][0]
    ): Request
    {

        // verify the required parameter 'taric_code' is set
        if ($taric_code === null || (is_array($taric_code) && count($taric_code) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $taric_code when calling restSystemSettingsTaricVatAssignmentTaricCodeCountryIdGet'
            );
        }

        // verify the required parameter 'country_id' is set
        if ($country_id === null || (is_array($country_id) && count($country_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $country_id when calling restSystemSettingsTaricVatAssignmentTaricCodeCountryIdGet'
            );
        }


        $resourcePath = '/rest/system/settings/taric_vat_assignment/{taricCode}/{countryId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($taric_code !== null) {
            $resourcePath = str_replace(
                '{' . 'taricCode' . '}',
                ObjectSerializer::toPathValue($taric_code),
                $resourcePath
            );
        }
        // path params
        if ($country_id !== null) {
            $resourcePath = str_replace(
                '{' . 'countryId' . '}',
                ObjectSerializer::toPathValue($country_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPost
     *
     * Create taric vat assignment
     *
     * @param  string $taric_code The taric code. (required)
     * @param  int $country_id The country id. (required)
     * @param  \ck\Model\RestSystemSettingsTaricVatAssignmentTaricCodeCountryIdPutRequest|null $_rest_system_settings_taric_vat_assignment_taric_code_country_id _rest_system_settings_taric_vat_assignment_taric_code_country_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\TaricVatAssignment
     */
    public function restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPost(
        string $taric_code,
        int $country_id,
        ?\ck\Model\RestSystemSettingsTaricVatAssignmentTaricCodeCountryIdPutRequest $_rest_system_settings_taric_vat_assignment_taric_code_country_id = null,
        string $contentType = self::contentTypes['restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPost'][0]
    ): \ck\Model\TaricVatAssignment
    {
        list($response) = $this->restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPostWithHttpInfo($taric_code, $country_id, $_rest_system_settings_taric_vat_assignment_taric_code_country_id, $contentType);
        return $response;
    }

    /**
     * Operation restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPostWithHttpInfo
     *
     * Create taric vat assignment
     *
     * @param  string $taric_code The taric code. (required)
     * @param  int $country_id The country id. (required)
     * @param  \ck\Model\RestSystemSettingsTaricVatAssignmentTaricCodeCountryIdPutRequest|null $_rest_system_settings_taric_vat_assignment_taric_code_country_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\TaricVatAssignment, HTTP status code, HTTP response headers (array of strings)
     */
    public function restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPostWithHttpInfo(
        string $taric_code,
        int $country_id,
        ?\ck\Model\RestSystemSettingsTaricVatAssignmentTaricCodeCountryIdPutRequest $_rest_system_settings_taric_vat_assignment_taric_code_country_id = null,
        string $contentType = self::contentTypes['restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPost'][0]
    ): array
    {
        $request = $this->restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPostRequest($taric_code, $country_id, $_rest_system_settings_taric_vat_assignment_taric_code_country_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\TaricVatAssignment' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\TaricVatAssignment' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\TaricVatAssignment', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\TaricVatAssignment';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\TaricVatAssignment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPostAsync
     *
     * Create taric vat assignment
     *
     * @param  string $taric_code The taric code. (required)
     * @param  int $country_id The country id. (required)
     * @param  \ck\Model\RestSystemSettingsTaricVatAssignmentTaricCodeCountryIdPutRequest|null $_rest_system_settings_taric_vat_assignment_taric_code_country_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPostAsync(
        string $taric_code,
        int $country_id,
        ?\ck\Model\RestSystemSettingsTaricVatAssignmentTaricCodeCountryIdPutRequest $_rest_system_settings_taric_vat_assignment_taric_code_country_id = null,
        string $contentType = self::contentTypes['restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPost'][0]
    ): PromiseInterface
    {
        return $this->restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPostAsyncWithHttpInfo($taric_code, $country_id, $_rest_system_settings_taric_vat_assignment_taric_code_country_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPostAsyncWithHttpInfo
     *
     * Create taric vat assignment
     *
     * @param  string $taric_code The taric code. (required)
     * @param  int $country_id The country id. (required)
     * @param  \ck\Model\RestSystemSettingsTaricVatAssignmentTaricCodeCountryIdPutRequest|null $_rest_system_settings_taric_vat_assignment_taric_code_country_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPostAsyncWithHttpInfo(
        $taric_code,
        $country_id,
        $_rest_system_settings_taric_vat_assignment_taric_code_country_id = null,
        string $contentType = self::contentTypes['restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\TaricVatAssignment';
        $request = $this->restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPostRequest($taric_code, $country_id, $_rest_system_settings_taric_vat_assignment_taric_code_country_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPost'
     *
     * @param  string $taric_code The taric code. (required)
     * @param  int $country_id The country id. (required)
     * @param  \ck\Model\RestSystemSettingsTaricVatAssignmentTaricCodeCountryIdPutRequest|null $_rest_system_settings_taric_vat_assignment_taric_code_country_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPostRequest(
        $taric_code,
        $country_id,
        $_rest_system_settings_taric_vat_assignment_taric_code_country_id = null,
        string $contentType = self::contentTypes['restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPost'][0]
    ): Request
    {

        // verify the required parameter 'taric_code' is set
        if ($taric_code === null || (is_array($taric_code) && count($taric_code) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $taric_code when calling restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPost'
            );
        }

        // verify the required parameter 'country_id' is set
        if ($country_id === null || (is_array($country_id) && count($country_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $country_id when calling restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPost'
            );
        }



        $resourcePath = '/rest/system/settings/taric_vat_assignment/{taricCode}/{countryId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($taric_code !== null) {
            $resourcePath = str_replace(
                '{' . 'taricCode' . '}',
                ObjectSerializer::toPathValue($taric_code),
                $resourcePath
            );
        }
        // path params
        if ($country_id !== null) {
            $resourcePath = str_replace(
                '{' . 'countryId' . '}',
                ObjectSerializer::toPathValue($country_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_system_settings_taric_vat_assignment_taric_code_country_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_system_settings_taric_vat_assignment_taric_code_country_id));
            } else {
                $httpBody = $_rest_system_settings_taric_vat_assignment_taric_code_country_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPut
     *
     * Update taric vat assignment
     *
     * @param  string $taric_code The taric code. (required)
     * @param  int $country_id The country id. (required)
     * @param  \ck\Model\RestSystemSettingsTaricVatAssignmentTaricCodeCountryIdPutRequest|null $_rest_system_settings_taric_vat_assignment_taric_code_country_id _rest_system_settings_taric_vat_assignment_taric_code_country_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\TaricVatAssignment
     */
    public function restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPut(
        string $taric_code,
        int $country_id,
        ?\ck\Model\RestSystemSettingsTaricVatAssignmentTaricCodeCountryIdPutRequest $_rest_system_settings_taric_vat_assignment_taric_code_country_id = null,
        string $contentType = self::contentTypes['restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPut'][0]
    ): \ck\Model\TaricVatAssignment
    {
        list($response) = $this->restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPutWithHttpInfo($taric_code, $country_id, $_rest_system_settings_taric_vat_assignment_taric_code_country_id, $contentType);
        return $response;
    }

    /**
     * Operation restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPutWithHttpInfo
     *
     * Update taric vat assignment
     *
     * @param  string $taric_code The taric code. (required)
     * @param  int $country_id The country id. (required)
     * @param  \ck\Model\RestSystemSettingsTaricVatAssignmentTaricCodeCountryIdPutRequest|null $_rest_system_settings_taric_vat_assignment_taric_code_country_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\TaricVatAssignment, HTTP status code, HTTP response headers (array of strings)
     */
    public function restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPutWithHttpInfo(
        string $taric_code,
        int $country_id,
        ?\ck\Model\RestSystemSettingsTaricVatAssignmentTaricCodeCountryIdPutRequest $_rest_system_settings_taric_vat_assignment_taric_code_country_id = null,
        string $contentType = self::contentTypes['restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPut'][0]
    ): array
    {
        $request = $this->restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPutRequest($taric_code, $country_id, $_rest_system_settings_taric_vat_assignment_taric_code_country_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\TaricVatAssignment' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\TaricVatAssignment' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\TaricVatAssignment', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\TaricVatAssignment';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\TaricVatAssignment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPutAsync
     *
     * Update taric vat assignment
     *
     * @param  string $taric_code The taric code. (required)
     * @param  int $country_id The country id. (required)
     * @param  \ck\Model\RestSystemSettingsTaricVatAssignmentTaricCodeCountryIdPutRequest|null $_rest_system_settings_taric_vat_assignment_taric_code_country_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPutAsync(
        string $taric_code,
        int $country_id,
        ?\ck\Model\RestSystemSettingsTaricVatAssignmentTaricCodeCountryIdPutRequest $_rest_system_settings_taric_vat_assignment_taric_code_country_id = null,
        string $contentType = self::contentTypes['restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPut'][0]
    ): PromiseInterface
    {
        return $this->restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPutAsyncWithHttpInfo($taric_code, $country_id, $_rest_system_settings_taric_vat_assignment_taric_code_country_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPutAsyncWithHttpInfo
     *
     * Update taric vat assignment
     *
     * @param  string $taric_code The taric code. (required)
     * @param  int $country_id The country id. (required)
     * @param  \ck\Model\RestSystemSettingsTaricVatAssignmentTaricCodeCountryIdPutRequest|null $_rest_system_settings_taric_vat_assignment_taric_code_country_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPutAsyncWithHttpInfo(
        $taric_code,
        $country_id,
        $_rest_system_settings_taric_vat_assignment_taric_code_country_id = null,
        string $contentType = self::contentTypes['restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\TaricVatAssignment';
        $request = $this->restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPutRequest($taric_code, $country_id, $_rest_system_settings_taric_vat_assignment_taric_code_country_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPut'
     *
     * @param  string $taric_code The taric code. (required)
     * @param  int $country_id The country id. (required)
     * @param  \ck\Model\RestSystemSettingsTaricVatAssignmentTaricCodeCountryIdPutRequest|null $_rest_system_settings_taric_vat_assignment_taric_code_country_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPutRequest(
        $taric_code,
        $country_id,
        $_rest_system_settings_taric_vat_assignment_taric_code_country_id = null,
        string $contentType = self::contentTypes['restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPut'][0]
    ): Request
    {

        // verify the required parameter 'taric_code' is set
        if ($taric_code === null || (is_array($taric_code) && count($taric_code) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $taric_code when calling restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPut'
            );
        }

        // verify the required parameter 'country_id' is set
        if ($country_id === null || (is_array($country_id) && count($country_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $country_id when calling restSystemSettingsTaricVatAssignmentTaricCodeCountryIdPut'
            );
        }



        $resourcePath = '/rest/system/settings/taric_vat_assignment/{taricCode}/{countryId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($taric_code !== null) {
            $resourcePath = str_replace(
                '{' . 'taricCode' . '}',
                ObjectSerializer::toPathValue($taric_code),
                $resourcePath
            );
        }
        // path params
        if ($country_id !== null) {
            $resourcePath = str_replace(
                '{' . 'countryId' . '}',
                ObjectSerializer::toPathValue($country_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_system_settings_taric_vat_assignment_taric_code_country_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_system_settings_taric_vat_assignment_taric_code_country_id));
            } else {
                $httpBody = $_rest_system_settings_taric_vat_assignment_taric_code_country_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption(): array
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
