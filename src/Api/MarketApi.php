<?php
/**
 * MarketApi
 * PHP version 8.1
 *
 * @package  ck
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * plentymarkets REST-API
 *
 * The plentymarkets REST API expands the functionality of the plentymarkets CMS and allows access to resources, i.e. data records, via unique URI paths
 *
 * The version of the OpenAPI document: 1.0.0
 * @generated Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 7.1.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace ck\Api;

use InvalidArgumentException;
use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use GuzzleHttp\Promise\PromiseInterface;
use ck\ApiException;
use ck\Configuration;
use ck\HeaderSelector;
use ck\ObjectSerializer;

/**
 * MarketApi Class Doc Comment
 *
 * @package  ck
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class MarketApi
{
    /**
     * @var ClientInterface
     */
    protected ClientInterface $client;

    /**
     * @var Configuration
     */
    protected Configuration $config;

    /**
     * @var HeaderSelector
     */
    protected HeaderSelector $headerSelector;

    /**
     * @var int Host index
     */
    protected int $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'restMarketsCredentialsCredentialsIdDelete' => [
            'application/json',
        ],
        'restMarketsCredentialsCredentialsIdGet' => [
            'application/json',
        ],
        'restMarketsCredentialsCredentialsIdPut' => [
            'application/json',
        ],
        'restMarketsCredentialsGet' => [
            'application/json',
        ],
        'restMarketsCredentialsPost' => [
            'application/json',
        ],
        'restMarketsEbayAuthLoginGet' => [
            'application/json',
        ],
        'restMarketsEbayAuthRefreshTokenPut' => [
            'application/json',
        ],
        'restMarketsEbayCategoriesGet' => [
            'application/json',
        ],
        'restMarketsEbayCategoriesIdGet' => [
            'application/json',
        ],
        'restMarketsEbayFulfillmentPoliciesIdGet' => [
            'application/json',
        ],
        'restMarketsEbayItemSpecificsGet' => [
            'application/json',
        ],
        'restMarketsEbayMarketplacesGet' => [
            'application/json',
        ],
        'restMarketsEbayPartsFitmentsFitmentIdDelete' => [
            'application/json',
        ],
        'restMarketsEbayPartsFitmentsFitmentIdGet' => [
            'application/json',
        ],
        'restMarketsEbayPartsFitmentsFitmentIdPut' => [
            'application/json',
        ],
        'restMarketsEbayPartsFitmentsGet' => [
            'application/json',
        ],
        'restMarketsEbayPartsFitmentsPost' => [
            'application/json',
        ],
        'restMarketsEbayPartsFitmentsSearchGet' => [
            'application/json',
        ],
        'restMarketsEbayPaymentPoliciesIdGet' => [
            'application/json',
        ],
        'restMarketsEbayReturnPoliciesIdGet' => [
            'application/json',
        ],
        'restMarketsEbayShopCategoriesGet' => [
            'application/json',
        ],
        'restMarketsListingsMarketplacesGet' => [
            'application/json',
        ],
        'restMarketsSettingsBulkPost' => [
            'application/json',
        ],
        'restMarketsSettingsBulkPut' => [
            'application/json',
        ],
        'restMarketsSettingsCorrelationsBulkPost' => [
            'application/json',
        ],
        'restMarketsSettingsCorrelationsGet' => [
            'application/json',
        ],
        'restMarketsSettingsCorrelationsPost' => [
            'application/json',
        ],
        'restMarketsSettingsGet' => [
            'application/json',
        ],
        'restMarketsSettingsPost' => [
            'application/json',
        ],
        'restMarketsSettingsSettingIdDelete' => [
            'application/json',
        ],
        'restMarketsSettingsSettingIdGet' => [
            'application/json',
        ],
        'restMarketsSettingsSettingIdPut' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface|null $client
     * @param Configuration|null   $config
     * @param HeaderSelector|null  $selector
     * @param int                  $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex(int $hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex(): int
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig(): Configuration
    {
        return $this->config;
    }

    /**
     * Operation restMarketsCredentialsCredentialsIdDelete
     *
     * Delete a credential
     *
     * @param  int $id The ID of the credentials to be deleted. (required)
     * @param  int $credentials_id credentials_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsCredentialsCredentialsIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restMarketsCredentialsCredentialsIdDelete(
        int $id,
        int $credentials_id,
        string $contentType = self::contentTypes['restMarketsCredentialsCredentialsIdDelete'][0]
    ): object
    {
        list($response) = $this->restMarketsCredentialsCredentialsIdDeleteWithHttpInfo($id, $credentials_id, $contentType);
        return $response;
    }

    /**
     * Operation restMarketsCredentialsCredentialsIdDeleteWithHttpInfo
     *
     * Delete a credential
     *
     * @param  int $id The ID of the credentials to be deleted. (required)
     * @param  int $credentials_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsCredentialsCredentialsIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restMarketsCredentialsCredentialsIdDeleteWithHttpInfo(
        int $id,
        int $credentials_id,
        string $contentType = self::contentTypes['restMarketsCredentialsCredentialsIdDelete'][0]
    ): array
    {
        $request = $this->restMarketsCredentialsCredentialsIdDeleteRequest($id, $credentials_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restMarketsCredentialsCredentialsIdDeleteAsync
     *
     * Delete a credential
     *
     * @param  int $id The ID of the credentials to be deleted. (required)
     * @param  int $credentials_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsCredentialsCredentialsIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsCredentialsCredentialsIdDeleteAsync(
        int $id,
        int $credentials_id,
        string $contentType = self::contentTypes['restMarketsCredentialsCredentialsIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restMarketsCredentialsCredentialsIdDeleteAsyncWithHttpInfo($id, $credentials_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restMarketsCredentialsCredentialsIdDeleteAsyncWithHttpInfo
     *
     * Delete a credential
     *
     * @param  int $id The ID of the credentials to be deleted. (required)
     * @param  int $credentials_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsCredentialsCredentialsIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsCredentialsCredentialsIdDeleteAsyncWithHttpInfo(
        $id,
        $credentials_id,
        string $contentType = self::contentTypes['restMarketsCredentialsCredentialsIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restMarketsCredentialsCredentialsIdDeleteRequest($id, $credentials_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restMarketsCredentialsCredentialsIdDelete'
     *
     * @param  int $id The ID of the credentials to be deleted. (required)
     * @param  int $credentials_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsCredentialsCredentialsIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restMarketsCredentialsCredentialsIdDeleteRequest(
        $id,
        $credentials_id,
        string $contentType = self::contentTypes['restMarketsCredentialsCredentialsIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restMarketsCredentialsCredentialsIdDelete'
            );
        }

        // verify the required parameter 'credentials_id' is set
        if ($credentials_id === null || (is_array($credentials_id) && count($credentials_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $credentials_id when calling restMarketsCredentialsCredentialsIdDelete'
            );
        }


        $resourcePath = '/rest/markets/credentials/{credentialsId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);


        // path params
        if ($credentials_id !== null) {
            $resourcePath = str_replace(
                '{' . 'credentialsId' . '}',
                ObjectSerializer::toPathValue($credentials_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restMarketsCredentialsCredentialsIdGet
     *
     * Get a credential
     *
     * @param  int $id The ID of the credentials to be found. (required)
     * @param  int $credentials_id credentials_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsCredentialsCredentialsIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Credentials
     */
    public function restMarketsCredentialsCredentialsIdGet(
        int $id,
        int $credentials_id,
        string $contentType = self::contentTypes['restMarketsCredentialsCredentialsIdGet'][0]
    ): \ck\Model\Credentials
    {
        list($response) = $this->restMarketsCredentialsCredentialsIdGetWithHttpInfo($id, $credentials_id, $contentType);
        return $response;
    }

    /**
     * Operation restMarketsCredentialsCredentialsIdGetWithHttpInfo
     *
     * Get a credential
     *
     * @param  int $id The ID of the credentials to be found. (required)
     * @param  int $credentials_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsCredentialsCredentialsIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Credentials, HTTP status code, HTTP response headers (array of strings)
     */
    public function restMarketsCredentialsCredentialsIdGetWithHttpInfo(
        int $id,
        int $credentials_id,
        string $contentType = self::contentTypes['restMarketsCredentialsCredentialsIdGet'][0]
    ): array
    {
        $request = $this->restMarketsCredentialsCredentialsIdGetRequest($id, $credentials_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Credentials' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Credentials' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Credentials', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Credentials';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Credentials',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restMarketsCredentialsCredentialsIdGetAsync
     *
     * Get a credential
     *
     * @param  int $id The ID of the credentials to be found. (required)
     * @param  int $credentials_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsCredentialsCredentialsIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsCredentialsCredentialsIdGetAsync(
        int $id,
        int $credentials_id,
        string $contentType = self::contentTypes['restMarketsCredentialsCredentialsIdGet'][0]
    ): PromiseInterface
    {
        return $this->restMarketsCredentialsCredentialsIdGetAsyncWithHttpInfo($id, $credentials_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restMarketsCredentialsCredentialsIdGetAsyncWithHttpInfo
     *
     * Get a credential
     *
     * @param  int $id The ID of the credentials to be found. (required)
     * @param  int $credentials_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsCredentialsCredentialsIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsCredentialsCredentialsIdGetAsyncWithHttpInfo(
        $id,
        $credentials_id,
        string $contentType = self::contentTypes['restMarketsCredentialsCredentialsIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Credentials';
        $request = $this->restMarketsCredentialsCredentialsIdGetRequest($id, $credentials_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restMarketsCredentialsCredentialsIdGet'
     *
     * @param  int $id The ID of the credentials to be found. (required)
     * @param  int $credentials_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsCredentialsCredentialsIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restMarketsCredentialsCredentialsIdGetRequest(
        $id,
        $credentials_id,
        string $contentType = self::contentTypes['restMarketsCredentialsCredentialsIdGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restMarketsCredentialsCredentialsIdGet'
            );
        }

        // verify the required parameter 'credentials_id' is set
        if ($credentials_id === null || (is_array($credentials_id) && count($credentials_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $credentials_id when calling restMarketsCredentialsCredentialsIdGet'
            );
        }


        $resourcePath = '/rest/markets/credentials/{credentialsId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);


        // path params
        if ($credentials_id !== null) {
            $resourcePath = str_replace(
                '{' . 'credentialsId' . '}',
                ObjectSerializer::toPathValue($credentials_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restMarketsCredentialsCredentialsIdPut
     *
     * Update a credential
     *
     * @param  int $credentials_id credentials_id (required)
     * @param  \ck\Model\RestMarketsCredentialsCredentialsIdPutRequest|null $_rest_markets_credentials_credentials_id _rest_markets_credentials_credentials_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsCredentialsCredentialsIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Credentials
     */
    public function restMarketsCredentialsCredentialsIdPut(
        int $credentials_id,
        ?\ck\Model\RestMarketsCredentialsCredentialsIdPutRequest $_rest_markets_credentials_credentials_id = null,
        string $contentType = self::contentTypes['restMarketsCredentialsCredentialsIdPut'][0]
    ): \ck\Model\Credentials
    {
        list($response) = $this->restMarketsCredentialsCredentialsIdPutWithHttpInfo($credentials_id, $_rest_markets_credentials_credentials_id, $contentType);
        return $response;
    }

    /**
     * Operation restMarketsCredentialsCredentialsIdPutWithHttpInfo
     *
     * Update a credential
     *
     * @param  int $credentials_id (required)
     * @param  \ck\Model\RestMarketsCredentialsCredentialsIdPutRequest|null $_rest_markets_credentials_credentials_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsCredentialsCredentialsIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Credentials, HTTP status code, HTTP response headers (array of strings)
     */
    public function restMarketsCredentialsCredentialsIdPutWithHttpInfo(
        int $credentials_id,
        ?\ck\Model\RestMarketsCredentialsCredentialsIdPutRequest $_rest_markets_credentials_credentials_id = null,
        string $contentType = self::contentTypes['restMarketsCredentialsCredentialsIdPut'][0]
    ): array
    {
        $request = $this->restMarketsCredentialsCredentialsIdPutRequest($credentials_id, $_rest_markets_credentials_credentials_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Credentials' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Credentials' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Credentials', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Credentials';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Credentials',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restMarketsCredentialsCredentialsIdPutAsync
     *
     * Update a credential
     *
     * @param  int $credentials_id (required)
     * @param  \ck\Model\RestMarketsCredentialsCredentialsIdPutRequest|null $_rest_markets_credentials_credentials_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsCredentialsCredentialsIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsCredentialsCredentialsIdPutAsync(
        int $credentials_id,
        ?\ck\Model\RestMarketsCredentialsCredentialsIdPutRequest $_rest_markets_credentials_credentials_id = null,
        string $contentType = self::contentTypes['restMarketsCredentialsCredentialsIdPut'][0]
    ): PromiseInterface
    {
        return $this->restMarketsCredentialsCredentialsIdPutAsyncWithHttpInfo($credentials_id, $_rest_markets_credentials_credentials_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restMarketsCredentialsCredentialsIdPutAsyncWithHttpInfo
     *
     * Update a credential
     *
     * @param  int $credentials_id (required)
     * @param  \ck\Model\RestMarketsCredentialsCredentialsIdPutRequest|null $_rest_markets_credentials_credentials_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsCredentialsCredentialsIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsCredentialsCredentialsIdPutAsyncWithHttpInfo(
        $credentials_id,
        $_rest_markets_credentials_credentials_id = null,
        string $contentType = self::contentTypes['restMarketsCredentialsCredentialsIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Credentials';
        $request = $this->restMarketsCredentialsCredentialsIdPutRequest($credentials_id, $_rest_markets_credentials_credentials_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restMarketsCredentialsCredentialsIdPut'
     *
     * @param  int $credentials_id (required)
     * @param  \ck\Model\RestMarketsCredentialsCredentialsIdPutRequest|null $_rest_markets_credentials_credentials_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsCredentialsCredentialsIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restMarketsCredentialsCredentialsIdPutRequest(
        $credentials_id,
        $_rest_markets_credentials_credentials_id = null,
        string $contentType = self::contentTypes['restMarketsCredentialsCredentialsIdPut'][0]
    ): Request
    {

        // verify the required parameter 'credentials_id' is set
        if ($credentials_id === null || (is_array($credentials_id) && count($credentials_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $credentials_id when calling restMarketsCredentialsCredentialsIdPut'
            );
        }



        $resourcePath = '/rest/markets/credentials/{credentialsId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($credentials_id !== null) {
            $resourcePath = str_replace(
                '{' . 'credentialsId' . '}',
                ObjectSerializer::toPathValue($credentials_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_markets_credentials_credentials_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_markets_credentials_credentials_id));
            } else {
                $httpBody = $_rest_markets_credentials_credentials_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restMarketsCredentialsGet
     *
     * List credentials
     *
     * @param  int $page The page of results to search for (required)
     * @param  int $items_per_page The items per page to search for (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsCredentialsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestMarketsCredentialsGet200Response
     */
    public function restMarketsCredentialsGet(
        int $page,
        int $items_per_page,
        string $contentType = self::contentTypes['restMarketsCredentialsGet'][0]
    ): \ck\Model\RestMarketsCredentialsGet200Response
    {
        list($response) = $this->restMarketsCredentialsGetWithHttpInfo($page, $items_per_page, $contentType);
        return $response;
    }

    /**
     * Operation restMarketsCredentialsGetWithHttpInfo
     *
     * List credentials
     *
     * @param  int $page The page of results to search for (required)
     * @param  int $items_per_page The items per page to search for (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsCredentialsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestMarketsCredentialsGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restMarketsCredentialsGetWithHttpInfo(
        int $page,
        int $items_per_page,
        string $contentType = self::contentTypes['restMarketsCredentialsGet'][0]
    ): array
    {
        $request = $this->restMarketsCredentialsGetRequest($page, $items_per_page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestMarketsCredentialsGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestMarketsCredentialsGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestMarketsCredentialsGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestMarketsCredentialsGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestMarketsCredentialsGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restMarketsCredentialsGetAsync
     *
     * List credentials
     *
     * @param  int $page The page of results to search for (required)
     * @param  int $items_per_page The items per page to search for (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsCredentialsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsCredentialsGetAsync(
        int $page,
        int $items_per_page,
        string $contentType = self::contentTypes['restMarketsCredentialsGet'][0]
    ): PromiseInterface
    {
        return $this->restMarketsCredentialsGetAsyncWithHttpInfo($page, $items_per_page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restMarketsCredentialsGetAsyncWithHttpInfo
     *
     * List credentials
     *
     * @param  int $page The page of results to search for (required)
     * @param  int $items_per_page The items per page to search for (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsCredentialsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsCredentialsGetAsyncWithHttpInfo(
        $page,
        $items_per_page,
        string $contentType = self::contentTypes['restMarketsCredentialsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestMarketsCredentialsGet200Response';
        $request = $this->restMarketsCredentialsGetRequest($page, $items_per_page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restMarketsCredentialsGet'
     *
     * @param  int $page The page of results to search for (required)
     * @param  int $items_per_page The items per page to search for (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsCredentialsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restMarketsCredentialsGetRequest(
        $page,
        $items_per_page,
        string $contentType = self::contentTypes['restMarketsCredentialsGet'][0]
    ): Request
    {

        // verify the required parameter 'page' is set
        if ($page === null || (is_array($page) && count($page) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $page when calling restMarketsCredentialsGet'
            );
        }

        // verify the required parameter 'items_per_page' is set
        if ($items_per_page === null || (is_array($items_per_page) && count($items_per_page) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $items_per_page when calling restMarketsCredentialsGet'
            );
        }


        $resourcePath = '/rest/markets/credentials';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $items_per_page,
            'itemsPerPage', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restMarketsCredentialsPost
     *
     * Create a credential
     *
     * @param  \ck\Model\RestMarketsCredentialsPostRequest|null $_rest_markets_credentials _rest_markets_credentials (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsCredentialsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Credentials
     */
    public function restMarketsCredentialsPost(
        ?\ck\Model\RestMarketsCredentialsPostRequest $_rest_markets_credentials = null,
        string $contentType = self::contentTypes['restMarketsCredentialsPost'][0]
    ): \ck\Model\Credentials
    {
        list($response) = $this->restMarketsCredentialsPostWithHttpInfo($_rest_markets_credentials, $contentType);
        return $response;
    }

    /**
     * Operation restMarketsCredentialsPostWithHttpInfo
     *
     * Create a credential
     *
     * @param  \ck\Model\RestMarketsCredentialsPostRequest|null $_rest_markets_credentials (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsCredentialsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Credentials, HTTP status code, HTTP response headers (array of strings)
     */
    public function restMarketsCredentialsPostWithHttpInfo(
        ?\ck\Model\RestMarketsCredentialsPostRequest $_rest_markets_credentials = null,
        string $contentType = self::contentTypes['restMarketsCredentialsPost'][0]
    ): array
    {
        $request = $this->restMarketsCredentialsPostRequest($_rest_markets_credentials, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Credentials' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Credentials' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Credentials', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Credentials';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Credentials',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restMarketsCredentialsPostAsync
     *
     * Create a credential
     *
     * @param  \ck\Model\RestMarketsCredentialsPostRequest|null $_rest_markets_credentials (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsCredentialsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsCredentialsPostAsync(
        ?\ck\Model\RestMarketsCredentialsPostRequest $_rest_markets_credentials = null,
        string $contentType = self::contentTypes['restMarketsCredentialsPost'][0]
    ): PromiseInterface
    {
        return $this->restMarketsCredentialsPostAsyncWithHttpInfo($_rest_markets_credentials, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restMarketsCredentialsPostAsyncWithHttpInfo
     *
     * Create a credential
     *
     * @param  \ck\Model\RestMarketsCredentialsPostRequest|null $_rest_markets_credentials (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsCredentialsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsCredentialsPostAsyncWithHttpInfo(
        $_rest_markets_credentials = null,
        string $contentType = self::contentTypes['restMarketsCredentialsPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Credentials';
        $request = $this->restMarketsCredentialsPostRequest($_rest_markets_credentials, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restMarketsCredentialsPost'
     *
     * @param  \ck\Model\RestMarketsCredentialsPostRequest|null $_rest_markets_credentials (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsCredentialsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restMarketsCredentialsPostRequest(
        $_rest_markets_credentials = null,
        string $contentType = self::contentTypes['restMarketsCredentialsPost'][0]
    ): Request
    {



        $resourcePath = '/rest/markets/credentials';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_markets_credentials)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_markets_credentials));
            } else {
                $httpBody = $_rest_markets_credentials;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restMarketsEbayAuthLoginGet
     *
     * Get the login URL.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayAuthLoginGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restMarketsEbayAuthLoginGet(
        string $contentType = self::contentTypes['restMarketsEbayAuthLoginGet'][0]
    ): object
    {
        list($response) = $this->restMarketsEbayAuthLoginGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restMarketsEbayAuthLoginGetWithHttpInfo
     *
     * Get the login URL.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayAuthLoginGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restMarketsEbayAuthLoginGetWithHttpInfo(
        string $contentType = self::contentTypes['restMarketsEbayAuthLoginGet'][0]
    ): array
    {
        $request = $this->restMarketsEbayAuthLoginGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restMarketsEbayAuthLoginGetAsync
     *
     * Get the login URL.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayAuthLoginGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsEbayAuthLoginGetAsync(
        string $contentType = self::contentTypes['restMarketsEbayAuthLoginGet'][0]
    ): PromiseInterface
    {
        return $this->restMarketsEbayAuthLoginGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restMarketsEbayAuthLoginGetAsyncWithHttpInfo
     *
     * Get the login URL.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayAuthLoginGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsEbayAuthLoginGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restMarketsEbayAuthLoginGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restMarketsEbayAuthLoginGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restMarketsEbayAuthLoginGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayAuthLoginGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restMarketsEbayAuthLoginGetRequest(
        string $contentType = self::contentTypes['restMarketsEbayAuthLoginGet'][0]
    ): Request
    {


        $resourcePath = '/rest/markets/ebay/auth/login';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restMarketsEbayAuthRefreshTokenPut
     *
     * Refresh an expired access token.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayAuthRefreshTokenPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restMarketsEbayAuthRefreshTokenPut(
        string $contentType = self::contentTypes['restMarketsEbayAuthRefreshTokenPut'][0]
    ): object
    {
        list($response) = $this->restMarketsEbayAuthRefreshTokenPutWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restMarketsEbayAuthRefreshTokenPutWithHttpInfo
     *
     * Refresh an expired access token.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayAuthRefreshTokenPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restMarketsEbayAuthRefreshTokenPutWithHttpInfo(
        string $contentType = self::contentTypes['restMarketsEbayAuthRefreshTokenPut'][0]
    ): array
    {
        $request = $this->restMarketsEbayAuthRefreshTokenPutRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restMarketsEbayAuthRefreshTokenPutAsync
     *
     * Refresh an expired access token.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayAuthRefreshTokenPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsEbayAuthRefreshTokenPutAsync(
        string $contentType = self::contentTypes['restMarketsEbayAuthRefreshTokenPut'][0]
    ): PromiseInterface
    {
        return $this->restMarketsEbayAuthRefreshTokenPutAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restMarketsEbayAuthRefreshTokenPutAsyncWithHttpInfo
     *
     * Refresh an expired access token.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayAuthRefreshTokenPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsEbayAuthRefreshTokenPutAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restMarketsEbayAuthRefreshTokenPut'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restMarketsEbayAuthRefreshTokenPutRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restMarketsEbayAuthRefreshTokenPut'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayAuthRefreshTokenPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restMarketsEbayAuthRefreshTokenPutRequest(
        string $contentType = self::contentTypes['restMarketsEbayAuthRefreshTokenPut'][0]
    ): Request
    {


        $resourcePath = '/rest/markets/ebay/auth/refresh-token';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restMarketsEbayCategoriesGet
     *
     * List categories
     *
     * @param  string $marketplace_id Filter that restricts the search result to categories that belong to the specified marketplace ID. (required)
     * @param  string|null $category_id Filter that restricts the search result to categories that belong to the specified category ID. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayCategoriesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Category[]
     */
    public function restMarketsEbayCategoriesGet(
        string $marketplace_id,
        ?string $category_id = null,
        string $contentType = self::contentTypes['restMarketsEbayCategoriesGet'][0]
    ): array
    {
        list($response) = $this->restMarketsEbayCategoriesGetWithHttpInfo($marketplace_id, $category_id, $contentType);
        return $response;
    }

    /**
     * Operation restMarketsEbayCategoriesGetWithHttpInfo
     *
     * List categories
     *
     * @param  string $marketplace_id Filter that restricts the search result to categories that belong to the specified marketplace ID. (required)
     * @param  string|null $category_id Filter that restricts the search result to categories that belong to the specified category ID. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayCategoriesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Category[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restMarketsEbayCategoriesGetWithHttpInfo(
        string $marketplace_id,
        ?string $category_id = null,
        string $contentType = self::contentTypes['restMarketsEbayCategoriesGet'][0]
    ): array
    {
        $request = $this->restMarketsEbayCategoriesGetRequest($marketplace_id, $category_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Category[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Category[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Category[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Category[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Category[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restMarketsEbayCategoriesGetAsync
     *
     * List categories
     *
     * @param  string $marketplace_id Filter that restricts the search result to categories that belong to the specified marketplace ID. (required)
     * @param  string|null $category_id Filter that restricts the search result to categories that belong to the specified category ID. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayCategoriesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsEbayCategoriesGetAsync(
        string $marketplace_id,
        ?string $category_id = null,
        string $contentType = self::contentTypes['restMarketsEbayCategoriesGet'][0]
    ): PromiseInterface
    {
        return $this->restMarketsEbayCategoriesGetAsyncWithHttpInfo($marketplace_id, $category_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restMarketsEbayCategoriesGetAsyncWithHttpInfo
     *
     * List categories
     *
     * @param  string $marketplace_id Filter that restricts the search result to categories that belong to the specified marketplace ID. (required)
     * @param  string|null $category_id Filter that restricts the search result to categories that belong to the specified category ID. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayCategoriesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsEbayCategoriesGetAsyncWithHttpInfo(
        $marketplace_id,
        $category_id = null,
        string $contentType = self::contentTypes['restMarketsEbayCategoriesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Category[]';
        $request = $this->restMarketsEbayCategoriesGetRequest($marketplace_id, $category_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restMarketsEbayCategoriesGet'
     *
     * @param  string $marketplace_id Filter that restricts the search result to categories that belong to the specified marketplace ID. (required)
     * @param  string|null $category_id Filter that restricts the search result to categories that belong to the specified category ID. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayCategoriesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restMarketsEbayCategoriesGetRequest(
        $marketplace_id,
        $category_id = null,
        string $contentType = self::contentTypes['restMarketsEbayCategoriesGet'][0]
    ): Request
    {

        // verify the required parameter 'marketplace_id' is set
        if ($marketplace_id === null || (is_array($marketplace_id) && count($marketplace_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $marketplace_id when calling restMarketsEbayCategoriesGet'
            );
        }



        $resourcePath = '/rest/markets/ebay/categories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $marketplace_id,
            'marketplaceId', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $category_id,
            'categoryId', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restMarketsEbayCategoriesIdGet
     *
     * Get category
     *
     * @param  int $id The ID of the category to be found. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayCategoriesIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Category
     */
    public function restMarketsEbayCategoriesIdGet(
        int $id,
        string $contentType = self::contentTypes['restMarketsEbayCategoriesIdGet'][0]
    ): \ck\Model\Category
    {
        list($response) = $this->restMarketsEbayCategoriesIdGetWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation restMarketsEbayCategoriesIdGetWithHttpInfo
     *
     * Get category
     *
     * @param  int $id The ID of the category to be found. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayCategoriesIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Category, HTTP status code, HTTP response headers (array of strings)
     */
    public function restMarketsEbayCategoriesIdGetWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restMarketsEbayCategoriesIdGet'][0]
    ): array
    {
        $request = $this->restMarketsEbayCategoriesIdGetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Category' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Category' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Category', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Category';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Category',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restMarketsEbayCategoriesIdGetAsync
     *
     * Get category
     *
     * @param  int $id The ID of the category to be found. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayCategoriesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsEbayCategoriesIdGetAsync(
        int $id,
        string $contentType = self::contentTypes['restMarketsEbayCategoriesIdGet'][0]
    ): PromiseInterface
    {
        return $this->restMarketsEbayCategoriesIdGetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restMarketsEbayCategoriesIdGetAsyncWithHttpInfo
     *
     * Get category
     *
     * @param  int $id The ID of the category to be found. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayCategoriesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsEbayCategoriesIdGetAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restMarketsEbayCategoriesIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Category';
        $request = $this->restMarketsEbayCategoriesIdGetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restMarketsEbayCategoriesIdGet'
     *
     * @param  int $id The ID of the category to be found. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayCategoriesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restMarketsEbayCategoriesIdGetRequest(
        $id,
        string $contentType = self::contentTypes['restMarketsEbayCategoriesIdGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restMarketsEbayCategoriesIdGet'
            );
        }


        $resourcePath = '/rest/markets/ebay/categories/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restMarketsEbayFulfillmentPoliciesIdGet
     *
     * Get fulfillment policy
     *
     * @param  string $marketplace_id The ID of the marketplace for which to get the policy. (required)
     * @param  int $credentials_id The ID of credentials for which to get the policy. (required)
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayFulfillmentPoliciesIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\FulfillmentPolicy
     */
    public function restMarketsEbayFulfillmentPoliciesIdGet(
        string $marketplace_id,
        int $credentials_id,
        int $id,
        string $contentType = self::contentTypes['restMarketsEbayFulfillmentPoliciesIdGet'][0]
    ): \ck\Model\FulfillmentPolicy
    {
        list($response) = $this->restMarketsEbayFulfillmentPoliciesIdGetWithHttpInfo($marketplace_id, $credentials_id, $id, $contentType);
        return $response;
    }

    /**
     * Operation restMarketsEbayFulfillmentPoliciesIdGetWithHttpInfo
     *
     * Get fulfillment policy
     *
     * @param  string $marketplace_id The ID of the marketplace for which to get the policy. (required)
     * @param  int $credentials_id The ID of credentials for which to get the policy. (required)
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayFulfillmentPoliciesIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\FulfillmentPolicy, HTTP status code, HTTP response headers (array of strings)
     */
    public function restMarketsEbayFulfillmentPoliciesIdGetWithHttpInfo(
        string $marketplace_id,
        int $credentials_id,
        int $id,
        string $contentType = self::contentTypes['restMarketsEbayFulfillmentPoliciesIdGet'][0]
    ): array
    {
        $request = $this->restMarketsEbayFulfillmentPoliciesIdGetRequest($marketplace_id, $credentials_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\FulfillmentPolicy' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\FulfillmentPolicy' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\FulfillmentPolicy', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\FulfillmentPolicy';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\FulfillmentPolicy',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restMarketsEbayFulfillmentPoliciesIdGetAsync
     *
     * Get fulfillment policy
     *
     * @param  string $marketplace_id The ID of the marketplace for which to get the policy. (required)
     * @param  int $credentials_id The ID of credentials for which to get the policy. (required)
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayFulfillmentPoliciesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsEbayFulfillmentPoliciesIdGetAsync(
        string $marketplace_id,
        int $credentials_id,
        int $id,
        string $contentType = self::contentTypes['restMarketsEbayFulfillmentPoliciesIdGet'][0]
    ): PromiseInterface
    {
        return $this->restMarketsEbayFulfillmentPoliciesIdGetAsyncWithHttpInfo($marketplace_id, $credentials_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restMarketsEbayFulfillmentPoliciesIdGetAsyncWithHttpInfo
     *
     * Get fulfillment policy
     *
     * @param  string $marketplace_id The ID of the marketplace for which to get the policy. (required)
     * @param  int $credentials_id The ID of credentials for which to get the policy. (required)
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayFulfillmentPoliciesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsEbayFulfillmentPoliciesIdGetAsyncWithHttpInfo(
        $marketplace_id,
        $credentials_id,
        $id,
        string $contentType = self::contentTypes['restMarketsEbayFulfillmentPoliciesIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\FulfillmentPolicy';
        $request = $this->restMarketsEbayFulfillmentPoliciesIdGetRequest($marketplace_id, $credentials_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restMarketsEbayFulfillmentPoliciesIdGet'
     *
     * @param  string $marketplace_id The ID of the marketplace for which to get the policy. (required)
     * @param  int $credentials_id The ID of credentials for which to get the policy. (required)
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayFulfillmentPoliciesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restMarketsEbayFulfillmentPoliciesIdGetRequest(
        $marketplace_id,
        $credentials_id,
        $id,
        string $contentType = self::contentTypes['restMarketsEbayFulfillmentPoliciesIdGet'][0]
    ): Request
    {

        // verify the required parameter 'marketplace_id' is set
        if ($marketplace_id === null || (is_array($marketplace_id) && count($marketplace_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $marketplace_id when calling restMarketsEbayFulfillmentPoliciesIdGet'
            );
        }

        // verify the required parameter 'credentials_id' is set
        if ($credentials_id === null || (is_array($credentials_id) && count($credentials_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $credentials_id when calling restMarketsEbayFulfillmentPoliciesIdGet'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restMarketsEbayFulfillmentPoliciesIdGet'
            );
        }


        $resourcePath = '/rest/markets/ebay/fulfillment_policies/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $marketplace_id,
            'marketplaceId', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $credentials_id,
            'credentialsId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restMarketsEbayItemSpecificsGet
     *
     * List item specifics
     *
     * @param  int $category_id The ID of the category for which to list item specifics (required)
     * @param  string $marketplace_id Filter that restricts the search result to categories that belong to the specified marketplace ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayItemSpecificsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ItemSpecific[]
     */
    public function restMarketsEbayItemSpecificsGet(
        int $category_id,
        string $marketplace_id,
        string $contentType = self::contentTypes['restMarketsEbayItemSpecificsGet'][0]
    ): array
    {
        list($response) = $this->restMarketsEbayItemSpecificsGetWithHttpInfo($category_id, $marketplace_id, $contentType);
        return $response;
    }

    /**
     * Operation restMarketsEbayItemSpecificsGetWithHttpInfo
     *
     * List item specifics
     *
     * @param  int $category_id The ID of the category for which to list item specifics (required)
     * @param  string $marketplace_id Filter that restricts the search result to categories that belong to the specified marketplace ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayItemSpecificsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ItemSpecific[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restMarketsEbayItemSpecificsGetWithHttpInfo(
        int $category_id,
        string $marketplace_id,
        string $contentType = self::contentTypes['restMarketsEbayItemSpecificsGet'][0]
    ): array
    {
        $request = $this->restMarketsEbayItemSpecificsGetRequest($category_id, $marketplace_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ItemSpecific[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ItemSpecific[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ItemSpecific[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ItemSpecific[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ItemSpecific[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restMarketsEbayItemSpecificsGetAsync
     *
     * List item specifics
     *
     * @param  int $category_id The ID of the category for which to list item specifics (required)
     * @param  string $marketplace_id Filter that restricts the search result to categories that belong to the specified marketplace ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayItemSpecificsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsEbayItemSpecificsGetAsync(
        int $category_id,
        string $marketplace_id,
        string $contentType = self::contentTypes['restMarketsEbayItemSpecificsGet'][0]
    ): PromiseInterface
    {
        return $this->restMarketsEbayItemSpecificsGetAsyncWithHttpInfo($category_id, $marketplace_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restMarketsEbayItemSpecificsGetAsyncWithHttpInfo
     *
     * List item specifics
     *
     * @param  int $category_id The ID of the category for which to list item specifics (required)
     * @param  string $marketplace_id Filter that restricts the search result to categories that belong to the specified marketplace ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayItemSpecificsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsEbayItemSpecificsGetAsyncWithHttpInfo(
        $category_id,
        $marketplace_id,
        string $contentType = self::contentTypes['restMarketsEbayItemSpecificsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ItemSpecific[]';
        $request = $this->restMarketsEbayItemSpecificsGetRequest($category_id, $marketplace_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restMarketsEbayItemSpecificsGet'
     *
     * @param  int $category_id The ID of the category for which to list item specifics (required)
     * @param  string $marketplace_id Filter that restricts the search result to categories that belong to the specified marketplace ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayItemSpecificsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restMarketsEbayItemSpecificsGetRequest(
        $category_id,
        $marketplace_id,
        string $contentType = self::contentTypes['restMarketsEbayItemSpecificsGet'][0]
    ): Request
    {

        // verify the required parameter 'category_id' is set
        if ($category_id === null || (is_array($category_id) && count($category_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $category_id when calling restMarketsEbayItemSpecificsGet'
            );
        }

        // verify the required parameter 'marketplace_id' is set
        if ($marketplace_id === null || (is_array($marketplace_id) && count($marketplace_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $marketplace_id when calling restMarketsEbayItemSpecificsGet'
            );
        }


        $resourcePath = '/rest/markets/ebay/item_specifics';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $category_id,
            'categoryId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $marketplace_id,
            'marketplaceId', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restMarketsEbayMarketplacesGet
     *
     * Get all eBay marketplaces.
     *
     * @param  float|null $referrer_id Get only marketplaces that match the given referrer ID (optional)
     * @param  string|null $marketplace_id Get only marketplaces that match the given marketplace ID (optional)
     * @param  int|null $market_id Get only marketplaces that match the given market ID (optional)
     * @param  int|null $site_id Get only marketplaces that match the given site ID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayMarketplacesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Marketplace[]
     */
    public function restMarketsEbayMarketplacesGet(
        ?float $referrer_id = null,
        ?string $marketplace_id = null,
        ?int $market_id = null,
        ?int $site_id = null,
        string $contentType = self::contentTypes['restMarketsEbayMarketplacesGet'][0]
    ): array
    {
        list($response) = $this->restMarketsEbayMarketplacesGetWithHttpInfo($referrer_id, $marketplace_id, $market_id, $site_id, $contentType);
        return $response;
    }

    /**
     * Operation restMarketsEbayMarketplacesGetWithHttpInfo
     *
     * Get all eBay marketplaces.
     *
     * @param  float|null $referrer_id Get only marketplaces that match the given referrer ID (optional)
     * @param  string|null $marketplace_id Get only marketplaces that match the given marketplace ID (optional)
     * @param  int|null $market_id Get only marketplaces that match the given market ID (optional)
     * @param  int|null $site_id Get only marketplaces that match the given site ID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayMarketplacesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Marketplace[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restMarketsEbayMarketplacesGetWithHttpInfo(
        ?float $referrer_id = null,
        ?string $marketplace_id = null,
        ?int $market_id = null,
        ?int $site_id = null,
        string $contentType = self::contentTypes['restMarketsEbayMarketplacesGet'][0]
    ): array
    {
        $request = $this->restMarketsEbayMarketplacesGetRequest($referrer_id, $marketplace_id, $market_id, $site_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Marketplace[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Marketplace[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Marketplace[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Marketplace[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Marketplace[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restMarketsEbayMarketplacesGetAsync
     *
     * Get all eBay marketplaces.
     *
     * @param  float|null $referrer_id Get only marketplaces that match the given referrer ID (optional)
     * @param  string|null $marketplace_id Get only marketplaces that match the given marketplace ID (optional)
     * @param  int|null $market_id Get only marketplaces that match the given market ID (optional)
     * @param  int|null $site_id Get only marketplaces that match the given site ID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayMarketplacesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsEbayMarketplacesGetAsync(
        ?float $referrer_id = null,
        ?string $marketplace_id = null,
        ?int $market_id = null,
        ?int $site_id = null,
        string $contentType = self::contentTypes['restMarketsEbayMarketplacesGet'][0]
    ): PromiseInterface
    {
        return $this->restMarketsEbayMarketplacesGetAsyncWithHttpInfo($referrer_id, $marketplace_id, $market_id, $site_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restMarketsEbayMarketplacesGetAsyncWithHttpInfo
     *
     * Get all eBay marketplaces.
     *
     * @param  float|null $referrer_id Get only marketplaces that match the given referrer ID (optional)
     * @param  string|null $marketplace_id Get only marketplaces that match the given marketplace ID (optional)
     * @param  int|null $market_id Get only marketplaces that match the given market ID (optional)
     * @param  int|null $site_id Get only marketplaces that match the given site ID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayMarketplacesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsEbayMarketplacesGetAsyncWithHttpInfo(
        $referrer_id = null,
        $marketplace_id = null,
        $market_id = null,
        $site_id = null,
        string $contentType = self::contentTypes['restMarketsEbayMarketplacesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Marketplace[]';
        $request = $this->restMarketsEbayMarketplacesGetRequest($referrer_id, $marketplace_id, $market_id, $site_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restMarketsEbayMarketplacesGet'
     *
     * @param  float|null $referrer_id Get only marketplaces that match the given referrer ID (optional)
     * @param  string|null $marketplace_id Get only marketplaces that match the given marketplace ID (optional)
     * @param  int|null $market_id Get only marketplaces that match the given market ID (optional)
     * @param  int|null $site_id Get only marketplaces that match the given site ID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayMarketplacesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restMarketsEbayMarketplacesGetRequest(
        $referrer_id = null,
        $marketplace_id = null,
        $market_id = null,
        $site_id = null,
        string $contentType = self::contentTypes['restMarketsEbayMarketplacesGet'][0]
    ): Request
    {






        $resourcePath = '/rest/markets/ebay/marketplaces';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $referrer_id,
            'referrerId', // param base name
            'number', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $marketplace_id,
            'marketplaceId', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $market_id,
            'marketId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $site_id,
            'siteId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restMarketsEbayPartsFitmentsFitmentIdDelete
     *
     * Delete a fitment.
     *
     * @param  int $id The fitment ID. (required)
     * @param  int $fitment_id fitment_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayPartsFitmentsFitmentIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restMarketsEbayPartsFitmentsFitmentIdDelete(
        int $id,
        int $fitment_id,
        string $contentType = self::contentTypes['restMarketsEbayPartsFitmentsFitmentIdDelete'][0]
    ): object
    {
        list($response) = $this->restMarketsEbayPartsFitmentsFitmentIdDeleteWithHttpInfo($id, $fitment_id, $contentType);
        return $response;
    }

    /**
     * Operation restMarketsEbayPartsFitmentsFitmentIdDeleteWithHttpInfo
     *
     * Delete a fitment.
     *
     * @param  int $id The fitment ID. (required)
     * @param  int $fitment_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayPartsFitmentsFitmentIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restMarketsEbayPartsFitmentsFitmentIdDeleteWithHttpInfo(
        int $id,
        int $fitment_id,
        string $contentType = self::contentTypes['restMarketsEbayPartsFitmentsFitmentIdDelete'][0]
    ): array
    {
        $request = $this->restMarketsEbayPartsFitmentsFitmentIdDeleteRequest($id, $fitment_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restMarketsEbayPartsFitmentsFitmentIdDeleteAsync
     *
     * Delete a fitment.
     *
     * @param  int $id The fitment ID. (required)
     * @param  int $fitment_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayPartsFitmentsFitmentIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsEbayPartsFitmentsFitmentIdDeleteAsync(
        int $id,
        int $fitment_id,
        string $contentType = self::contentTypes['restMarketsEbayPartsFitmentsFitmentIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restMarketsEbayPartsFitmentsFitmentIdDeleteAsyncWithHttpInfo($id, $fitment_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restMarketsEbayPartsFitmentsFitmentIdDeleteAsyncWithHttpInfo
     *
     * Delete a fitment.
     *
     * @param  int $id The fitment ID. (required)
     * @param  int $fitment_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayPartsFitmentsFitmentIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsEbayPartsFitmentsFitmentIdDeleteAsyncWithHttpInfo(
        $id,
        $fitment_id,
        string $contentType = self::contentTypes['restMarketsEbayPartsFitmentsFitmentIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restMarketsEbayPartsFitmentsFitmentIdDeleteRequest($id, $fitment_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restMarketsEbayPartsFitmentsFitmentIdDelete'
     *
     * @param  int $id The fitment ID. (required)
     * @param  int $fitment_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayPartsFitmentsFitmentIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restMarketsEbayPartsFitmentsFitmentIdDeleteRequest(
        $id,
        $fitment_id,
        string $contentType = self::contentTypes['restMarketsEbayPartsFitmentsFitmentIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restMarketsEbayPartsFitmentsFitmentIdDelete'
            );
        }

        // verify the required parameter 'fitment_id' is set
        if ($fitment_id === null || (is_array($fitment_id) && count($fitment_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $fitment_id when calling restMarketsEbayPartsFitmentsFitmentIdDelete'
            );
        }


        $resourcePath = '/rest/markets/ebay/parts-fitments/{fitmentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);


        // path params
        if ($fitment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'fitmentId' . '}',
                ObjectSerializer::toPathValue($fitment_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restMarketsEbayPartsFitmentsFitmentIdGet
     *
     * Get a fitment
     *
     * @param  int $id The fitment ID. (required)
     * @param  int $fitment_id fitment_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayPartsFitmentsFitmentIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Fitment
     */
    public function restMarketsEbayPartsFitmentsFitmentIdGet(
        int $id,
        int $fitment_id,
        string $contentType = self::contentTypes['restMarketsEbayPartsFitmentsFitmentIdGet'][0]
    ): \ck\Model\Fitment
    {
        list($response) = $this->restMarketsEbayPartsFitmentsFitmentIdGetWithHttpInfo($id, $fitment_id, $contentType);
        return $response;
    }

    /**
     * Operation restMarketsEbayPartsFitmentsFitmentIdGetWithHttpInfo
     *
     * Get a fitment
     *
     * @param  int $id The fitment ID. (required)
     * @param  int $fitment_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayPartsFitmentsFitmentIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Fitment, HTTP status code, HTTP response headers (array of strings)
     */
    public function restMarketsEbayPartsFitmentsFitmentIdGetWithHttpInfo(
        int $id,
        int $fitment_id,
        string $contentType = self::contentTypes['restMarketsEbayPartsFitmentsFitmentIdGet'][0]
    ): array
    {
        $request = $this->restMarketsEbayPartsFitmentsFitmentIdGetRequest($id, $fitment_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Fitment' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Fitment' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Fitment', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Fitment';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Fitment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restMarketsEbayPartsFitmentsFitmentIdGetAsync
     *
     * Get a fitment
     *
     * @param  int $id The fitment ID. (required)
     * @param  int $fitment_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayPartsFitmentsFitmentIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsEbayPartsFitmentsFitmentIdGetAsync(
        int $id,
        int $fitment_id,
        string $contentType = self::contentTypes['restMarketsEbayPartsFitmentsFitmentIdGet'][0]
    ): PromiseInterface
    {
        return $this->restMarketsEbayPartsFitmentsFitmentIdGetAsyncWithHttpInfo($id, $fitment_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restMarketsEbayPartsFitmentsFitmentIdGetAsyncWithHttpInfo
     *
     * Get a fitment
     *
     * @param  int $id The fitment ID. (required)
     * @param  int $fitment_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayPartsFitmentsFitmentIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsEbayPartsFitmentsFitmentIdGetAsyncWithHttpInfo(
        $id,
        $fitment_id,
        string $contentType = self::contentTypes['restMarketsEbayPartsFitmentsFitmentIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Fitment';
        $request = $this->restMarketsEbayPartsFitmentsFitmentIdGetRequest($id, $fitment_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restMarketsEbayPartsFitmentsFitmentIdGet'
     *
     * @param  int $id The fitment ID. (required)
     * @param  int $fitment_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayPartsFitmentsFitmentIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restMarketsEbayPartsFitmentsFitmentIdGetRequest(
        $id,
        $fitment_id,
        string $contentType = self::contentTypes['restMarketsEbayPartsFitmentsFitmentIdGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restMarketsEbayPartsFitmentsFitmentIdGet'
            );
        }

        // verify the required parameter 'fitment_id' is set
        if ($fitment_id === null || (is_array($fitment_id) && count($fitment_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $fitment_id when calling restMarketsEbayPartsFitmentsFitmentIdGet'
            );
        }


        $resourcePath = '/rest/markets/ebay/parts-fitments/{fitmentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);


        // path params
        if ($fitment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'fitmentId' . '}',
                ObjectSerializer::toPathValue($fitment_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restMarketsEbayPartsFitmentsFitmentIdPut
     *
     * Update fitment.
     *
     * @param  int $id The ID of the fitment list. (required)
     * @param  int $fitment_id fitment_id (required)
     * @param  \ck\Model\RestMarketsEbayPartsFitmentsPostRequest|null $_rest_markets_ebay_parts_fitments_fitment_id _rest_markets_ebay_parts_fitments_fitment_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayPartsFitmentsFitmentIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Fitment
     */
    public function restMarketsEbayPartsFitmentsFitmentIdPut(
        int $id,
        int $fitment_id,
        ?\ck\Model\RestMarketsEbayPartsFitmentsPostRequest $_rest_markets_ebay_parts_fitments_fitment_id = null,
        string $contentType = self::contentTypes['restMarketsEbayPartsFitmentsFitmentIdPut'][0]
    ): \ck\Model\Fitment
    {
        list($response) = $this->restMarketsEbayPartsFitmentsFitmentIdPutWithHttpInfo($id, $fitment_id, $_rest_markets_ebay_parts_fitments_fitment_id, $contentType);
        return $response;
    }

    /**
     * Operation restMarketsEbayPartsFitmentsFitmentIdPutWithHttpInfo
     *
     * Update fitment.
     *
     * @param  int $id The ID of the fitment list. (required)
     * @param  int $fitment_id (required)
     * @param  \ck\Model\RestMarketsEbayPartsFitmentsPostRequest|null $_rest_markets_ebay_parts_fitments_fitment_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayPartsFitmentsFitmentIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Fitment, HTTP status code, HTTP response headers (array of strings)
     */
    public function restMarketsEbayPartsFitmentsFitmentIdPutWithHttpInfo(
        int $id,
        int $fitment_id,
        ?\ck\Model\RestMarketsEbayPartsFitmentsPostRequest $_rest_markets_ebay_parts_fitments_fitment_id = null,
        string $contentType = self::contentTypes['restMarketsEbayPartsFitmentsFitmentIdPut'][0]
    ): array
    {
        $request = $this->restMarketsEbayPartsFitmentsFitmentIdPutRequest($id, $fitment_id, $_rest_markets_ebay_parts_fitments_fitment_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Fitment' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Fitment' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Fitment', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Fitment';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Fitment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restMarketsEbayPartsFitmentsFitmentIdPutAsync
     *
     * Update fitment.
     *
     * @param  int $id The ID of the fitment list. (required)
     * @param  int $fitment_id (required)
     * @param  \ck\Model\RestMarketsEbayPartsFitmentsPostRequest|null $_rest_markets_ebay_parts_fitments_fitment_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayPartsFitmentsFitmentIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsEbayPartsFitmentsFitmentIdPutAsync(
        int $id,
        int $fitment_id,
        ?\ck\Model\RestMarketsEbayPartsFitmentsPostRequest $_rest_markets_ebay_parts_fitments_fitment_id = null,
        string $contentType = self::contentTypes['restMarketsEbayPartsFitmentsFitmentIdPut'][0]
    ): PromiseInterface
    {
        return $this->restMarketsEbayPartsFitmentsFitmentIdPutAsyncWithHttpInfo($id, $fitment_id, $_rest_markets_ebay_parts_fitments_fitment_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restMarketsEbayPartsFitmentsFitmentIdPutAsyncWithHttpInfo
     *
     * Update fitment.
     *
     * @param  int $id The ID of the fitment list. (required)
     * @param  int $fitment_id (required)
     * @param  \ck\Model\RestMarketsEbayPartsFitmentsPostRequest|null $_rest_markets_ebay_parts_fitments_fitment_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayPartsFitmentsFitmentIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsEbayPartsFitmentsFitmentIdPutAsyncWithHttpInfo(
        $id,
        $fitment_id,
        $_rest_markets_ebay_parts_fitments_fitment_id = null,
        string $contentType = self::contentTypes['restMarketsEbayPartsFitmentsFitmentIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Fitment';
        $request = $this->restMarketsEbayPartsFitmentsFitmentIdPutRequest($id, $fitment_id, $_rest_markets_ebay_parts_fitments_fitment_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restMarketsEbayPartsFitmentsFitmentIdPut'
     *
     * @param  int $id The ID of the fitment list. (required)
     * @param  int $fitment_id (required)
     * @param  \ck\Model\RestMarketsEbayPartsFitmentsPostRequest|null $_rest_markets_ebay_parts_fitments_fitment_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayPartsFitmentsFitmentIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restMarketsEbayPartsFitmentsFitmentIdPutRequest(
        $id,
        $fitment_id,
        $_rest_markets_ebay_parts_fitments_fitment_id = null,
        string $contentType = self::contentTypes['restMarketsEbayPartsFitmentsFitmentIdPut'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restMarketsEbayPartsFitmentsFitmentIdPut'
            );
        }

        // verify the required parameter 'fitment_id' is set
        if ($fitment_id === null || (is_array($fitment_id) && count($fitment_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $fitment_id when calling restMarketsEbayPartsFitmentsFitmentIdPut'
            );
        }



        $resourcePath = '/rest/markets/ebay/parts-fitments/{fitmentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);


        // path params
        if ($fitment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'fitmentId' . '}',
                ObjectSerializer::toPathValue($fitment_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_markets_ebay_parts_fitments_fitment_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_markets_ebay_parts_fitments_fitment_id));
            } else {
                $httpBody = $_rest_markets_ebay_parts_fitments_fitment_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restMarketsEbayPartsFitmentsGet
     *
     * List fitments
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayPartsFitmentsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Fitment[]
     */
    public function restMarketsEbayPartsFitmentsGet(
        string $contentType = self::contentTypes['restMarketsEbayPartsFitmentsGet'][0]
    ): array
    {
        list($response) = $this->restMarketsEbayPartsFitmentsGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restMarketsEbayPartsFitmentsGetWithHttpInfo
     *
     * List fitments
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayPartsFitmentsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Fitment[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restMarketsEbayPartsFitmentsGetWithHttpInfo(
        string $contentType = self::contentTypes['restMarketsEbayPartsFitmentsGet'][0]
    ): array
    {
        $request = $this->restMarketsEbayPartsFitmentsGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Fitment[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Fitment[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Fitment[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Fitment[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Fitment[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restMarketsEbayPartsFitmentsGetAsync
     *
     * List fitments
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayPartsFitmentsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsEbayPartsFitmentsGetAsync(
        string $contentType = self::contentTypes['restMarketsEbayPartsFitmentsGet'][0]
    ): PromiseInterface
    {
        return $this->restMarketsEbayPartsFitmentsGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restMarketsEbayPartsFitmentsGetAsyncWithHttpInfo
     *
     * List fitments
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayPartsFitmentsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsEbayPartsFitmentsGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restMarketsEbayPartsFitmentsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Fitment[]';
        $request = $this->restMarketsEbayPartsFitmentsGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restMarketsEbayPartsFitmentsGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayPartsFitmentsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restMarketsEbayPartsFitmentsGetRequest(
        string $contentType = self::contentTypes['restMarketsEbayPartsFitmentsGet'][0]
    ): Request
    {


        $resourcePath = '/rest/markets/ebay/parts-fitments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restMarketsEbayPartsFitmentsPost
     *
     * Create a fitment
     *
     * @param  \ck\Model\RestMarketsEbayPartsFitmentsPostRequest|null $_rest_markets_ebay_parts_fitments _rest_markets_ebay_parts_fitments (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayPartsFitmentsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Fitment
     */
    public function restMarketsEbayPartsFitmentsPost(
        ?\ck\Model\RestMarketsEbayPartsFitmentsPostRequest $_rest_markets_ebay_parts_fitments = null,
        string $contentType = self::contentTypes['restMarketsEbayPartsFitmentsPost'][0]
    ): \ck\Model\Fitment
    {
        list($response) = $this->restMarketsEbayPartsFitmentsPostWithHttpInfo($_rest_markets_ebay_parts_fitments, $contentType);
        return $response;
    }

    /**
     * Operation restMarketsEbayPartsFitmentsPostWithHttpInfo
     *
     * Create a fitment
     *
     * @param  \ck\Model\RestMarketsEbayPartsFitmentsPostRequest|null $_rest_markets_ebay_parts_fitments (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayPartsFitmentsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Fitment, HTTP status code, HTTP response headers (array of strings)
     */
    public function restMarketsEbayPartsFitmentsPostWithHttpInfo(
        ?\ck\Model\RestMarketsEbayPartsFitmentsPostRequest $_rest_markets_ebay_parts_fitments = null,
        string $contentType = self::contentTypes['restMarketsEbayPartsFitmentsPost'][0]
    ): array
    {
        $request = $this->restMarketsEbayPartsFitmentsPostRequest($_rest_markets_ebay_parts_fitments, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Fitment' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Fitment' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Fitment', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Fitment';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Fitment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restMarketsEbayPartsFitmentsPostAsync
     *
     * Create a fitment
     *
     * @param  \ck\Model\RestMarketsEbayPartsFitmentsPostRequest|null $_rest_markets_ebay_parts_fitments (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayPartsFitmentsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsEbayPartsFitmentsPostAsync(
        ?\ck\Model\RestMarketsEbayPartsFitmentsPostRequest $_rest_markets_ebay_parts_fitments = null,
        string $contentType = self::contentTypes['restMarketsEbayPartsFitmentsPost'][0]
    ): PromiseInterface
    {
        return $this->restMarketsEbayPartsFitmentsPostAsyncWithHttpInfo($_rest_markets_ebay_parts_fitments, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restMarketsEbayPartsFitmentsPostAsyncWithHttpInfo
     *
     * Create a fitment
     *
     * @param  \ck\Model\RestMarketsEbayPartsFitmentsPostRequest|null $_rest_markets_ebay_parts_fitments (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayPartsFitmentsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsEbayPartsFitmentsPostAsyncWithHttpInfo(
        $_rest_markets_ebay_parts_fitments = null,
        string $contentType = self::contentTypes['restMarketsEbayPartsFitmentsPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Fitment';
        $request = $this->restMarketsEbayPartsFitmentsPostRequest($_rest_markets_ebay_parts_fitments, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restMarketsEbayPartsFitmentsPost'
     *
     * @param  \ck\Model\RestMarketsEbayPartsFitmentsPostRequest|null $_rest_markets_ebay_parts_fitments (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayPartsFitmentsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restMarketsEbayPartsFitmentsPostRequest(
        $_rest_markets_ebay_parts_fitments = null,
        string $contentType = self::contentTypes['restMarketsEbayPartsFitmentsPost'][0]
    ): Request
    {



        $resourcePath = '/rest/markets/ebay/parts-fitments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_markets_ebay_parts_fitments)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_markets_ebay_parts_fitments));
            } else {
                $httpBody = $_rest_markets_ebay_parts_fitments;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restMarketsEbayPartsFitmentsSearchGet
     *
     * Search fitments
     *
     * @param  int|null $category_id Filter that restricts the search result to fitments with specific eBay category ID. Several IDs can be entered as array. (optional)
     * @param  int|null $id Filter that restricts the search result to fitments with specific ID. Several IDs can be entered as array. (optional)
     * @param  int|null $market_id Filter that restricts the search result to fitments with specific market ID. Several IDs can be entered as array. (optional)
     * @param  string|null $name Filter that restricts the search result to fitments with specific name. (optional)
     * @param  string|null $property_name Filter that restricts the search result to fitments with specific property name. (optional)
     * @param  string|null $property_value Filter that restricts the search result to fitments with specific property value. (optional)
     * @param  int|null $page The page of results to search for. (optional)
     * @param  int|null $items_per_page The number of items to list per page. (optional)
     * @param  int|null $with An array with child instances to be loaded. Available values: &#39;items&#39;, &#39;items.properties&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayPartsFitmentsSearchGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestMarketsEbayPartsFitmentsSearchGet200Response
     */
    public function restMarketsEbayPartsFitmentsSearchGet(
        ?int $category_id = null,
        ?int $id = null,
        ?int $market_id = null,
        ?string $name = null,
        ?string $property_name = null,
        ?string $property_value = null,
        ?int $page = null,
        ?int $items_per_page = null,
        ?int $with = null,
        string $contentType = self::contentTypes['restMarketsEbayPartsFitmentsSearchGet'][0]
    ): \ck\Model\RestMarketsEbayPartsFitmentsSearchGet200Response
    {
        list($response) = $this->restMarketsEbayPartsFitmentsSearchGetWithHttpInfo($category_id, $id, $market_id, $name, $property_name, $property_value, $page, $items_per_page, $with, $contentType);
        return $response;
    }

    /**
     * Operation restMarketsEbayPartsFitmentsSearchGetWithHttpInfo
     *
     * Search fitments
     *
     * @param  int|null $category_id Filter that restricts the search result to fitments with specific eBay category ID. Several IDs can be entered as array. (optional)
     * @param  int|null $id Filter that restricts the search result to fitments with specific ID. Several IDs can be entered as array. (optional)
     * @param  int|null $market_id Filter that restricts the search result to fitments with specific market ID. Several IDs can be entered as array. (optional)
     * @param  string|null $name Filter that restricts the search result to fitments with specific name. (optional)
     * @param  string|null $property_name Filter that restricts the search result to fitments with specific property name. (optional)
     * @param  string|null $property_value Filter that restricts the search result to fitments with specific property value. (optional)
     * @param  int|null $page The page of results to search for. (optional)
     * @param  int|null $items_per_page The number of items to list per page. (optional)
     * @param  int|null $with An array with child instances to be loaded. Available values: &#39;items&#39;, &#39;items.properties&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayPartsFitmentsSearchGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestMarketsEbayPartsFitmentsSearchGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restMarketsEbayPartsFitmentsSearchGetWithHttpInfo(
        ?int $category_id = null,
        ?int $id = null,
        ?int $market_id = null,
        ?string $name = null,
        ?string $property_name = null,
        ?string $property_value = null,
        ?int $page = null,
        ?int $items_per_page = null,
        ?int $with = null,
        string $contentType = self::contentTypes['restMarketsEbayPartsFitmentsSearchGet'][0]
    ): array
    {
        $request = $this->restMarketsEbayPartsFitmentsSearchGetRequest($category_id, $id, $market_id, $name, $property_name, $property_value, $page, $items_per_page, $with, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestMarketsEbayPartsFitmentsSearchGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestMarketsEbayPartsFitmentsSearchGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestMarketsEbayPartsFitmentsSearchGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestMarketsEbayPartsFitmentsSearchGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestMarketsEbayPartsFitmentsSearchGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restMarketsEbayPartsFitmentsSearchGetAsync
     *
     * Search fitments
     *
     * @param  int|null $category_id Filter that restricts the search result to fitments with specific eBay category ID. Several IDs can be entered as array. (optional)
     * @param  int|null $id Filter that restricts the search result to fitments with specific ID. Several IDs can be entered as array. (optional)
     * @param  int|null $market_id Filter that restricts the search result to fitments with specific market ID. Several IDs can be entered as array. (optional)
     * @param  string|null $name Filter that restricts the search result to fitments with specific name. (optional)
     * @param  string|null $property_name Filter that restricts the search result to fitments with specific property name. (optional)
     * @param  string|null $property_value Filter that restricts the search result to fitments with specific property value. (optional)
     * @param  int|null $page The page of results to search for. (optional)
     * @param  int|null $items_per_page The number of items to list per page. (optional)
     * @param  int|null $with An array with child instances to be loaded. Available values: &#39;items&#39;, &#39;items.properties&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayPartsFitmentsSearchGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsEbayPartsFitmentsSearchGetAsync(
        ?int $category_id = null,
        ?int $id = null,
        ?int $market_id = null,
        ?string $name = null,
        ?string $property_name = null,
        ?string $property_value = null,
        ?int $page = null,
        ?int $items_per_page = null,
        ?int $with = null,
        string $contentType = self::contentTypes['restMarketsEbayPartsFitmentsSearchGet'][0]
    ): PromiseInterface
    {
        return $this->restMarketsEbayPartsFitmentsSearchGetAsyncWithHttpInfo($category_id, $id, $market_id, $name, $property_name, $property_value, $page, $items_per_page, $with, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restMarketsEbayPartsFitmentsSearchGetAsyncWithHttpInfo
     *
     * Search fitments
     *
     * @param  int|null $category_id Filter that restricts the search result to fitments with specific eBay category ID. Several IDs can be entered as array. (optional)
     * @param  int|null $id Filter that restricts the search result to fitments with specific ID. Several IDs can be entered as array. (optional)
     * @param  int|null $market_id Filter that restricts the search result to fitments with specific market ID. Several IDs can be entered as array. (optional)
     * @param  string|null $name Filter that restricts the search result to fitments with specific name. (optional)
     * @param  string|null $property_name Filter that restricts the search result to fitments with specific property name. (optional)
     * @param  string|null $property_value Filter that restricts the search result to fitments with specific property value. (optional)
     * @param  int|null $page The page of results to search for. (optional)
     * @param  int|null $items_per_page The number of items to list per page. (optional)
     * @param  int|null $with An array with child instances to be loaded. Available values: &#39;items&#39;, &#39;items.properties&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayPartsFitmentsSearchGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsEbayPartsFitmentsSearchGetAsyncWithHttpInfo(
        $category_id = null,
        $id = null,
        $market_id = null,
        $name = null,
        $property_name = null,
        $property_value = null,
        $page = null,
        $items_per_page = null,
        $with = null,
        string $contentType = self::contentTypes['restMarketsEbayPartsFitmentsSearchGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestMarketsEbayPartsFitmentsSearchGet200Response';
        $request = $this->restMarketsEbayPartsFitmentsSearchGetRequest($category_id, $id, $market_id, $name, $property_name, $property_value, $page, $items_per_page, $with, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restMarketsEbayPartsFitmentsSearchGet'
     *
     * @param  int|null $category_id Filter that restricts the search result to fitments with specific eBay category ID. Several IDs can be entered as array. (optional)
     * @param  int|null $id Filter that restricts the search result to fitments with specific ID. Several IDs can be entered as array. (optional)
     * @param  int|null $market_id Filter that restricts the search result to fitments with specific market ID. Several IDs can be entered as array. (optional)
     * @param  string|null $name Filter that restricts the search result to fitments with specific name. (optional)
     * @param  string|null $property_name Filter that restricts the search result to fitments with specific property name. (optional)
     * @param  string|null $property_value Filter that restricts the search result to fitments with specific property value. (optional)
     * @param  int|null $page The page of results to search for. (optional)
     * @param  int|null $items_per_page The number of items to list per page. (optional)
     * @param  int|null $with An array with child instances to be loaded. Available values: &#39;items&#39;, &#39;items.properties&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayPartsFitmentsSearchGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restMarketsEbayPartsFitmentsSearchGetRequest(
        $category_id = null,
        $id = null,
        $market_id = null,
        $name = null,
        $property_name = null,
        $property_value = null,
        $page = null,
        $items_per_page = null,
        $with = null,
        string $contentType = self::contentTypes['restMarketsEbayPartsFitmentsSearchGet'][0]
    ): Request
    {











        $resourcePath = '/rest/markets/ebay/parts-fitments/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $category_id,
            'categoryId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $market_id,
            'marketId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $property_name,
            'propertyName', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $property_value,
            'propertyValue', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $items_per_page,
            'itemsPerPage', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restMarketsEbayPaymentPoliciesIdGet
     *
     * Get payment policy
     *
     * @param  string $marketplace_id The ID of the marketplace for which to get the policy. (required)
     * @param  int $credentials_id The ID of credentials for which to get the policy. (required)
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayPaymentPoliciesIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\PaymentPolicy
     */
    public function restMarketsEbayPaymentPoliciesIdGet(
        string $marketplace_id,
        int $credentials_id,
        int $id,
        string $contentType = self::contentTypes['restMarketsEbayPaymentPoliciesIdGet'][0]
    ): \ck\Model\PaymentPolicy
    {
        list($response) = $this->restMarketsEbayPaymentPoliciesIdGetWithHttpInfo($marketplace_id, $credentials_id, $id, $contentType);
        return $response;
    }

    /**
     * Operation restMarketsEbayPaymentPoliciesIdGetWithHttpInfo
     *
     * Get payment policy
     *
     * @param  string $marketplace_id The ID of the marketplace for which to get the policy. (required)
     * @param  int $credentials_id The ID of credentials for which to get the policy. (required)
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayPaymentPoliciesIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\PaymentPolicy, HTTP status code, HTTP response headers (array of strings)
     */
    public function restMarketsEbayPaymentPoliciesIdGetWithHttpInfo(
        string $marketplace_id,
        int $credentials_id,
        int $id,
        string $contentType = self::contentTypes['restMarketsEbayPaymentPoliciesIdGet'][0]
    ): array
    {
        $request = $this->restMarketsEbayPaymentPoliciesIdGetRequest($marketplace_id, $credentials_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\PaymentPolicy' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\PaymentPolicy' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\PaymentPolicy', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\PaymentPolicy';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\PaymentPolicy',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restMarketsEbayPaymentPoliciesIdGetAsync
     *
     * Get payment policy
     *
     * @param  string $marketplace_id The ID of the marketplace for which to get the policy. (required)
     * @param  int $credentials_id The ID of credentials for which to get the policy. (required)
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayPaymentPoliciesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsEbayPaymentPoliciesIdGetAsync(
        string $marketplace_id,
        int $credentials_id,
        int $id,
        string $contentType = self::contentTypes['restMarketsEbayPaymentPoliciesIdGet'][0]
    ): PromiseInterface
    {
        return $this->restMarketsEbayPaymentPoliciesIdGetAsyncWithHttpInfo($marketplace_id, $credentials_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restMarketsEbayPaymentPoliciesIdGetAsyncWithHttpInfo
     *
     * Get payment policy
     *
     * @param  string $marketplace_id The ID of the marketplace for which to get the policy. (required)
     * @param  int $credentials_id The ID of credentials for which to get the policy. (required)
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayPaymentPoliciesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsEbayPaymentPoliciesIdGetAsyncWithHttpInfo(
        $marketplace_id,
        $credentials_id,
        $id,
        string $contentType = self::contentTypes['restMarketsEbayPaymentPoliciesIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\PaymentPolicy';
        $request = $this->restMarketsEbayPaymentPoliciesIdGetRequest($marketplace_id, $credentials_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restMarketsEbayPaymentPoliciesIdGet'
     *
     * @param  string $marketplace_id The ID of the marketplace for which to get the policy. (required)
     * @param  int $credentials_id The ID of credentials for which to get the policy. (required)
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayPaymentPoliciesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restMarketsEbayPaymentPoliciesIdGetRequest(
        $marketplace_id,
        $credentials_id,
        $id,
        string $contentType = self::contentTypes['restMarketsEbayPaymentPoliciesIdGet'][0]
    ): Request
    {

        // verify the required parameter 'marketplace_id' is set
        if ($marketplace_id === null || (is_array($marketplace_id) && count($marketplace_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $marketplace_id when calling restMarketsEbayPaymentPoliciesIdGet'
            );
        }

        // verify the required parameter 'credentials_id' is set
        if ($credentials_id === null || (is_array($credentials_id) && count($credentials_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $credentials_id when calling restMarketsEbayPaymentPoliciesIdGet'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restMarketsEbayPaymentPoliciesIdGet'
            );
        }


        $resourcePath = '/rest/markets/ebay/payment_policies/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $marketplace_id,
            'marketplaceId', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $credentials_id,
            'credentialsId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restMarketsEbayReturnPoliciesIdGet
     *
     * Get return policy
     *
     * @param  string $marketplace_id The ID of the marketplace for which to get the policy. (required)
     * @param  int $credentials_id The ID of credentials for which to get the policy. (required)
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayReturnPoliciesIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ReturnPolicy
     */
    public function restMarketsEbayReturnPoliciesIdGet(
        string $marketplace_id,
        int $credentials_id,
        int $id,
        string $contentType = self::contentTypes['restMarketsEbayReturnPoliciesIdGet'][0]
    ): \ck\Model\ReturnPolicy
    {
        list($response) = $this->restMarketsEbayReturnPoliciesIdGetWithHttpInfo($marketplace_id, $credentials_id, $id, $contentType);
        return $response;
    }

    /**
     * Operation restMarketsEbayReturnPoliciesIdGetWithHttpInfo
     *
     * Get return policy
     *
     * @param  string $marketplace_id The ID of the marketplace for which to get the policy. (required)
     * @param  int $credentials_id The ID of credentials for which to get the policy. (required)
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayReturnPoliciesIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ReturnPolicy, HTTP status code, HTTP response headers (array of strings)
     */
    public function restMarketsEbayReturnPoliciesIdGetWithHttpInfo(
        string $marketplace_id,
        int $credentials_id,
        int $id,
        string $contentType = self::contentTypes['restMarketsEbayReturnPoliciesIdGet'][0]
    ): array
    {
        $request = $this->restMarketsEbayReturnPoliciesIdGetRequest($marketplace_id, $credentials_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ReturnPolicy' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ReturnPolicy' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ReturnPolicy', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ReturnPolicy';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ReturnPolicy',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restMarketsEbayReturnPoliciesIdGetAsync
     *
     * Get return policy
     *
     * @param  string $marketplace_id The ID of the marketplace for which to get the policy. (required)
     * @param  int $credentials_id The ID of credentials for which to get the policy. (required)
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayReturnPoliciesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsEbayReturnPoliciesIdGetAsync(
        string $marketplace_id,
        int $credentials_id,
        int $id,
        string $contentType = self::contentTypes['restMarketsEbayReturnPoliciesIdGet'][0]
    ): PromiseInterface
    {
        return $this->restMarketsEbayReturnPoliciesIdGetAsyncWithHttpInfo($marketplace_id, $credentials_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restMarketsEbayReturnPoliciesIdGetAsyncWithHttpInfo
     *
     * Get return policy
     *
     * @param  string $marketplace_id The ID of the marketplace for which to get the policy. (required)
     * @param  int $credentials_id The ID of credentials for which to get the policy. (required)
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayReturnPoliciesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsEbayReturnPoliciesIdGetAsyncWithHttpInfo(
        $marketplace_id,
        $credentials_id,
        $id,
        string $contentType = self::contentTypes['restMarketsEbayReturnPoliciesIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ReturnPolicy';
        $request = $this->restMarketsEbayReturnPoliciesIdGetRequest($marketplace_id, $credentials_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restMarketsEbayReturnPoliciesIdGet'
     *
     * @param  string $marketplace_id The ID of the marketplace for which to get the policy. (required)
     * @param  int $credentials_id The ID of credentials for which to get the policy. (required)
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayReturnPoliciesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restMarketsEbayReturnPoliciesIdGetRequest(
        $marketplace_id,
        $credentials_id,
        $id,
        string $contentType = self::contentTypes['restMarketsEbayReturnPoliciesIdGet'][0]
    ): Request
    {

        // verify the required parameter 'marketplace_id' is set
        if ($marketplace_id === null || (is_array($marketplace_id) && count($marketplace_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $marketplace_id when calling restMarketsEbayReturnPoliciesIdGet'
            );
        }

        // verify the required parameter 'credentials_id' is set
        if ($credentials_id === null || (is_array($credentials_id) && count($credentials_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $credentials_id when calling restMarketsEbayReturnPoliciesIdGet'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restMarketsEbayReturnPoliciesIdGet'
            );
        }


        $resourcePath = '/rest/markets/ebay/return_policies/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $marketplace_id,
            'marketplaceId', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $credentials_id,
            'credentialsId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restMarketsEbayShopCategoriesGet
     *
     * List all eBay shop categories
     *
     * @param  int $credentials_id The credentials ID for whom to fetch eBay shop categories. (required)
     * @param  string|null $view_type How should the eBay shop categories be returned. Possible values: &#39;list&#39; or &#39;tree&#39;. Default is &#39;list&#39; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayShopCategoriesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object[]
     */
    public function restMarketsEbayShopCategoriesGet(
        int $credentials_id,
        ?string $view_type = null,
        string $contentType = self::contentTypes['restMarketsEbayShopCategoriesGet'][0]
    ): array
    {
        list($response) = $this->restMarketsEbayShopCategoriesGetWithHttpInfo($credentials_id, $view_type, $contentType);
        return $response;
    }

    /**
     * Operation restMarketsEbayShopCategoriesGetWithHttpInfo
     *
     * List all eBay shop categories
     *
     * @param  int $credentials_id The credentials ID for whom to fetch eBay shop categories. (required)
     * @param  string|null $view_type How should the eBay shop categories be returned. Possible values: &#39;list&#39; or &#39;tree&#39;. Default is &#39;list&#39; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayShopCategoriesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restMarketsEbayShopCategoriesGetWithHttpInfo(
        int $credentials_id,
        ?string $view_type = null,
        string $contentType = self::contentTypes['restMarketsEbayShopCategoriesGet'][0]
    ): array
    {
        $request = $this->restMarketsEbayShopCategoriesGetRequest($credentials_id, $view_type, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restMarketsEbayShopCategoriesGetAsync
     *
     * List all eBay shop categories
     *
     * @param  int $credentials_id The credentials ID for whom to fetch eBay shop categories. (required)
     * @param  string|null $view_type How should the eBay shop categories be returned. Possible values: &#39;list&#39; or &#39;tree&#39;. Default is &#39;list&#39; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayShopCategoriesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsEbayShopCategoriesGetAsync(
        int $credentials_id,
        ?string $view_type = null,
        string $contentType = self::contentTypes['restMarketsEbayShopCategoriesGet'][0]
    ): PromiseInterface
    {
        return $this->restMarketsEbayShopCategoriesGetAsyncWithHttpInfo($credentials_id, $view_type, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restMarketsEbayShopCategoriesGetAsyncWithHttpInfo
     *
     * List all eBay shop categories
     *
     * @param  int $credentials_id The credentials ID for whom to fetch eBay shop categories. (required)
     * @param  string|null $view_type How should the eBay shop categories be returned. Possible values: &#39;list&#39; or &#39;tree&#39;. Default is &#39;list&#39; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayShopCategoriesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsEbayShopCategoriesGetAsyncWithHttpInfo(
        $credentials_id,
        $view_type = null,
        string $contentType = self::contentTypes['restMarketsEbayShopCategoriesGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object[]';
        $request = $this->restMarketsEbayShopCategoriesGetRequest($credentials_id, $view_type, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restMarketsEbayShopCategoriesGet'
     *
     * @param  int $credentials_id The credentials ID for whom to fetch eBay shop categories. (required)
     * @param  string|null $view_type How should the eBay shop categories be returned. Possible values: &#39;list&#39; or &#39;tree&#39;. Default is &#39;list&#39; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsEbayShopCategoriesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restMarketsEbayShopCategoriesGetRequest(
        $credentials_id,
        $view_type = null,
        string $contentType = self::contentTypes['restMarketsEbayShopCategoriesGet'][0]
    ): Request
    {

        // verify the required parameter 'credentials_id' is set
        if ($credentials_id === null || (is_array($credentials_id) && count($credentials_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $credentials_id when calling restMarketsEbayShopCategoriesGet'
            );
        }



        $resourcePath = '/rest/markets/ebay/shop_categories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $credentials_id,
            'credentialsId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $view_type,
            'viewType', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restMarketsListingsMarketplacesGet
     *
     * Get all listing marketplaces.
     *
     * @param  float|null $referrer_id Get only marketplaces that match the given referrer ID (optional)
     * @param  string|null $marketplace_id Get only marketplaces that match the given marketplace ID (optional)
     * @param  int|null $market_id Get only marketplaces that match the given market ID (optional)
     * @param  int|null $site_id Get only marketplaces that match the given site ID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsListingsMarketplacesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Marketplace[]
     */
    public function restMarketsListingsMarketplacesGet(
        ?float $referrer_id = null,
        ?string $marketplace_id = null,
        ?int $market_id = null,
        ?int $site_id = null,
        string $contentType = self::contentTypes['restMarketsListingsMarketplacesGet'][0]
    ): array
    {
        list($response) = $this->restMarketsListingsMarketplacesGetWithHttpInfo($referrer_id, $marketplace_id, $market_id, $site_id, $contentType);
        return $response;
    }

    /**
     * Operation restMarketsListingsMarketplacesGetWithHttpInfo
     *
     * Get all listing marketplaces.
     *
     * @param  float|null $referrer_id Get only marketplaces that match the given referrer ID (optional)
     * @param  string|null $marketplace_id Get only marketplaces that match the given marketplace ID (optional)
     * @param  int|null $market_id Get only marketplaces that match the given market ID (optional)
     * @param  int|null $site_id Get only marketplaces that match the given site ID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsListingsMarketplacesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Marketplace[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restMarketsListingsMarketplacesGetWithHttpInfo(
        ?float $referrer_id = null,
        ?string $marketplace_id = null,
        ?int $market_id = null,
        ?int $site_id = null,
        string $contentType = self::contentTypes['restMarketsListingsMarketplacesGet'][0]
    ): array
    {
        $request = $this->restMarketsListingsMarketplacesGetRequest($referrer_id, $marketplace_id, $market_id, $site_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Marketplace[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Marketplace[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Marketplace[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Marketplace[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Marketplace[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restMarketsListingsMarketplacesGetAsync
     *
     * Get all listing marketplaces.
     *
     * @param  float|null $referrer_id Get only marketplaces that match the given referrer ID (optional)
     * @param  string|null $marketplace_id Get only marketplaces that match the given marketplace ID (optional)
     * @param  int|null $market_id Get only marketplaces that match the given market ID (optional)
     * @param  int|null $site_id Get only marketplaces that match the given site ID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsListingsMarketplacesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsListingsMarketplacesGetAsync(
        ?float $referrer_id = null,
        ?string $marketplace_id = null,
        ?int $market_id = null,
        ?int $site_id = null,
        string $contentType = self::contentTypes['restMarketsListingsMarketplacesGet'][0]
    ): PromiseInterface
    {
        return $this->restMarketsListingsMarketplacesGetAsyncWithHttpInfo($referrer_id, $marketplace_id, $market_id, $site_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restMarketsListingsMarketplacesGetAsyncWithHttpInfo
     *
     * Get all listing marketplaces.
     *
     * @param  float|null $referrer_id Get only marketplaces that match the given referrer ID (optional)
     * @param  string|null $marketplace_id Get only marketplaces that match the given marketplace ID (optional)
     * @param  int|null $market_id Get only marketplaces that match the given market ID (optional)
     * @param  int|null $site_id Get only marketplaces that match the given site ID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsListingsMarketplacesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsListingsMarketplacesGetAsyncWithHttpInfo(
        $referrer_id = null,
        $marketplace_id = null,
        $market_id = null,
        $site_id = null,
        string $contentType = self::contentTypes['restMarketsListingsMarketplacesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Marketplace[]';
        $request = $this->restMarketsListingsMarketplacesGetRequest($referrer_id, $marketplace_id, $market_id, $site_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restMarketsListingsMarketplacesGet'
     *
     * @param  float|null $referrer_id Get only marketplaces that match the given referrer ID (optional)
     * @param  string|null $marketplace_id Get only marketplaces that match the given marketplace ID (optional)
     * @param  int|null $market_id Get only marketplaces that match the given market ID (optional)
     * @param  int|null $site_id Get only marketplaces that match the given site ID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsListingsMarketplacesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restMarketsListingsMarketplacesGetRequest(
        $referrer_id = null,
        $marketplace_id = null,
        $market_id = null,
        $site_id = null,
        string $contentType = self::contentTypes['restMarketsListingsMarketplacesGet'][0]
    ): Request
    {






        $resourcePath = '/rest/markets/listings/marketplaces';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $referrer_id,
            'referrerId', // param base name
            'number', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $marketplace_id,
            'marketplaceId', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $market_id,
            'marketId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $site_id,
            'siteId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restMarketsSettingsBulkPost
     *
     * Create market settings
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsSettingsBulkPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Settings[]
     */
    public function restMarketsSettingsBulkPost(
        string $contentType = self::contentTypes['restMarketsSettingsBulkPost'][0]
    ): array
    {
        list($response) = $this->restMarketsSettingsBulkPostWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restMarketsSettingsBulkPostWithHttpInfo
     *
     * Create market settings
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsSettingsBulkPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Settings[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restMarketsSettingsBulkPostWithHttpInfo(
        string $contentType = self::contentTypes['restMarketsSettingsBulkPost'][0]
    ): array
    {
        $request = $this->restMarketsSettingsBulkPostRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Settings[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Settings[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Settings[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Settings[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Settings[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restMarketsSettingsBulkPostAsync
     *
     * Create market settings
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsSettingsBulkPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsSettingsBulkPostAsync(
        string $contentType = self::contentTypes['restMarketsSettingsBulkPost'][0]
    ): PromiseInterface
    {
        return $this->restMarketsSettingsBulkPostAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restMarketsSettingsBulkPostAsyncWithHttpInfo
     *
     * Create market settings
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsSettingsBulkPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsSettingsBulkPostAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restMarketsSettingsBulkPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Settings[]';
        $request = $this->restMarketsSettingsBulkPostRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restMarketsSettingsBulkPost'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsSettingsBulkPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restMarketsSettingsBulkPostRequest(
        string $contentType = self::contentTypes['restMarketsSettingsBulkPost'][0]
    ): Request
    {


        $resourcePath = '/rest/markets/settings/bulk';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restMarketsSettingsBulkPut
     *
     * Update market settings
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsSettingsBulkPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Settings[]
     */
    public function restMarketsSettingsBulkPut(
        string $contentType = self::contentTypes['restMarketsSettingsBulkPut'][0]
    ): array
    {
        list($response) = $this->restMarketsSettingsBulkPutWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restMarketsSettingsBulkPutWithHttpInfo
     *
     * Update market settings
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsSettingsBulkPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Settings[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restMarketsSettingsBulkPutWithHttpInfo(
        string $contentType = self::contentTypes['restMarketsSettingsBulkPut'][0]
    ): array
    {
        $request = $this->restMarketsSettingsBulkPutRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Settings[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Settings[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Settings[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Settings[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Settings[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restMarketsSettingsBulkPutAsync
     *
     * Update market settings
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsSettingsBulkPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsSettingsBulkPutAsync(
        string $contentType = self::contentTypes['restMarketsSettingsBulkPut'][0]
    ): PromiseInterface
    {
        return $this->restMarketsSettingsBulkPutAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restMarketsSettingsBulkPutAsyncWithHttpInfo
     *
     * Update market settings
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsSettingsBulkPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsSettingsBulkPutAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restMarketsSettingsBulkPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Settings[]';
        $request = $this->restMarketsSettingsBulkPutRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restMarketsSettingsBulkPut'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsSettingsBulkPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restMarketsSettingsBulkPutRequest(
        string $contentType = self::contentTypes['restMarketsSettingsBulkPut'][0]
    ): Request
    {


        $resourcePath = '/rest/markets/settings/bulk';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restMarketsSettingsCorrelationsBulkPost
     *
     * Create multiple correlations
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsSettingsCorrelationsBulkPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restMarketsSettingsCorrelationsBulkPost(
        string $contentType = self::contentTypes['restMarketsSettingsCorrelationsBulkPost'][0]
    ): object
    {
        list($response) = $this->restMarketsSettingsCorrelationsBulkPostWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restMarketsSettingsCorrelationsBulkPostWithHttpInfo
     *
     * Create multiple correlations
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsSettingsCorrelationsBulkPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restMarketsSettingsCorrelationsBulkPostWithHttpInfo(
        string $contentType = self::contentTypes['restMarketsSettingsCorrelationsBulkPost'][0]
    ): array
    {
        $request = $this->restMarketsSettingsCorrelationsBulkPostRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restMarketsSettingsCorrelationsBulkPostAsync
     *
     * Create multiple correlations
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsSettingsCorrelationsBulkPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsSettingsCorrelationsBulkPostAsync(
        string $contentType = self::contentTypes['restMarketsSettingsCorrelationsBulkPost'][0]
    ): PromiseInterface
    {
        return $this->restMarketsSettingsCorrelationsBulkPostAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restMarketsSettingsCorrelationsBulkPostAsyncWithHttpInfo
     *
     * Create multiple correlations
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsSettingsCorrelationsBulkPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsSettingsCorrelationsBulkPostAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restMarketsSettingsCorrelationsBulkPost'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restMarketsSettingsCorrelationsBulkPostRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restMarketsSettingsCorrelationsBulkPost'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsSettingsCorrelationsBulkPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restMarketsSettingsCorrelationsBulkPostRequest(
        string $contentType = self::contentTypes['restMarketsSettingsCorrelationsBulkPost'][0]
    ): Request
    {


        $resourcePath = '/rest/markets/settings/correlations/bulk';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restMarketsSettingsCorrelationsGet
     *
     * List correlation
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsSettingsCorrelationsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Settings
     */
    public function restMarketsSettingsCorrelationsGet(
        string $contentType = self::contentTypes['restMarketsSettingsCorrelationsGet'][0]
    ): \ck\Model\Settings
    {
        list($response) = $this->restMarketsSettingsCorrelationsGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restMarketsSettingsCorrelationsGetWithHttpInfo
     *
     * List correlation
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsSettingsCorrelationsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Settings, HTTP status code, HTTP response headers (array of strings)
     */
    public function restMarketsSettingsCorrelationsGetWithHttpInfo(
        string $contentType = self::contentTypes['restMarketsSettingsCorrelationsGet'][0]
    ): array
    {
        $request = $this->restMarketsSettingsCorrelationsGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Settings' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Settings' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Settings', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Settings';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Settings',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restMarketsSettingsCorrelationsGetAsync
     *
     * List correlation
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsSettingsCorrelationsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsSettingsCorrelationsGetAsync(
        string $contentType = self::contentTypes['restMarketsSettingsCorrelationsGet'][0]
    ): PromiseInterface
    {
        return $this->restMarketsSettingsCorrelationsGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restMarketsSettingsCorrelationsGetAsyncWithHttpInfo
     *
     * List correlation
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsSettingsCorrelationsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsSettingsCorrelationsGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restMarketsSettingsCorrelationsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Settings';
        $request = $this->restMarketsSettingsCorrelationsGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restMarketsSettingsCorrelationsGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsSettingsCorrelationsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restMarketsSettingsCorrelationsGetRequest(
        string $contentType = self::contentTypes['restMarketsSettingsCorrelationsGet'][0]
    ): Request
    {


        $resourcePath = '/rest/markets/settings/correlations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restMarketsSettingsCorrelationsPost
     *
     * Create a correlation
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsSettingsCorrelationsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restMarketsSettingsCorrelationsPost(
        string $contentType = self::contentTypes['restMarketsSettingsCorrelationsPost'][0]
    ): void
    {
        $this->restMarketsSettingsCorrelationsPostWithHttpInfo($contentType);
    }

    /**
     * Operation restMarketsSettingsCorrelationsPostWithHttpInfo
     *
     * Create a correlation
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsSettingsCorrelationsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restMarketsSettingsCorrelationsPostWithHttpInfo(
        string $contentType = self::contentTypes['restMarketsSettingsCorrelationsPost'][0]
    ): array
    {
        $request = $this->restMarketsSettingsCorrelationsPostRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restMarketsSettingsCorrelationsPostAsync
     *
     * Create a correlation
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsSettingsCorrelationsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsSettingsCorrelationsPostAsync(
        string $contentType = self::contentTypes['restMarketsSettingsCorrelationsPost'][0]
    ): PromiseInterface
    {
        return $this->restMarketsSettingsCorrelationsPostAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restMarketsSettingsCorrelationsPostAsyncWithHttpInfo
     *
     * Create a correlation
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsSettingsCorrelationsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsSettingsCorrelationsPostAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restMarketsSettingsCorrelationsPost'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restMarketsSettingsCorrelationsPostRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restMarketsSettingsCorrelationsPost'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsSettingsCorrelationsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restMarketsSettingsCorrelationsPostRequest(
        string $contentType = self::contentTypes['restMarketsSettingsCorrelationsPost'][0]
    ): Request
    {


        $resourcePath = '/rest/markets/settings/correlations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restMarketsSettingsGet
     *
     * List market settings
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsSettingsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Settings[]
     */
    public function restMarketsSettingsGet(
        string $contentType = self::contentTypes['restMarketsSettingsGet'][0]
    ): array
    {
        list($response) = $this->restMarketsSettingsGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restMarketsSettingsGetWithHttpInfo
     *
     * List market settings
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsSettingsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Settings[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restMarketsSettingsGetWithHttpInfo(
        string $contentType = self::contentTypes['restMarketsSettingsGet'][0]
    ): array
    {
        $request = $this->restMarketsSettingsGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Settings[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Settings[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Settings[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Settings[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Settings[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restMarketsSettingsGetAsync
     *
     * List market settings
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsSettingsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsSettingsGetAsync(
        string $contentType = self::contentTypes['restMarketsSettingsGet'][0]
    ): PromiseInterface
    {
        return $this->restMarketsSettingsGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restMarketsSettingsGetAsyncWithHttpInfo
     *
     * List market settings
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsSettingsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsSettingsGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restMarketsSettingsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Settings[]';
        $request = $this->restMarketsSettingsGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restMarketsSettingsGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsSettingsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restMarketsSettingsGetRequest(
        string $contentType = self::contentTypes['restMarketsSettingsGet'][0]
    ): Request
    {


        $resourcePath = '/rest/markets/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restMarketsSettingsPost
     *
     * Create market settings
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsSettingsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Settings
     */
    public function restMarketsSettingsPost(
        string $contentType = self::contentTypes['restMarketsSettingsPost'][0]
    ): \ck\Model\Settings
    {
        list($response) = $this->restMarketsSettingsPostWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restMarketsSettingsPostWithHttpInfo
     *
     * Create market settings
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsSettingsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Settings, HTTP status code, HTTP response headers (array of strings)
     */
    public function restMarketsSettingsPostWithHttpInfo(
        string $contentType = self::contentTypes['restMarketsSettingsPost'][0]
    ): array
    {
        $request = $this->restMarketsSettingsPostRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Settings' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Settings' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Settings', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Settings';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Settings',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restMarketsSettingsPostAsync
     *
     * Create market settings
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsSettingsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsSettingsPostAsync(
        string $contentType = self::contentTypes['restMarketsSettingsPost'][0]
    ): PromiseInterface
    {
        return $this->restMarketsSettingsPostAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restMarketsSettingsPostAsyncWithHttpInfo
     *
     * Create market settings
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsSettingsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsSettingsPostAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restMarketsSettingsPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Settings';
        $request = $this->restMarketsSettingsPostRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restMarketsSettingsPost'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsSettingsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restMarketsSettingsPostRequest(
        string $contentType = self::contentTypes['restMarketsSettingsPost'][0]
    ): Request
    {


        $resourcePath = '/rest/markets/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restMarketsSettingsSettingIdDelete
     *
     * Delete market settings
     *
     * @param  int $setting_id setting_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsSettingsSettingIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restMarketsSettingsSettingIdDelete(
        int $setting_id,
        string $contentType = self::contentTypes['restMarketsSettingsSettingIdDelete'][0]
    ): object
    {
        list($response) = $this->restMarketsSettingsSettingIdDeleteWithHttpInfo($setting_id, $contentType);
        return $response;
    }

    /**
     * Operation restMarketsSettingsSettingIdDeleteWithHttpInfo
     *
     * Delete market settings
     *
     * @param  int $setting_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsSettingsSettingIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restMarketsSettingsSettingIdDeleteWithHttpInfo(
        int $setting_id,
        string $contentType = self::contentTypes['restMarketsSettingsSettingIdDelete'][0]
    ): array
    {
        $request = $this->restMarketsSettingsSettingIdDeleteRequest($setting_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restMarketsSettingsSettingIdDeleteAsync
     *
     * Delete market settings
     *
     * @param  int $setting_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsSettingsSettingIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsSettingsSettingIdDeleteAsync(
        int $setting_id,
        string $contentType = self::contentTypes['restMarketsSettingsSettingIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restMarketsSettingsSettingIdDeleteAsyncWithHttpInfo($setting_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restMarketsSettingsSettingIdDeleteAsyncWithHttpInfo
     *
     * Delete market settings
     *
     * @param  int $setting_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsSettingsSettingIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsSettingsSettingIdDeleteAsyncWithHttpInfo(
        $setting_id,
        string $contentType = self::contentTypes['restMarketsSettingsSettingIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restMarketsSettingsSettingIdDeleteRequest($setting_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restMarketsSettingsSettingIdDelete'
     *
     * @param  int $setting_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsSettingsSettingIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restMarketsSettingsSettingIdDeleteRequest(
        $setting_id,
        string $contentType = self::contentTypes['restMarketsSettingsSettingIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'setting_id' is set
        if ($setting_id === null || (is_array($setting_id) && count($setting_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $setting_id when calling restMarketsSettingsSettingIdDelete'
            );
        }


        $resourcePath = '/rest/markets/settings/{settingId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($setting_id !== null) {
            $resourcePath = str_replace(
                '{' . 'settingId' . '}',
                ObjectSerializer::toPathValue($setting_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restMarketsSettingsSettingIdGet
     *
     * Get market settings
     *
     * @param  int $setting_id setting_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsSettingsSettingIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Settings
     */
    public function restMarketsSettingsSettingIdGet(
        int $setting_id,
        string $contentType = self::contentTypes['restMarketsSettingsSettingIdGet'][0]
    ): \ck\Model\Settings
    {
        list($response) = $this->restMarketsSettingsSettingIdGetWithHttpInfo($setting_id, $contentType);
        return $response;
    }

    /**
     * Operation restMarketsSettingsSettingIdGetWithHttpInfo
     *
     * Get market settings
     *
     * @param  int $setting_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsSettingsSettingIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Settings, HTTP status code, HTTP response headers (array of strings)
     */
    public function restMarketsSettingsSettingIdGetWithHttpInfo(
        int $setting_id,
        string $contentType = self::contentTypes['restMarketsSettingsSettingIdGet'][0]
    ): array
    {
        $request = $this->restMarketsSettingsSettingIdGetRequest($setting_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Settings' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Settings' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Settings', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Settings';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Settings',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restMarketsSettingsSettingIdGetAsync
     *
     * Get market settings
     *
     * @param  int $setting_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsSettingsSettingIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsSettingsSettingIdGetAsync(
        int $setting_id,
        string $contentType = self::contentTypes['restMarketsSettingsSettingIdGet'][0]
    ): PromiseInterface
    {
        return $this->restMarketsSettingsSettingIdGetAsyncWithHttpInfo($setting_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restMarketsSettingsSettingIdGetAsyncWithHttpInfo
     *
     * Get market settings
     *
     * @param  int $setting_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsSettingsSettingIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsSettingsSettingIdGetAsyncWithHttpInfo(
        $setting_id,
        string $contentType = self::contentTypes['restMarketsSettingsSettingIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Settings';
        $request = $this->restMarketsSettingsSettingIdGetRequest($setting_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restMarketsSettingsSettingIdGet'
     *
     * @param  int $setting_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsSettingsSettingIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restMarketsSettingsSettingIdGetRequest(
        $setting_id,
        string $contentType = self::contentTypes['restMarketsSettingsSettingIdGet'][0]
    ): Request
    {

        // verify the required parameter 'setting_id' is set
        if ($setting_id === null || (is_array($setting_id) && count($setting_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $setting_id when calling restMarketsSettingsSettingIdGet'
            );
        }


        $resourcePath = '/rest/markets/settings/{settingId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($setting_id !== null) {
            $resourcePath = str_replace(
                '{' . 'settingId' . '}',
                ObjectSerializer::toPathValue($setting_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restMarketsSettingsSettingIdPut
     *
     * Update market settings
     *
     * @param  int $setting_id setting_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsSettingsSettingIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Settings
     */
    public function restMarketsSettingsSettingIdPut(
        int $setting_id,
        string $contentType = self::contentTypes['restMarketsSettingsSettingIdPut'][0]
    ): \ck\Model\Settings
    {
        list($response) = $this->restMarketsSettingsSettingIdPutWithHttpInfo($setting_id, $contentType);
        return $response;
    }

    /**
     * Operation restMarketsSettingsSettingIdPutWithHttpInfo
     *
     * Update market settings
     *
     * @param  int $setting_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsSettingsSettingIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Settings, HTTP status code, HTTP response headers (array of strings)
     */
    public function restMarketsSettingsSettingIdPutWithHttpInfo(
        int $setting_id,
        string $contentType = self::contentTypes['restMarketsSettingsSettingIdPut'][0]
    ): array
    {
        $request = $this->restMarketsSettingsSettingIdPutRequest($setting_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Settings' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Settings' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Settings', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Settings';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Settings',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restMarketsSettingsSettingIdPutAsync
     *
     * Update market settings
     *
     * @param  int $setting_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsSettingsSettingIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsSettingsSettingIdPutAsync(
        int $setting_id,
        string $contentType = self::contentTypes['restMarketsSettingsSettingIdPut'][0]
    ): PromiseInterface
    {
        return $this->restMarketsSettingsSettingIdPutAsyncWithHttpInfo($setting_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restMarketsSettingsSettingIdPutAsyncWithHttpInfo
     *
     * Update market settings
     *
     * @param  int $setting_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsSettingsSettingIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restMarketsSettingsSettingIdPutAsyncWithHttpInfo(
        $setting_id,
        string $contentType = self::contentTypes['restMarketsSettingsSettingIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Settings';
        $request = $this->restMarketsSettingsSettingIdPutRequest($setting_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restMarketsSettingsSettingIdPut'
     *
     * @param  int $setting_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restMarketsSettingsSettingIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restMarketsSettingsSettingIdPutRequest(
        $setting_id,
        string $contentType = self::contentTypes['restMarketsSettingsSettingIdPut'][0]
    ): Request
    {

        // verify the required parameter 'setting_id' is set
        if ($setting_id === null || (is_array($setting_id) && count($setting_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $setting_id when calling restMarketsSettingsSettingIdPut'
            );
        }


        $resourcePath = '/rest/markets/settings/{settingId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($setting_id !== null) {
            $resourcePath = str_replace(
                '{' . 'settingId' . '}',
                ObjectSerializer::toPathValue($setting_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption(): array
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
