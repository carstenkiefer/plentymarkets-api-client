<?php
/**
 * ItemApi
 * PHP version 8.1
 *
 * @package  ck
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * plentymarkets REST-API
 *
 * The plentymarkets REST API expands the functionality of the plentymarkets CMS and allows access to resources, i.e. data records, via unique URI paths
 *
 * The version of the OpenAPI document: 1.0.0
 * @generated Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 7.1.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace ck\Api;

use InvalidArgumentException;
use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use GuzzleHttp\Promise\PromiseInterface;
use ck\ApiException;
use ck\Configuration;
use ck\HeaderSelector;
use ck\ObjectSerializer;

/**
 * ItemApi Class Doc Comment
 *
 * @package  ck
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class ItemApi
{
    /**
     * @var ClientInterface
     */
    protected ClientInterface $client;

    /**
     * @var Configuration
     */
    protected Configuration $config;

    /**
     * @var HeaderSelector
     */
    protected HeaderSelector $headerSelector;

    /**
     * @var int Host index
     */
    protected int $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'restAvailabilitiesGet' => [
            'application/json',
        ],
        'restAvailabilitiesIdGet' => [
            'application/json',
        ],
        'restAvailabilitiesIdPut' => [
            'application/json',
        ],
        'restItemSetsDelete' => [
            'application/json',
        ],
        'restItemSetsGet' => [
            'application/json',
        ],
        'restItemSetsIdDelete' => [
            'application/json',
        ],
        'restItemSetsIdGet' => [
            'application/json',
        ],
        'restItemSetsIdPut' => [
            'application/json',
        ],
        'restItemSetsPost' => [
            'application/json',
        ],
        'restItemSetsPut' => [
            'application/json',
        ],
        'restItemSetsSetIdComponentsDelete' => [
            'application/json',
        ],
        'restItemSetsSetIdComponentsGet' => [
            'application/json',
        ],
        'restItemSetsSetIdComponentsIdDelete' => [
            'application/json',
        ],
        'restItemSetsSetIdComponentsIdGet' => [
            'application/json',
        ],
        'restItemSetsSetIdComponentsIdPut' => [
            'application/json',
        ],
        'restItemSetsSetIdComponentsPost' => [
            'application/json',
        ],
        'restItemSetsSetIdComponentsPut' => [
            'application/json',
        ],
        'restItemSetsSetIdConfigGet' => [
            'application/json',
        ],
        'restItemSetsSetIdConfigPut' => [
            'application/json',
        ],
        'restItemsAttributeValuesValueIdNamesGet' => [
            'application/json',
        ],
        'restItemsAttributeValuesValueIdNamesLangDelete' => [
            'application/json',
        ],
        'restItemsAttributeValuesValueIdNamesLangGet' => [
            'application/json',
        ],
        'restItemsAttributeValuesValueIdNamesLangPut' => [
            'application/json',
        ],
        'restItemsAttributeValuesValueIdNamesPost' => [
            'application/json',
        ],
        'restItemsAttributesAttributeIdMarketsMarketIdMapsDelete' => [
            'application/json',
        ],
        'restItemsAttributesAttributeIdMarketsMarketIdMapsGet' => [
            'application/json',
        ],
        'restItemsAttributesAttributeIdMarketsMarketIdMapsPut' => [
            'application/json',
        ],
        'restItemsAttributesAttributeIdNamesGet' => [
            'application/json',
        ],
        'restItemsAttributesAttributeIdNamesLangDelete' => [
            'application/json',
        ],
        'restItemsAttributesAttributeIdNamesLangGet' => [
            'application/json',
        ],
        'restItemsAttributesAttributeIdNamesLangPut' => [
            'application/json',
        ],
        'restItemsAttributesAttributeIdNamesPost' => [
            'application/json',
        ],
        'restItemsAttributesAttributeIdValueMarketNamesGet' => [
            'application/json',
        ],
        'restItemsAttributesAttributeIdValueMarketNamesPost' => [
            'application/json',
        ],
        'restItemsAttributesAttributeIdValueMarketNamesValueIdLangReferenceTypeDelete' => [
            'application/json',
        ],
        'restItemsAttributesAttributeIdValueMarketNamesValueIdLangReferenceTypePut' => [
            'application/json',
        ],
        'restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsDelete' => [
            'application/json',
        ],
        'restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsGet' => [
            'application/json',
        ],
        'restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsPut' => [
            'application/json',
        ],
        'restItemsAttributesAttributeIdValuesGet' => [
            'application/json',
        ],
        'restItemsAttributesAttributeIdValuesIdDelete' => [
            'application/json',
        ],
        'restItemsAttributesAttributeIdValuesIdGet' => [
            'application/json',
        ],
        'restItemsAttributesAttributeIdValuesIdPut' => [
            'application/json',
        ],
        'restItemsAttributesAttributeIdValuesPost' => [
            'application/json',
        ],
        'restItemsAttributesGet' => [
            'application/json',
        ],
        'restItemsAttributesIdDelete' => [
            'application/json',
        ],
        'restItemsAttributesIdGet' => [
            'application/json',
        ],
        'restItemsAttributesIdPut' => [
            'application/json',
        ],
        'restItemsAttributesMapsGet' => [
            'application/json',
        ],
        'restItemsAttributesMarketsMapsPost' => [
            'application/json',
        ],
        'restItemsAttributesPost' => [
            'application/json',
        ],
        'restItemsAttributesValuesMapsGet' => [
            'application/json',
        ],
        'restItemsAttributesValuesMarketsMapsPost' => [
            'application/json',
        ],
        'restItemsBarcodesBarcodeIdDelete' => [
            'application/json',
        ],
        'restItemsBarcodesBarcodeIdGet' => [
            'application/json',
        ],
        'restItemsBarcodesBarcodeIdPut' => [
            'application/json',
        ],
        'restItemsBarcodesBarcodeIdReferrerPost' => [
            'application/json',
        ],
        'restItemsBarcodesBarcodeIdReferrerReferrerIdDelete' => [
            'application/json',
        ],
        'restItemsBarcodesGet' => [
            'application/json',
        ],
        'restItemsBarcodesPost' => [
            'application/json',
        ],
        'restItemsBarcodesReferrerReferrerIdGet' => [
            'application/json',
        ],
        'restItemsBarcodesTypeTypeGet' => [
            'application/json',
        ],
        'restItemsGet' => [
            'application/json',
        ],
        'restItemsIdImagesAttributeValueMarketsGet' => [
            'application/json',
        ],
        'restItemsIdImagesGet' => [
            'application/json',
        ],
        'restItemsIdImagesImageIdAttributeValueMarketsPost' => [
            'application/json',
        ],
        'restItemsIdImagesImageIdAttributeValueMarketsValueIdDelete' => [
            'application/json',
        ],
        'restItemsIdImagesImageIdAttributeValueMarketsValueIdGet' => [
            'application/json',
        ],
        'restItemsIdImagesImageIdAttributeValueMarketsValueIdPut' => [
            'application/json',
        ],
        'restItemsIdImagesImageIdAvailabilitiesDelete' => [
            'application/json',
        ],
        'restItemsIdImagesImageIdAvailabilitiesGet' => [
            'application/json',
        ],
        'restItemsIdImagesImageIdAvailabilitiesPost' => [
            'application/json',
        ],
        'restItemsIdImagesImageIdDelete' => [
            'application/json',
        ],
        'restItemsIdImagesImageIdGet' => [
            'application/json',
        ],
        'restItemsIdImagesImageIdNamesGet' => [
            'application/json',
        ],
        'restItemsIdImagesImageIdNamesLangDelete' => [
            'application/json',
        ],
        'restItemsIdImagesImageIdNamesLangGet' => [
            'application/json',
        ],
        'restItemsIdImagesImageIdNamesLangPut' => [
            'application/json',
        ],
        'restItemsIdImagesImageIdNamesPost' => [
            'application/json',
        ],
        'restItemsIdImagesImageIdPut' => [
            'application/json',
        ],
        'restItemsIdImagesImageIdVariationImagesGet' => [
            'application/json',
        ],
        'restItemsIdImagesUploadPost' => [
            'application/json',
        ],
        'restItemsIdItemCrossSellingCrossItemIdDelete' => [
            'application/json',
        ],
        'restItemsIdItemCrossSellingGet' => [
            'application/json',
        ],
        'restItemsIdItemCrossSellingPost' => [
            'application/json',
        ],
        'restItemsIdVariationImagesGet' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdDescriptionsGet' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdDescriptionsLangDelete' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdDescriptionsLangGet' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdDescriptionsLangPut' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdDescriptionsPost' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdImagesGet' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdLabelsPost' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdMarketIdentNumbersGet' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdDelete' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdGet' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdPut' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdMarketIdentNumbersPost' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdStockBookIncomingItemsPut' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdStockBookOutgoingItemsPut' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdStockCorrectionPut' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdStockGet' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdStockMovementsGet' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdStockRedistributePut' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdStockStorageLocationsGet' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdDelete' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdGet' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdPut' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationAdditionalSkusGet' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationAdditionalSkusPost' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdDelete' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdGet' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdPut' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationBarcodesGet' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationBarcodesPost' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationBundlesBundleIdDelete' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationBundlesBundleIdGet' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationBundlesBundleIdPut' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationBundlesGet' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationBundlesPost' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationCategoriesCatIdDelete' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationCategoriesCatIdGet' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationCategoriesCatIdPut' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationCategoriesGet' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationCategoriesPost' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationClientsGet' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationClientsPlentyIdDelete' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationClientsPost' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationComponentBundlesGet' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationDefaultCategoriesGet' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationDefaultCategoriesPlentyIdDelete' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationDefaultCategoriesPlentyIdGet' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationDefaultCategoriesPost' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationImagesGet' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationImagesImageIdDelete' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationImagesPost' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationMarketsDelete' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationMarketsGet' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationMarketsMarketplaceIdDelete' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationMarketsPost' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationPropertiesDelete' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationPropertiesGet' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationPropertiesPost' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationPropertiesPropertyIdDelete' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationPropertiesPropertyIdGet' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationPropertiesPropertyIdPut' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationSalesPricesDelete' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationSalesPricesGet' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationSalesPricesPost' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationSalesPricesPriceIdDelete' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationSalesPricesPriceIdGet' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationSalesPricesPriceIdPut' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationSkusGet' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationSkusPost' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationSkusSkuIdDelete' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationSkusSkuIdGet' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationSkusSkuIdPut' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationSuppliersGet' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationSuppliersPost' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdDelete' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdGet' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdPut' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationWarehousesGet' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationWarehousesPost' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdDelete' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdGet' => [
            'application/json',
        ],
        'restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdPut' => [
            'application/json',
        ],
        'restItemsItemIdDelete' => [
            'application/json',
        ],
        'restItemsItemIdFillPost' => [
            'application/json',
        ],
        'restItemsItemIdGet' => [
            'application/json',
        ],
        'restItemsItemIdItemShippingProfilesDelete' => [
            'application/json',
        ],
        'restItemsItemIdItemShippingProfilesGet' => [
            'application/json',
        ],
        'restItemsItemIdItemShippingProfilesIdDelete' => [
            'application/json',
        ],
        'restItemsItemIdItemShippingProfilesPost' => [
            'application/json',
        ],
        'restItemsItemIdPut' => [
            'application/json',
        ],
        'restItemsItemIdVariationsGet' => [
            'application/json',
        ],
        'restItemsItemIdVariationsPost' => [
            'application/json',
        ],
        'restItemsItemIdVariationsVariationIdDelete' => [
            'application/json',
        ],
        'restItemsItemIdVariationsVariationIdFillPost' => [
            'application/json',
        ],
        'restItemsItemIdVariationsVariationIdGet' => [
            'application/json',
        ],
        'restItemsItemIdVariationsVariationIdPut' => [
            'application/json',
        ],
        'restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsGet' => [
            'application/json',
        ],
        'restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangDelete' => [
            'application/json',
        ],
        'restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangGet' => [
            'application/json',
        ],
        'restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangPut' => [
            'application/json',
        ],
        'restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsPost' => [
            'application/json',
        ],
        'restItemsItemShippingProfilesGet' => [
            'application/json',
        ],
        'restItemsItemShippingProfilesPost' => [
            'application/json',
        ],
        'restItemsLabelsGet' => [
            'application/json',
        ],
        'restItemsManufacturersGet' => [
            'application/json',
        ],
        'restItemsManufacturersIdCommissionsGet' => [
            'application/json',
        ],
        'restItemsManufacturersIdCommissionsManufacturerIdDelete' => [
            'application/json',
        ],
        'restItemsManufacturersIdCommissionsManufacturerIdGet' => [
            'application/json',
        ],
        'restItemsManufacturersIdCommissionsManufacturerIdPut' => [
            'application/json',
        ],
        'restItemsManufacturersIdCommissionsPost' => [
            'application/json',
        ],
        'restItemsManufacturersIdDelete' => [
            'application/json',
        ],
        'restItemsManufacturersIdGet' => [
            'application/json',
        ],
        'restItemsManufacturersIdPut' => [
            'application/json',
        ],
        'restItemsManufacturersPost' => [
            'application/json',
        ],
        'restItemsPackingUnitsGet' => [
            'application/json',
        ],
        'restItemsPackingUnitsIdGet' => [
            'application/json',
        ],
        'restItemsPost' => [
            'application/json',
        ],
        'restItemsPropertiesGet' => [
            'application/json',
        ],
        'restItemsPropertiesIdDelete' => [
            'application/json',
        ],
        'restItemsPropertiesIdGet' => [
            'application/json',
        ],
        'restItemsPropertiesIdMarketReferencesGet' => [
            'application/json',
        ],
        'restItemsPropertiesIdMarketReferencesMarketIdDelete' => [
            'application/json',
        ],
        'restItemsPropertiesIdMarketReferencesMarketIdGet' => [
            'application/json',
        ],
        'restItemsPropertiesIdMarketReferencesMarketIdPut' => [
            'application/json',
        ],
        'restItemsPropertiesIdMarketReferencesPost' => [
            'application/json',
        ],
        'restItemsPropertiesIdNamesGet' => [
            'application/json',
        ],
        'restItemsPropertiesIdNamesLangDelete' => [
            'application/json',
        ],
        'restItemsPropertiesIdNamesLangGet' => [
            'application/json',
        ],
        'restItemsPropertiesIdNamesLangPut' => [
            'application/json',
        ],
        'restItemsPropertiesIdNamesPost' => [
            'application/json',
        ],
        'restItemsPropertiesIdPut' => [
            'application/json',
        ],
        'restItemsPropertiesPost' => [
            'application/json',
        ],
        'restItemsPropertiesPropertyIdSelectionsGet' => [
            'application/json',
        ],
        'restItemsPropertiesPropertyIdSelectionsIdDelete' => [
            'application/json',
        ],
        'restItemsPropertiesPropertyIdSelectionsIdGet' => [
            'application/json',
        ],
        'restItemsPropertiesPropertyIdSelectionsIdLangDelete' => [
            'application/json',
        ],
        'restItemsPropertiesPropertyIdSelectionsIdLangGet' => [
            'application/json',
        ],
        'restItemsPropertiesPropertyIdSelectionsIdLangPut' => [
            'application/json',
        ],
        'restItemsPropertiesPropertyIdSelectionsIdPost' => [
            'application/json',
        ],
        'restItemsPropertiesPropertyIdSelectionsLangGet' => [
            'application/json',
        ],
        'restItemsPropertiesPropertyIdSelectionsPost' => [
            'application/json',
        ],
        'restItemsPropertyGroupsGet' => [
            'application/json',
        ],
        'restItemsPropertyGroupsIdDelete' => [
            'application/json',
        ],
        'restItemsPropertyGroupsIdGet' => [
            'application/json',
        ],
        'restItemsPropertyGroupsIdNamesGet' => [
            'application/json',
        ],
        'restItemsPropertyGroupsIdNamesLangDelete' => [
            'application/json',
        ],
        'restItemsPropertyGroupsIdNamesLangGet' => [
            'application/json',
        ],
        'restItemsPropertyGroupsIdNamesLangPut' => [
            'application/json',
        ],
        'restItemsPropertyGroupsIdNamesPost' => [
            'application/json',
        ],
        'restItemsPropertyGroupsIdPut' => [
            'application/json',
        ],
        'restItemsPropertyGroupsPost' => [
            'application/json',
        ],
        'restItemsPut' => [
            'application/json',
        ],
        'restItemsSalesPricesGet' => [
            'application/json',
        ],
        'restItemsSalesPricesIdAccountsAccountTypeAccountIdDelete' => [
            'application/json',
        ],
        'restItemsSalesPricesIdAccountsGet' => [
            'application/json',
        ],
        'restItemsSalesPricesIdAccountsPost' => [
            'application/json',
        ],
        'restItemsSalesPricesIdCountriesCountryIdDelete' => [
            'application/json',
        ],
        'restItemsSalesPricesIdCountriesGet' => [
            'application/json',
        ],
        'restItemsSalesPricesIdCountriesPost' => [
            'application/json',
        ],
        'restItemsSalesPricesIdCurrenciesCurrencyDelete' => [
            'application/json',
        ],
        'restItemsSalesPricesIdCurrenciesGet' => [
            'application/json',
        ],
        'restItemsSalesPricesIdCurrenciesPost' => [
            'application/json',
        ],
        'restItemsSalesPricesIdCustomerClassesCustomerClassIdDelete' => [
            'application/json',
        ],
        'restItemsSalesPricesIdCustomerClassesGet' => [
            'application/json',
        ],
        'restItemsSalesPricesIdCustomerClassesPost' => [
            'application/json',
        ],
        'restItemsSalesPricesIdDelete' => [
            'application/json',
        ],
        'restItemsSalesPricesIdGet' => [
            'application/json',
        ],
        'restItemsSalesPricesIdNamesGet' => [
            'application/json',
        ],
        'restItemsSalesPricesIdNamesLangDelete' => [
            'application/json',
        ],
        'restItemsSalesPricesIdNamesLangGet' => [
            'application/json',
        ],
        'restItemsSalesPricesIdNamesLangPut' => [
            'application/json',
        ],
        'restItemsSalesPricesIdNamesPost' => [
            'application/json',
        ],
        'restItemsSalesPricesIdOnlineStoresGet' => [
            'application/json',
        ],
        'restItemsSalesPricesIdOnlineStoresPost' => [
            'application/json',
        ],
        'restItemsSalesPricesIdOnlineStoresWebstoreIdDelete' => [
            'application/json',
        ],
        'restItemsSalesPricesIdPut' => [
            'application/json',
        ],
        'restItemsSalesPricesIdReferrersGet' => [
            'application/json',
        ],
        'restItemsSalesPricesIdReferrersPost' => [
            'application/json',
        ],
        'restItemsSalesPricesIdReferrersReferrerIdDelete' => [
            'application/json',
        ],
        'restItemsSalesPricesPost' => [
            'application/json',
        ],
        'restItemsUnitsGet' => [
            'application/json',
        ],
        'restItemsUnitsIdDelete' => [
            'application/json',
        ],
        'restItemsUnitsIdGet' => [
            'application/json',
        ],
        'restItemsUnitsIdNamesGet' => [
            'application/json',
        ],
        'restItemsUnitsIdNamesLangDelete' => [
            'application/json',
        ],
        'restItemsUnitsIdNamesLangGet' => [
            'application/json',
        ],
        'restItemsUnitsIdNamesLangPut' => [
            'application/json',
        ],
        'restItemsUnitsIdNamesPost' => [
            'application/json',
        ],
        'restItemsUnitsIdPut' => [
            'application/json',
        ],
        'restItemsUnitsPost' => [
            'application/json',
        ],
        'restItemsVariationsGet' => [
            'application/json',
        ],
        'restItemsVariationsPut' => [
            'application/json',
        ],
        'restItemsVariationsVariationCategoriesPost' => [
            'application/json',
        ],
        'restItemsVariationsVariationCategoriesPut' => [
            'application/json',
        ],
        'restItemsVariationsVariationMarketsGet' => [
            'application/json',
        ],
        'restItemsVariationsVariationMarketsPost' => [
            'application/json',
        ],
        'restItemsVariationsVariationPropertiesPost' => [
            'application/json',
        ],
        'restItemsVariationsVariationPropertiesPut' => [
            'application/json',
        ],
        'restItemsVariationsVariationSalesPricesGet' => [
            'application/json',
        ],
        'restItemsVariationsVariationSalesPricesPost' => [
            'application/json',
        ],
        'restItemsVariationsVariationSalesPricesPut' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface|null $client
     * @param Configuration|null   $config
     * @param HeaderSelector|null  $selector
     * @param int                  $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex(int $hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex(): int
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig(): Configuration
    {
        return $this->config;
    }

    /**
     * Operation restAvailabilitiesGet
     *
     * List item availabilities
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAvailabilitiesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Availability[]
     */
    public function restAvailabilitiesGet(
        string $contentType = self::contentTypes['restAvailabilitiesGet'][0]
    ): array
    {
        list($response) = $this->restAvailabilitiesGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restAvailabilitiesGetWithHttpInfo
     *
     * List item availabilities
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAvailabilitiesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Availability[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAvailabilitiesGetWithHttpInfo(
        string $contentType = self::contentTypes['restAvailabilitiesGet'][0]
    ): array
    {
        $request = $this->restAvailabilitiesGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Availability[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Availability[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Availability[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Availability[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Availability[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAvailabilitiesGetAsync
     *
     * List item availabilities
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAvailabilitiesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAvailabilitiesGetAsync(
        string $contentType = self::contentTypes['restAvailabilitiesGet'][0]
    ): PromiseInterface
    {
        return $this->restAvailabilitiesGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAvailabilitiesGetAsyncWithHttpInfo
     *
     * List item availabilities
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAvailabilitiesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAvailabilitiesGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restAvailabilitiesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Availability[]';
        $request = $this->restAvailabilitiesGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAvailabilitiesGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAvailabilitiesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAvailabilitiesGetRequest(
        string $contentType = self::contentTypes['restAvailabilitiesGet'][0]
    ): Request
    {


        $resourcePath = '/rest/availabilities';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAvailabilitiesIdGet
     *
     * Get an item availability
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAvailabilitiesIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Availability
     */
    public function restAvailabilitiesIdGet(
        int $id,
        string $contentType = self::contentTypes['restAvailabilitiesIdGet'][0]
    ): \ck\Model\Availability
    {
        list($response) = $this->restAvailabilitiesIdGetWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation restAvailabilitiesIdGetWithHttpInfo
     *
     * Get an item availability
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAvailabilitiesIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Availability, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAvailabilitiesIdGetWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restAvailabilitiesIdGet'][0]
    ): array
    {
        $request = $this->restAvailabilitiesIdGetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Availability' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Availability' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Availability', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Availability';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Availability',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAvailabilitiesIdGetAsync
     *
     * Get an item availability
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAvailabilitiesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAvailabilitiesIdGetAsync(
        int $id,
        string $contentType = self::contentTypes['restAvailabilitiesIdGet'][0]
    ): PromiseInterface
    {
        return $this->restAvailabilitiesIdGetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAvailabilitiesIdGetAsyncWithHttpInfo
     *
     * Get an item availability
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAvailabilitiesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAvailabilitiesIdGetAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restAvailabilitiesIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Availability';
        $request = $this->restAvailabilitiesIdGetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAvailabilitiesIdGet'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAvailabilitiesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAvailabilitiesIdGetRequest(
        $id,
        string $contentType = self::contentTypes['restAvailabilitiesIdGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restAvailabilitiesIdGet'
            );
        }


        $resourcePath = '/rest/availabilities/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAvailabilitiesIdPut
     *
     * Update an item availability
     *
     * @param  int $id id (required)
     * @param  \ck\Model\RestAvailabilitiesIdPutRequest|null $_rest_availabilities_id _rest_availabilities_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAvailabilitiesIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Availability
     */
    public function restAvailabilitiesIdPut(
        int $id,
        ?\ck\Model\RestAvailabilitiesIdPutRequest $_rest_availabilities_id = null,
        string $contentType = self::contentTypes['restAvailabilitiesIdPut'][0]
    ): \ck\Model\Availability
    {
        list($response) = $this->restAvailabilitiesIdPutWithHttpInfo($id, $_rest_availabilities_id, $contentType);
        return $response;
    }

    /**
     * Operation restAvailabilitiesIdPutWithHttpInfo
     *
     * Update an item availability
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestAvailabilitiesIdPutRequest|null $_rest_availabilities_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAvailabilitiesIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Availability, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAvailabilitiesIdPutWithHttpInfo(
        int $id,
        ?\ck\Model\RestAvailabilitiesIdPutRequest $_rest_availabilities_id = null,
        string $contentType = self::contentTypes['restAvailabilitiesIdPut'][0]
    ): array
    {
        $request = $this->restAvailabilitiesIdPutRequest($id, $_rest_availabilities_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Availability' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Availability' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Availability', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Availability';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Availability',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAvailabilitiesIdPutAsync
     *
     * Update an item availability
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestAvailabilitiesIdPutRequest|null $_rest_availabilities_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAvailabilitiesIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAvailabilitiesIdPutAsync(
        int $id,
        ?\ck\Model\RestAvailabilitiesIdPutRequest $_rest_availabilities_id = null,
        string $contentType = self::contentTypes['restAvailabilitiesIdPut'][0]
    ): PromiseInterface
    {
        return $this->restAvailabilitiesIdPutAsyncWithHttpInfo($id, $_rest_availabilities_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAvailabilitiesIdPutAsyncWithHttpInfo
     *
     * Update an item availability
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestAvailabilitiesIdPutRequest|null $_rest_availabilities_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAvailabilitiesIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAvailabilitiesIdPutAsyncWithHttpInfo(
        $id,
        $_rest_availabilities_id = null,
        string $contentType = self::contentTypes['restAvailabilitiesIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Availability';
        $request = $this->restAvailabilitiesIdPutRequest($id, $_rest_availabilities_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAvailabilitiesIdPut'
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestAvailabilitiesIdPutRequest|null $_rest_availabilities_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAvailabilitiesIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAvailabilitiesIdPutRequest(
        $id,
        $_rest_availabilities_id = null,
        string $contentType = self::contentTypes['restAvailabilitiesIdPut'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restAvailabilitiesIdPut'
            );
        }



        $resourcePath = '/rest/availabilities/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_availabilities_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_availabilities_id));
            } else {
                $httpBody = $_rest_availabilities_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemSetsDelete
     *
     * Delete item sets
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ItemSet[]
     */
    public function restItemSetsDelete(
        string $contentType = self::contentTypes['restItemSetsDelete'][0]
    ): array
    {
        list($response) = $this->restItemSetsDeleteWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restItemSetsDeleteWithHttpInfo
     *
     * Delete item sets
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ItemSet[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemSetsDeleteWithHttpInfo(
        string $contentType = self::contentTypes['restItemSetsDelete'][0]
    ): array
    {
        $request = $this->restItemSetsDeleteRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ItemSet[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ItemSet[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ItemSet[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ItemSet[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ItemSet[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemSetsDeleteAsync
     *
     * Delete item sets
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemSetsDeleteAsync(
        string $contentType = self::contentTypes['restItemSetsDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemSetsDeleteAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemSetsDeleteAsyncWithHttpInfo
     *
     * Delete item sets
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemSetsDeleteAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restItemSetsDelete'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ItemSet[]';
        $request = $this->restItemSetsDeleteRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemSetsDelete'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemSetsDeleteRequest(
        string $contentType = self::contentTypes['restItemSetsDelete'][0]
    ): Request
    {


        $resourcePath = '/rest/item_sets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemSetsGet
     *
     * List item sets
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ItemSet[]
     */
    public function restItemSetsGet(
        string $contentType = self::contentTypes['restItemSetsGet'][0]
    ): array
    {
        list($response) = $this->restItemSetsGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restItemSetsGetWithHttpInfo
     *
     * List item sets
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ItemSet[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemSetsGetWithHttpInfo(
        string $contentType = self::contentTypes['restItemSetsGet'][0]
    ): array
    {
        $request = $this->restItemSetsGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ItemSet[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ItemSet[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ItemSet[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ItemSet[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ItemSet[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemSetsGetAsync
     *
     * List item sets
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemSetsGetAsync(
        string $contentType = self::contentTypes['restItemSetsGet'][0]
    ): PromiseInterface
    {
        return $this->restItemSetsGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemSetsGetAsyncWithHttpInfo
     *
     * List item sets
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemSetsGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restItemSetsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ItemSet[]';
        $request = $this->restItemSetsGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemSetsGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemSetsGetRequest(
        string $contentType = self::contentTypes['restItemSetsGet'][0]
    ): Request
    {


        $resourcePath = '/rest/item_sets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemSetsIdDelete
     *
     * Delete an item set
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemSetsIdDelete(
        int $id,
        string $contentType = self::contentTypes['restItemSetsIdDelete'][0]
    ): object
    {
        list($response) = $this->restItemSetsIdDeleteWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation restItemSetsIdDeleteWithHttpInfo
     *
     * Delete an item set
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemSetsIdDeleteWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restItemSetsIdDelete'][0]
    ): array
    {
        $request = $this->restItemSetsIdDeleteRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemSetsIdDeleteAsync
     *
     * Delete an item set
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemSetsIdDeleteAsync(
        int $id,
        string $contentType = self::contentTypes['restItemSetsIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemSetsIdDeleteAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemSetsIdDeleteAsyncWithHttpInfo
     *
     * Delete an item set
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemSetsIdDeleteAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restItemSetsIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemSetsIdDeleteRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemSetsIdDelete'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemSetsIdDeleteRequest(
        $id,
        string $contentType = self::contentTypes['restItemSetsIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemSetsIdDelete'
            );
        }


        $resourcePath = '/rest/item_sets/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemSetsIdGet
     *
     * Get an item set
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ItemSet
     */
    public function restItemSetsIdGet(
        int $id,
        string $contentType = self::contentTypes['restItemSetsIdGet'][0]
    ): \ck\Model\ItemSet
    {
        list($response) = $this->restItemSetsIdGetWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation restItemSetsIdGetWithHttpInfo
     *
     * Get an item set
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ItemSet, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemSetsIdGetWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restItemSetsIdGet'][0]
    ): array
    {
        $request = $this->restItemSetsIdGetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ItemSet' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ItemSet' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ItemSet', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ItemSet';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ItemSet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemSetsIdGetAsync
     *
     * Get an item set
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemSetsIdGetAsync(
        int $id,
        string $contentType = self::contentTypes['restItemSetsIdGet'][0]
    ): PromiseInterface
    {
        return $this->restItemSetsIdGetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemSetsIdGetAsyncWithHttpInfo
     *
     * Get an item set
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemSetsIdGetAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restItemSetsIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ItemSet';
        $request = $this->restItemSetsIdGetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemSetsIdGet'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemSetsIdGetRequest(
        $id,
        string $contentType = self::contentTypes['restItemSetsIdGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemSetsIdGet'
            );
        }


        $resourcePath = '/rest/item_sets/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemSetsIdPut
     *
     * Update an item set
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ItemSet
     */
    public function restItemSetsIdPut(
        int $id,
        string $contentType = self::contentTypes['restItemSetsIdPut'][0]
    ): \ck\Model\ItemSet
    {
        list($response) = $this->restItemSetsIdPutWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation restItemSetsIdPutWithHttpInfo
     *
     * Update an item set
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ItemSet, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemSetsIdPutWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restItemSetsIdPut'][0]
    ): array
    {
        $request = $this->restItemSetsIdPutRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ItemSet' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ItemSet' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ItemSet', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ItemSet';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ItemSet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemSetsIdPutAsync
     *
     * Update an item set
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemSetsIdPutAsync(
        int $id,
        string $contentType = self::contentTypes['restItemSetsIdPut'][0]
    ): PromiseInterface
    {
        return $this->restItemSetsIdPutAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemSetsIdPutAsyncWithHttpInfo
     *
     * Update an item set
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemSetsIdPutAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restItemSetsIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ItemSet';
        $request = $this->restItemSetsIdPutRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemSetsIdPut'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemSetsIdPutRequest(
        $id,
        string $contentType = self::contentTypes['restItemSetsIdPut'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemSetsIdPut'
            );
        }


        $resourcePath = '/rest/item_sets/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemSetsPost
     *
     * Create item sets
     *
     * @param  int|null $params includes the item sets that have to be created (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ItemSet
     */
    public function restItemSetsPost(
        ?int $params = null,
        string $contentType = self::contentTypes['restItemSetsPost'][0]
    ): \ck\Model\ItemSet
    {
        list($response) = $this->restItemSetsPostWithHttpInfo($params, $contentType);
        return $response;
    }

    /**
     * Operation restItemSetsPostWithHttpInfo
     *
     * Create item sets
     *
     * @param  int|null $params includes the item sets that have to be created (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ItemSet, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemSetsPostWithHttpInfo(
        ?int $params = null,
        string $contentType = self::contentTypes['restItemSetsPost'][0]
    ): array
    {
        $request = $this->restItemSetsPostRequest($params, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ItemSet' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ItemSet' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ItemSet', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ItemSet';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ItemSet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemSetsPostAsync
     *
     * Create item sets
     *
     * @param  int|null $params includes the item sets that have to be created (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemSetsPostAsync(
        ?int $params = null,
        string $contentType = self::contentTypes['restItemSetsPost'][0]
    ): PromiseInterface
    {
        return $this->restItemSetsPostAsyncWithHttpInfo($params, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemSetsPostAsyncWithHttpInfo
     *
     * Create item sets
     *
     * @param  int|null $params includes the item sets that have to be created (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemSetsPostAsyncWithHttpInfo(
        $params = null,
        string $contentType = self::contentTypes['restItemSetsPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ItemSet';
        $request = $this->restItemSetsPostRequest($params, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemSetsPost'
     *
     * @param  int|null $params includes the item sets that have to be created (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemSetsPostRequest(
        $params = null,
        string $contentType = self::contentTypes['restItemSetsPost'][0]
    ): Request
    {



        $resourcePath = '/rest/item_sets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $params,
            'params', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemSetsPut
     *
     * Update item sets
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ItemSet[]
     */
    public function restItemSetsPut(
        string $contentType = self::contentTypes['restItemSetsPut'][0]
    ): array
    {
        list($response) = $this->restItemSetsPutWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restItemSetsPutWithHttpInfo
     *
     * Update item sets
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ItemSet[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemSetsPutWithHttpInfo(
        string $contentType = self::contentTypes['restItemSetsPut'][0]
    ): array
    {
        $request = $this->restItemSetsPutRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ItemSet[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ItemSet[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ItemSet[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ItemSet[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ItemSet[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemSetsPutAsync
     *
     * Update item sets
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemSetsPutAsync(
        string $contentType = self::contentTypes['restItemSetsPut'][0]
    ): PromiseInterface
    {
        return $this->restItemSetsPutAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemSetsPutAsyncWithHttpInfo
     *
     * Update item sets
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemSetsPutAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restItemSetsPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ItemSet[]';
        $request = $this->restItemSetsPutRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemSetsPut'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemSetsPutRequest(
        string $contentType = self::contentTypes['restItemSetsPut'][0]
    ): Request
    {


        $resourcePath = '/rest/item_sets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemSetsSetIdComponentsDelete
     *
     * Delete item set components
     *
     * @param  int $set_id set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsSetIdComponentsDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ItemSetComponent
     */
    public function restItemSetsSetIdComponentsDelete(
        int $set_id,
        string $contentType = self::contentTypes['restItemSetsSetIdComponentsDelete'][0]
    ): \ck\Model\ItemSetComponent
    {
        list($response) = $this->restItemSetsSetIdComponentsDeleteWithHttpInfo($set_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemSetsSetIdComponentsDeleteWithHttpInfo
     *
     * Delete item set components
     *
     * @param  int $set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsSetIdComponentsDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ItemSetComponent, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemSetsSetIdComponentsDeleteWithHttpInfo(
        int $set_id,
        string $contentType = self::contentTypes['restItemSetsSetIdComponentsDelete'][0]
    ): array
    {
        $request = $this->restItemSetsSetIdComponentsDeleteRequest($set_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ItemSetComponent' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ItemSetComponent' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ItemSetComponent', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ItemSetComponent';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ItemSetComponent',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemSetsSetIdComponentsDeleteAsync
     *
     * Delete item set components
     *
     * @param  int $set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsSetIdComponentsDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemSetsSetIdComponentsDeleteAsync(
        int $set_id,
        string $contentType = self::contentTypes['restItemSetsSetIdComponentsDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemSetsSetIdComponentsDeleteAsyncWithHttpInfo($set_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemSetsSetIdComponentsDeleteAsyncWithHttpInfo
     *
     * Delete item set components
     *
     * @param  int $set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsSetIdComponentsDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemSetsSetIdComponentsDeleteAsyncWithHttpInfo(
        $set_id,
        string $contentType = self::contentTypes['restItemSetsSetIdComponentsDelete'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ItemSetComponent';
        $request = $this->restItemSetsSetIdComponentsDeleteRequest($set_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemSetsSetIdComponentsDelete'
     *
     * @param  int $set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsSetIdComponentsDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemSetsSetIdComponentsDeleteRequest(
        $set_id,
        string $contentType = self::contentTypes['restItemSetsSetIdComponentsDelete'][0]
    ): Request
    {

        // verify the required parameter 'set_id' is set
        if ($set_id === null || (is_array($set_id) && count($set_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $set_id when calling restItemSetsSetIdComponentsDelete'
            );
        }


        $resourcePath = '/rest/item_sets/{setId}/components';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($set_id !== null) {
            $resourcePath = str_replace(
                '{' . 'setId' . '}',
                ObjectSerializer::toPathValue($set_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemSetsSetIdComponentsGet
     *
     * List item set components of an item set
     *
     * @param  int $set_id set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsSetIdComponentsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ItemSetComponent[]
     */
    public function restItemSetsSetIdComponentsGet(
        int $set_id,
        string $contentType = self::contentTypes['restItemSetsSetIdComponentsGet'][0]
    ): array
    {
        list($response) = $this->restItemSetsSetIdComponentsGetWithHttpInfo($set_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemSetsSetIdComponentsGetWithHttpInfo
     *
     * List item set components of an item set
     *
     * @param  int $set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsSetIdComponentsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ItemSetComponent[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemSetsSetIdComponentsGetWithHttpInfo(
        int $set_id,
        string $contentType = self::contentTypes['restItemSetsSetIdComponentsGet'][0]
    ): array
    {
        $request = $this->restItemSetsSetIdComponentsGetRequest($set_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ItemSetComponent[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ItemSetComponent[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ItemSetComponent[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ItemSetComponent[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ItemSetComponent[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemSetsSetIdComponentsGetAsync
     *
     * List item set components of an item set
     *
     * @param  int $set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsSetIdComponentsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemSetsSetIdComponentsGetAsync(
        int $set_id,
        string $contentType = self::contentTypes['restItemSetsSetIdComponentsGet'][0]
    ): PromiseInterface
    {
        return $this->restItemSetsSetIdComponentsGetAsyncWithHttpInfo($set_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemSetsSetIdComponentsGetAsyncWithHttpInfo
     *
     * List item set components of an item set
     *
     * @param  int $set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsSetIdComponentsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemSetsSetIdComponentsGetAsyncWithHttpInfo(
        $set_id,
        string $contentType = self::contentTypes['restItemSetsSetIdComponentsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ItemSetComponent[]';
        $request = $this->restItemSetsSetIdComponentsGetRequest($set_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemSetsSetIdComponentsGet'
     *
     * @param  int $set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsSetIdComponentsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemSetsSetIdComponentsGetRequest(
        $set_id,
        string $contentType = self::contentTypes['restItemSetsSetIdComponentsGet'][0]
    ): Request
    {

        // verify the required parameter 'set_id' is set
        if ($set_id === null || (is_array($set_id) && count($set_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $set_id when calling restItemSetsSetIdComponentsGet'
            );
        }


        $resourcePath = '/rest/item_sets/{setId}/components';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($set_id !== null) {
            $resourcePath = str_replace(
                '{' . 'setId' . '}',
                ObjectSerializer::toPathValue($set_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemSetsSetIdComponentsIdDelete
     *
     * Delete an item set component
     *
     * @param  int $set_id set_id (required)
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsSetIdComponentsIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemSetsSetIdComponentsIdDelete(
        int $set_id,
        int $id,
        string $contentType = self::contentTypes['restItemSetsSetIdComponentsIdDelete'][0]
    ): object
    {
        list($response) = $this->restItemSetsSetIdComponentsIdDeleteWithHttpInfo($set_id, $id, $contentType);
        return $response;
    }

    /**
     * Operation restItemSetsSetIdComponentsIdDeleteWithHttpInfo
     *
     * Delete an item set component
     *
     * @param  int $set_id (required)
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsSetIdComponentsIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemSetsSetIdComponentsIdDeleteWithHttpInfo(
        int $set_id,
        int $id,
        string $contentType = self::contentTypes['restItemSetsSetIdComponentsIdDelete'][0]
    ): array
    {
        $request = $this->restItemSetsSetIdComponentsIdDeleteRequest($set_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemSetsSetIdComponentsIdDeleteAsync
     *
     * Delete an item set component
     *
     * @param  int $set_id (required)
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsSetIdComponentsIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemSetsSetIdComponentsIdDeleteAsync(
        int $set_id,
        int $id,
        string $contentType = self::contentTypes['restItemSetsSetIdComponentsIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemSetsSetIdComponentsIdDeleteAsyncWithHttpInfo($set_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemSetsSetIdComponentsIdDeleteAsyncWithHttpInfo
     *
     * Delete an item set component
     *
     * @param  int $set_id (required)
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsSetIdComponentsIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemSetsSetIdComponentsIdDeleteAsyncWithHttpInfo(
        $set_id,
        $id,
        string $contentType = self::contentTypes['restItemSetsSetIdComponentsIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemSetsSetIdComponentsIdDeleteRequest($set_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemSetsSetIdComponentsIdDelete'
     *
     * @param  int $set_id (required)
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsSetIdComponentsIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemSetsSetIdComponentsIdDeleteRequest(
        $set_id,
        $id,
        string $contentType = self::contentTypes['restItemSetsSetIdComponentsIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'set_id' is set
        if ($set_id === null || (is_array($set_id) && count($set_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $set_id when calling restItemSetsSetIdComponentsIdDelete'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemSetsSetIdComponentsIdDelete'
            );
        }


        $resourcePath = '/rest/item_sets/{setId}/components/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($set_id !== null) {
            $resourcePath = str_replace(
                '{' . 'setId' . '}',
                ObjectSerializer::toPathValue($set_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemSetsSetIdComponentsIdGet
     *
     * Get an item set component
     *
     * @param  int $set_id set_id (required)
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsSetIdComponentsIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ItemSetComponent
     */
    public function restItemSetsSetIdComponentsIdGet(
        int $set_id,
        int $id,
        string $contentType = self::contentTypes['restItemSetsSetIdComponentsIdGet'][0]
    ): \ck\Model\ItemSetComponent
    {
        list($response) = $this->restItemSetsSetIdComponentsIdGetWithHttpInfo($set_id, $id, $contentType);
        return $response;
    }

    /**
     * Operation restItemSetsSetIdComponentsIdGetWithHttpInfo
     *
     * Get an item set component
     *
     * @param  int $set_id (required)
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsSetIdComponentsIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ItemSetComponent, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemSetsSetIdComponentsIdGetWithHttpInfo(
        int $set_id,
        int $id,
        string $contentType = self::contentTypes['restItemSetsSetIdComponentsIdGet'][0]
    ): array
    {
        $request = $this->restItemSetsSetIdComponentsIdGetRequest($set_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ItemSetComponent' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ItemSetComponent' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ItemSetComponent', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ItemSetComponent';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ItemSetComponent',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemSetsSetIdComponentsIdGetAsync
     *
     * Get an item set component
     *
     * @param  int $set_id (required)
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsSetIdComponentsIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemSetsSetIdComponentsIdGetAsync(
        int $set_id,
        int $id,
        string $contentType = self::contentTypes['restItemSetsSetIdComponentsIdGet'][0]
    ): PromiseInterface
    {
        return $this->restItemSetsSetIdComponentsIdGetAsyncWithHttpInfo($set_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemSetsSetIdComponentsIdGetAsyncWithHttpInfo
     *
     * Get an item set component
     *
     * @param  int $set_id (required)
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsSetIdComponentsIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemSetsSetIdComponentsIdGetAsyncWithHttpInfo(
        $set_id,
        $id,
        string $contentType = self::contentTypes['restItemSetsSetIdComponentsIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ItemSetComponent';
        $request = $this->restItemSetsSetIdComponentsIdGetRequest($set_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemSetsSetIdComponentsIdGet'
     *
     * @param  int $set_id (required)
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsSetIdComponentsIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemSetsSetIdComponentsIdGetRequest(
        $set_id,
        $id,
        string $contentType = self::contentTypes['restItemSetsSetIdComponentsIdGet'][0]
    ): Request
    {

        // verify the required parameter 'set_id' is set
        if ($set_id === null || (is_array($set_id) && count($set_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $set_id when calling restItemSetsSetIdComponentsIdGet'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemSetsSetIdComponentsIdGet'
            );
        }


        $resourcePath = '/rest/item_sets/{setId}/components/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($set_id !== null) {
            $resourcePath = str_replace(
                '{' . 'setId' . '}',
                ObjectSerializer::toPathValue($set_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemSetsSetIdComponentsIdPut
     *
     * Update an item set component
     *
     * @param  int $set_id set_id (required)
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsSetIdComponentsIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ItemSetComponent
     */
    public function restItemSetsSetIdComponentsIdPut(
        int $set_id,
        int $id,
        string $contentType = self::contentTypes['restItemSetsSetIdComponentsIdPut'][0]
    ): \ck\Model\ItemSetComponent
    {
        list($response) = $this->restItemSetsSetIdComponentsIdPutWithHttpInfo($set_id, $id, $contentType);
        return $response;
    }

    /**
     * Operation restItemSetsSetIdComponentsIdPutWithHttpInfo
     *
     * Update an item set component
     *
     * @param  int $set_id (required)
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsSetIdComponentsIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ItemSetComponent, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemSetsSetIdComponentsIdPutWithHttpInfo(
        int $set_id,
        int $id,
        string $contentType = self::contentTypes['restItemSetsSetIdComponentsIdPut'][0]
    ): array
    {
        $request = $this->restItemSetsSetIdComponentsIdPutRequest($set_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ItemSetComponent' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ItemSetComponent' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ItemSetComponent', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ItemSetComponent';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ItemSetComponent',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemSetsSetIdComponentsIdPutAsync
     *
     * Update an item set component
     *
     * @param  int $set_id (required)
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsSetIdComponentsIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemSetsSetIdComponentsIdPutAsync(
        int $set_id,
        int $id,
        string $contentType = self::contentTypes['restItemSetsSetIdComponentsIdPut'][0]
    ): PromiseInterface
    {
        return $this->restItemSetsSetIdComponentsIdPutAsyncWithHttpInfo($set_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemSetsSetIdComponentsIdPutAsyncWithHttpInfo
     *
     * Update an item set component
     *
     * @param  int $set_id (required)
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsSetIdComponentsIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemSetsSetIdComponentsIdPutAsyncWithHttpInfo(
        $set_id,
        $id,
        string $contentType = self::contentTypes['restItemSetsSetIdComponentsIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ItemSetComponent';
        $request = $this->restItemSetsSetIdComponentsIdPutRequest($set_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemSetsSetIdComponentsIdPut'
     *
     * @param  int $set_id (required)
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsSetIdComponentsIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemSetsSetIdComponentsIdPutRequest(
        $set_id,
        $id,
        string $contentType = self::contentTypes['restItemSetsSetIdComponentsIdPut'][0]
    ): Request
    {

        // verify the required parameter 'set_id' is set
        if ($set_id === null || (is_array($set_id) && count($set_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $set_id when calling restItemSetsSetIdComponentsIdPut'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemSetsSetIdComponentsIdPut'
            );
        }


        $resourcePath = '/rest/item_sets/{setId}/components/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($set_id !== null) {
            $resourcePath = str_replace(
                '{' . 'setId' . '}',
                ObjectSerializer::toPathValue($set_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemSetsSetIdComponentsPost
     *
     * Create item set components
     *
     * @param  int $set_id set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsSetIdComponentsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ItemSetComponent
     */
    public function restItemSetsSetIdComponentsPost(
        int $set_id,
        string $contentType = self::contentTypes['restItemSetsSetIdComponentsPost'][0]
    ): \ck\Model\ItemSetComponent
    {
        list($response) = $this->restItemSetsSetIdComponentsPostWithHttpInfo($set_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemSetsSetIdComponentsPostWithHttpInfo
     *
     * Create item set components
     *
     * @param  int $set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsSetIdComponentsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ItemSetComponent, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemSetsSetIdComponentsPostWithHttpInfo(
        int $set_id,
        string $contentType = self::contentTypes['restItemSetsSetIdComponentsPost'][0]
    ): array
    {
        $request = $this->restItemSetsSetIdComponentsPostRequest($set_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ItemSetComponent' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ItemSetComponent' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ItemSetComponent', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ItemSetComponent';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ItemSetComponent',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemSetsSetIdComponentsPostAsync
     *
     * Create item set components
     *
     * @param  int $set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsSetIdComponentsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemSetsSetIdComponentsPostAsync(
        int $set_id,
        string $contentType = self::contentTypes['restItemSetsSetIdComponentsPost'][0]
    ): PromiseInterface
    {
        return $this->restItemSetsSetIdComponentsPostAsyncWithHttpInfo($set_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemSetsSetIdComponentsPostAsyncWithHttpInfo
     *
     * Create item set components
     *
     * @param  int $set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsSetIdComponentsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemSetsSetIdComponentsPostAsyncWithHttpInfo(
        $set_id,
        string $contentType = self::contentTypes['restItemSetsSetIdComponentsPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ItemSetComponent';
        $request = $this->restItemSetsSetIdComponentsPostRequest($set_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemSetsSetIdComponentsPost'
     *
     * @param  int $set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsSetIdComponentsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemSetsSetIdComponentsPostRequest(
        $set_id,
        string $contentType = self::contentTypes['restItemSetsSetIdComponentsPost'][0]
    ): Request
    {

        // verify the required parameter 'set_id' is set
        if ($set_id === null || (is_array($set_id) && count($set_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $set_id when calling restItemSetsSetIdComponentsPost'
            );
        }


        $resourcePath = '/rest/item_sets/{setId}/components';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($set_id !== null) {
            $resourcePath = str_replace(
                '{' . 'setId' . '}',
                ObjectSerializer::toPathValue($set_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemSetsSetIdComponentsPut
     *
     * Update item set components
     *
     * @param  int $set_id set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsSetIdComponentsPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ItemSetComponent
     */
    public function restItemSetsSetIdComponentsPut(
        int $set_id,
        string $contentType = self::contentTypes['restItemSetsSetIdComponentsPut'][0]
    ): \ck\Model\ItemSetComponent
    {
        list($response) = $this->restItemSetsSetIdComponentsPutWithHttpInfo($set_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemSetsSetIdComponentsPutWithHttpInfo
     *
     * Update item set components
     *
     * @param  int $set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsSetIdComponentsPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ItemSetComponent, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemSetsSetIdComponentsPutWithHttpInfo(
        int $set_id,
        string $contentType = self::contentTypes['restItemSetsSetIdComponentsPut'][0]
    ): array
    {
        $request = $this->restItemSetsSetIdComponentsPutRequest($set_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ItemSetComponent' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ItemSetComponent' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ItemSetComponent', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ItemSetComponent';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ItemSetComponent',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemSetsSetIdComponentsPutAsync
     *
     * Update item set components
     *
     * @param  int $set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsSetIdComponentsPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemSetsSetIdComponentsPutAsync(
        int $set_id,
        string $contentType = self::contentTypes['restItemSetsSetIdComponentsPut'][0]
    ): PromiseInterface
    {
        return $this->restItemSetsSetIdComponentsPutAsyncWithHttpInfo($set_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemSetsSetIdComponentsPutAsyncWithHttpInfo
     *
     * Update item set components
     *
     * @param  int $set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsSetIdComponentsPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemSetsSetIdComponentsPutAsyncWithHttpInfo(
        $set_id,
        string $contentType = self::contentTypes['restItemSetsSetIdComponentsPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ItemSetComponent';
        $request = $this->restItemSetsSetIdComponentsPutRequest($set_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemSetsSetIdComponentsPut'
     *
     * @param  int $set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsSetIdComponentsPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemSetsSetIdComponentsPutRequest(
        $set_id,
        string $contentType = self::contentTypes['restItemSetsSetIdComponentsPut'][0]
    ): Request
    {

        // verify the required parameter 'set_id' is set
        if ($set_id === null || (is_array($set_id) && count($set_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $set_id when calling restItemSetsSetIdComponentsPut'
            );
        }


        $resourcePath = '/rest/item_sets/{setId}/components';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($set_id !== null) {
            $resourcePath = str_replace(
                '{' . 'setId' . '}',
                ObjectSerializer::toPathValue($set_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemSetsSetIdConfigGet
     *
     * Get the item set configuration of an item set
     *
     * @param  int $set_id set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsSetIdConfigGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ItemSetConfig
     */
    public function restItemSetsSetIdConfigGet(
        int $set_id,
        string $contentType = self::contentTypes['restItemSetsSetIdConfigGet'][0]
    ): \ck\Model\ItemSetConfig
    {
        list($response) = $this->restItemSetsSetIdConfigGetWithHttpInfo($set_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemSetsSetIdConfigGetWithHttpInfo
     *
     * Get the item set configuration of an item set
     *
     * @param  int $set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsSetIdConfigGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ItemSetConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemSetsSetIdConfigGetWithHttpInfo(
        int $set_id,
        string $contentType = self::contentTypes['restItemSetsSetIdConfigGet'][0]
    ): array
    {
        $request = $this->restItemSetsSetIdConfigGetRequest($set_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ItemSetConfig' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ItemSetConfig' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ItemSetConfig', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ItemSetConfig';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ItemSetConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemSetsSetIdConfigGetAsync
     *
     * Get the item set configuration of an item set
     *
     * @param  int $set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsSetIdConfigGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemSetsSetIdConfigGetAsync(
        int $set_id,
        string $contentType = self::contentTypes['restItemSetsSetIdConfigGet'][0]
    ): PromiseInterface
    {
        return $this->restItemSetsSetIdConfigGetAsyncWithHttpInfo($set_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemSetsSetIdConfigGetAsyncWithHttpInfo
     *
     * Get the item set configuration of an item set
     *
     * @param  int $set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsSetIdConfigGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemSetsSetIdConfigGetAsyncWithHttpInfo(
        $set_id,
        string $contentType = self::contentTypes['restItemSetsSetIdConfigGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ItemSetConfig';
        $request = $this->restItemSetsSetIdConfigGetRequest($set_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemSetsSetIdConfigGet'
     *
     * @param  int $set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsSetIdConfigGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemSetsSetIdConfigGetRequest(
        $set_id,
        string $contentType = self::contentTypes['restItemSetsSetIdConfigGet'][0]
    ): Request
    {

        // verify the required parameter 'set_id' is set
        if ($set_id === null || (is_array($set_id) && count($set_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $set_id when calling restItemSetsSetIdConfigGet'
            );
        }


        $resourcePath = '/rest/item_sets/{setId}/config';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($set_id !== null) {
            $resourcePath = str_replace(
                '{' . 'setId' . '}',
                ObjectSerializer::toPathValue($set_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemSetsSetIdConfigPut
     *
     * Update an item set configuration
     *
     * @param  int $set_id set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsSetIdConfigPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ItemSetConfig
     */
    public function restItemSetsSetIdConfigPut(
        int $set_id,
        string $contentType = self::contentTypes['restItemSetsSetIdConfigPut'][0]
    ): \ck\Model\ItemSetConfig
    {
        list($response) = $this->restItemSetsSetIdConfigPutWithHttpInfo($set_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemSetsSetIdConfigPutWithHttpInfo
     *
     * Update an item set configuration
     *
     * @param  int $set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsSetIdConfigPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ItemSetConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemSetsSetIdConfigPutWithHttpInfo(
        int $set_id,
        string $contentType = self::contentTypes['restItemSetsSetIdConfigPut'][0]
    ): array
    {
        $request = $this->restItemSetsSetIdConfigPutRequest($set_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ItemSetConfig' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ItemSetConfig' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ItemSetConfig', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ItemSetConfig';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ItemSetConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemSetsSetIdConfigPutAsync
     *
     * Update an item set configuration
     *
     * @param  int $set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsSetIdConfigPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemSetsSetIdConfigPutAsync(
        int $set_id,
        string $contentType = self::contentTypes['restItemSetsSetIdConfigPut'][0]
    ): PromiseInterface
    {
        return $this->restItemSetsSetIdConfigPutAsyncWithHttpInfo($set_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemSetsSetIdConfigPutAsyncWithHttpInfo
     *
     * Update an item set configuration
     *
     * @param  int $set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsSetIdConfigPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemSetsSetIdConfigPutAsyncWithHttpInfo(
        $set_id,
        string $contentType = self::contentTypes['restItemSetsSetIdConfigPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ItemSetConfig';
        $request = $this->restItemSetsSetIdConfigPutRequest($set_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemSetsSetIdConfigPut'
     *
     * @param  int $set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemSetsSetIdConfigPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemSetsSetIdConfigPutRequest(
        $set_id,
        string $contentType = self::contentTypes['restItemSetsSetIdConfigPut'][0]
    ): Request
    {

        // verify the required parameter 'set_id' is set
        if ($set_id === null || (is_array($set_id) && count($set_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $set_id when calling restItemSetsSetIdConfigPut'
            );
        }


        $resourcePath = '/rest/item_sets/{setId}/config';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($set_id !== null) {
            $resourcePath = str_replace(
                '{' . 'setId' . '}',
                ObjectSerializer::toPathValue($set_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsAttributeValuesValueIdNamesGet
     *
     * Get name and language for an attribute value ID
     *
     * @param  int $value_id value_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributeValuesValueIdNamesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\AttributeValueName[]
     */
    public function restItemsAttributeValuesValueIdNamesGet(
        int $value_id,
        string $contentType = self::contentTypes['restItemsAttributeValuesValueIdNamesGet'][0]
    ): array
    {
        list($response) = $this->restItemsAttributeValuesValueIdNamesGetWithHttpInfo($value_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsAttributeValuesValueIdNamesGetWithHttpInfo
     *
     * Get name and language for an attribute value ID
     *
     * @param  int $value_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributeValuesValueIdNamesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\AttributeValueName[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsAttributeValuesValueIdNamesGetWithHttpInfo(
        int $value_id,
        string $contentType = self::contentTypes['restItemsAttributeValuesValueIdNamesGet'][0]
    ): array
    {
        $request = $this->restItemsAttributeValuesValueIdNamesGetRequest($value_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\AttributeValueName[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\AttributeValueName[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\AttributeValueName[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\AttributeValueName[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\AttributeValueName[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsAttributeValuesValueIdNamesGetAsync
     *
     * Get name and language for an attribute value ID
     *
     * @param  int $value_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributeValuesValueIdNamesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributeValuesValueIdNamesGetAsync(
        int $value_id,
        string $contentType = self::contentTypes['restItemsAttributeValuesValueIdNamesGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsAttributeValuesValueIdNamesGetAsyncWithHttpInfo($value_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsAttributeValuesValueIdNamesGetAsyncWithHttpInfo
     *
     * Get name and language for an attribute value ID
     *
     * @param  int $value_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributeValuesValueIdNamesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributeValuesValueIdNamesGetAsyncWithHttpInfo(
        $value_id,
        string $contentType = self::contentTypes['restItemsAttributeValuesValueIdNamesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\AttributeValueName[]';
        $request = $this->restItemsAttributeValuesValueIdNamesGetRequest($value_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsAttributeValuesValueIdNamesGet'
     *
     * @param  int $value_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributeValuesValueIdNamesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsAttributeValuesValueIdNamesGetRequest(
        $value_id,
        string $contentType = self::contentTypes['restItemsAttributeValuesValueIdNamesGet'][0]
    ): Request
    {

        // verify the required parameter 'value_id' is set
        if ($value_id === null || (is_array($value_id) && count($value_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $value_id when calling restItemsAttributeValuesValueIdNamesGet'
            );
        }


        $resourcePath = '/rest/items/attribute_values/{valueId}/names';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($value_id !== null) {
            $resourcePath = str_replace(
                '{' . 'valueId' . '}',
                ObjectSerializer::toPathValue($value_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsAttributeValuesValueIdNamesLangDelete
     *
     * Delete an attribute value name
     *
     * @param  int $value_id value_id (required)
     * @param  int $lang lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributeValuesValueIdNamesLangDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsAttributeValuesValueIdNamesLangDelete(
        int $value_id,
        int $lang,
        string $contentType = self::contentTypes['restItemsAttributeValuesValueIdNamesLangDelete'][0]
    ): object
    {
        list($response) = $this->restItemsAttributeValuesValueIdNamesLangDeleteWithHttpInfo($value_id, $lang, $contentType);
        return $response;
    }

    /**
     * Operation restItemsAttributeValuesValueIdNamesLangDeleteWithHttpInfo
     *
     * Delete an attribute value name
     *
     * @param  int $value_id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributeValuesValueIdNamesLangDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsAttributeValuesValueIdNamesLangDeleteWithHttpInfo(
        int $value_id,
        int $lang,
        string $contentType = self::contentTypes['restItemsAttributeValuesValueIdNamesLangDelete'][0]
    ): array
    {
        $request = $this->restItemsAttributeValuesValueIdNamesLangDeleteRequest($value_id, $lang, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsAttributeValuesValueIdNamesLangDeleteAsync
     *
     * Delete an attribute value name
     *
     * @param  int $value_id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributeValuesValueIdNamesLangDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributeValuesValueIdNamesLangDeleteAsync(
        int $value_id,
        int $lang,
        string $contentType = self::contentTypes['restItemsAttributeValuesValueIdNamesLangDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemsAttributeValuesValueIdNamesLangDeleteAsyncWithHttpInfo($value_id, $lang, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsAttributeValuesValueIdNamesLangDeleteAsyncWithHttpInfo
     *
     * Delete an attribute value name
     *
     * @param  int $value_id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributeValuesValueIdNamesLangDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributeValuesValueIdNamesLangDeleteAsyncWithHttpInfo(
        $value_id,
        $lang,
        string $contentType = self::contentTypes['restItemsAttributeValuesValueIdNamesLangDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsAttributeValuesValueIdNamesLangDeleteRequest($value_id, $lang, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsAttributeValuesValueIdNamesLangDelete'
     *
     * @param  int $value_id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributeValuesValueIdNamesLangDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsAttributeValuesValueIdNamesLangDeleteRequest(
        $value_id,
        $lang,
        string $contentType = self::contentTypes['restItemsAttributeValuesValueIdNamesLangDelete'][0]
    ): Request
    {

        // verify the required parameter 'value_id' is set
        if ($value_id === null || (is_array($value_id) && count($value_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $value_id when calling restItemsAttributeValuesValueIdNamesLangDelete'
            );
        }

        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $lang when calling restItemsAttributeValuesValueIdNamesLangDelete'
            );
        }


        $resourcePath = '/rest/items/attribute_values/{valueId}/names/{lang}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($value_id !== null) {
            $resourcePath = str_replace(
                '{' . 'valueId' . '}',
                ObjectSerializer::toPathValue($value_id),
                $resourcePath
            );
        }
        // path params
        if ($lang !== null) {
            $resourcePath = str_replace(
                '{' . 'lang' . '}',
                ObjectSerializer::toPathValue($lang),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsAttributeValuesValueIdNamesLangGet
     *
     * Get an attribute value name
     *
     * @param  int $value_id value_id (required)
     * @param  int $lang lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributeValuesValueIdNamesLangGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\AttributeValueName
     */
    public function restItemsAttributeValuesValueIdNamesLangGet(
        int $value_id,
        int $lang,
        string $contentType = self::contentTypes['restItemsAttributeValuesValueIdNamesLangGet'][0]
    ): \ck\Model\AttributeValueName
    {
        list($response) = $this->restItemsAttributeValuesValueIdNamesLangGetWithHttpInfo($value_id, $lang, $contentType);
        return $response;
    }

    /**
     * Operation restItemsAttributeValuesValueIdNamesLangGetWithHttpInfo
     *
     * Get an attribute value name
     *
     * @param  int $value_id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributeValuesValueIdNamesLangGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\AttributeValueName, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsAttributeValuesValueIdNamesLangGetWithHttpInfo(
        int $value_id,
        int $lang,
        string $contentType = self::contentTypes['restItemsAttributeValuesValueIdNamesLangGet'][0]
    ): array
    {
        $request = $this->restItemsAttributeValuesValueIdNamesLangGetRequest($value_id, $lang, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\AttributeValueName' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\AttributeValueName' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\AttributeValueName', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\AttributeValueName';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\AttributeValueName',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsAttributeValuesValueIdNamesLangGetAsync
     *
     * Get an attribute value name
     *
     * @param  int $value_id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributeValuesValueIdNamesLangGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributeValuesValueIdNamesLangGetAsync(
        int $value_id,
        int $lang,
        string $contentType = self::contentTypes['restItemsAttributeValuesValueIdNamesLangGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsAttributeValuesValueIdNamesLangGetAsyncWithHttpInfo($value_id, $lang, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsAttributeValuesValueIdNamesLangGetAsyncWithHttpInfo
     *
     * Get an attribute value name
     *
     * @param  int $value_id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributeValuesValueIdNamesLangGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributeValuesValueIdNamesLangGetAsyncWithHttpInfo(
        $value_id,
        $lang,
        string $contentType = self::contentTypes['restItemsAttributeValuesValueIdNamesLangGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\AttributeValueName';
        $request = $this->restItemsAttributeValuesValueIdNamesLangGetRequest($value_id, $lang, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsAttributeValuesValueIdNamesLangGet'
     *
     * @param  int $value_id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributeValuesValueIdNamesLangGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsAttributeValuesValueIdNamesLangGetRequest(
        $value_id,
        $lang,
        string $contentType = self::contentTypes['restItemsAttributeValuesValueIdNamesLangGet'][0]
    ): Request
    {

        // verify the required parameter 'value_id' is set
        if ($value_id === null || (is_array($value_id) && count($value_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $value_id when calling restItemsAttributeValuesValueIdNamesLangGet'
            );
        }

        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $lang when calling restItemsAttributeValuesValueIdNamesLangGet'
            );
        }


        $resourcePath = '/rest/items/attribute_values/{valueId}/names/{lang}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($value_id !== null) {
            $resourcePath = str_replace(
                '{' . 'valueId' . '}',
                ObjectSerializer::toPathValue($value_id),
                $resourcePath
            );
        }
        // path params
        if ($lang !== null) {
            $resourcePath = str_replace(
                '{' . 'lang' . '}',
                ObjectSerializer::toPathValue($lang),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsAttributeValuesValueIdNamesLangPut
     *
     * Update an attribute value name
     *
     * @param  int $value_id value_id (required)
     * @param  int $lang lang (required)
     * @param  \ck\Model\RestItemsAttributeValuesValueIdNamesPostRequest|null $_rest_items_attribute_values_value_id_names_lang _rest_items_attribute_values_value_id_names_lang (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributeValuesValueIdNamesLangPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\AttributeValueName
     */
    public function restItemsAttributeValuesValueIdNamesLangPut(
        int $value_id,
        int $lang,
        ?\ck\Model\RestItemsAttributeValuesValueIdNamesPostRequest $_rest_items_attribute_values_value_id_names_lang = null,
        string $contentType = self::contentTypes['restItemsAttributeValuesValueIdNamesLangPut'][0]
    ): \ck\Model\AttributeValueName
    {
        list($response) = $this->restItemsAttributeValuesValueIdNamesLangPutWithHttpInfo($value_id, $lang, $_rest_items_attribute_values_value_id_names_lang, $contentType);
        return $response;
    }

    /**
     * Operation restItemsAttributeValuesValueIdNamesLangPutWithHttpInfo
     *
     * Update an attribute value name
     *
     * @param  int $value_id (required)
     * @param  int $lang (required)
     * @param  \ck\Model\RestItemsAttributeValuesValueIdNamesPostRequest|null $_rest_items_attribute_values_value_id_names_lang (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributeValuesValueIdNamesLangPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\AttributeValueName, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsAttributeValuesValueIdNamesLangPutWithHttpInfo(
        int $value_id,
        int $lang,
        ?\ck\Model\RestItemsAttributeValuesValueIdNamesPostRequest $_rest_items_attribute_values_value_id_names_lang = null,
        string $contentType = self::contentTypes['restItemsAttributeValuesValueIdNamesLangPut'][0]
    ): array
    {
        $request = $this->restItemsAttributeValuesValueIdNamesLangPutRequest($value_id, $lang, $_rest_items_attribute_values_value_id_names_lang, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\AttributeValueName' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\AttributeValueName' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\AttributeValueName', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\AttributeValueName';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\AttributeValueName',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsAttributeValuesValueIdNamesLangPutAsync
     *
     * Update an attribute value name
     *
     * @param  int $value_id (required)
     * @param  int $lang (required)
     * @param  \ck\Model\RestItemsAttributeValuesValueIdNamesPostRequest|null $_rest_items_attribute_values_value_id_names_lang (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributeValuesValueIdNamesLangPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributeValuesValueIdNamesLangPutAsync(
        int $value_id,
        int $lang,
        ?\ck\Model\RestItemsAttributeValuesValueIdNamesPostRequest $_rest_items_attribute_values_value_id_names_lang = null,
        string $contentType = self::contentTypes['restItemsAttributeValuesValueIdNamesLangPut'][0]
    ): PromiseInterface
    {
        return $this->restItemsAttributeValuesValueIdNamesLangPutAsyncWithHttpInfo($value_id, $lang, $_rest_items_attribute_values_value_id_names_lang, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsAttributeValuesValueIdNamesLangPutAsyncWithHttpInfo
     *
     * Update an attribute value name
     *
     * @param  int $value_id (required)
     * @param  int $lang (required)
     * @param  \ck\Model\RestItemsAttributeValuesValueIdNamesPostRequest|null $_rest_items_attribute_values_value_id_names_lang (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributeValuesValueIdNamesLangPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributeValuesValueIdNamesLangPutAsyncWithHttpInfo(
        $value_id,
        $lang,
        $_rest_items_attribute_values_value_id_names_lang = null,
        string $contentType = self::contentTypes['restItemsAttributeValuesValueIdNamesLangPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\AttributeValueName';
        $request = $this->restItemsAttributeValuesValueIdNamesLangPutRequest($value_id, $lang, $_rest_items_attribute_values_value_id_names_lang, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsAttributeValuesValueIdNamesLangPut'
     *
     * @param  int $value_id (required)
     * @param  int $lang (required)
     * @param  \ck\Model\RestItemsAttributeValuesValueIdNamesPostRequest|null $_rest_items_attribute_values_value_id_names_lang (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributeValuesValueIdNamesLangPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsAttributeValuesValueIdNamesLangPutRequest(
        $value_id,
        $lang,
        $_rest_items_attribute_values_value_id_names_lang = null,
        string $contentType = self::contentTypes['restItemsAttributeValuesValueIdNamesLangPut'][0]
    ): Request
    {

        // verify the required parameter 'value_id' is set
        if ($value_id === null || (is_array($value_id) && count($value_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $value_id when calling restItemsAttributeValuesValueIdNamesLangPut'
            );
        }

        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $lang when calling restItemsAttributeValuesValueIdNamesLangPut'
            );
        }



        $resourcePath = '/rest/items/attribute_values/{valueId}/names/{lang}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($value_id !== null) {
            $resourcePath = str_replace(
                '{' . 'valueId' . '}',
                ObjectSerializer::toPathValue($value_id),
                $resourcePath
            );
        }
        // path params
        if ($lang !== null) {
            $resourcePath = str_replace(
                '{' . 'lang' . '}',
                ObjectSerializer::toPathValue($lang),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_attribute_values_value_id_names_lang)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_attribute_values_value_id_names_lang));
            } else {
                $httpBody = $_rest_items_attribute_values_value_id_names_lang;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsAttributeValuesValueIdNamesPost
     *
     * Create an attribute value name
     *
     * @param  int $value_id value_id (required)
     * @param  \ck\Model\RestItemsAttributeValuesValueIdNamesPostRequest|null $_rest_items_attribute_values_value_id_names _rest_items_attribute_values_value_id_names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributeValuesValueIdNamesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\AttributeValueName
     */
    public function restItemsAttributeValuesValueIdNamesPost(
        int $value_id,
        ?\ck\Model\RestItemsAttributeValuesValueIdNamesPostRequest $_rest_items_attribute_values_value_id_names = null,
        string $contentType = self::contentTypes['restItemsAttributeValuesValueIdNamesPost'][0]
    ): \ck\Model\AttributeValueName
    {
        list($response) = $this->restItemsAttributeValuesValueIdNamesPostWithHttpInfo($value_id, $_rest_items_attribute_values_value_id_names, $contentType);
        return $response;
    }

    /**
     * Operation restItemsAttributeValuesValueIdNamesPostWithHttpInfo
     *
     * Create an attribute value name
     *
     * @param  int $value_id (required)
     * @param  \ck\Model\RestItemsAttributeValuesValueIdNamesPostRequest|null $_rest_items_attribute_values_value_id_names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributeValuesValueIdNamesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\AttributeValueName, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsAttributeValuesValueIdNamesPostWithHttpInfo(
        int $value_id,
        ?\ck\Model\RestItemsAttributeValuesValueIdNamesPostRequest $_rest_items_attribute_values_value_id_names = null,
        string $contentType = self::contentTypes['restItemsAttributeValuesValueIdNamesPost'][0]
    ): array
    {
        $request = $this->restItemsAttributeValuesValueIdNamesPostRequest($value_id, $_rest_items_attribute_values_value_id_names, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\AttributeValueName' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\AttributeValueName' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\AttributeValueName', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\AttributeValueName';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\AttributeValueName',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsAttributeValuesValueIdNamesPostAsync
     *
     * Create an attribute value name
     *
     * @param  int $value_id (required)
     * @param  \ck\Model\RestItemsAttributeValuesValueIdNamesPostRequest|null $_rest_items_attribute_values_value_id_names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributeValuesValueIdNamesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributeValuesValueIdNamesPostAsync(
        int $value_id,
        ?\ck\Model\RestItemsAttributeValuesValueIdNamesPostRequest $_rest_items_attribute_values_value_id_names = null,
        string $contentType = self::contentTypes['restItemsAttributeValuesValueIdNamesPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsAttributeValuesValueIdNamesPostAsyncWithHttpInfo($value_id, $_rest_items_attribute_values_value_id_names, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsAttributeValuesValueIdNamesPostAsyncWithHttpInfo
     *
     * Create an attribute value name
     *
     * @param  int $value_id (required)
     * @param  \ck\Model\RestItemsAttributeValuesValueIdNamesPostRequest|null $_rest_items_attribute_values_value_id_names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributeValuesValueIdNamesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributeValuesValueIdNamesPostAsyncWithHttpInfo(
        $value_id,
        $_rest_items_attribute_values_value_id_names = null,
        string $contentType = self::contentTypes['restItemsAttributeValuesValueIdNamesPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\AttributeValueName';
        $request = $this->restItemsAttributeValuesValueIdNamesPostRequest($value_id, $_rest_items_attribute_values_value_id_names, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsAttributeValuesValueIdNamesPost'
     *
     * @param  int $value_id (required)
     * @param  \ck\Model\RestItemsAttributeValuesValueIdNamesPostRequest|null $_rest_items_attribute_values_value_id_names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributeValuesValueIdNamesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsAttributeValuesValueIdNamesPostRequest(
        $value_id,
        $_rest_items_attribute_values_value_id_names = null,
        string $contentType = self::contentTypes['restItemsAttributeValuesValueIdNamesPost'][0]
    ): Request
    {

        // verify the required parameter 'value_id' is set
        if ($value_id === null || (is_array($value_id) && count($value_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $value_id when calling restItemsAttributeValuesValueIdNamesPost'
            );
        }



        $resourcePath = '/rest/items/attribute_values/{valueId}/names';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($value_id !== null) {
            $resourcePath = str_replace(
                '{' . 'valueId' . '}',
                ObjectSerializer::toPathValue($value_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_attribute_values_value_id_names)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_attribute_values_value_id_names));
            } else {
                $httpBody = $_rest_items_attribute_values_value_id_names;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsAttributesAttributeIdMarketsMarketIdMapsDelete
     *
     * Deletes an attribute map.
     *
     * @param  int $attribute_id attribute_id (required)
     * @param  int $market_id market_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdMarketsMarketIdMapsDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsAttributesAttributeIdMarketsMarketIdMapsDelete(
        int $attribute_id,
        int $market_id,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdMarketsMarketIdMapsDelete'][0]
    ): object
    {
        list($response) = $this->restItemsAttributesAttributeIdMarketsMarketIdMapsDeleteWithHttpInfo($attribute_id, $market_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsAttributesAttributeIdMarketsMarketIdMapsDeleteWithHttpInfo
     *
     * Deletes an attribute map.
     *
     * @param  int $attribute_id (required)
     * @param  int $market_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdMarketsMarketIdMapsDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsAttributesAttributeIdMarketsMarketIdMapsDeleteWithHttpInfo(
        int $attribute_id,
        int $market_id,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdMarketsMarketIdMapsDelete'][0]
    ): array
    {
        $request = $this->restItemsAttributesAttributeIdMarketsMarketIdMapsDeleteRequest($attribute_id, $market_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsAttributesAttributeIdMarketsMarketIdMapsDeleteAsync
     *
     * Deletes an attribute map.
     *
     * @param  int $attribute_id (required)
     * @param  int $market_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdMarketsMarketIdMapsDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributesAttributeIdMarketsMarketIdMapsDeleteAsync(
        int $attribute_id,
        int $market_id,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdMarketsMarketIdMapsDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemsAttributesAttributeIdMarketsMarketIdMapsDeleteAsyncWithHttpInfo($attribute_id, $market_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsAttributesAttributeIdMarketsMarketIdMapsDeleteAsyncWithHttpInfo
     *
     * Deletes an attribute map.
     *
     * @param  int $attribute_id (required)
     * @param  int $market_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdMarketsMarketIdMapsDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributesAttributeIdMarketsMarketIdMapsDeleteAsyncWithHttpInfo(
        $attribute_id,
        $market_id,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdMarketsMarketIdMapsDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsAttributesAttributeIdMarketsMarketIdMapsDeleteRequest($attribute_id, $market_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsAttributesAttributeIdMarketsMarketIdMapsDelete'
     *
     * @param  int $attribute_id (required)
     * @param  int $market_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdMarketsMarketIdMapsDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsAttributesAttributeIdMarketsMarketIdMapsDeleteRequest(
        $attribute_id,
        $market_id,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdMarketsMarketIdMapsDelete'][0]
    ): Request
    {

        // verify the required parameter 'attribute_id' is set
        if ($attribute_id === null || (is_array($attribute_id) && count($attribute_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $attribute_id when calling restItemsAttributesAttributeIdMarketsMarketIdMapsDelete'
            );
        }

        // verify the required parameter 'market_id' is set
        if ($market_id === null || (is_array($market_id) && count($market_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $market_id when calling restItemsAttributesAttributeIdMarketsMarketIdMapsDelete'
            );
        }


        $resourcePath = '/rest/items/attributes/{attributeId}/markets/{marketId}/maps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($attribute_id !== null) {
            $resourcePath = str_replace(
                '{' . 'attributeId' . '}',
                ObjectSerializer::toPathValue($attribute_id),
                $resourcePath
            );
        }
        // path params
        if ($market_id !== null) {
            $resourcePath = str_replace(
                '{' . 'marketId' . '}',
                ObjectSerializer::toPathValue($market_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsAttributesAttributeIdMarketsMarketIdMapsGet
     *
     * Gets an attribute map.
     *
     * @param  int $attribute_id attribute_id (required)
     * @param  int $market_id market_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdMarketsMarketIdMapsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\AttributeMap
     */
    public function restItemsAttributesAttributeIdMarketsMarketIdMapsGet(
        int $attribute_id,
        int $market_id,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdMarketsMarketIdMapsGet'][0]
    ): \ck\Model\AttributeMap
    {
        list($response) = $this->restItemsAttributesAttributeIdMarketsMarketIdMapsGetWithHttpInfo($attribute_id, $market_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsAttributesAttributeIdMarketsMarketIdMapsGetWithHttpInfo
     *
     * Gets an attribute map.
     *
     * @param  int $attribute_id (required)
     * @param  int $market_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdMarketsMarketIdMapsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\AttributeMap, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsAttributesAttributeIdMarketsMarketIdMapsGetWithHttpInfo(
        int $attribute_id,
        int $market_id,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdMarketsMarketIdMapsGet'][0]
    ): array
    {
        $request = $this->restItemsAttributesAttributeIdMarketsMarketIdMapsGetRequest($attribute_id, $market_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\AttributeMap' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\AttributeMap' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\AttributeMap', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\AttributeMap';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\AttributeMap',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsAttributesAttributeIdMarketsMarketIdMapsGetAsync
     *
     * Gets an attribute map.
     *
     * @param  int $attribute_id (required)
     * @param  int $market_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdMarketsMarketIdMapsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributesAttributeIdMarketsMarketIdMapsGetAsync(
        int $attribute_id,
        int $market_id,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdMarketsMarketIdMapsGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsAttributesAttributeIdMarketsMarketIdMapsGetAsyncWithHttpInfo($attribute_id, $market_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsAttributesAttributeIdMarketsMarketIdMapsGetAsyncWithHttpInfo
     *
     * Gets an attribute map.
     *
     * @param  int $attribute_id (required)
     * @param  int $market_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdMarketsMarketIdMapsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributesAttributeIdMarketsMarketIdMapsGetAsyncWithHttpInfo(
        $attribute_id,
        $market_id,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdMarketsMarketIdMapsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\AttributeMap';
        $request = $this->restItemsAttributesAttributeIdMarketsMarketIdMapsGetRequest($attribute_id, $market_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsAttributesAttributeIdMarketsMarketIdMapsGet'
     *
     * @param  int $attribute_id (required)
     * @param  int $market_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdMarketsMarketIdMapsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsAttributesAttributeIdMarketsMarketIdMapsGetRequest(
        $attribute_id,
        $market_id,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdMarketsMarketIdMapsGet'][0]
    ): Request
    {

        // verify the required parameter 'attribute_id' is set
        if ($attribute_id === null || (is_array($attribute_id) && count($attribute_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $attribute_id when calling restItemsAttributesAttributeIdMarketsMarketIdMapsGet'
            );
        }

        // verify the required parameter 'market_id' is set
        if ($market_id === null || (is_array($market_id) && count($market_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $market_id when calling restItemsAttributesAttributeIdMarketsMarketIdMapsGet'
            );
        }


        $resourcePath = '/rest/items/attributes/{attributeId}/markets/{marketId}/maps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($attribute_id !== null) {
            $resourcePath = str_replace(
                '{' . 'attributeId' . '}',
                ObjectSerializer::toPathValue($attribute_id),
                $resourcePath
            );
        }
        // path params
        if ($market_id !== null) {
            $resourcePath = str_replace(
                '{' . 'marketId' . '}',
                ObjectSerializer::toPathValue($market_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsAttributesAttributeIdMarketsMarketIdMapsPut
     *
     * Updates an attribute map.
     *
     * @param  int $attribute_id attribute_id (required)
     * @param  int $market_id market_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdMarketsMarketIdMapsPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\AttributeMap
     */
    public function restItemsAttributesAttributeIdMarketsMarketIdMapsPut(
        int $attribute_id,
        int $market_id,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdMarketsMarketIdMapsPut'][0]
    ): \ck\Model\AttributeMap
    {
        list($response) = $this->restItemsAttributesAttributeIdMarketsMarketIdMapsPutWithHttpInfo($attribute_id, $market_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsAttributesAttributeIdMarketsMarketIdMapsPutWithHttpInfo
     *
     * Updates an attribute map.
     *
     * @param  int $attribute_id (required)
     * @param  int $market_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdMarketsMarketIdMapsPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\AttributeMap, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsAttributesAttributeIdMarketsMarketIdMapsPutWithHttpInfo(
        int $attribute_id,
        int $market_id,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdMarketsMarketIdMapsPut'][0]
    ): array
    {
        $request = $this->restItemsAttributesAttributeIdMarketsMarketIdMapsPutRequest($attribute_id, $market_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\AttributeMap' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\AttributeMap' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\AttributeMap', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\AttributeMap';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\AttributeMap',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsAttributesAttributeIdMarketsMarketIdMapsPutAsync
     *
     * Updates an attribute map.
     *
     * @param  int $attribute_id (required)
     * @param  int $market_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdMarketsMarketIdMapsPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributesAttributeIdMarketsMarketIdMapsPutAsync(
        int $attribute_id,
        int $market_id,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdMarketsMarketIdMapsPut'][0]
    ): PromiseInterface
    {
        return $this->restItemsAttributesAttributeIdMarketsMarketIdMapsPutAsyncWithHttpInfo($attribute_id, $market_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsAttributesAttributeIdMarketsMarketIdMapsPutAsyncWithHttpInfo
     *
     * Updates an attribute map.
     *
     * @param  int $attribute_id (required)
     * @param  int $market_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdMarketsMarketIdMapsPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributesAttributeIdMarketsMarketIdMapsPutAsyncWithHttpInfo(
        $attribute_id,
        $market_id,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdMarketsMarketIdMapsPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\AttributeMap';
        $request = $this->restItemsAttributesAttributeIdMarketsMarketIdMapsPutRequest($attribute_id, $market_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsAttributesAttributeIdMarketsMarketIdMapsPut'
     *
     * @param  int $attribute_id (required)
     * @param  int $market_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdMarketsMarketIdMapsPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsAttributesAttributeIdMarketsMarketIdMapsPutRequest(
        $attribute_id,
        $market_id,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdMarketsMarketIdMapsPut'][0]
    ): Request
    {

        // verify the required parameter 'attribute_id' is set
        if ($attribute_id === null || (is_array($attribute_id) && count($attribute_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $attribute_id when calling restItemsAttributesAttributeIdMarketsMarketIdMapsPut'
            );
        }

        // verify the required parameter 'market_id' is set
        if ($market_id === null || (is_array($market_id) && count($market_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $market_id when calling restItemsAttributesAttributeIdMarketsMarketIdMapsPut'
            );
        }


        $resourcePath = '/rest/items/attributes/{attributeId}/markets/{marketId}/maps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($attribute_id !== null) {
            $resourcePath = str_replace(
                '{' . 'attributeId' . '}',
                ObjectSerializer::toPathValue($attribute_id),
                $resourcePath
            );
        }
        // path params
        if ($market_id !== null) {
            $resourcePath = str_replace(
                '{' . 'marketId' . '}',
                ObjectSerializer::toPathValue($market_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsAttributesAttributeIdNamesGet
     *
     * Get an attribute name
     *
     * @param  int $attribute_id attribute_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdNamesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\AttributeName[]
     */
    public function restItemsAttributesAttributeIdNamesGet(
        int $attribute_id,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdNamesGet'][0]
    ): array
    {
        list($response) = $this->restItemsAttributesAttributeIdNamesGetWithHttpInfo($attribute_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsAttributesAttributeIdNamesGetWithHttpInfo
     *
     * Get an attribute name
     *
     * @param  int $attribute_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdNamesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\AttributeName[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsAttributesAttributeIdNamesGetWithHttpInfo(
        int $attribute_id,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdNamesGet'][0]
    ): array
    {
        $request = $this->restItemsAttributesAttributeIdNamesGetRequest($attribute_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\AttributeName[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\AttributeName[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\AttributeName[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\AttributeName[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\AttributeName[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsAttributesAttributeIdNamesGetAsync
     *
     * Get an attribute name
     *
     * @param  int $attribute_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdNamesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributesAttributeIdNamesGetAsync(
        int $attribute_id,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdNamesGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsAttributesAttributeIdNamesGetAsyncWithHttpInfo($attribute_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsAttributesAttributeIdNamesGetAsyncWithHttpInfo
     *
     * Get an attribute name
     *
     * @param  int $attribute_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdNamesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributesAttributeIdNamesGetAsyncWithHttpInfo(
        $attribute_id,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdNamesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\AttributeName[]';
        $request = $this->restItemsAttributesAttributeIdNamesGetRequest($attribute_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsAttributesAttributeIdNamesGet'
     *
     * @param  int $attribute_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdNamesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsAttributesAttributeIdNamesGetRequest(
        $attribute_id,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdNamesGet'][0]
    ): Request
    {

        // verify the required parameter 'attribute_id' is set
        if ($attribute_id === null || (is_array($attribute_id) && count($attribute_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $attribute_id when calling restItemsAttributesAttributeIdNamesGet'
            );
        }


        $resourcePath = '/rest/items/attributes/{attributeId}/names';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($attribute_id !== null) {
            $resourcePath = str_replace(
                '{' . 'attributeId' . '}',
                ObjectSerializer::toPathValue($attribute_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsAttributesAttributeIdNamesLangDelete
     *
     * Delete an attribute name
     *
     * @param  int $attribute_id attribute_id (required)
     * @param  int $lang lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdNamesLangDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsAttributesAttributeIdNamesLangDelete(
        int $attribute_id,
        int $lang,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdNamesLangDelete'][0]
    ): object
    {
        list($response) = $this->restItemsAttributesAttributeIdNamesLangDeleteWithHttpInfo($attribute_id, $lang, $contentType);
        return $response;
    }

    /**
     * Operation restItemsAttributesAttributeIdNamesLangDeleteWithHttpInfo
     *
     * Delete an attribute name
     *
     * @param  int $attribute_id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdNamesLangDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsAttributesAttributeIdNamesLangDeleteWithHttpInfo(
        int $attribute_id,
        int $lang,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdNamesLangDelete'][0]
    ): array
    {
        $request = $this->restItemsAttributesAttributeIdNamesLangDeleteRequest($attribute_id, $lang, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsAttributesAttributeIdNamesLangDeleteAsync
     *
     * Delete an attribute name
     *
     * @param  int $attribute_id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdNamesLangDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributesAttributeIdNamesLangDeleteAsync(
        int $attribute_id,
        int $lang,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdNamesLangDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemsAttributesAttributeIdNamesLangDeleteAsyncWithHttpInfo($attribute_id, $lang, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsAttributesAttributeIdNamesLangDeleteAsyncWithHttpInfo
     *
     * Delete an attribute name
     *
     * @param  int $attribute_id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdNamesLangDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributesAttributeIdNamesLangDeleteAsyncWithHttpInfo(
        $attribute_id,
        $lang,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdNamesLangDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsAttributesAttributeIdNamesLangDeleteRequest($attribute_id, $lang, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsAttributesAttributeIdNamesLangDelete'
     *
     * @param  int $attribute_id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdNamesLangDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsAttributesAttributeIdNamesLangDeleteRequest(
        $attribute_id,
        $lang,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdNamesLangDelete'][0]
    ): Request
    {

        // verify the required parameter 'attribute_id' is set
        if ($attribute_id === null || (is_array($attribute_id) && count($attribute_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $attribute_id when calling restItemsAttributesAttributeIdNamesLangDelete'
            );
        }

        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $lang when calling restItemsAttributesAttributeIdNamesLangDelete'
            );
        }


        $resourcePath = '/rest/items/attributes/{attributeId}/names/{lang}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($attribute_id !== null) {
            $resourcePath = str_replace(
                '{' . 'attributeId' . '}',
                ObjectSerializer::toPathValue($attribute_id),
                $resourcePath
            );
        }
        // path params
        if ($lang !== null) {
            $resourcePath = str_replace(
                '{' . 'lang' . '}',
                ObjectSerializer::toPathValue($lang),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsAttributesAttributeIdNamesLangGet
     *
     * List attribute names
     *
     * @param  int $attribute_id attribute_id (required)
     * @param  int $lang lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdNamesLangGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\AttributeName
     */
    public function restItemsAttributesAttributeIdNamesLangGet(
        int $attribute_id,
        int $lang,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdNamesLangGet'][0]
    ): \ck\Model\AttributeName
    {
        list($response) = $this->restItemsAttributesAttributeIdNamesLangGetWithHttpInfo($attribute_id, $lang, $contentType);
        return $response;
    }

    /**
     * Operation restItemsAttributesAttributeIdNamesLangGetWithHttpInfo
     *
     * List attribute names
     *
     * @param  int $attribute_id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdNamesLangGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\AttributeName, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsAttributesAttributeIdNamesLangGetWithHttpInfo(
        int $attribute_id,
        int $lang,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdNamesLangGet'][0]
    ): array
    {
        $request = $this->restItemsAttributesAttributeIdNamesLangGetRequest($attribute_id, $lang, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\AttributeName' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\AttributeName' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\AttributeName', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\AttributeName';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\AttributeName',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsAttributesAttributeIdNamesLangGetAsync
     *
     * List attribute names
     *
     * @param  int $attribute_id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdNamesLangGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributesAttributeIdNamesLangGetAsync(
        int $attribute_id,
        int $lang,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdNamesLangGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsAttributesAttributeIdNamesLangGetAsyncWithHttpInfo($attribute_id, $lang, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsAttributesAttributeIdNamesLangGetAsyncWithHttpInfo
     *
     * List attribute names
     *
     * @param  int $attribute_id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdNamesLangGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributesAttributeIdNamesLangGetAsyncWithHttpInfo(
        $attribute_id,
        $lang,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdNamesLangGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\AttributeName';
        $request = $this->restItemsAttributesAttributeIdNamesLangGetRequest($attribute_id, $lang, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsAttributesAttributeIdNamesLangGet'
     *
     * @param  int $attribute_id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdNamesLangGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsAttributesAttributeIdNamesLangGetRequest(
        $attribute_id,
        $lang,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdNamesLangGet'][0]
    ): Request
    {

        // verify the required parameter 'attribute_id' is set
        if ($attribute_id === null || (is_array($attribute_id) && count($attribute_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $attribute_id when calling restItemsAttributesAttributeIdNamesLangGet'
            );
        }

        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $lang when calling restItemsAttributesAttributeIdNamesLangGet'
            );
        }


        $resourcePath = '/rest/items/attributes/{attributeId}/names/{lang}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($attribute_id !== null) {
            $resourcePath = str_replace(
                '{' . 'attributeId' . '}',
                ObjectSerializer::toPathValue($attribute_id),
                $resourcePath
            );
        }
        // path params
        if ($lang !== null) {
            $resourcePath = str_replace(
                '{' . 'lang' . '}',
                ObjectSerializer::toPathValue($lang),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsAttributesAttributeIdNamesLangPut
     *
     * Update an attribute name
     *
     * @param  int $attribute_id attribute_id (required)
     * @param  int $lang lang (required)
     * @param  \ck\Model\RestItemsAttributesAttributeIdNamesPostRequest|null $_rest_items_attributes_attribute_id_names_lang _rest_items_attributes_attribute_id_names_lang (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdNamesLangPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\AttributeName
     */
    public function restItemsAttributesAttributeIdNamesLangPut(
        int $attribute_id,
        int $lang,
        ?\ck\Model\RestItemsAttributesAttributeIdNamesPostRequest $_rest_items_attributes_attribute_id_names_lang = null,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdNamesLangPut'][0]
    ): \ck\Model\AttributeName
    {
        list($response) = $this->restItemsAttributesAttributeIdNamesLangPutWithHttpInfo($attribute_id, $lang, $_rest_items_attributes_attribute_id_names_lang, $contentType);
        return $response;
    }

    /**
     * Operation restItemsAttributesAttributeIdNamesLangPutWithHttpInfo
     *
     * Update an attribute name
     *
     * @param  int $attribute_id (required)
     * @param  int $lang (required)
     * @param  \ck\Model\RestItemsAttributesAttributeIdNamesPostRequest|null $_rest_items_attributes_attribute_id_names_lang (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdNamesLangPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\AttributeName, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsAttributesAttributeIdNamesLangPutWithHttpInfo(
        int $attribute_id,
        int $lang,
        ?\ck\Model\RestItemsAttributesAttributeIdNamesPostRequest $_rest_items_attributes_attribute_id_names_lang = null,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdNamesLangPut'][0]
    ): array
    {
        $request = $this->restItemsAttributesAttributeIdNamesLangPutRequest($attribute_id, $lang, $_rest_items_attributes_attribute_id_names_lang, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\AttributeName' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\AttributeName' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\AttributeName', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\AttributeName';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\AttributeName',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsAttributesAttributeIdNamesLangPutAsync
     *
     * Update an attribute name
     *
     * @param  int $attribute_id (required)
     * @param  int $lang (required)
     * @param  \ck\Model\RestItemsAttributesAttributeIdNamesPostRequest|null $_rest_items_attributes_attribute_id_names_lang (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdNamesLangPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributesAttributeIdNamesLangPutAsync(
        int $attribute_id,
        int $lang,
        ?\ck\Model\RestItemsAttributesAttributeIdNamesPostRequest $_rest_items_attributes_attribute_id_names_lang = null,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdNamesLangPut'][0]
    ): PromiseInterface
    {
        return $this->restItemsAttributesAttributeIdNamesLangPutAsyncWithHttpInfo($attribute_id, $lang, $_rest_items_attributes_attribute_id_names_lang, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsAttributesAttributeIdNamesLangPutAsyncWithHttpInfo
     *
     * Update an attribute name
     *
     * @param  int $attribute_id (required)
     * @param  int $lang (required)
     * @param  \ck\Model\RestItemsAttributesAttributeIdNamesPostRequest|null $_rest_items_attributes_attribute_id_names_lang (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdNamesLangPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributesAttributeIdNamesLangPutAsyncWithHttpInfo(
        $attribute_id,
        $lang,
        $_rest_items_attributes_attribute_id_names_lang = null,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdNamesLangPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\AttributeName';
        $request = $this->restItemsAttributesAttributeIdNamesLangPutRequest($attribute_id, $lang, $_rest_items_attributes_attribute_id_names_lang, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsAttributesAttributeIdNamesLangPut'
     *
     * @param  int $attribute_id (required)
     * @param  int $lang (required)
     * @param  \ck\Model\RestItemsAttributesAttributeIdNamesPostRequest|null $_rest_items_attributes_attribute_id_names_lang (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdNamesLangPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsAttributesAttributeIdNamesLangPutRequest(
        $attribute_id,
        $lang,
        $_rest_items_attributes_attribute_id_names_lang = null,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdNamesLangPut'][0]
    ): Request
    {

        // verify the required parameter 'attribute_id' is set
        if ($attribute_id === null || (is_array($attribute_id) && count($attribute_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $attribute_id when calling restItemsAttributesAttributeIdNamesLangPut'
            );
        }

        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $lang when calling restItemsAttributesAttributeIdNamesLangPut'
            );
        }



        $resourcePath = '/rest/items/attributes/{attributeId}/names/{lang}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($attribute_id !== null) {
            $resourcePath = str_replace(
                '{' . 'attributeId' . '}',
                ObjectSerializer::toPathValue($attribute_id),
                $resourcePath
            );
        }
        // path params
        if ($lang !== null) {
            $resourcePath = str_replace(
                '{' . 'lang' . '}',
                ObjectSerializer::toPathValue($lang),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_attributes_attribute_id_names_lang)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_attributes_attribute_id_names_lang));
            } else {
                $httpBody = $_rest_items_attributes_attribute_id_names_lang;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsAttributesAttributeIdNamesPost
     *
     * Create an attribute name
     *
     * @param  int $attribute_id attribute_id (required)
     * @param  \ck\Model\RestItemsAttributesAttributeIdNamesPostRequest|null $_rest_items_attributes_attribute_id_names _rest_items_attributes_attribute_id_names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdNamesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\AttributeName
     */
    public function restItemsAttributesAttributeIdNamesPost(
        int $attribute_id,
        ?\ck\Model\RestItemsAttributesAttributeIdNamesPostRequest $_rest_items_attributes_attribute_id_names = null,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdNamesPost'][0]
    ): \ck\Model\AttributeName
    {
        list($response) = $this->restItemsAttributesAttributeIdNamesPostWithHttpInfo($attribute_id, $_rest_items_attributes_attribute_id_names, $contentType);
        return $response;
    }

    /**
     * Operation restItemsAttributesAttributeIdNamesPostWithHttpInfo
     *
     * Create an attribute name
     *
     * @param  int $attribute_id (required)
     * @param  \ck\Model\RestItemsAttributesAttributeIdNamesPostRequest|null $_rest_items_attributes_attribute_id_names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdNamesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\AttributeName, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsAttributesAttributeIdNamesPostWithHttpInfo(
        int $attribute_id,
        ?\ck\Model\RestItemsAttributesAttributeIdNamesPostRequest $_rest_items_attributes_attribute_id_names = null,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdNamesPost'][0]
    ): array
    {
        $request = $this->restItemsAttributesAttributeIdNamesPostRequest($attribute_id, $_rest_items_attributes_attribute_id_names, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\AttributeName' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\AttributeName' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\AttributeName', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\AttributeName';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\AttributeName',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsAttributesAttributeIdNamesPostAsync
     *
     * Create an attribute name
     *
     * @param  int $attribute_id (required)
     * @param  \ck\Model\RestItemsAttributesAttributeIdNamesPostRequest|null $_rest_items_attributes_attribute_id_names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdNamesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributesAttributeIdNamesPostAsync(
        int $attribute_id,
        ?\ck\Model\RestItemsAttributesAttributeIdNamesPostRequest $_rest_items_attributes_attribute_id_names = null,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdNamesPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsAttributesAttributeIdNamesPostAsyncWithHttpInfo($attribute_id, $_rest_items_attributes_attribute_id_names, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsAttributesAttributeIdNamesPostAsyncWithHttpInfo
     *
     * Create an attribute name
     *
     * @param  int $attribute_id (required)
     * @param  \ck\Model\RestItemsAttributesAttributeIdNamesPostRequest|null $_rest_items_attributes_attribute_id_names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdNamesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributesAttributeIdNamesPostAsyncWithHttpInfo(
        $attribute_id,
        $_rest_items_attributes_attribute_id_names = null,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdNamesPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\AttributeName';
        $request = $this->restItemsAttributesAttributeIdNamesPostRequest($attribute_id, $_rest_items_attributes_attribute_id_names, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsAttributesAttributeIdNamesPost'
     *
     * @param  int $attribute_id (required)
     * @param  \ck\Model\RestItemsAttributesAttributeIdNamesPostRequest|null $_rest_items_attributes_attribute_id_names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdNamesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsAttributesAttributeIdNamesPostRequest(
        $attribute_id,
        $_rest_items_attributes_attribute_id_names = null,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdNamesPost'][0]
    ): Request
    {

        // verify the required parameter 'attribute_id' is set
        if ($attribute_id === null || (is_array($attribute_id) && count($attribute_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $attribute_id when calling restItemsAttributesAttributeIdNamesPost'
            );
        }



        $resourcePath = '/rest/items/attributes/{attributeId}/names';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($attribute_id !== null) {
            $resourcePath = str_replace(
                '{' . 'attributeId' . '}',
                ObjectSerializer::toPathValue($attribute_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_attributes_attribute_id_names)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_attributes_attribute_id_names));
            } else {
                $httpBody = $_rest_items_attributes_attribute_id_names;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsAttributesAttributeIdValueMarketNamesGet
     *
     * Search attribute value market names
     *
     * @param  int $attribute_id attribute_id (required)
     * @param  string|null $reference_type reference_type (optional)
     * @param  string|null $lang lang (optional)
     * @param  int|null $page The page of results to search for (optional)
     * @param  int|null $items_per_page The number of items to list per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValueMarketNamesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestItemsAttributesAttributeIdValueMarketNamesGet200Response
     */
    public function restItemsAttributesAttributeIdValueMarketNamesGet(
        int $attribute_id,
        ?string $reference_type = null,
        ?string $lang = null,
        ?int $page = null,
        ?int $items_per_page = null,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValueMarketNamesGet'][0]
    ): \ck\Model\RestItemsAttributesAttributeIdValueMarketNamesGet200Response
    {
        list($response) = $this->restItemsAttributesAttributeIdValueMarketNamesGetWithHttpInfo($attribute_id, $reference_type, $lang, $page, $items_per_page, $contentType);
        return $response;
    }

    /**
     * Operation restItemsAttributesAttributeIdValueMarketNamesGetWithHttpInfo
     *
     * Search attribute value market names
     *
     * @param  int $attribute_id (required)
     * @param  string|null $reference_type (optional)
     * @param  string|null $lang (optional)
     * @param  int|null $page The page of results to search for (optional)
     * @param  int|null $items_per_page The number of items to list per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValueMarketNamesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestItemsAttributesAttributeIdValueMarketNamesGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsAttributesAttributeIdValueMarketNamesGetWithHttpInfo(
        int $attribute_id,
        ?string $reference_type = null,
        ?string $lang = null,
        ?int $page = null,
        ?int $items_per_page = null,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValueMarketNamesGet'][0]
    ): array
    {
        $request = $this->restItemsAttributesAttributeIdValueMarketNamesGetRequest($attribute_id, $reference_type, $lang, $page, $items_per_page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestItemsAttributesAttributeIdValueMarketNamesGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestItemsAttributesAttributeIdValueMarketNamesGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestItemsAttributesAttributeIdValueMarketNamesGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestItemsAttributesAttributeIdValueMarketNamesGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestItemsAttributesAttributeIdValueMarketNamesGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsAttributesAttributeIdValueMarketNamesGetAsync
     *
     * Search attribute value market names
     *
     * @param  int $attribute_id (required)
     * @param  string|null $reference_type (optional)
     * @param  string|null $lang (optional)
     * @param  int|null $page The page of results to search for (optional)
     * @param  int|null $items_per_page The number of items to list per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValueMarketNamesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributesAttributeIdValueMarketNamesGetAsync(
        int $attribute_id,
        ?string $reference_type = null,
        ?string $lang = null,
        ?int $page = null,
        ?int $items_per_page = null,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValueMarketNamesGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsAttributesAttributeIdValueMarketNamesGetAsyncWithHttpInfo($attribute_id, $reference_type, $lang, $page, $items_per_page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsAttributesAttributeIdValueMarketNamesGetAsyncWithHttpInfo
     *
     * Search attribute value market names
     *
     * @param  int $attribute_id (required)
     * @param  string|null $reference_type (optional)
     * @param  string|null $lang (optional)
     * @param  int|null $page The page of results to search for (optional)
     * @param  int|null $items_per_page The number of items to list per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValueMarketNamesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributesAttributeIdValueMarketNamesGetAsyncWithHttpInfo(
        $attribute_id,
        $reference_type = null,
        $lang = null,
        $page = null,
        $items_per_page = null,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValueMarketNamesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestItemsAttributesAttributeIdValueMarketNamesGet200Response';
        $request = $this->restItemsAttributesAttributeIdValueMarketNamesGetRequest($attribute_id, $reference_type, $lang, $page, $items_per_page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsAttributesAttributeIdValueMarketNamesGet'
     *
     * @param  int $attribute_id (required)
     * @param  string|null $reference_type (optional)
     * @param  string|null $lang (optional)
     * @param  int|null $page The page of results to search for (optional)
     * @param  int|null $items_per_page The number of items to list per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValueMarketNamesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsAttributesAttributeIdValueMarketNamesGetRequest(
        $attribute_id,
        $reference_type = null,
        $lang = null,
        $page = null,
        $items_per_page = null,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValueMarketNamesGet'][0]
    ): Request
    {

        // verify the required parameter 'attribute_id' is set
        if ($attribute_id === null || (is_array($attribute_id) && count($attribute_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $attribute_id when calling restItemsAttributesAttributeIdValueMarketNamesGet'
            );
        }






        $resourcePath = '/rest/items/attributes/{attributeId}/value_market_names';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $reference_type,
            'referenceType', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $lang,
            'lang', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $items_per_page,
            'itemsPerPage', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($attribute_id !== null) {
            $resourcePath = str_replace(
                '{' . 'attributeId' . '}',
                ObjectSerializer::toPathValue($attribute_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsAttributesAttributeIdValueMarketNamesPost
     *
     * Create an attribute value market name
     *
     * @param  int $attribute_id attribute_id (required)
     * @param  \ck\Model\RestItemsAttributesAttributeIdValueMarketNamesPostRequest|null $_rest_items_attributes_attribute_id_value_market_names _rest_items_attributes_attribute_id_value_market_names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValueMarketNamesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\AttributeValueMarketName
     */
    public function restItemsAttributesAttributeIdValueMarketNamesPost(
        int $attribute_id,
        ?\ck\Model\RestItemsAttributesAttributeIdValueMarketNamesPostRequest $_rest_items_attributes_attribute_id_value_market_names = null,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValueMarketNamesPost'][0]
    ): \ck\Model\AttributeValueMarketName
    {
        list($response) = $this->restItemsAttributesAttributeIdValueMarketNamesPostWithHttpInfo($attribute_id, $_rest_items_attributes_attribute_id_value_market_names, $contentType);
        return $response;
    }

    /**
     * Operation restItemsAttributesAttributeIdValueMarketNamesPostWithHttpInfo
     *
     * Create an attribute value market name
     *
     * @param  int $attribute_id (required)
     * @param  \ck\Model\RestItemsAttributesAttributeIdValueMarketNamesPostRequest|null $_rest_items_attributes_attribute_id_value_market_names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValueMarketNamesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\AttributeValueMarketName, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsAttributesAttributeIdValueMarketNamesPostWithHttpInfo(
        int $attribute_id,
        ?\ck\Model\RestItemsAttributesAttributeIdValueMarketNamesPostRequest $_rest_items_attributes_attribute_id_value_market_names = null,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValueMarketNamesPost'][0]
    ): array
    {
        $request = $this->restItemsAttributesAttributeIdValueMarketNamesPostRequest($attribute_id, $_rest_items_attributes_attribute_id_value_market_names, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\AttributeValueMarketName' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\AttributeValueMarketName' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\AttributeValueMarketName', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\AttributeValueMarketName';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\AttributeValueMarketName',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsAttributesAttributeIdValueMarketNamesPostAsync
     *
     * Create an attribute value market name
     *
     * @param  int $attribute_id (required)
     * @param  \ck\Model\RestItemsAttributesAttributeIdValueMarketNamesPostRequest|null $_rest_items_attributes_attribute_id_value_market_names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValueMarketNamesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributesAttributeIdValueMarketNamesPostAsync(
        int $attribute_id,
        ?\ck\Model\RestItemsAttributesAttributeIdValueMarketNamesPostRequest $_rest_items_attributes_attribute_id_value_market_names = null,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValueMarketNamesPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsAttributesAttributeIdValueMarketNamesPostAsyncWithHttpInfo($attribute_id, $_rest_items_attributes_attribute_id_value_market_names, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsAttributesAttributeIdValueMarketNamesPostAsyncWithHttpInfo
     *
     * Create an attribute value market name
     *
     * @param  int $attribute_id (required)
     * @param  \ck\Model\RestItemsAttributesAttributeIdValueMarketNamesPostRequest|null $_rest_items_attributes_attribute_id_value_market_names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValueMarketNamesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributesAttributeIdValueMarketNamesPostAsyncWithHttpInfo(
        $attribute_id,
        $_rest_items_attributes_attribute_id_value_market_names = null,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValueMarketNamesPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\AttributeValueMarketName';
        $request = $this->restItemsAttributesAttributeIdValueMarketNamesPostRequest($attribute_id, $_rest_items_attributes_attribute_id_value_market_names, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsAttributesAttributeIdValueMarketNamesPost'
     *
     * @param  int $attribute_id (required)
     * @param  \ck\Model\RestItemsAttributesAttributeIdValueMarketNamesPostRequest|null $_rest_items_attributes_attribute_id_value_market_names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValueMarketNamesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsAttributesAttributeIdValueMarketNamesPostRequest(
        $attribute_id,
        $_rest_items_attributes_attribute_id_value_market_names = null,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValueMarketNamesPost'][0]
    ): Request
    {

        // verify the required parameter 'attribute_id' is set
        if ($attribute_id === null || (is_array($attribute_id) && count($attribute_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $attribute_id when calling restItemsAttributesAttributeIdValueMarketNamesPost'
            );
        }



        $resourcePath = '/rest/items/attributes/{attributeId}/value_market_names';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($attribute_id !== null) {
            $resourcePath = str_replace(
                '{' . 'attributeId' . '}',
                ObjectSerializer::toPathValue($attribute_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_attributes_attribute_id_value_market_names)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_attributes_attribute_id_value_market_names));
            } else {
                $httpBody = $_rest_items_attributes_attribute_id_value_market_names;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsAttributesAttributeIdValueMarketNamesValueIdLangReferenceTypeDelete
     *
     * Delete an attribute value market name
     *
     * @param  int $attribute_id attribute_id (required)
     * @param  int $value_id value_id (required)
     * @param  int $lang lang (required)
     * @param  int $reference_type reference_type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValueMarketNamesValueIdLangReferenceTypeDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsAttributesAttributeIdValueMarketNamesValueIdLangReferenceTypeDelete(
        int $attribute_id,
        int $value_id,
        int $lang,
        int $reference_type,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValueMarketNamesValueIdLangReferenceTypeDelete'][0]
    ): object
    {
        list($response) = $this->restItemsAttributesAttributeIdValueMarketNamesValueIdLangReferenceTypeDeleteWithHttpInfo($attribute_id, $value_id, $lang, $reference_type, $contentType);
        return $response;
    }

    /**
     * Operation restItemsAttributesAttributeIdValueMarketNamesValueIdLangReferenceTypeDeleteWithHttpInfo
     *
     * Delete an attribute value market name
     *
     * @param  int $attribute_id (required)
     * @param  int $value_id (required)
     * @param  int $lang (required)
     * @param  int $reference_type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValueMarketNamesValueIdLangReferenceTypeDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsAttributesAttributeIdValueMarketNamesValueIdLangReferenceTypeDeleteWithHttpInfo(
        int $attribute_id,
        int $value_id,
        int $lang,
        int $reference_type,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValueMarketNamesValueIdLangReferenceTypeDelete'][0]
    ): array
    {
        $request = $this->restItemsAttributesAttributeIdValueMarketNamesValueIdLangReferenceTypeDeleteRequest($attribute_id, $value_id, $lang, $reference_type, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsAttributesAttributeIdValueMarketNamesValueIdLangReferenceTypeDeleteAsync
     *
     * Delete an attribute value market name
     *
     * @param  int $attribute_id (required)
     * @param  int $value_id (required)
     * @param  int $lang (required)
     * @param  int $reference_type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValueMarketNamesValueIdLangReferenceTypeDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributesAttributeIdValueMarketNamesValueIdLangReferenceTypeDeleteAsync(
        int $attribute_id,
        int $value_id,
        int $lang,
        int $reference_type,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValueMarketNamesValueIdLangReferenceTypeDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemsAttributesAttributeIdValueMarketNamesValueIdLangReferenceTypeDeleteAsyncWithHttpInfo($attribute_id, $value_id, $lang, $reference_type, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsAttributesAttributeIdValueMarketNamesValueIdLangReferenceTypeDeleteAsyncWithHttpInfo
     *
     * Delete an attribute value market name
     *
     * @param  int $attribute_id (required)
     * @param  int $value_id (required)
     * @param  int $lang (required)
     * @param  int $reference_type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValueMarketNamesValueIdLangReferenceTypeDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributesAttributeIdValueMarketNamesValueIdLangReferenceTypeDeleteAsyncWithHttpInfo(
        $attribute_id,
        $value_id,
        $lang,
        $reference_type,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValueMarketNamesValueIdLangReferenceTypeDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsAttributesAttributeIdValueMarketNamesValueIdLangReferenceTypeDeleteRequest($attribute_id, $value_id, $lang, $reference_type, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsAttributesAttributeIdValueMarketNamesValueIdLangReferenceTypeDelete'
     *
     * @param  int $attribute_id (required)
     * @param  int $value_id (required)
     * @param  int $lang (required)
     * @param  int $reference_type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValueMarketNamesValueIdLangReferenceTypeDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsAttributesAttributeIdValueMarketNamesValueIdLangReferenceTypeDeleteRequest(
        $attribute_id,
        $value_id,
        $lang,
        $reference_type,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValueMarketNamesValueIdLangReferenceTypeDelete'][0]
    ): Request
    {

        // verify the required parameter 'attribute_id' is set
        if ($attribute_id === null || (is_array($attribute_id) && count($attribute_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $attribute_id when calling restItemsAttributesAttributeIdValueMarketNamesValueIdLangReferenceTypeDelete'
            );
        }

        // verify the required parameter 'value_id' is set
        if ($value_id === null || (is_array($value_id) && count($value_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $value_id when calling restItemsAttributesAttributeIdValueMarketNamesValueIdLangReferenceTypeDelete'
            );
        }

        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $lang when calling restItemsAttributesAttributeIdValueMarketNamesValueIdLangReferenceTypeDelete'
            );
        }

        // verify the required parameter 'reference_type' is set
        if ($reference_type === null || (is_array($reference_type) && count($reference_type) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $reference_type when calling restItemsAttributesAttributeIdValueMarketNamesValueIdLangReferenceTypeDelete'
            );
        }


        $resourcePath = '/rest/items/attributes/{attributeId}/value_market_names/{valueId}/{lang}/{referenceType}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($attribute_id !== null) {
            $resourcePath = str_replace(
                '{' . 'attributeId' . '}',
                ObjectSerializer::toPathValue($attribute_id),
                $resourcePath
            );
        }
        // path params
        if ($value_id !== null) {
            $resourcePath = str_replace(
                '{' . 'valueId' . '}',
                ObjectSerializer::toPathValue($value_id),
                $resourcePath
            );
        }
        // path params
        if ($lang !== null) {
            $resourcePath = str_replace(
                '{' . 'lang' . '}',
                ObjectSerializer::toPathValue($lang),
                $resourcePath
            );
        }
        // path params
        if ($reference_type !== null) {
            $resourcePath = str_replace(
                '{' . 'referenceType' . '}',
                ObjectSerializer::toPathValue($reference_type),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsAttributesAttributeIdValueMarketNamesValueIdLangReferenceTypePut
     *
     * Update an attribute value market name
     *
     * @param  int $attribute_id attribute_id (required)
     * @param  int $value_id value_id (required)
     * @param  int $lang lang (required)
     * @param  int $reference_type reference_type (required)
     * @param  \ck\Model\RestItemsAttributesAttributeIdValueMarketNamesPostRequest|null $_rest_items_attributes_attribute_id_value_market_names_value_id_lang_reference_type _rest_items_attributes_attribute_id_value_market_names_value_id_lang_reference_type (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValueMarketNamesValueIdLangReferenceTypePut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\AttributeValueMarketName
     */
    public function restItemsAttributesAttributeIdValueMarketNamesValueIdLangReferenceTypePut(
        int $attribute_id,
        int $value_id,
        int $lang,
        int $reference_type,
        ?\ck\Model\RestItemsAttributesAttributeIdValueMarketNamesPostRequest $_rest_items_attributes_attribute_id_value_market_names_value_id_lang_reference_type = null,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValueMarketNamesValueIdLangReferenceTypePut'][0]
    ): \ck\Model\AttributeValueMarketName
    {
        list($response) = $this->restItemsAttributesAttributeIdValueMarketNamesValueIdLangReferenceTypePutWithHttpInfo($attribute_id, $value_id, $lang, $reference_type, $_rest_items_attributes_attribute_id_value_market_names_value_id_lang_reference_type, $contentType);
        return $response;
    }

    /**
     * Operation restItemsAttributesAttributeIdValueMarketNamesValueIdLangReferenceTypePutWithHttpInfo
     *
     * Update an attribute value market name
     *
     * @param  int $attribute_id (required)
     * @param  int $value_id (required)
     * @param  int $lang (required)
     * @param  int $reference_type (required)
     * @param  \ck\Model\RestItemsAttributesAttributeIdValueMarketNamesPostRequest|null $_rest_items_attributes_attribute_id_value_market_names_value_id_lang_reference_type (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValueMarketNamesValueIdLangReferenceTypePut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\AttributeValueMarketName, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsAttributesAttributeIdValueMarketNamesValueIdLangReferenceTypePutWithHttpInfo(
        int $attribute_id,
        int $value_id,
        int $lang,
        int $reference_type,
        ?\ck\Model\RestItemsAttributesAttributeIdValueMarketNamesPostRequest $_rest_items_attributes_attribute_id_value_market_names_value_id_lang_reference_type = null,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValueMarketNamesValueIdLangReferenceTypePut'][0]
    ): array
    {
        $request = $this->restItemsAttributesAttributeIdValueMarketNamesValueIdLangReferenceTypePutRequest($attribute_id, $value_id, $lang, $reference_type, $_rest_items_attributes_attribute_id_value_market_names_value_id_lang_reference_type, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\AttributeValueMarketName' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\AttributeValueMarketName' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\AttributeValueMarketName', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\AttributeValueMarketName';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\AttributeValueMarketName',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsAttributesAttributeIdValueMarketNamesValueIdLangReferenceTypePutAsync
     *
     * Update an attribute value market name
     *
     * @param  int $attribute_id (required)
     * @param  int $value_id (required)
     * @param  int $lang (required)
     * @param  int $reference_type (required)
     * @param  \ck\Model\RestItemsAttributesAttributeIdValueMarketNamesPostRequest|null $_rest_items_attributes_attribute_id_value_market_names_value_id_lang_reference_type (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValueMarketNamesValueIdLangReferenceTypePut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributesAttributeIdValueMarketNamesValueIdLangReferenceTypePutAsync(
        int $attribute_id,
        int $value_id,
        int $lang,
        int $reference_type,
        ?\ck\Model\RestItemsAttributesAttributeIdValueMarketNamesPostRequest $_rest_items_attributes_attribute_id_value_market_names_value_id_lang_reference_type = null,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValueMarketNamesValueIdLangReferenceTypePut'][0]
    ): PromiseInterface
    {
        return $this->restItemsAttributesAttributeIdValueMarketNamesValueIdLangReferenceTypePutAsyncWithHttpInfo($attribute_id, $value_id, $lang, $reference_type, $_rest_items_attributes_attribute_id_value_market_names_value_id_lang_reference_type, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsAttributesAttributeIdValueMarketNamesValueIdLangReferenceTypePutAsyncWithHttpInfo
     *
     * Update an attribute value market name
     *
     * @param  int $attribute_id (required)
     * @param  int $value_id (required)
     * @param  int $lang (required)
     * @param  int $reference_type (required)
     * @param  \ck\Model\RestItemsAttributesAttributeIdValueMarketNamesPostRequest|null $_rest_items_attributes_attribute_id_value_market_names_value_id_lang_reference_type (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValueMarketNamesValueIdLangReferenceTypePut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributesAttributeIdValueMarketNamesValueIdLangReferenceTypePutAsyncWithHttpInfo(
        $attribute_id,
        $value_id,
        $lang,
        $reference_type,
        $_rest_items_attributes_attribute_id_value_market_names_value_id_lang_reference_type = null,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValueMarketNamesValueIdLangReferenceTypePut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\AttributeValueMarketName';
        $request = $this->restItemsAttributesAttributeIdValueMarketNamesValueIdLangReferenceTypePutRequest($attribute_id, $value_id, $lang, $reference_type, $_rest_items_attributes_attribute_id_value_market_names_value_id_lang_reference_type, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsAttributesAttributeIdValueMarketNamesValueIdLangReferenceTypePut'
     *
     * @param  int $attribute_id (required)
     * @param  int $value_id (required)
     * @param  int $lang (required)
     * @param  int $reference_type (required)
     * @param  \ck\Model\RestItemsAttributesAttributeIdValueMarketNamesPostRequest|null $_rest_items_attributes_attribute_id_value_market_names_value_id_lang_reference_type (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValueMarketNamesValueIdLangReferenceTypePut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsAttributesAttributeIdValueMarketNamesValueIdLangReferenceTypePutRequest(
        $attribute_id,
        $value_id,
        $lang,
        $reference_type,
        $_rest_items_attributes_attribute_id_value_market_names_value_id_lang_reference_type = null,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValueMarketNamesValueIdLangReferenceTypePut'][0]
    ): Request
    {

        // verify the required parameter 'attribute_id' is set
        if ($attribute_id === null || (is_array($attribute_id) && count($attribute_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $attribute_id when calling restItemsAttributesAttributeIdValueMarketNamesValueIdLangReferenceTypePut'
            );
        }

        // verify the required parameter 'value_id' is set
        if ($value_id === null || (is_array($value_id) && count($value_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $value_id when calling restItemsAttributesAttributeIdValueMarketNamesValueIdLangReferenceTypePut'
            );
        }

        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $lang when calling restItemsAttributesAttributeIdValueMarketNamesValueIdLangReferenceTypePut'
            );
        }

        // verify the required parameter 'reference_type' is set
        if ($reference_type === null || (is_array($reference_type) && count($reference_type) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $reference_type when calling restItemsAttributesAttributeIdValueMarketNamesValueIdLangReferenceTypePut'
            );
        }



        $resourcePath = '/rest/items/attributes/{attributeId}/value_market_names/{valueId}/{lang}/{referenceType}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($attribute_id !== null) {
            $resourcePath = str_replace(
                '{' . 'attributeId' . '}',
                ObjectSerializer::toPathValue($attribute_id),
                $resourcePath
            );
        }
        // path params
        if ($value_id !== null) {
            $resourcePath = str_replace(
                '{' . 'valueId' . '}',
                ObjectSerializer::toPathValue($value_id),
                $resourcePath
            );
        }
        // path params
        if ($lang !== null) {
            $resourcePath = str_replace(
                '{' . 'lang' . '}',
                ObjectSerializer::toPathValue($lang),
                $resourcePath
            );
        }
        // path params
        if ($reference_type !== null) {
            $resourcePath = str_replace(
                '{' . 'referenceType' . '}',
                ObjectSerializer::toPathValue($reference_type),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_attributes_attribute_id_value_market_names_value_id_lang_reference_type)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_attributes_attribute_id_value_market_names_value_id_lang_reference_type));
            } else {
                $httpBody = $_rest_items_attributes_attribute_id_value_market_names_value_id_lang_reference_type;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsDelete
     *
     * Deletes an attribute value map.
     *
     * @param  int $attribute_id attribute_id (required)
     * @param  int $attribute_value_id attribute_value_id (required)
     * @param  int $market_id market_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsDelete(
        int $attribute_id,
        int $attribute_value_id,
        int $market_id,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsDelete'][0]
    ): object
    {
        list($response) = $this->restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsDeleteWithHttpInfo($attribute_id, $attribute_value_id, $market_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsDeleteWithHttpInfo
     *
     * Deletes an attribute value map.
     *
     * @param  int $attribute_id (required)
     * @param  int $attribute_value_id (required)
     * @param  int $market_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsDeleteWithHttpInfo(
        int $attribute_id,
        int $attribute_value_id,
        int $market_id,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsDelete'][0]
    ): array
    {
        $request = $this->restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsDeleteRequest($attribute_id, $attribute_value_id, $market_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsDeleteAsync
     *
     * Deletes an attribute value map.
     *
     * @param  int $attribute_id (required)
     * @param  int $attribute_value_id (required)
     * @param  int $market_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsDeleteAsync(
        int $attribute_id,
        int $attribute_value_id,
        int $market_id,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsDeleteAsyncWithHttpInfo($attribute_id, $attribute_value_id, $market_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsDeleteAsyncWithHttpInfo
     *
     * Deletes an attribute value map.
     *
     * @param  int $attribute_id (required)
     * @param  int $attribute_value_id (required)
     * @param  int $market_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsDeleteAsyncWithHttpInfo(
        $attribute_id,
        $attribute_value_id,
        $market_id,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsDeleteRequest($attribute_id, $attribute_value_id, $market_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsDelete'
     *
     * @param  int $attribute_id (required)
     * @param  int $attribute_value_id (required)
     * @param  int $market_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsDeleteRequest(
        $attribute_id,
        $attribute_value_id,
        $market_id,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsDelete'][0]
    ): Request
    {

        // verify the required parameter 'attribute_id' is set
        if ($attribute_id === null || (is_array($attribute_id) && count($attribute_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $attribute_id when calling restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsDelete'
            );
        }

        // verify the required parameter 'attribute_value_id' is set
        if ($attribute_value_id === null || (is_array($attribute_value_id) && count($attribute_value_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $attribute_value_id when calling restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsDelete'
            );
        }

        // verify the required parameter 'market_id' is set
        if ($market_id === null || (is_array($market_id) && count($market_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $market_id when calling restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsDelete'
            );
        }


        $resourcePath = '/rest/items/attributes/{attributeId}/values/{attributeValueId}/markets/{marketId}/maps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($attribute_id !== null) {
            $resourcePath = str_replace(
                '{' . 'attributeId' . '}',
                ObjectSerializer::toPathValue($attribute_id),
                $resourcePath
            );
        }
        // path params
        if ($attribute_value_id !== null) {
            $resourcePath = str_replace(
                '{' . 'attributeValueId' . '}',
                ObjectSerializer::toPathValue($attribute_value_id),
                $resourcePath
            );
        }
        // path params
        if ($market_id !== null) {
            $resourcePath = str_replace(
                '{' . 'marketId' . '}',
                ObjectSerializer::toPathValue($market_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsGet
     *
     * Gets an attribute value map.
     *
     * @param  int $attribute_id attribute_id (required)
     * @param  int $attribute_value_id attribute_value_id (required)
     * @param  int $market_id market_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\AttributeValueMap
     */
    public function restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsGet(
        int $attribute_id,
        int $attribute_value_id,
        int $market_id,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsGet'][0]
    ): \ck\Model\AttributeValueMap
    {
        list($response) = $this->restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsGetWithHttpInfo($attribute_id, $attribute_value_id, $market_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsGetWithHttpInfo
     *
     * Gets an attribute value map.
     *
     * @param  int $attribute_id (required)
     * @param  int $attribute_value_id (required)
     * @param  int $market_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\AttributeValueMap, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsGetWithHttpInfo(
        int $attribute_id,
        int $attribute_value_id,
        int $market_id,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsGet'][0]
    ): array
    {
        $request = $this->restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsGetRequest($attribute_id, $attribute_value_id, $market_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\AttributeValueMap' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\AttributeValueMap' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\AttributeValueMap', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\AttributeValueMap';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\AttributeValueMap',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsGetAsync
     *
     * Gets an attribute value map.
     *
     * @param  int $attribute_id (required)
     * @param  int $attribute_value_id (required)
     * @param  int $market_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsGetAsync(
        int $attribute_id,
        int $attribute_value_id,
        int $market_id,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsGetAsyncWithHttpInfo($attribute_id, $attribute_value_id, $market_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsGetAsyncWithHttpInfo
     *
     * Gets an attribute value map.
     *
     * @param  int $attribute_id (required)
     * @param  int $attribute_value_id (required)
     * @param  int $market_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsGetAsyncWithHttpInfo(
        $attribute_id,
        $attribute_value_id,
        $market_id,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\AttributeValueMap';
        $request = $this->restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsGetRequest($attribute_id, $attribute_value_id, $market_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsGet'
     *
     * @param  int $attribute_id (required)
     * @param  int $attribute_value_id (required)
     * @param  int $market_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsGetRequest(
        $attribute_id,
        $attribute_value_id,
        $market_id,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsGet'][0]
    ): Request
    {

        // verify the required parameter 'attribute_id' is set
        if ($attribute_id === null || (is_array($attribute_id) && count($attribute_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $attribute_id when calling restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsGet'
            );
        }

        // verify the required parameter 'attribute_value_id' is set
        if ($attribute_value_id === null || (is_array($attribute_value_id) && count($attribute_value_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $attribute_value_id when calling restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsGet'
            );
        }

        // verify the required parameter 'market_id' is set
        if ($market_id === null || (is_array($market_id) && count($market_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $market_id when calling restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsGet'
            );
        }


        $resourcePath = '/rest/items/attributes/{attributeId}/values/{attributeValueId}/markets/{marketId}/maps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($attribute_id !== null) {
            $resourcePath = str_replace(
                '{' . 'attributeId' . '}',
                ObjectSerializer::toPathValue($attribute_id),
                $resourcePath
            );
        }
        // path params
        if ($attribute_value_id !== null) {
            $resourcePath = str_replace(
                '{' . 'attributeValueId' . '}',
                ObjectSerializer::toPathValue($attribute_value_id),
                $resourcePath
            );
        }
        // path params
        if ($market_id !== null) {
            $resourcePath = str_replace(
                '{' . 'marketId' . '}',
                ObjectSerializer::toPathValue($market_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsPut
     *
     * Updates an attribute value map.
     *
     * @param  int $attribute_id attribute_id (required)
     * @param  int $attribute_value_id attribute_value_id (required)
     * @param  int $market_id market_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\AttributeValueMap
     */
    public function restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsPut(
        int $attribute_id,
        int $attribute_value_id,
        int $market_id,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsPut'][0]
    ): \ck\Model\AttributeValueMap
    {
        list($response) = $this->restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsPutWithHttpInfo($attribute_id, $attribute_value_id, $market_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsPutWithHttpInfo
     *
     * Updates an attribute value map.
     *
     * @param  int $attribute_id (required)
     * @param  int $attribute_value_id (required)
     * @param  int $market_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\AttributeValueMap, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsPutWithHttpInfo(
        int $attribute_id,
        int $attribute_value_id,
        int $market_id,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsPut'][0]
    ): array
    {
        $request = $this->restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsPutRequest($attribute_id, $attribute_value_id, $market_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\AttributeValueMap' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\AttributeValueMap' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\AttributeValueMap', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\AttributeValueMap';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\AttributeValueMap',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsPutAsync
     *
     * Updates an attribute value map.
     *
     * @param  int $attribute_id (required)
     * @param  int $attribute_value_id (required)
     * @param  int $market_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsPutAsync(
        int $attribute_id,
        int $attribute_value_id,
        int $market_id,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsPut'][0]
    ): PromiseInterface
    {
        return $this->restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsPutAsyncWithHttpInfo($attribute_id, $attribute_value_id, $market_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsPutAsyncWithHttpInfo
     *
     * Updates an attribute value map.
     *
     * @param  int $attribute_id (required)
     * @param  int $attribute_value_id (required)
     * @param  int $market_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsPutAsyncWithHttpInfo(
        $attribute_id,
        $attribute_value_id,
        $market_id,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\AttributeValueMap';
        $request = $this->restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsPutRequest($attribute_id, $attribute_value_id, $market_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsPut'
     *
     * @param  int $attribute_id (required)
     * @param  int $attribute_value_id (required)
     * @param  int $market_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsPutRequest(
        $attribute_id,
        $attribute_value_id,
        $market_id,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsPut'][0]
    ): Request
    {

        // verify the required parameter 'attribute_id' is set
        if ($attribute_id === null || (is_array($attribute_id) && count($attribute_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $attribute_id when calling restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsPut'
            );
        }

        // verify the required parameter 'attribute_value_id' is set
        if ($attribute_value_id === null || (is_array($attribute_value_id) && count($attribute_value_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $attribute_value_id when calling restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsPut'
            );
        }

        // verify the required parameter 'market_id' is set
        if ($market_id === null || (is_array($market_id) && count($market_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $market_id when calling restItemsAttributesAttributeIdValuesAttributeValueIdMarketsMarketIdMapsPut'
            );
        }


        $resourcePath = '/rest/items/attributes/{attributeId}/values/{attributeValueId}/markets/{marketId}/maps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($attribute_id !== null) {
            $resourcePath = str_replace(
                '{' . 'attributeId' . '}',
                ObjectSerializer::toPathValue($attribute_id),
                $resourcePath
            );
        }
        // path params
        if ($attribute_value_id !== null) {
            $resourcePath = str_replace(
                '{' . 'attributeValueId' . '}',
                ObjectSerializer::toPathValue($attribute_value_id),
                $resourcePath
            );
        }
        // path params
        if ($market_id !== null) {
            $resourcePath = str_replace(
                '{' . 'marketId' . '}',
                ObjectSerializer::toPathValue($market_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsAttributesAttributeIdValuesGet
     *
     * List attribute values
     *
     * @param  int $attribute_id attribute_id (required)
     * @param  string|null $with Includes the specified attribute value information in the results. The following parameters are available:&lt;ul&gt;&lt;li&gt;attribute &#x3D; The attribute of the value&lt;/li&gt;&lt;li&gt;names &#x3D; The attribute value names in all languages&lt;/li&gt;&lt;li&gt;marketNames &#x3D; The market attribute value links (amazon only)&lt;/li&gt;&lt;li&gt;valueMaps &#x3D; The market attribute value links (amazon excluded)&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string|null $updated_at Filter restricts the list of results to items updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValuesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestItemsAttributesAttributeIdValuesGet200Response
     */
    public function restItemsAttributesAttributeIdValuesGet(
        int $attribute_id,
        ?string $with = null,
        ?string $updated_at = null,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValuesGet'][0]
    ): \ck\Model\RestItemsAttributesAttributeIdValuesGet200Response
    {
        list($response) = $this->restItemsAttributesAttributeIdValuesGetWithHttpInfo($attribute_id, $with, $updated_at, $contentType);
        return $response;
    }

    /**
     * Operation restItemsAttributesAttributeIdValuesGetWithHttpInfo
     *
     * List attribute values
     *
     * @param  int $attribute_id (required)
     * @param  string|null $with Includes the specified attribute value information in the results. The following parameters are available:&lt;ul&gt;&lt;li&gt;attribute &#x3D; The attribute of the value&lt;/li&gt;&lt;li&gt;names &#x3D; The attribute value names in all languages&lt;/li&gt;&lt;li&gt;marketNames &#x3D; The market attribute value links (amazon only)&lt;/li&gt;&lt;li&gt;valueMaps &#x3D; The market attribute value links (amazon excluded)&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string|null $updated_at Filter restricts the list of results to items updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValuesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestItemsAttributesAttributeIdValuesGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsAttributesAttributeIdValuesGetWithHttpInfo(
        int $attribute_id,
        ?string $with = null,
        ?string $updated_at = null,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValuesGet'][0]
    ): array
    {
        $request = $this->restItemsAttributesAttributeIdValuesGetRequest($attribute_id, $with, $updated_at, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestItemsAttributesAttributeIdValuesGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestItemsAttributesAttributeIdValuesGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestItemsAttributesAttributeIdValuesGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestItemsAttributesAttributeIdValuesGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestItemsAttributesAttributeIdValuesGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsAttributesAttributeIdValuesGetAsync
     *
     * List attribute values
     *
     * @param  int $attribute_id (required)
     * @param  string|null $with Includes the specified attribute value information in the results. The following parameters are available:&lt;ul&gt;&lt;li&gt;attribute &#x3D; The attribute of the value&lt;/li&gt;&lt;li&gt;names &#x3D; The attribute value names in all languages&lt;/li&gt;&lt;li&gt;marketNames &#x3D; The market attribute value links (amazon only)&lt;/li&gt;&lt;li&gt;valueMaps &#x3D; The market attribute value links (amazon excluded)&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string|null $updated_at Filter restricts the list of results to items updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValuesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributesAttributeIdValuesGetAsync(
        int $attribute_id,
        ?string $with = null,
        ?string $updated_at = null,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValuesGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsAttributesAttributeIdValuesGetAsyncWithHttpInfo($attribute_id, $with, $updated_at, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsAttributesAttributeIdValuesGetAsyncWithHttpInfo
     *
     * List attribute values
     *
     * @param  int $attribute_id (required)
     * @param  string|null $with Includes the specified attribute value information in the results. The following parameters are available:&lt;ul&gt;&lt;li&gt;attribute &#x3D; The attribute of the value&lt;/li&gt;&lt;li&gt;names &#x3D; The attribute value names in all languages&lt;/li&gt;&lt;li&gt;marketNames &#x3D; The market attribute value links (amazon only)&lt;/li&gt;&lt;li&gt;valueMaps &#x3D; The market attribute value links (amazon excluded)&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string|null $updated_at Filter restricts the list of results to items updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValuesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributesAttributeIdValuesGetAsyncWithHttpInfo(
        $attribute_id,
        $with = null,
        $updated_at = null,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValuesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestItemsAttributesAttributeIdValuesGet200Response';
        $request = $this->restItemsAttributesAttributeIdValuesGetRequest($attribute_id, $with, $updated_at, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsAttributesAttributeIdValuesGet'
     *
     * @param  int $attribute_id (required)
     * @param  string|null $with Includes the specified attribute value information in the results. The following parameters are available:&lt;ul&gt;&lt;li&gt;attribute &#x3D; The attribute of the value&lt;/li&gt;&lt;li&gt;names &#x3D; The attribute value names in all languages&lt;/li&gt;&lt;li&gt;marketNames &#x3D; The market attribute value links (amazon only)&lt;/li&gt;&lt;li&gt;valueMaps &#x3D; The market attribute value links (amazon excluded)&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string|null $updated_at Filter restricts the list of results to items updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValuesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsAttributesAttributeIdValuesGetRequest(
        $attribute_id,
        $with = null,
        $updated_at = null,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValuesGet'][0]
    ): Request
    {

        // verify the required parameter 'attribute_id' is set
        if ($attribute_id === null || (is_array($attribute_id) && count($attribute_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $attribute_id when calling restItemsAttributesAttributeIdValuesGet'
            );
        }




        $resourcePath = '/rest/items/attributes/{attributeId}/values';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_at,
            'updatedAt', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($attribute_id !== null) {
            $resourcePath = str_replace(
                '{' . 'attributeId' . '}',
                ObjectSerializer::toPathValue($attribute_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsAttributesAttributeIdValuesIdDelete
     *
     * Delete an attribute value
     *
     * @param  int $attribute_id attribute_id (required)
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValuesIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsAttributesAttributeIdValuesIdDelete(
        int $attribute_id,
        int $id,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValuesIdDelete'][0]
    ): object
    {
        list($response) = $this->restItemsAttributesAttributeIdValuesIdDeleteWithHttpInfo($attribute_id, $id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsAttributesAttributeIdValuesIdDeleteWithHttpInfo
     *
     * Delete an attribute value
     *
     * @param  int $attribute_id (required)
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValuesIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsAttributesAttributeIdValuesIdDeleteWithHttpInfo(
        int $attribute_id,
        int $id,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValuesIdDelete'][0]
    ): array
    {
        $request = $this->restItemsAttributesAttributeIdValuesIdDeleteRequest($attribute_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsAttributesAttributeIdValuesIdDeleteAsync
     *
     * Delete an attribute value
     *
     * @param  int $attribute_id (required)
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValuesIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributesAttributeIdValuesIdDeleteAsync(
        int $attribute_id,
        int $id,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValuesIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemsAttributesAttributeIdValuesIdDeleteAsyncWithHttpInfo($attribute_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsAttributesAttributeIdValuesIdDeleteAsyncWithHttpInfo
     *
     * Delete an attribute value
     *
     * @param  int $attribute_id (required)
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValuesIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributesAttributeIdValuesIdDeleteAsyncWithHttpInfo(
        $attribute_id,
        $id,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValuesIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsAttributesAttributeIdValuesIdDeleteRequest($attribute_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsAttributesAttributeIdValuesIdDelete'
     *
     * @param  int $attribute_id (required)
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValuesIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsAttributesAttributeIdValuesIdDeleteRequest(
        $attribute_id,
        $id,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValuesIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'attribute_id' is set
        if ($attribute_id === null || (is_array($attribute_id) && count($attribute_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $attribute_id when calling restItemsAttributesAttributeIdValuesIdDelete'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsAttributesAttributeIdValuesIdDelete'
            );
        }


        $resourcePath = '/rest/items/attributes/{attributeId}/values/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($attribute_id !== null) {
            $resourcePath = str_replace(
                '{' . 'attributeId' . '}',
                ObjectSerializer::toPathValue($attribute_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsAttributesAttributeIdValuesIdGet
     *
     * Get an attribute value
     *
     * @param  int $attribute_id attribute_id (required)
     * @param  int $id id (required)
     * @param  string|null $with Includes the specified attribute value information in the results. The following parameters are available:&lt;ul&gt;&lt;li&gt;attribute &#x3D; The attribute of the value&lt;/li&gt;&lt;li&gt;names &#x3D; The attribute value names in all languages&lt;/li&gt;&lt;li&gt;marketNames &#x3D; The market attribute value links (amazon only)&lt;/li&gt;&lt;li&gt;valueMaps &#x3D; The market attribute links (amazon excluded)&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValuesIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\AttributeValue
     */
    public function restItemsAttributesAttributeIdValuesIdGet(
        int $attribute_id,
        int $id,
        ?string $with = null,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValuesIdGet'][0]
    ): \ck\Model\AttributeValue
    {
        list($response) = $this->restItemsAttributesAttributeIdValuesIdGetWithHttpInfo($attribute_id, $id, $with, $contentType);
        return $response;
    }

    /**
     * Operation restItemsAttributesAttributeIdValuesIdGetWithHttpInfo
     *
     * Get an attribute value
     *
     * @param  int $attribute_id (required)
     * @param  int $id (required)
     * @param  string|null $with Includes the specified attribute value information in the results. The following parameters are available:&lt;ul&gt;&lt;li&gt;attribute &#x3D; The attribute of the value&lt;/li&gt;&lt;li&gt;names &#x3D; The attribute value names in all languages&lt;/li&gt;&lt;li&gt;marketNames &#x3D; The market attribute value links (amazon only)&lt;/li&gt;&lt;li&gt;valueMaps &#x3D; The market attribute links (amazon excluded)&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValuesIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\AttributeValue, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsAttributesAttributeIdValuesIdGetWithHttpInfo(
        int $attribute_id,
        int $id,
        ?string $with = null,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValuesIdGet'][0]
    ): array
    {
        $request = $this->restItemsAttributesAttributeIdValuesIdGetRequest($attribute_id, $id, $with, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\AttributeValue' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\AttributeValue' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\AttributeValue', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\AttributeValue';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\AttributeValue',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsAttributesAttributeIdValuesIdGetAsync
     *
     * Get an attribute value
     *
     * @param  int $attribute_id (required)
     * @param  int $id (required)
     * @param  string|null $with Includes the specified attribute value information in the results. The following parameters are available:&lt;ul&gt;&lt;li&gt;attribute &#x3D; The attribute of the value&lt;/li&gt;&lt;li&gt;names &#x3D; The attribute value names in all languages&lt;/li&gt;&lt;li&gt;marketNames &#x3D; The market attribute value links (amazon only)&lt;/li&gt;&lt;li&gt;valueMaps &#x3D; The market attribute links (amazon excluded)&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValuesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributesAttributeIdValuesIdGetAsync(
        int $attribute_id,
        int $id,
        ?string $with = null,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValuesIdGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsAttributesAttributeIdValuesIdGetAsyncWithHttpInfo($attribute_id, $id, $with, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsAttributesAttributeIdValuesIdGetAsyncWithHttpInfo
     *
     * Get an attribute value
     *
     * @param  int $attribute_id (required)
     * @param  int $id (required)
     * @param  string|null $with Includes the specified attribute value information in the results. The following parameters are available:&lt;ul&gt;&lt;li&gt;attribute &#x3D; The attribute of the value&lt;/li&gt;&lt;li&gt;names &#x3D; The attribute value names in all languages&lt;/li&gt;&lt;li&gt;marketNames &#x3D; The market attribute value links (amazon only)&lt;/li&gt;&lt;li&gt;valueMaps &#x3D; The market attribute links (amazon excluded)&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValuesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributesAttributeIdValuesIdGetAsyncWithHttpInfo(
        $attribute_id,
        $id,
        $with = null,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValuesIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\AttributeValue';
        $request = $this->restItemsAttributesAttributeIdValuesIdGetRequest($attribute_id, $id, $with, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsAttributesAttributeIdValuesIdGet'
     *
     * @param  int $attribute_id (required)
     * @param  int $id (required)
     * @param  string|null $with Includes the specified attribute value information in the results. The following parameters are available:&lt;ul&gt;&lt;li&gt;attribute &#x3D; The attribute of the value&lt;/li&gt;&lt;li&gt;names &#x3D; The attribute value names in all languages&lt;/li&gt;&lt;li&gt;marketNames &#x3D; The market attribute value links (amazon only)&lt;/li&gt;&lt;li&gt;valueMaps &#x3D; The market attribute links (amazon excluded)&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValuesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsAttributesAttributeIdValuesIdGetRequest(
        $attribute_id,
        $id,
        $with = null,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValuesIdGet'][0]
    ): Request
    {

        // verify the required parameter 'attribute_id' is set
        if ($attribute_id === null || (is_array($attribute_id) && count($attribute_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $attribute_id when calling restItemsAttributesAttributeIdValuesIdGet'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsAttributesAttributeIdValuesIdGet'
            );
        }



        $resourcePath = '/rest/items/attributes/{attributeId}/values/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($attribute_id !== null) {
            $resourcePath = str_replace(
                '{' . 'attributeId' . '}',
                ObjectSerializer::toPathValue($attribute_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsAttributesAttributeIdValuesIdPut
     *
     * Update an attribute value
     *
     * @param  int $attribute_id attribute_id (required)
     * @param  int $id id (required)
     * @param  \ck\Model\RestItemsAttributesAttributeIdValuesPostRequest|null $_rest_items_attributes_attribute_id_values_id _rest_items_attributes_attribute_id_values_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValuesIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\AttributeValue
     */
    public function restItemsAttributesAttributeIdValuesIdPut(
        int $attribute_id,
        int $id,
        ?\ck\Model\RestItemsAttributesAttributeIdValuesPostRequest $_rest_items_attributes_attribute_id_values_id = null,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValuesIdPut'][0]
    ): \ck\Model\AttributeValue
    {
        list($response) = $this->restItemsAttributesAttributeIdValuesIdPutWithHttpInfo($attribute_id, $id, $_rest_items_attributes_attribute_id_values_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsAttributesAttributeIdValuesIdPutWithHttpInfo
     *
     * Update an attribute value
     *
     * @param  int $attribute_id (required)
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsAttributesAttributeIdValuesPostRequest|null $_rest_items_attributes_attribute_id_values_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValuesIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\AttributeValue, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsAttributesAttributeIdValuesIdPutWithHttpInfo(
        int $attribute_id,
        int $id,
        ?\ck\Model\RestItemsAttributesAttributeIdValuesPostRequest $_rest_items_attributes_attribute_id_values_id = null,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValuesIdPut'][0]
    ): array
    {
        $request = $this->restItemsAttributesAttributeIdValuesIdPutRequest($attribute_id, $id, $_rest_items_attributes_attribute_id_values_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\AttributeValue' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\AttributeValue' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\AttributeValue', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\AttributeValue';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\AttributeValue',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsAttributesAttributeIdValuesIdPutAsync
     *
     * Update an attribute value
     *
     * @param  int $attribute_id (required)
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsAttributesAttributeIdValuesPostRequest|null $_rest_items_attributes_attribute_id_values_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValuesIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributesAttributeIdValuesIdPutAsync(
        int $attribute_id,
        int $id,
        ?\ck\Model\RestItemsAttributesAttributeIdValuesPostRequest $_rest_items_attributes_attribute_id_values_id = null,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValuesIdPut'][0]
    ): PromiseInterface
    {
        return $this->restItemsAttributesAttributeIdValuesIdPutAsyncWithHttpInfo($attribute_id, $id, $_rest_items_attributes_attribute_id_values_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsAttributesAttributeIdValuesIdPutAsyncWithHttpInfo
     *
     * Update an attribute value
     *
     * @param  int $attribute_id (required)
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsAttributesAttributeIdValuesPostRequest|null $_rest_items_attributes_attribute_id_values_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValuesIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributesAttributeIdValuesIdPutAsyncWithHttpInfo(
        $attribute_id,
        $id,
        $_rest_items_attributes_attribute_id_values_id = null,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValuesIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\AttributeValue';
        $request = $this->restItemsAttributesAttributeIdValuesIdPutRequest($attribute_id, $id, $_rest_items_attributes_attribute_id_values_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsAttributesAttributeIdValuesIdPut'
     *
     * @param  int $attribute_id (required)
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsAttributesAttributeIdValuesPostRequest|null $_rest_items_attributes_attribute_id_values_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValuesIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsAttributesAttributeIdValuesIdPutRequest(
        $attribute_id,
        $id,
        $_rest_items_attributes_attribute_id_values_id = null,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValuesIdPut'][0]
    ): Request
    {

        // verify the required parameter 'attribute_id' is set
        if ($attribute_id === null || (is_array($attribute_id) && count($attribute_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $attribute_id when calling restItemsAttributesAttributeIdValuesIdPut'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsAttributesAttributeIdValuesIdPut'
            );
        }



        $resourcePath = '/rest/items/attributes/{attributeId}/values/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($attribute_id !== null) {
            $resourcePath = str_replace(
                '{' . 'attributeId' . '}',
                ObjectSerializer::toPathValue($attribute_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_attributes_attribute_id_values_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_attributes_attribute_id_values_id));
            } else {
                $httpBody = $_rest_items_attributes_attribute_id_values_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsAttributesAttributeIdValuesPost
     *
     * Create an attribute value
     *
     * @param  int $attribute_id attribute_id (required)
     * @param  \ck\Model\RestItemsAttributesAttributeIdValuesPostRequest|null $_rest_items_attributes_attribute_id_values _rest_items_attributes_attribute_id_values (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValuesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\AttributeValue
     */
    public function restItemsAttributesAttributeIdValuesPost(
        int $attribute_id,
        ?\ck\Model\RestItemsAttributesAttributeIdValuesPostRequest $_rest_items_attributes_attribute_id_values = null,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValuesPost'][0]
    ): \ck\Model\AttributeValue
    {
        list($response) = $this->restItemsAttributesAttributeIdValuesPostWithHttpInfo($attribute_id, $_rest_items_attributes_attribute_id_values, $contentType);
        return $response;
    }

    /**
     * Operation restItemsAttributesAttributeIdValuesPostWithHttpInfo
     *
     * Create an attribute value
     *
     * @param  int $attribute_id (required)
     * @param  \ck\Model\RestItemsAttributesAttributeIdValuesPostRequest|null $_rest_items_attributes_attribute_id_values (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValuesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\AttributeValue, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsAttributesAttributeIdValuesPostWithHttpInfo(
        int $attribute_id,
        ?\ck\Model\RestItemsAttributesAttributeIdValuesPostRequest $_rest_items_attributes_attribute_id_values = null,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValuesPost'][0]
    ): array
    {
        $request = $this->restItemsAttributesAttributeIdValuesPostRequest($attribute_id, $_rest_items_attributes_attribute_id_values, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\AttributeValue' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\AttributeValue' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\AttributeValue', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\AttributeValue';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\AttributeValue',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsAttributesAttributeIdValuesPostAsync
     *
     * Create an attribute value
     *
     * @param  int $attribute_id (required)
     * @param  \ck\Model\RestItemsAttributesAttributeIdValuesPostRequest|null $_rest_items_attributes_attribute_id_values (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValuesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributesAttributeIdValuesPostAsync(
        int $attribute_id,
        ?\ck\Model\RestItemsAttributesAttributeIdValuesPostRequest $_rest_items_attributes_attribute_id_values = null,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValuesPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsAttributesAttributeIdValuesPostAsyncWithHttpInfo($attribute_id, $_rest_items_attributes_attribute_id_values, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsAttributesAttributeIdValuesPostAsyncWithHttpInfo
     *
     * Create an attribute value
     *
     * @param  int $attribute_id (required)
     * @param  \ck\Model\RestItemsAttributesAttributeIdValuesPostRequest|null $_rest_items_attributes_attribute_id_values (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValuesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributesAttributeIdValuesPostAsyncWithHttpInfo(
        $attribute_id,
        $_rest_items_attributes_attribute_id_values = null,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValuesPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\AttributeValue';
        $request = $this->restItemsAttributesAttributeIdValuesPostRequest($attribute_id, $_rest_items_attributes_attribute_id_values, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsAttributesAttributeIdValuesPost'
     *
     * @param  int $attribute_id (required)
     * @param  \ck\Model\RestItemsAttributesAttributeIdValuesPostRequest|null $_rest_items_attributes_attribute_id_values (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesAttributeIdValuesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsAttributesAttributeIdValuesPostRequest(
        $attribute_id,
        $_rest_items_attributes_attribute_id_values = null,
        string $contentType = self::contentTypes['restItemsAttributesAttributeIdValuesPost'][0]
    ): Request
    {

        // verify the required parameter 'attribute_id' is set
        if ($attribute_id === null || (is_array($attribute_id) && count($attribute_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $attribute_id when calling restItemsAttributesAttributeIdValuesPost'
            );
        }



        $resourcePath = '/rest/items/attributes/{attributeId}/values';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($attribute_id !== null) {
            $resourcePath = str_replace(
                '{' . 'attributeId' . '}',
                ObjectSerializer::toPathValue($attribute_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_attributes_attribute_id_values)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_attributes_attribute_id_values));
            } else {
                $httpBody = $_rest_items_attributes_attribute_id_values;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsAttributesGet
     *
     * List attributes
     *
     * @param  string|null $with Includes the specified attribute information in the results. The following parameters are available: &lt;ul&gt;&lt;li&gt;names&lt;/b&gt; &#x3D; The names of the attribute&lt;/li&gt;&lt;li&gt;values&lt;/b&gt; &#x3D; The values of the attribute&lt;/li&gt;&lt;li&gt;maps&lt;/b&gt; &#x3D; The market maps of the attribute&lt;/li&gt;&lt;/ul&gt; More than one parameter should be separated by commas. (optional)
     * @param  string|null $updated_at Filter restricts the list of results to items updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestItemsAttributesGet200Response
     */
    public function restItemsAttributesGet(
        ?string $with = null,
        ?string $updated_at = null,
        string $contentType = self::contentTypes['restItemsAttributesGet'][0]
    ): \ck\Model\RestItemsAttributesGet200Response
    {
        list($response) = $this->restItemsAttributesGetWithHttpInfo($with, $updated_at, $contentType);
        return $response;
    }

    /**
     * Operation restItemsAttributesGetWithHttpInfo
     *
     * List attributes
     *
     * @param  string|null $with Includes the specified attribute information in the results. The following parameters are available: &lt;ul&gt;&lt;li&gt;names&lt;/b&gt; &#x3D; The names of the attribute&lt;/li&gt;&lt;li&gt;values&lt;/b&gt; &#x3D; The values of the attribute&lt;/li&gt;&lt;li&gt;maps&lt;/b&gt; &#x3D; The market maps of the attribute&lt;/li&gt;&lt;/ul&gt; More than one parameter should be separated by commas. (optional)
     * @param  string|null $updated_at Filter restricts the list of results to items updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestItemsAttributesGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsAttributesGetWithHttpInfo(
        ?string $with = null,
        ?string $updated_at = null,
        string $contentType = self::contentTypes['restItemsAttributesGet'][0]
    ): array
    {
        $request = $this->restItemsAttributesGetRequest($with, $updated_at, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestItemsAttributesGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestItemsAttributesGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestItemsAttributesGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestItemsAttributesGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestItemsAttributesGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsAttributesGetAsync
     *
     * List attributes
     *
     * @param  string|null $with Includes the specified attribute information in the results. The following parameters are available: &lt;ul&gt;&lt;li&gt;names&lt;/b&gt; &#x3D; The names of the attribute&lt;/li&gt;&lt;li&gt;values&lt;/b&gt; &#x3D; The values of the attribute&lt;/li&gt;&lt;li&gt;maps&lt;/b&gt; &#x3D; The market maps of the attribute&lt;/li&gt;&lt;/ul&gt; More than one parameter should be separated by commas. (optional)
     * @param  string|null $updated_at Filter restricts the list of results to items updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributesGetAsync(
        ?string $with = null,
        ?string $updated_at = null,
        string $contentType = self::contentTypes['restItemsAttributesGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsAttributesGetAsyncWithHttpInfo($with, $updated_at, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsAttributesGetAsyncWithHttpInfo
     *
     * List attributes
     *
     * @param  string|null $with Includes the specified attribute information in the results. The following parameters are available: &lt;ul&gt;&lt;li&gt;names&lt;/b&gt; &#x3D; The names of the attribute&lt;/li&gt;&lt;li&gt;values&lt;/b&gt; &#x3D; The values of the attribute&lt;/li&gt;&lt;li&gt;maps&lt;/b&gt; &#x3D; The market maps of the attribute&lt;/li&gt;&lt;/ul&gt; More than one parameter should be separated by commas. (optional)
     * @param  string|null $updated_at Filter restricts the list of results to items updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributesGetAsyncWithHttpInfo(
        $with = null,
        $updated_at = null,
        string $contentType = self::contentTypes['restItemsAttributesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestItemsAttributesGet200Response';
        $request = $this->restItemsAttributesGetRequest($with, $updated_at, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsAttributesGet'
     *
     * @param  string|null $with Includes the specified attribute information in the results. The following parameters are available: &lt;ul&gt;&lt;li&gt;names&lt;/b&gt; &#x3D; The names of the attribute&lt;/li&gt;&lt;li&gt;values&lt;/b&gt; &#x3D; The values of the attribute&lt;/li&gt;&lt;li&gt;maps&lt;/b&gt; &#x3D; The market maps of the attribute&lt;/li&gt;&lt;/ul&gt; More than one parameter should be separated by commas. (optional)
     * @param  string|null $updated_at Filter restricts the list of results to items updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsAttributesGetRequest(
        $with = null,
        $updated_at = null,
        string $contentType = self::contentTypes['restItemsAttributesGet'][0]
    ): Request
    {




        $resourcePath = '/rest/items/attributes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_at,
            'updatedAt', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsAttributesIdDelete
     *
     * Delete an attribute
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsAttributesIdDelete(
        int $id,
        string $contentType = self::contentTypes['restItemsAttributesIdDelete'][0]
    ): object
    {
        list($response) = $this->restItemsAttributesIdDeleteWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsAttributesIdDeleteWithHttpInfo
     *
     * Delete an attribute
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsAttributesIdDeleteWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restItemsAttributesIdDelete'][0]
    ): array
    {
        $request = $this->restItemsAttributesIdDeleteRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsAttributesIdDeleteAsync
     *
     * Delete an attribute
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributesIdDeleteAsync(
        int $id,
        string $contentType = self::contentTypes['restItemsAttributesIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemsAttributesIdDeleteAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsAttributesIdDeleteAsyncWithHttpInfo
     *
     * Delete an attribute
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributesIdDeleteAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restItemsAttributesIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsAttributesIdDeleteRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsAttributesIdDelete'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsAttributesIdDeleteRequest(
        $id,
        string $contentType = self::contentTypes['restItemsAttributesIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsAttributesIdDelete'
            );
        }


        $resourcePath = '/rest/items/attributes/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsAttributesIdGet
     *
     * Get an attribute
     *
     * @param  int $id id (required)
     * @param  string|null $with Includes the specified attribute information in the results. The following parameters are available: &lt;ul&gt;&lt;li&gt;names&lt;/b&gt; &#x3D; The names of the attribute&lt;/li&gt;&lt;li&gt;values&lt;/b&gt; &#x3D; The values of the attribute&lt;/li&gt;&lt;li&gt;maps&lt;/b&gt; &#x3D; The market maps of the attribute&lt;/li&gt;&lt;/ul&gt; More than one parameter should be separated by commas. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Attribute
     */
    public function restItemsAttributesIdGet(
        int $id,
        ?string $with = null,
        string $contentType = self::contentTypes['restItemsAttributesIdGet'][0]
    ): \ck\Model\Attribute
    {
        list($response) = $this->restItemsAttributesIdGetWithHttpInfo($id, $with, $contentType);
        return $response;
    }

    /**
     * Operation restItemsAttributesIdGetWithHttpInfo
     *
     * Get an attribute
     *
     * @param  int $id (required)
     * @param  string|null $with Includes the specified attribute information in the results. The following parameters are available: &lt;ul&gt;&lt;li&gt;names&lt;/b&gt; &#x3D; The names of the attribute&lt;/li&gt;&lt;li&gt;values&lt;/b&gt; &#x3D; The values of the attribute&lt;/li&gt;&lt;li&gt;maps&lt;/b&gt; &#x3D; The market maps of the attribute&lt;/li&gt;&lt;/ul&gt; More than one parameter should be separated by commas. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Attribute, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsAttributesIdGetWithHttpInfo(
        int $id,
        ?string $with = null,
        string $contentType = self::contentTypes['restItemsAttributesIdGet'][0]
    ): array
    {
        $request = $this->restItemsAttributesIdGetRequest($id, $with, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Attribute' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Attribute' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Attribute', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Attribute';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Attribute',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsAttributesIdGetAsync
     *
     * Get an attribute
     *
     * @param  int $id (required)
     * @param  string|null $with Includes the specified attribute information in the results. The following parameters are available: &lt;ul&gt;&lt;li&gt;names&lt;/b&gt; &#x3D; The names of the attribute&lt;/li&gt;&lt;li&gt;values&lt;/b&gt; &#x3D; The values of the attribute&lt;/li&gt;&lt;li&gt;maps&lt;/b&gt; &#x3D; The market maps of the attribute&lt;/li&gt;&lt;/ul&gt; More than one parameter should be separated by commas. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributesIdGetAsync(
        int $id,
        ?string $with = null,
        string $contentType = self::contentTypes['restItemsAttributesIdGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsAttributesIdGetAsyncWithHttpInfo($id, $with, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsAttributesIdGetAsyncWithHttpInfo
     *
     * Get an attribute
     *
     * @param  int $id (required)
     * @param  string|null $with Includes the specified attribute information in the results. The following parameters are available: &lt;ul&gt;&lt;li&gt;names&lt;/b&gt; &#x3D; The names of the attribute&lt;/li&gt;&lt;li&gt;values&lt;/b&gt; &#x3D; The values of the attribute&lt;/li&gt;&lt;li&gt;maps&lt;/b&gt; &#x3D; The market maps of the attribute&lt;/li&gt;&lt;/ul&gt; More than one parameter should be separated by commas. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributesIdGetAsyncWithHttpInfo(
        $id,
        $with = null,
        string $contentType = self::contentTypes['restItemsAttributesIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Attribute';
        $request = $this->restItemsAttributesIdGetRequest($id, $with, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsAttributesIdGet'
     *
     * @param  int $id (required)
     * @param  string|null $with Includes the specified attribute information in the results. The following parameters are available: &lt;ul&gt;&lt;li&gt;names&lt;/b&gt; &#x3D; The names of the attribute&lt;/li&gt;&lt;li&gt;values&lt;/b&gt; &#x3D; The values of the attribute&lt;/li&gt;&lt;li&gt;maps&lt;/b&gt; &#x3D; The market maps of the attribute&lt;/li&gt;&lt;/ul&gt; More than one parameter should be separated by commas. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsAttributesIdGetRequest(
        $id,
        $with = null,
        string $contentType = self::contentTypes['restItemsAttributesIdGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsAttributesIdGet'
            );
        }



        $resourcePath = '/rest/items/attributes/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsAttributesIdPut
     *
     * Update an attribute
     *
     * @param  int $id id (required)
     * @param  \ck\Model\RestItemsAttributesPostRequest|null $_rest_items_attributes_id _rest_items_attributes_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Attribute
     */
    public function restItemsAttributesIdPut(
        int $id,
        ?\ck\Model\RestItemsAttributesPostRequest $_rest_items_attributes_id = null,
        string $contentType = self::contentTypes['restItemsAttributesIdPut'][0]
    ): \ck\Model\Attribute
    {
        list($response) = $this->restItemsAttributesIdPutWithHttpInfo($id, $_rest_items_attributes_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsAttributesIdPutWithHttpInfo
     *
     * Update an attribute
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsAttributesPostRequest|null $_rest_items_attributes_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Attribute, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsAttributesIdPutWithHttpInfo(
        int $id,
        ?\ck\Model\RestItemsAttributesPostRequest $_rest_items_attributes_id = null,
        string $contentType = self::contentTypes['restItemsAttributesIdPut'][0]
    ): array
    {
        $request = $this->restItemsAttributesIdPutRequest($id, $_rest_items_attributes_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Attribute' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Attribute' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Attribute', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Attribute';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Attribute',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsAttributesIdPutAsync
     *
     * Update an attribute
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsAttributesPostRequest|null $_rest_items_attributes_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributesIdPutAsync(
        int $id,
        ?\ck\Model\RestItemsAttributesPostRequest $_rest_items_attributes_id = null,
        string $contentType = self::contentTypes['restItemsAttributesIdPut'][0]
    ): PromiseInterface
    {
        return $this->restItemsAttributesIdPutAsyncWithHttpInfo($id, $_rest_items_attributes_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsAttributesIdPutAsyncWithHttpInfo
     *
     * Update an attribute
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsAttributesPostRequest|null $_rest_items_attributes_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributesIdPutAsyncWithHttpInfo(
        $id,
        $_rest_items_attributes_id = null,
        string $contentType = self::contentTypes['restItemsAttributesIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Attribute';
        $request = $this->restItemsAttributesIdPutRequest($id, $_rest_items_attributes_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsAttributesIdPut'
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsAttributesPostRequest|null $_rest_items_attributes_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsAttributesIdPutRequest(
        $id,
        $_rest_items_attributes_id = null,
        string $contentType = self::contentTypes['restItemsAttributesIdPut'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsAttributesIdPut'
            );
        }



        $resourcePath = '/rest/items/attributes/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_attributes_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_attributes_id));
            } else {
                $httpBody = $_rest_items_attributes_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsAttributesMapsGet
     *
     * Lists all attribute maps.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesMapsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response
     */
    public function restItemsAttributesMapsGet(
        string $contentType = self::contentTypes['restItemsAttributesMapsGet'][0]
    ): \ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response
    {
        list($response) = $this->restItemsAttributesMapsGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restItemsAttributesMapsGetWithHttpInfo
     *
     * Lists all attribute maps.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesMapsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsAttributesMapsGetWithHttpInfo(
        string $contentType = self::contentTypes['restItemsAttributesMapsGet'][0]
    ): array
    {
        $request = $this->restItemsAttributesMapsGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsAttributesMapsGetAsync
     *
     * Lists all attribute maps.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesMapsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributesMapsGetAsync(
        string $contentType = self::contentTypes['restItemsAttributesMapsGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsAttributesMapsGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsAttributesMapsGetAsyncWithHttpInfo
     *
     * Lists all attribute maps.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesMapsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributesMapsGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restItemsAttributesMapsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response';
        $request = $this->restItemsAttributesMapsGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsAttributesMapsGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesMapsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsAttributesMapsGetRequest(
        string $contentType = self::contentTypes['restItemsAttributesMapsGet'][0]
    ): Request
    {


        $resourcePath = '/rest/items/attributes/maps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsAttributesMarketsMapsPost
     *
     * Creates a new attribute map.
     *
     * @param  \ck\Model\RestItemsAttributesMarketsMapsPostRequest|null $_rest_items_attributes_markets_maps _rest_items_attributes_markets_maps (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesMarketsMapsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\AttributeMap
     */
    public function restItemsAttributesMarketsMapsPost(
        ?\ck\Model\RestItemsAttributesMarketsMapsPostRequest $_rest_items_attributes_markets_maps = null,
        string $contentType = self::contentTypes['restItemsAttributesMarketsMapsPost'][0]
    ): \ck\Model\AttributeMap
    {
        list($response) = $this->restItemsAttributesMarketsMapsPostWithHttpInfo($_rest_items_attributes_markets_maps, $contentType);
        return $response;
    }

    /**
     * Operation restItemsAttributesMarketsMapsPostWithHttpInfo
     *
     * Creates a new attribute map.
     *
     * @param  \ck\Model\RestItemsAttributesMarketsMapsPostRequest|null $_rest_items_attributes_markets_maps (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesMarketsMapsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\AttributeMap, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsAttributesMarketsMapsPostWithHttpInfo(
        ?\ck\Model\RestItemsAttributesMarketsMapsPostRequest $_rest_items_attributes_markets_maps = null,
        string $contentType = self::contentTypes['restItemsAttributesMarketsMapsPost'][0]
    ): array
    {
        $request = $this->restItemsAttributesMarketsMapsPostRequest($_rest_items_attributes_markets_maps, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\AttributeMap' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\AttributeMap' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\AttributeMap', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\AttributeMap';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\AttributeMap',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsAttributesMarketsMapsPostAsync
     *
     * Creates a new attribute map.
     *
     * @param  \ck\Model\RestItemsAttributesMarketsMapsPostRequest|null $_rest_items_attributes_markets_maps (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesMarketsMapsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributesMarketsMapsPostAsync(
        ?\ck\Model\RestItemsAttributesMarketsMapsPostRequest $_rest_items_attributes_markets_maps = null,
        string $contentType = self::contentTypes['restItemsAttributesMarketsMapsPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsAttributesMarketsMapsPostAsyncWithHttpInfo($_rest_items_attributes_markets_maps, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsAttributesMarketsMapsPostAsyncWithHttpInfo
     *
     * Creates a new attribute map.
     *
     * @param  \ck\Model\RestItemsAttributesMarketsMapsPostRequest|null $_rest_items_attributes_markets_maps (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesMarketsMapsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributesMarketsMapsPostAsyncWithHttpInfo(
        $_rest_items_attributes_markets_maps = null,
        string $contentType = self::contentTypes['restItemsAttributesMarketsMapsPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\AttributeMap';
        $request = $this->restItemsAttributesMarketsMapsPostRequest($_rest_items_attributes_markets_maps, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsAttributesMarketsMapsPost'
     *
     * @param  \ck\Model\RestItemsAttributesMarketsMapsPostRequest|null $_rest_items_attributes_markets_maps (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesMarketsMapsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsAttributesMarketsMapsPostRequest(
        $_rest_items_attributes_markets_maps = null,
        string $contentType = self::contentTypes['restItemsAttributesMarketsMapsPost'][0]
    ): Request
    {



        $resourcePath = '/rest/items/attributes/markets/maps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_attributes_markets_maps)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_attributes_markets_maps));
            } else {
                $httpBody = $_rest_items_attributes_markets_maps;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsAttributesPost
     *
     * Create an attribute
     *
     * @param  \ck\Model\RestItemsAttributesPostRequest|null $_rest_items_attributes _rest_items_attributes (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Attribute
     */
    public function restItemsAttributesPost(
        ?\ck\Model\RestItemsAttributesPostRequest $_rest_items_attributes = null,
        string $contentType = self::contentTypes['restItemsAttributesPost'][0]
    ): \ck\Model\Attribute
    {
        list($response) = $this->restItemsAttributesPostWithHttpInfo($_rest_items_attributes, $contentType);
        return $response;
    }

    /**
     * Operation restItemsAttributesPostWithHttpInfo
     *
     * Create an attribute
     *
     * @param  \ck\Model\RestItemsAttributesPostRequest|null $_rest_items_attributes (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Attribute, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsAttributesPostWithHttpInfo(
        ?\ck\Model\RestItemsAttributesPostRequest $_rest_items_attributes = null,
        string $contentType = self::contentTypes['restItemsAttributesPost'][0]
    ): array
    {
        $request = $this->restItemsAttributesPostRequest($_rest_items_attributes, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Attribute' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Attribute' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Attribute', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Attribute';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Attribute',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsAttributesPostAsync
     *
     * Create an attribute
     *
     * @param  \ck\Model\RestItemsAttributesPostRequest|null $_rest_items_attributes (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributesPostAsync(
        ?\ck\Model\RestItemsAttributesPostRequest $_rest_items_attributes = null,
        string $contentType = self::contentTypes['restItemsAttributesPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsAttributesPostAsyncWithHttpInfo($_rest_items_attributes, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsAttributesPostAsyncWithHttpInfo
     *
     * Create an attribute
     *
     * @param  \ck\Model\RestItemsAttributesPostRequest|null $_rest_items_attributes (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributesPostAsyncWithHttpInfo(
        $_rest_items_attributes = null,
        string $contentType = self::contentTypes['restItemsAttributesPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Attribute';
        $request = $this->restItemsAttributesPostRequest($_rest_items_attributes, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsAttributesPost'
     *
     * @param  \ck\Model\RestItemsAttributesPostRequest|null $_rest_items_attributes (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsAttributesPostRequest(
        $_rest_items_attributes = null,
        string $contentType = self::contentTypes['restItemsAttributesPost'][0]
    ): Request
    {



        $resourcePath = '/rest/items/attributes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_attributes)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_attributes));
            } else {
                $httpBody = $_rest_items_attributes;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsAttributesValuesMapsGet
     *
     * Lists all attribute value maps.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesValuesMapsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response
     */
    public function restItemsAttributesValuesMapsGet(
        string $contentType = self::contentTypes['restItemsAttributesValuesMapsGet'][0]
    ): \ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response
    {
        list($response) = $this->restItemsAttributesValuesMapsGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restItemsAttributesValuesMapsGetWithHttpInfo
     *
     * Lists all attribute value maps.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesValuesMapsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsAttributesValuesMapsGetWithHttpInfo(
        string $contentType = self::contentTypes['restItemsAttributesValuesMapsGet'][0]
    ): array
    {
        $request = $this->restItemsAttributesValuesMapsGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsAttributesValuesMapsGetAsync
     *
     * Lists all attribute value maps.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesValuesMapsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributesValuesMapsGetAsync(
        string $contentType = self::contentTypes['restItemsAttributesValuesMapsGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsAttributesValuesMapsGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsAttributesValuesMapsGetAsyncWithHttpInfo
     *
     * Lists all attribute value maps.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesValuesMapsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributesValuesMapsGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restItemsAttributesValuesMapsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response';
        $request = $this->restItemsAttributesValuesMapsGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsAttributesValuesMapsGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesValuesMapsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsAttributesValuesMapsGetRequest(
        string $contentType = self::contentTypes['restItemsAttributesValuesMapsGet'][0]
    ): Request
    {


        $resourcePath = '/rest/items/attributes/values/maps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsAttributesValuesMarketsMapsPost
     *
     * Creates a new attribute value map.
     *
     * @param  \ck\Model\RestItemsAttributesValuesMarketsMapsPostRequest|null $_rest_items_attributes_values_markets_maps _rest_items_attributes_values_markets_maps (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesValuesMarketsMapsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\AttributeValueMap
     */
    public function restItemsAttributesValuesMarketsMapsPost(
        ?\ck\Model\RestItemsAttributesValuesMarketsMapsPostRequest $_rest_items_attributes_values_markets_maps = null,
        string $contentType = self::contentTypes['restItemsAttributesValuesMarketsMapsPost'][0]
    ): \ck\Model\AttributeValueMap
    {
        list($response) = $this->restItemsAttributesValuesMarketsMapsPostWithHttpInfo($_rest_items_attributes_values_markets_maps, $contentType);
        return $response;
    }

    /**
     * Operation restItemsAttributesValuesMarketsMapsPostWithHttpInfo
     *
     * Creates a new attribute value map.
     *
     * @param  \ck\Model\RestItemsAttributesValuesMarketsMapsPostRequest|null $_rest_items_attributes_values_markets_maps (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesValuesMarketsMapsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\AttributeValueMap, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsAttributesValuesMarketsMapsPostWithHttpInfo(
        ?\ck\Model\RestItemsAttributesValuesMarketsMapsPostRequest $_rest_items_attributes_values_markets_maps = null,
        string $contentType = self::contentTypes['restItemsAttributesValuesMarketsMapsPost'][0]
    ): array
    {
        $request = $this->restItemsAttributesValuesMarketsMapsPostRequest($_rest_items_attributes_values_markets_maps, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\AttributeValueMap' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\AttributeValueMap' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\AttributeValueMap', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\AttributeValueMap';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\AttributeValueMap',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsAttributesValuesMarketsMapsPostAsync
     *
     * Creates a new attribute value map.
     *
     * @param  \ck\Model\RestItemsAttributesValuesMarketsMapsPostRequest|null $_rest_items_attributes_values_markets_maps (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesValuesMarketsMapsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributesValuesMarketsMapsPostAsync(
        ?\ck\Model\RestItemsAttributesValuesMarketsMapsPostRequest $_rest_items_attributes_values_markets_maps = null,
        string $contentType = self::contentTypes['restItemsAttributesValuesMarketsMapsPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsAttributesValuesMarketsMapsPostAsyncWithHttpInfo($_rest_items_attributes_values_markets_maps, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsAttributesValuesMarketsMapsPostAsyncWithHttpInfo
     *
     * Creates a new attribute value map.
     *
     * @param  \ck\Model\RestItemsAttributesValuesMarketsMapsPostRequest|null $_rest_items_attributes_values_markets_maps (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesValuesMarketsMapsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsAttributesValuesMarketsMapsPostAsyncWithHttpInfo(
        $_rest_items_attributes_values_markets_maps = null,
        string $contentType = self::contentTypes['restItemsAttributesValuesMarketsMapsPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\AttributeValueMap';
        $request = $this->restItemsAttributesValuesMarketsMapsPostRequest($_rest_items_attributes_values_markets_maps, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsAttributesValuesMarketsMapsPost'
     *
     * @param  \ck\Model\RestItemsAttributesValuesMarketsMapsPostRequest|null $_rest_items_attributes_values_markets_maps (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsAttributesValuesMarketsMapsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsAttributesValuesMarketsMapsPostRequest(
        $_rest_items_attributes_values_markets_maps = null,
        string $contentType = self::contentTypes['restItemsAttributesValuesMarketsMapsPost'][0]
    ): Request
    {



        $resourcePath = '/rest/items/attributes/values/markets/maps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_attributes_values_markets_maps)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_attributes_values_markets_maps));
            } else {
                $httpBody = $_rest_items_attributes_values_markets_maps;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsBarcodesBarcodeIdDelete
     *
     * Delete a barcode
     *
     * @param  int $barcode_id barcode_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsBarcodesBarcodeIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsBarcodesBarcodeIdDelete(
        int $barcode_id,
        string $contentType = self::contentTypes['restItemsBarcodesBarcodeIdDelete'][0]
    ): object
    {
        list($response) = $this->restItemsBarcodesBarcodeIdDeleteWithHttpInfo($barcode_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsBarcodesBarcodeIdDeleteWithHttpInfo
     *
     * Delete a barcode
     *
     * @param  int $barcode_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsBarcodesBarcodeIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsBarcodesBarcodeIdDeleteWithHttpInfo(
        int $barcode_id,
        string $contentType = self::contentTypes['restItemsBarcodesBarcodeIdDelete'][0]
    ): array
    {
        $request = $this->restItemsBarcodesBarcodeIdDeleteRequest($barcode_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsBarcodesBarcodeIdDeleteAsync
     *
     * Delete a barcode
     *
     * @param  int $barcode_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsBarcodesBarcodeIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsBarcodesBarcodeIdDeleteAsync(
        int $barcode_id,
        string $contentType = self::contentTypes['restItemsBarcodesBarcodeIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemsBarcodesBarcodeIdDeleteAsyncWithHttpInfo($barcode_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsBarcodesBarcodeIdDeleteAsyncWithHttpInfo
     *
     * Delete a barcode
     *
     * @param  int $barcode_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsBarcodesBarcodeIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsBarcodesBarcodeIdDeleteAsyncWithHttpInfo(
        $barcode_id,
        string $contentType = self::contentTypes['restItemsBarcodesBarcodeIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsBarcodesBarcodeIdDeleteRequest($barcode_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsBarcodesBarcodeIdDelete'
     *
     * @param  int $barcode_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsBarcodesBarcodeIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsBarcodesBarcodeIdDeleteRequest(
        $barcode_id,
        string $contentType = self::contentTypes['restItemsBarcodesBarcodeIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'barcode_id' is set
        if ($barcode_id === null || (is_array($barcode_id) && count($barcode_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $barcode_id when calling restItemsBarcodesBarcodeIdDelete'
            );
        }


        $resourcePath = '/rest/items/barcodes/{barcodeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($barcode_id !== null) {
            $resourcePath = str_replace(
                '{' . 'barcodeId' . '}',
                ObjectSerializer::toPathValue($barcode_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsBarcodesBarcodeIdGet
     *
     * Get a barcode
     *
     * @param  int $barcode_id barcode_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsBarcodesBarcodeIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Barcode
     */
    public function restItemsBarcodesBarcodeIdGet(
        int $barcode_id,
        string $contentType = self::contentTypes['restItemsBarcodesBarcodeIdGet'][0]
    ): \ck\Model\Barcode
    {
        list($response) = $this->restItemsBarcodesBarcodeIdGetWithHttpInfo($barcode_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsBarcodesBarcodeIdGetWithHttpInfo
     *
     * Get a barcode
     *
     * @param  int $barcode_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsBarcodesBarcodeIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Barcode, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsBarcodesBarcodeIdGetWithHttpInfo(
        int $barcode_id,
        string $contentType = self::contentTypes['restItemsBarcodesBarcodeIdGet'][0]
    ): array
    {
        $request = $this->restItemsBarcodesBarcodeIdGetRequest($barcode_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Barcode' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Barcode' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Barcode', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Barcode';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Barcode',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsBarcodesBarcodeIdGetAsync
     *
     * Get a barcode
     *
     * @param  int $barcode_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsBarcodesBarcodeIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsBarcodesBarcodeIdGetAsync(
        int $barcode_id,
        string $contentType = self::contentTypes['restItemsBarcodesBarcodeIdGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsBarcodesBarcodeIdGetAsyncWithHttpInfo($barcode_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsBarcodesBarcodeIdGetAsyncWithHttpInfo
     *
     * Get a barcode
     *
     * @param  int $barcode_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsBarcodesBarcodeIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsBarcodesBarcodeIdGetAsyncWithHttpInfo(
        $barcode_id,
        string $contentType = self::contentTypes['restItemsBarcodesBarcodeIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Barcode';
        $request = $this->restItemsBarcodesBarcodeIdGetRequest($barcode_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsBarcodesBarcodeIdGet'
     *
     * @param  int $barcode_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsBarcodesBarcodeIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsBarcodesBarcodeIdGetRequest(
        $barcode_id,
        string $contentType = self::contentTypes['restItemsBarcodesBarcodeIdGet'][0]
    ): Request
    {

        // verify the required parameter 'barcode_id' is set
        if ($barcode_id === null || (is_array($barcode_id) && count($barcode_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $barcode_id when calling restItemsBarcodesBarcodeIdGet'
            );
        }


        $resourcePath = '/rest/items/barcodes/{barcodeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($barcode_id !== null) {
            $resourcePath = str_replace(
                '{' . 'barcodeId' . '}',
                ObjectSerializer::toPathValue($barcode_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsBarcodesBarcodeIdPut
     *
     * Update a barcode
     *
     * @param  int $barcode_id barcode_id (required)
     * @param  \ck\Model\RestItemsBarcodesPostRequest|null $_rest_items_barcodes_barcode_id _rest_items_barcodes_barcode_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsBarcodesBarcodeIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Barcode
     */
    public function restItemsBarcodesBarcodeIdPut(
        int $barcode_id,
        ?\ck\Model\RestItemsBarcodesPostRequest $_rest_items_barcodes_barcode_id = null,
        string $contentType = self::contentTypes['restItemsBarcodesBarcodeIdPut'][0]
    ): \ck\Model\Barcode
    {
        list($response) = $this->restItemsBarcodesBarcodeIdPutWithHttpInfo($barcode_id, $_rest_items_barcodes_barcode_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsBarcodesBarcodeIdPutWithHttpInfo
     *
     * Update a barcode
     *
     * @param  int $barcode_id (required)
     * @param  \ck\Model\RestItemsBarcodesPostRequest|null $_rest_items_barcodes_barcode_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsBarcodesBarcodeIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Barcode, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsBarcodesBarcodeIdPutWithHttpInfo(
        int $barcode_id,
        ?\ck\Model\RestItemsBarcodesPostRequest $_rest_items_barcodes_barcode_id = null,
        string $contentType = self::contentTypes['restItemsBarcodesBarcodeIdPut'][0]
    ): array
    {
        $request = $this->restItemsBarcodesBarcodeIdPutRequest($barcode_id, $_rest_items_barcodes_barcode_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Barcode' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Barcode' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Barcode', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Barcode';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Barcode',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsBarcodesBarcodeIdPutAsync
     *
     * Update a barcode
     *
     * @param  int $barcode_id (required)
     * @param  \ck\Model\RestItemsBarcodesPostRequest|null $_rest_items_barcodes_barcode_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsBarcodesBarcodeIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsBarcodesBarcodeIdPutAsync(
        int $barcode_id,
        ?\ck\Model\RestItemsBarcodesPostRequest $_rest_items_barcodes_barcode_id = null,
        string $contentType = self::contentTypes['restItemsBarcodesBarcodeIdPut'][0]
    ): PromiseInterface
    {
        return $this->restItemsBarcodesBarcodeIdPutAsyncWithHttpInfo($barcode_id, $_rest_items_barcodes_barcode_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsBarcodesBarcodeIdPutAsyncWithHttpInfo
     *
     * Update a barcode
     *
     * @param  int $barcode_id (required)
     * @param  \ck\Model\RestItemsBarcodesPostRequest|null $_rest_items_barcodes_barcode_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsBarcodesBarcodeIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsBarcodesBarcodeIdPutAsyncWithHttpInfo(
        $barcode_id,
        $_rest_items_barcodes_barcode_id = null,
        string $contentType = self::contentTypes['restItemsBarcodesBarcodeIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Barcode';
        $request = $this->restItemsBarcodesBarcodeIdPutRequest($barcode_id, $_rest_items_barcodes_barcode_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsBarcodesBarcodeIdPut'
     *
     * @param  int $barcode_id (required)
     * @param  \ck\Model\RestItemsBarcodesPostRequest|null $_rest_items_barcodes_barcode_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsBarcodesBarcodeIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsBarcodesBarcodeIdPutRequest(
        $barcode_id,
        $_rest_items_barcodes_barcode_id = null,
        string $contentType = self::contentTypes['restItemsBarcodesBarcodeIdPut'][0]
    ): Request
    {

        // verify the required parameter 'barcode_id' is set
        if ($barcode_id === null || (is_array($barcode_id) && count($barcode_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $barcode_id when calling restItemsBarcodesBarcodeIdPut'
            );
        }



        $resourcePath = '/rest/items/barcodes/{barcodeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($barcode_id !== null) {
            $resourcePath = str_replace(
                '{' . 'barcodeId' . '}',
                ObjectSerializer::toPathValue($barcode_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_barcodes_barcode_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_barcodes_barcode_id));
            } else {
                $httpBody = $_rest_items_barcodes_barcode_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsBarcodesBarcodeIdReferrerPost
     *
     * Activate a referrer
     *
     * @param  int $barcode_id barcode_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsBarcodesBarcodeIdReferrerPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\BarcodeLinkReferrer
     */
    public function restItemsBarcodesBarcodeIdReferrerPost(
        int $barcode_id,
        string $contentType = self::contentTypes['restItemsBarcodesBarcodeIdReferrerPost'][0]
    ): \ck\Model\BarcodeLinkReferrer
    {
        list($response) = $this->restItemsBarcodesBarcodeIdReferrerPostWithHttpInfo($barcode_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsBarcodesBarcodeIdReferrerPostWithHttpInfo
     *
     * Activate a referrer
     *
     * @param  int $barcode_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsBarcodesBarcodeIdReferrerPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\BarcodeLinkReferrer, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsBarcodesBarcodeIdReferrerPostWithHttpInfo(
        int $barcode_id,
        string $contentType = self::contentTypes['restItemsBarcodesBarcodeIdReferrerPost'][0]
    ): array
    {
        $request = $this->restItemsBarcodesBarcodeIdReferrerPostRequest($barcode_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\BarcodeLinkReferrer' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\BarcodeLinkReferrer' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\BarcodeLinkReferrer', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\BarcodeLinkReferrer';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\BarcodeLinkReferrer',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsBarcodesBarcodeIdReferrerPostAsync
     *
     * Activate a referrer
     *
     * @param  int $barcode_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsBarcodesBarcodeIdReferrerPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsBarcodesBarcodeIdReferrerPostAsync(
        int $barcode_id,
        string $contentType = self::contentTypes['restItemsBarcodesBarcodeIdReferrerPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsBarcodesBarcodeIdReferrerPostAsyncWithHttpInfo($barcode_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsBarcodesBarcodeIdReferrerPostAsyncWithHttpInfo
     *
     * Activate a referrer
     *
     * @param  int $barcode_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsBarcodesBarcodeIdReferrerPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsBarcodesBarcodeIdReferrerPostAsyncWithHttpInfo(
        $barcode_id,
        string $contentType = self::contentTypes['restItemsBarcodesBarcodeIdReferrerPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\BarcodeLinkReferrer';
        $request = $this->restItemsBarcodesBarcodeIdReferrerPostRequest($barcode_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsBarcodesBarcodeIdReferrerPost'
     *
     * @param  int $barcode_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsBarcodesBarcodeIdReferrerPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsBarcodesBarcodeIdReferrerPostRequest(
        $barcode_id,
        string $contentType = self::contentTypes['restItemsBarcodesBarcodeIdReferrerPost'][0]
    ): Request
    {

        // verify the required parameter 'barcode_id' is set
        if ($barcode_id === null || (is_array($barcode_id) && count($barcode_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $barcode_id when calling restItemsBarcodesBarcodeIdReferrerPost'
            );
        }


        $resourcePath = '/rest/items/barcodes/{barcodeId}/referrer';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($barcode_id !== null) {
            $resourcePath = str_replace(
                '{' . 'barcodeId' . '}',
                ObjectSerializer::toPathValue($barcode_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsBarcodesBarcodeIdReferrerReferrerIdDelete
     *
     * Deactivate a referrer
     *
     * @param  int $barcode_id barcode_id (required)
     * @param  int $referrer_id referrer_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsBarcodesBarcodeIdReferrerReferrerIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsBarcodesBarcodeIdReferrerReferrerIdDelete(
        int $barcode_id,
        int $referrer_id,
        string $contentType = self::contentTypes['restItemsBarcodesBarcodeIdReferrerReferrerIdDelete'][0]
    ): object
    {
        list($response) = $this->restItemsBarcodesBarcodeIdReferrerReferrerIdDeleteWithHttpInfo($barcode_id, $referrer_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsBarcodesBarcodeIdReferrerReferrerIdDeleteWithHttpInfo
     *
     * Deactivate a referrer
     *
     * @param  int $barcode_id (required)
     * @param  int $referrer_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsBarcodesBarcodeIdReferrerReferrerIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsBarcodesBarcodeIdReferrerReferrerIdDeleteWithHttpInfo(
        int $barcode_id,
        int $referrer_id,
        string $contentType = self::contentTypes['restItemsBarcodesBarcodeIdReferrerReferrerIdDelete'][0]
    ): array
    {
        $request = $this->restItemsBarcodesBarcodeIdReferrerReferrerIdDeleteRequest($barcode_id, $referrer_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsBarcodesBarcodeIdReferrerReferrerIdDeleteAsync
     *
     * Deactivate a referrer
     *
     * @param  int $barcode_id (required)
     * @param  int $referrer_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsBarcodesBarcodeIdReferrerReferrerIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsBarcodesBarcodeIdReferrerReferrerIdDeleteAsync(
        int $barcode_id,
        int $referrer_id,
        string $contentType = self::contentTypes['restItemsBarcodesBarcodeIdReferrerReferrerIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemsBarcodesBarcodeIdReferrerReferrerIdDeleteAsyncWithHttpInfo($barcode_id, $referrer_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsBarcodesBarcodeIdReferrerReferrerIdDeleteAsyncWithHttpInfo
     *
     * Deactivate a referrer
     *
     * @param  int $barcode_id (required)
     * @param  int $referrer_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsBarcodesBarcodeIdReferrerReferrerIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsBarcodesBarcodeIdReferrerReferrerIdDeleteAsyncWithHttpInfo(
        $barcode_id,
        $referrer_id,
        string $contentType = self::contentTypes['restItemsBarcodesBarcodeIdReferrerReferrerIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsBarcodesBarcodeIdReferrerReferrerIdDeleteRequest($barcode_id, $referrer_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsBarcodesBarcodeIdReferrerReferrerIdDelete'
     *
     * @param  int $barcode_id (required)
     * @param  int $referrer_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsBarcodesBarcodeIdReferrerReferrerIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsBarcodesBarcodeIdReferrerReferrerIdDeleteRequest(
        $barcode_id,
        $referrer_id,
        string $contentType = self::contentTypes['restItemsBarcodesBarcodeIdReferrerReferrerIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'barcode_id' is set
        if ($barcode_id === null || (is_array($barcode_id) && count($barcode_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $barcode_id when calling restItemsBarcodesBarcodeIdReferrerReferrerIdDelete'
            );
        }

        // verify the required parameter 'referrer_id' is set
        if ($referrer_id === null || (is_array($referrer_id) && count($referrer_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $referrer_id when calling restItemsBarcodesBarcodeIdReferrerReferrerIdDelete'
            );
        }


        $resourcePath = '/rest/items/barcodes/{barcodeId}/referrer/{referrerId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($barcode_id !== null) {
            $resourcePath = str_replace(
                '{' . 'barcodeId' . '}',
                ObjectSerializer::toPathValue($barcode_id),
                $resourcePath
            );
        }
        // path params
        if ($referrer_id !== null) {
            $resourcePath = str_replace(
                '{' . 'referrerId' . '}',
                ObjectSerializer::toPathValue($referrer_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsBarcodesGet
     *
     * List barcodes
     *
     * @param  string|null $updated_at Filter restricts the list of results to items updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsBarcodesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestItemsBarcodesGet200Response
     */
    public function restItemsBarcodesGet(
        ?string $updated_at = null,
        string $contentType = self::contentTypes['restItemsBarcodesGet'][0]
    ): \ck\Model\RestItemsBarcodesGet200Response
    {
        list($response) = $this->restItemsBarcodesGetWithHttpInfo($updated_at, $contentType);
        return $response;
    }

    /**
     * Operation restItemsBarcodesGetWithHttpInfo
     *
     * List barcodes
     *
     * @param  string|null $updated_at Filter restricts the list of results to items updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsBarcodesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestItemsBarcodesGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsBarcodesGetWithHttpInfo(
        ?string $updated_at = null,
        string $contentType = self::contentTypes['restItemsBarcodesGet'][0]
    ): array
    {
        $request = $this->restItemsBarcodesGetRequest($updated_at, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestItemsBarcodesGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestItemsBarcodesGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestItemsBarcodesGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestItemsBarcodesGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestItemsBarcodesGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsBarcodesGetAsync
     *
     * List barcodes
     *
     * @param  string|null $updated_at Filter restricts the list of results to items updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsBarcodesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsBarcodesGetAsync(
        ?string $updated_at = null,
        string $contentType = self::contentTypes['restItemsBarcodesGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsBarcodesGetAsyncWithHttpInfo($updated_at, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsBarcodesGetAsyncWithHttpInfo
     *
     * List barcodes
     *
     * @param  string|null $updated_at Filter restricts the list of results to items updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsBarcodesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsBarcodesGetAsyncWithHttpInfo(
        $updated_at = null,
        string $contentType = self::contentTypes['restItemsBarcodesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestItemsBarcodesGet200Response';
        $request = $this->restItemsBarcodesGetRequest($updated_at, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsBarcodesGet'
     *
     * @param  string|null $updated_at Filter restricts the list of results to items updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsBarcodesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsBarcodesGetRequest(
        $updated_at = null,
        string $contentType = self::contentTypes['restItemsBarcodesGet'][0]
    ): Request
    {



        $resourcePath = '/rest/items/barcodes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_at,
            'updatedAt', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsBarcodesPost
     *
     * Create a barcode
     *
     * @param  \ck\Model\RestItemsBarcodesPostRequest|null $_rest_items_barcodes _rest_items_barcodes (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsBarcodesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Barcode
     */
    public function restItemsBarcodesPost(
        ?\ck\Model\RestItemsBarcodesPostRequest $_rest_items_barcodes = null,
        string $contentType = self::contentTypes['restItemsBarcodesPost'][0]
    ): \ck\Model\Barcode
    {
        list($response) = $this->restItemsBarcodesPostWithHttpInfo($_rest_items_barcodes, $contentType);
        return $response;
    }

    /**
     * Operation restItemsBarcodesPostWithHttpInfo
     *
     * Create a barcode
     *
     * @param  \ck\Model\RestItemsBarcodesPostRequest|null $_rest_items_barcodes (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsBarcodesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Barcode, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsBarcodesPostWithHttpInfo(
        ?\ck\Model\RestItemsBarcodesPostRequest $_rest_items_barcodes = null,
        string $contentType = self::contentTypes['restItemsBarcodesPost'][0]
    ): array
    {
        $request = $this->restItemsBarcodesPostRequest($_rest_items_barcodes, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Barcode' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Barcode' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Barcode', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Barcode';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Barcode',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsBarcodesPostAsync
     *
     * Create a barcode
     *
     * @param  \ck\Model\RestItemsBarcodesPostRequest|null $_rest_items_barcodes (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsBarcodesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsBarcodesPostAsync(
        ?\ck\Model\RestItemsBarcodesPostRequest $_rest_items_barcodes = null,
        string $contentType = self::contentTypes['restItemsBarcodesPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsBarcodesPostAsyncWithHttpInfo($_rest_items_barcodes, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsBarcodesPostAsyncWithHttpInfo
     *
     * Create a barcode
     *
     * @param  \ck\Model\RestItemsBarcodesPostRequest|null $_rest_items_barcodes (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsBarcodesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsBarcodesPostAsyncWithHttpInfo(
        $_rest_items_barcodes = null,
        string $contentType = self::contentTypes['restItemsBarcodesPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Barcode';
        $request = $this->restItemsBarcodesPostRequest($_rest_items_barcodes, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsBarcodesPost'
     *
     * @param  \ck\Model\RestItemsBarcodesPostRequest|null $_rest_items_barcodes (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsBarcodesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsBarcodesPostRequest(
        $_rest_items_barcodes = null,
        string $contentType = self::contentTypes['restItemsBarcodesPost'][0]
    ): Request
    {



        $resourcePath = '/rest/items/barcodes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_barcodes)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_barcodes));
            } else {
                $httpBody = $_rest_items_barcodes;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsBarcodesReferrerReferrerIdGet
     *
     * List barcodes by referrer
     *
     * @param  int $referrer_id referrer_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsBarcodesReferrerReferrerIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Barcode[]
     */
    public function restItemsBarcodesReferrerReferrerIdGet(
        int $referrer_id,
        string $contentType = self::contentTypes['restItemsBarcodesReferrerReferrerIdGet'][0]
    ): array
    {
        list($response) = $this->restItemsBarcodesReferrerReferrerIdGetWithHttpInfo($referrer_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsBarcodesReferrerReferrerIdGetWithHttpInfo
     *
     * List barcodes by referrer
     *
     * @param  int $referrer_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsBarcodesReferrerReferrerIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Barcode[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsBarcodesReferrerReferrerIdGetWithHttpInfo(
        int $referrer_id,
        string $contentType = self::contentTypes['restItemsBarcodesReferrerReferrerIdGet'][0]
    ): array
    {
        $request = $this->restItemsBarcodesReferrerReferrerIdGetRequest($referrer_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Barcode[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Barcode[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Barcode[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Barcode[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Barcode[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsBarcodesReferrerReferrerIdGetAsync
     *
     * List barcodes by referrer
     *
     * @param  int $referrer_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsBarcodesReferrerReferrerIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsBarcodesReferrerReferrerIdGetAsync(
        int $referrer_id,
        string $contentType = self::contentTypes['restItemsBarcodesReferrerReferrerIdGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsBarcodesReferrerReferrerIdGetAsyncWithHttpInfo($referrer_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsBarcodesReferrerReferrerIdGetAsyncWithHttpInfo
     *
     * List barcodes by referrer
     *
     * @param  int $referrer_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsBarcodesReferrerReferrerIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsBarcodesReferrerReferrerIdGetAsyncWithHttpInfo(
        $referrer_id,
        string $contentType = self::contentTypes['restItemsBarcodesReferrerReferrerIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Barcode[]';
        $request = $this->restItemsBarcodesReferrerReferrerIdGetRequest($referrer_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsBarcodesReferrerReferrerIdGet'
     *
     * @param  int $referrer_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsBarcodesReferrerReferrerIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsBarcodesReferrerReferrerIdGetRequest(
        $referrer_id,
        string $contentType = self::contentTypes['restItemsBarcodesReferrerReferrerIdGet'][0]
    ): Request
    {

        // verify the required parameter 'referrer_id' is set
        if ($referrer_id === null || (is_array($referrer_id) && count($referrer_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $referrer_id when calling restItemsBarcodesReferrerReferrerIdGet'
            );
        }


        $resourcePath = '/rest/items/barcodes/referrer/{referrerId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($referrer_id !== null) {
            $resourcePath = str_replace(
                '{' . 'referrerId' . '}',
                ObjectSerializer::toPathValue($referrer_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsBarcodesTypeTypeGet
     *
     * List barcodes by type
     *
     * @param  int $type type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsBarcodesTypeTypeGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Barcode[]
     */
    public function restItemsBarcodesTypeTypeGet(
        int $type,
        string $contentType = self::contentTypes['restItemsBarcodesTypeTypeGet'][0]
    ): array
    {
        list($response) = $this->restItemsBarcodesTypeTypeGetWithHttpInfo($type, $contentType);
        return $response;
    }

    /**
     * Operation restItemsBarcodesTypeTypeGetWithHttpInfo
     *
     * List barcodes by type
     *
     * @param  int $type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsBarcodesTypeTypeGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Barcode[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsBarcodesTypeTypeGetWithHttpInfo(
        int $type,
        string $contentType = self::contentTypes['restItemsBarcodesTypeTypeGet'][0]
    ): array
    {
        $request = $this->restItemsBarcodesTypeTypeGetRequest($type, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Barcode[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Barcode[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Barcode[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Barcode[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Barcode[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsBarcodesTypeTypeGetAsync
     *
     * List barcodes by type
     *
     * @param  int $type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsBarcodesTypeTypeGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsBarcodesTypeTypeGetAsync(
        int $type,
        string $contentType = self::contentTypes['restItemsBarcodesTypeTypeGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsBarcodesTypeTypeGetAsyncWithHttpInfo($type, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsBarcodesTypeTypeGetAsyncWithHttpInfo
     *
     * List barcodes by type
     *
     * @param  int $type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsBarcodesTypeTypeGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsBarcodesTypeTypeGetAsyncWithHttpInfo(
        $type,
        string $contentType = self::contentTypes['restItemsBarcodesTypeTypeGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Barcode[]';
        $request = $this->restItemsBarcodesTypeTypeGetRequest($type, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsBarcodesTypeTypeGet'
     *
     * @param  int $type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsBarcodesTypeTypeGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsBarcodesTypeTypeGetRequest(
        $type,
        string $contentType = self::contentTypes['restItemsBarcodesTypeTypeGet'][0]
    ): Request
    {

        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $type when calling restItemsBarcodesTypeTypeGet'
            );
        }


        $resourcePath = '/rest/items/barcodes/type/{type}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($type !== null) {
            $resourcePath = str_replace(
                '{' . 'type' . '}',
                ObjectSerializer::toPathValue($type),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsGet
     *
     * Search item
     *
     * @param  string|null $with Includes the specified variation information in the results. The following parameters are available: itemProperties, itemCrossSelling, variations, itemImages, itemShippingProfiles, ebayTitles (optional)
     * @param  string|null $lang The &lt;a href&#x3D;&#39;https://developers.plentymarkets.com/rest-doc/introduction#countries&#39; target&#x3D;&#39;_blank&#39;&gt;language&lt;/a&gt; of the variation information. (optional)
     * @param  int|null $page Limits the results to a specific page. The page number must be specified. (optional)
     * @param  int|null $items_per_page Limits the number of results listed per page to a specific number. The number of variations to be listed per page must be specified. (optional)
     * @param  string|null $name Filter restricts the list of results to items with the specified item name. An item name must be specified. (optional)
     * @param  string|null $manufacturer_id Filter restricts the list of results to items with the specified manufacturerId. (optional)
     * @param  int|null $id Filter restricts the list of results to items with the specified ID. More than one ID should be separated by commas. (optional)
     * @param  int|null $flag_one Filter restricts the list of results to items with the specified flagOne. (optional)
     * @param  int|null $flag_two Filter restricts the list of results to items with the specified flagTwo. (optional)
     * @param  string|null $updated_between Filter restricts the list of results to items updated during the specified period. The end date (to) is optional. If no end date is specified, items updated between the start date (from) and the present will be listed. The dates can be specified as unix timestamps or in the ISO 8601 date format. Start date and optional end date are separated by a comma. For example, .../items?updatedBetween&#x3D;1451606400,1456790400 will list items updated between 2016-01-01 and 2016-03-01. .../items?updatedBetween&#x3D;1451606400 will list items updated since 2016-01-01. The PHP function strtotime is also supported. (optional)
     * @param  string|null $variation_updated_between Filter restricts the list of results to items with variations that were updated during the specified period. The end date (to) is optional. If no end date is specified, items with variations updated between the start date (from) and the present will be listed. The dates can be specified as unix timestamps or in the ISO 8601 date format. Start date and optional end date are separated by a comma. For example, .../items?updatedBetween&#x3D;1451606400,1456790400 will list items with variations that were updated between 2016-01-01 and 2016-03-01. .../items?updatedBetween&#x3D;1451606400 will list items with variations that were updated since 2016-01-01. The PHP function strtotime is also supported. (optional)
     * @param  string|null $variation_related_updated_between Filter restricts the list of results to items with variations for which related information was updated during the specified period. Related information is defined as information linked to the variation, i.e. barcodes, categories, images, markets, clients (stores), prices, suppliers, warehouses and the default category. See variationUpdatedBetween for supported formats. (optional)
     * @param  string|null $or Filters can be defined in this param to link them via OR instead of AND. The syntax looks like the following: or&#x3D;(updatedBetween&#x3D;1573050718&amp;varitionUpdatedBetween&#x3D;1573050718). Everything in the brackets is written in the normal URL-Syntax. The or-param can be used multiple times if it is used like this: or[]&#x3D;(...)&amp;or[]&#x3D;(...) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestItemsGet200Response
     */
    public function restItemsGet(
        ?string $with = null,
        ?string $lang = null,
        ?int $page = null,
        ?int $items_per_page = null,
        ?string $name = null,
        ?string $manufacturer_id = null,
        ?int $id = null,
        ?int $flag_one = null,
        ?int $flag_two = null,
        ?string $updated_between = null,
        ?string $variation_updated_between = null,
        ?string $variation_related_updated_between = null,
        ?string $or = null,
        string $contentType = self::contentTypes['restItemsGet'][0]
    ): \ck\Model\RestItemsGet200Response
    {
        list($response) = $this->restItemsGetWithHttpInfo($with, $lang, $page, $items_per_page, $name, $manufacturer_id, $id, $flag_one, $flag_two, $updated_between, $variation_updated_between, $variation_related_updated_between, $or, $contentType);
        return $response;
    }

    /**
     * Operation restItemsGetWithHttpInfo
     *
     * Search item
     *
     * @param  string|null $with Includes the specified variation information in the results. The following parameters are available: itemProperties, itemCrossSelling, variations, itemImages, itemShippingProfiles, ebayTitles (optional)
     * @param  string|null $lang The &lt;a href&#x3D;&#39;https://developers.plentymarkets.com/rest-doc/introduction#countries&#39; target&#x3D;&#39;_blank&#39;&gt;language&lt;/a&gt; of the variation information. (optional)
     * @param  int|null $page Limits the results to a specific page. The page number must be specified. (optional)
     * @param  int|null $items_per_page Limits the number of results listed per page to a specific number. The number of variations to be listed per page must be specified. (optional)
     * @param  string|null $name Filter restricts the list of results to items with the specified item name. An item name must be specified. (optional)
     * @param  string|null $manufacturer_id Filter restricts the list of results to items with the specified manufacturerId. (optional)
     * @param  int|null $id Filter restricts the list of results to items with the specified ID. More than one ID should be separated by commas. (optional)
     * @param  int|null $flag_one Filter restricts the list of results to items with the specified flagOne. (optional)
     * @param  int|null $flag_two Filter restricts the list of results to items with the specified flagTwo. (optional)
     * @param  string|null $updated_between Filter restricts the list of results to items updated during the specified period. The end date (to) is optional. If no end date is specified, items updated between the start date (from) and the present will be listed. The dates can be specified as unix timestamps or in the ISO 8601 date format. Start date and optional end date are separated by a comma. For example, .../items?updatedBetween&#x3D;1451606400,1456790400 will list items updated between 2016-01-01 and 2016-03-01. .../items?updatedBetween&#x3D;1451606400 will list items updated since 2016-01-01. The PHP function strtotime is also supported. (optional)
     * @param  string|null $variation_updated_between Filter restricts the list of results to items with variations that were updated during the specified period. The end date (to) is optional. If no end date is specified, items with variations updated between the start date (from) and the present will be listed. The dates can be specified as unix timestamps or in the ISO 8601 date format. Start date and optional end date are separated by a comma. For example, .../items?updatedBetween&#x3D;1451606400,1456790400 will list items with variations that were updated between 2016-01-01 and 2016-03-01. .../items?updatedBetween&#x3D;1451606400 will list items with variations that were updated since 2016-01-01. The PHP function strtotime is also supported. (optional)
     * @param  string|null $variation_related_updated_between Filter restricts the list of results to items with variations for which related information was updated during the specified period. Related information is defined as information linked to the variation, i.e. barcodes, categories, images, markets, clients (stores), prices, suppliers, warehouses and the default category. See variationUpdatedBetween for supported formats. (optional)
     * @param  string|null $or Filters can be defined in this param to link them via OR instead of AND. The syntax looks like the following: or&#x3D;(updatedBetween&#x3D;1573050718&amp;varitionUpdatedBetween&#x3D;1573050718). Everything in the brackets is written in the normal URL-Syntax. The or-param can be used multiple times if it is used like this: or[]&#x3D;(...)&amp;or[]&#x3D;(...) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestItemsGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsGetWithHttpInfo(
        ?string $with = null,
        ?string $lang = null,
        ?int $page = null,
        ?int $items_per_page = null,
        ?string $name = null,
        ?string $manufacturer_id = null,
        ?int $id = null,
        ?int $flag_one = null,
        ?int $flag_two = null,
        ?string $updated_between = null,
        ?string $variation_updated_between = null,
        ?string $variation_related_updated_between = null,
        ?string $or = null,
        string $contentType = self::contentTypes['restItemsGet'][0]
    ): array
    {
        $request = $this->restItemsGetRequest($with, $lang, $page, $items_per_page, $name, $manufacturer_id, $id, $flag_one, $flag_two, $updated_between, $variation_updated_between, $variation_related_updated_between, $or, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestItemsGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestItemsGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestItemsGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestItemsGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestItemsGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsGetAsync
     *
     * Search item
     *
     * @param  string|null $with Includes the specified variation information in the results. The following parameters are available: itemProperties, itemCrossSelling, variations, itemImages, itemShippingProfiles, ebayTitles (optional)
     * @param  string|null $lang The &lt;a href&#x3D;&#39;https://developers.plentymarkets.com/rest-doc/introduction#countries&#39; target&#x3D;&#39;_blank&#39;&gt;language&lt;/a&gt; of the variation information. (optional)
     * @param  int|null $page Limits the results to a specific page. The page number must be specified. (optional)
     * @param  int|null $items_per_page Limits the number of results listed per page to a specific number. The number of variations to be listed per page must be specified. (optional)
     * @param  string|null $name Filter restricts the list of results to items with the specified item name. An item name must be specified. (optional)
     * @param  string|null $manufacturer_id Filter restricts the list of results to items with the specified manufacturerId. (optional)
     * @param  int|null $id Filter restricts the list of results to items with the specified ID. More than one ID should be separated by commas. (optional)
     * @param  int|null $flag_one Filter restricts the list of results to items with the specified flagOne. (optional)
     * @param  int|null $flag_two Filter restricts the list of results to items with the specified flagTwo. (optional)
     * @param  string|null $updated_between Filter restricts the list of results to items updated during the specified period. The end date (to) is optional. If no end date is specified, items updated between the start date (from) and the present will be listed. The dates can be specified as unix timestamps or in the ISO 8601 date format. Start date and optional end date are separated by a comma. For example, .../items?updatedBetween&#x3D;1451606400,1456790400 will list items updated between 2016-01-01 and 2016-03-01. .../items?updatedBetween&#x3D;1451606400 will list items updated since 2016-01-01. The PHP function strtotime is also supported. (optional)
     * @param  string|null $variation_updated_between Filter restricts the list of results to items with variations that were updated during the specified period. The end date (to) is optional. If no end date is specified, items with variations updated between the start date (from) and the present will be listed. The dates can be specified as unix timestamps or in the ISO 8601 date format. Start date and optional end date are separated by a comma. For example, .../items?updatedBetween&#x3D;1451606400,1456790400 will list items with variations that were updated between 2016-01-01 and 2016-03-01. .../items?updatedBetween&#x3D;1451606400 will list items with variations that were updated since 2016-01-01. The PHP function strtotime is also supported. (optional)
     * @param  string|null $variation_related_updated_between Filter restricts the list of results to items with variations for which related information was updated during the specified period. Related information is defined as information linked to the variation, i.e. barcodes, categories, images, markets, clients (stores), prices, suppliers, warehouses and the default category. See variationUpdatedBetween for supported formats. (optional)
     * @param  string|null $or Filters can be defined in this param to link them via OR instead of AND. The syntax looks like the following: or&#x3D;(updatedBetween&#x3D;1573050718&amp;varitionUpdatedBetween&#x3D;1573050718). Everything in the brackets is written in the normal URL-Syntax. The or-param can be used multiple times if it is used like this: or[]&#x3D;(...)&amp;or[]&#x3D;(...) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsGetAsync(
        ?string $with = null,
        ?string $lang = null,
        ?int $page = null,
        ?int $items_per_page = null,
        ?string $name = null,
        ?string $manufacturer_id = null,
        ?int $id = null,
        ?int $flag_one = null,
        ?int $flag_two = null,
        ?string $updated_between = null,
        ?string $variation_updated_between = null,
        ?string $variation_related_updated_between = null,
        ?string $or = null,
        string $contentType = self::contentTypes['restItemsGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsGetAsyncWithHttpInfo($with, $lang, $page, $items_per_page, $name, $manufacturer_id, $id, $flag_one, $flag_two, $updated_between, $variation_updated_between, $variation_related_updated_between, $or, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsGetAsyncWithHttpInfo
     *
     * Search item
     *
     * @param  string|null $with Includes the specified variation information in the results. The following parameters are available: itemProperties, itemCrossSelling, variations, itemImages, itemShippingProfiles, ebayTitles (optional)
     * @param  string|null $lang The &lt;a href&#x3D;&#39;https://developers.plentymarkets.com/rest-doc/introduction#countries&#39; target&#x3D;&#39;_blank&#39;&gt;language&lt;/a&gt; of the variation information. (optional)
     * @param  int|null $page Limits the results to a specific page. The page number must be specified. (optional)
     * @param  int|null $items_per_page Limits the number of results listed per page to a specific number. The number of variations to be listed per page must be specified. (optional)
     * @param  string|null $name Filter restricts the list of results to items with the specified item name. An item name must be specified. (optional)
     * @param  string|null $manufacturer_id Filter restricts the list of results to items with the specified manufacturerId. (optional)
     * @param  int|null $id Filter restricts the list of results to items with the specified ID. More than one ID should be separated by commas. (optional)
     * @param  int|null $flag_one Filter restricts the list of results to items with the specified flagOne. (optional)
     * @param  int|null $flag_two Filter restricts the list of results to items with the specified flagTwo. (optional)
     * @param  string|null $updated_between Filter restricts the list of results to items updated during the specified period. The end date (to) is optional. If no end date is specified, items updated between the start date (from) and the present will be listed. The dates can be specified as unix timestamps or in the ISO 8601 date format. Start date and optional end date are separated by a comma. For example, .../items?updatedBetween&#x3D;1451606400,1456790400 will list items updated between 2016-01-01 and 2016-03-01. .../items?updatedBetween&#x3D;1451606400 will list items updated since 2016-01-01. The PHP function strtotime is also supported. (optional)
     * @param  string|null $variation_updated_between Filter restricts the list of results to items with variations that were updated during the specified period. The end date (to) is optional. If no end date is specified, items with variations updated between the start date (from) and the present will be listed. The dates can be specified as unix timestamps or in the ISO 8601 date format. Start date and optional end date are separated by a comma. For example, .../items?updatedBetween&#x3D;1451606400,1456790400 will list items with variations that were updated between 2016-01-01 and 2016-03-01. .../items?updatedBetween&#x3D;1451606400 will list items with variations that were updated since 2016-01-01. The PHP function strtotime is also supported. (optional)
     * @param  string|null $variation_related_updated_between Filter restricts the list of results to items with variations for which related information was updated during the specified period. Related information is defined as information linked to the variation, i.e. barcodes, categories, images, markets, clients (stores), prices, suppliers, warehouses and the default category. See variationUpdatedBetween for supported formats. (optional)
     * @param  string|null $or Filters can be defined in this param to link them via OR instead of AND. The syntax looks like the following: or&#x3D;(updatedBetween&#x3D;1573050718&amp;varitionUpdatedBetween&#x3D;1573050718). Everything in the brackets is written in the normal URL-Syntax. The or-param can be used multiple times if it is used like this: or[]&#x3D;(...)&amp;or[]&#x3D;(...) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsGetAsyncWithHttpInfo(
        $with = null,
        $lang = null,
        $page = null,
        $items_per_page = null,
        $name = null,
        $manufacturer_id = null,
        $id = null,
        $flag_one = null,
        $flag_two = null,
        $updated_between = null,
        $variation_updated_between = null,
        $variation_related_updated_between = null,
        $or = null,
        string $contentType = self::contentTypes['restItemsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestItemsGet200Response';
        $request = $this->restItemsGetRequest($with, $lang, $page, $items_per_page, $name, $manufacturer_id, $id, $flag_one, $flag_two, $updated_between, $variation_updated_between, $variation_related_updated_between, $or, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsGet'
     *
     * @param  string|null $with Includes the specified variation information in the results. The following parameters are available: itemProperties, itemCrossSelling, variations, itemImages, itemShippingProfiles, ebayTitles (optional)
     * @param  string|null $lang The &lt;a href&#x3D;&#39;https://developers.plentymarkets.com/rest-doc/introduction#countries&#39; target&#x3D;&#39;_blank&#39;&gt;language&lt;/a&gt; of the variation information. (optional)
     * @param  int|null $page Limits the results to a specific page. The page number must be specified. (optional)
     * @param  int|null $items_per_page Limits the number of results listed per page to a specific number. The number of variations to be listed per page must be specified. (optional)
     * @param  string|null $name Filter restricts the list of results to items with the specified item name. An item name must be specified. (optional)
     * @param  string|null $manufacturer_id Filter restricts the list of results to items with the specified manufacturerId. (optional)
     * @param  int|null $id Filter restricts the list of results to items with the specified ID. More than one ID should be separated by commas. (optional)
     * @param  int|null $flag_one Filter restricts the list of results to items with the specified flagOne. (optional)
     * @param  int|null $flag_two Filter restricts the list of results to items with the specified flagTwo. (optional)
     * @param  string|null $updated_between Filter restricts the list of results to items updated during the specified period. The end date (to) is optional. If no end date is specified, items updated between the start date (from) and the present will be listed. The dates can be specified as unix timestamps or in the ISO 8601 date format. Start date and optional end date are separated by a comma. For example, .../items?updatedBetween&#x3D;1451606400,1456790400 will list items updated between 2016-01-01 and 2016-03-01. .../items?updatedBetween&#x3D;1451606400 will list items updated since 2016-01-01. The PHP function strtotime is also supported. (optional)
     * @param  string|null $variation_updated_between Filter restricts the list of results to items with variations that were updated during the specified period. The end date (to) is optional. If no end date is specified, items with variations updated between the start date (from) and the present will be listed. The dates can be specified as unix timestamps or in the ISO 8601 date format. Start date and optional end date are separated by a comma. For example, .../items?updatedBetween&#x3D;1451606400,1456790400 will list items with variations that were updated between 2016-01-01 and 2016-03-01. .../items?updatedBetween&#x3D;1451606400 will list items with variations that were updated since 2016-01-01. The PHP function strtotime is also supported. (optional)
     * @param  string|null $variation_related_updated_between Filter restricts the list of results to items with variations for which related information was updated during the specified period. Related information is defined as information linked to the variation, i.e. barcodes, categories, images, markets, clients (stores), prices, suppliers, warehouses and the default category. See variationUpdatedBetween for supported formats. (optional)
     * @param  string|null $or Filters can be defined in this param to link them via OR instead of AND. The syntax looks like the following: or&#x3D;(updatedBetween&#x3D;1573050718&amp;varitionUpdatedBetween&#x3D;1573050718). Everything in the brackets is written in the normal URL-Syntax. The or-param can be used multiple times if it is used like this: or[]&#x3D;(...)&amp;or[]&#x3D;(...) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsGetRequest(
        $with = null,
        $lang = null,
        $page = null,
        $items_per_page = null,
        $name = null,
        $manufacturer_id = null,
        $id = null,
        $flag_one = null,
        $flag_two = null,
        $updated_between = null,
        $variation_updated_between = null,
        $variation_related_updated_between = null,
        $or = null,
        string $contentType = self::contentTypes['restItemsGet'][0]
    ): Request
    {















        $resourcePath = '/rest/items';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $lang,
            'lang', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $items_per_page,
            'itemsPerPage', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $manufacturer_id,
            'manufacturerId', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $flag_one,
            'flagOne', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $flag_two,
            'flagTwo', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_between,
            'updatedBetween', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $variation_updated_between,
            'variationUpdatedBetween', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $variation_related_updated_between,
            'variationRelatedUpdatedBetween', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $or,
            'or', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdImagesAttributeValueMarketsGet
     *
     * List attribute value image link
     *
     * @param  int $id id (required)
     * @param  int|null $image_id The unique ID of the image (optional)
     * @param  int|null $item_id The unique ID of the item (optional)
     * @param  int|null $value_id The unique ID of the attribute value (optional)
     * @param  int|null $attribute_id The unique ID of the attribute (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesAttributeValueMarketsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsIdImagesAttributeValueMarketsGet(
        int $id,
        ?int $image_id = null,
        ?int $item_id = null,
        ?int $value_id = null,
        ?int $attribute_id = null,
        string $contentType = self::contentTypes['restItemsIdImagesAttributeValueMarketsGet'][0]
    ): object
    {
        list($response) = $this->restItemsIdImagesAttributeValueMarketsGetWithHttpInfo($id, $image_id, $item_id, $value_id, $attribute_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdImagesAttributeValueMarketsGetWithHttpInfo
     *
     * List attribute value image link
     *
     * @param  int $id (required)
     * @param  int|null $image_id The unique ID of the image (optional)
     * @param  int|null $item_id The unique ID of the item (optional)
     * @param  int|null $value_id The unique ID of the attribute value (optional)
     * @param  int|null $attribute_id The unique ID of the attribute (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesAttributeValueMarketsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdImagesAttributeValueMarketsGetWithHttpInfo(
        int $id,
        ?int $image_id = null,
        ?int $item_id = null,
        ?int $value_id = null,
        ?int $attribute_id = null,
        string $contentType = self::contentTypes['restItemsIdImagesAttributeValueMarketsGet'][0]
    ): array
    {
        $request = $this->restItemsIdImagesAttributeValueMarketsGetRequest($id, $image_id, $item_id, $value_id, $attribute_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdImagesAttributeValueMarketsGetAsync
     *
     * List attribute value image link
     *
     * @param  int $id (required)
     * @param  int|null $image_id The unique ID of the image (optional)
     * @param  int|null $item_id The unique ID of the item (optional)
     * @param  int|null $value_id The unique ID of the attribute value (optional)
     * @param  int|null $attribute_id The unique ID of the attribute (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesAttributeValueMarketsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdImagesAttributeValueMarketsGetAsync(
        int $id,
        ?int $image_id = null,
        ?int $item_id = null,
        ?int $value_id = null,
        ?int $attribute_id = null,
        string $contentType = self::contentTypes['restItemsIdImagesAttributeValueMarketsGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdImagesAttributeValueMarketsGetAsyncWithHttpInfo($id, $image_id, $item_id, $value_id, $attribute_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdImagesAttributeValueMarketsGetAsyncWithHttpInfo
     *
     * List attribute value image link
     *
     * @param  int $id (required)
     * @param  int|null $image_id The unique ID of the image (optional)
     * @param  int|null $item_id The unique ID of the item (optional)
     * @param  int|null $value_id The unique ID of the attribute value (optional)
     * @param  int|null $attribute_id The unique ID of the attribute (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesAttributeValueMarketsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdImagesAttributeValueMarketsGetAsyncWithHttpInfo(
        $id,
        $image_id = null,
        $item_id = null,
        $value_id = null,
        $attribute_id = null,
        string $contentType = self::contentTypes['restItemsIdImagesAttributeValueMarketsGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsIdImagesAttributeValueMarketsGetRequest($id, $image_id, $item_id, $value_id, $attribute_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdImagesAttributeValueMarketsGet'
     *
     * @param  int $id (required)
     * @param  int|null $image_id The unique ID of the image (optional)
     * @param  int|null $item_id The unique ID of the item (optional)
     * @param  int|null $value_id The unique ID of the attribute value (optional)
     * @param  int|null $attribute_id The unique ID of the attribute (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesAttributeValueMarketsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdImagesAttributeValueMarketsGetRequest(
        $id,
        $image_id = null,
        $item_id = null,
        $value_id = null,
        $attribute_id = null,
        string $contentType = self::contentTypes['restItemsIdImagesAttributeValueMarketsGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdImagesAttributeValueMarketsGet'
            );
        }






        $resourcePath = '/rest/items/{id}/images/attribute_value_markets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $image_id,
            'imageId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $item_id,
            'itemId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $value_id,
            'valueId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $attribute_id,
            'attributeId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdImagesGet
     *
     * List images of an item
     *
     * @param  int $id id (required)
     * @param  string|null $updated_at Filter restricts the list of results to items updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ItemImage[]
     */
    public function restItemsIdImagesGet(
        int $id,
        ?string $updated_at = null,
        string $contentType = self::contentTypes['restItemsIdImagesGet'][0]
    ): array
    {
        list($response) = $this->restItemsIdImagesGetWithHttpInfo($id, $updated_at, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdImagesGetWithHttpInfo
     *
     * List images of an item
     *
     * @param  int $id (required)
     * @param  string|null $updated_at Filter restricts the list of results to items updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ItemImage[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdImagesGetWithHttpInfo(
        int $id,
        ?string $updated_at = null,
        string $contentType = self::contentTypes['restItemsIdImagesGet'][0]
    ): array
    {
        $request = $this->restItemsIdImagesGetRequest($id, $updated_at, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ItemImage[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ItemImage[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ItemImage[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ItemImage[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ItemImage[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdImagesGetAsync
     *
     * List images of an item
     *
     * @param  int $id (required)
     * @param  string|null $updated_at Filter restricts the list of results to items updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdImagesGetAsync(
        int $id,
        ?string $updated_at = null,
        string $contentType = self::contentTypes['restItemsIdImagesGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdImagesGetAsyncWithHttpInfo($id, $updated_at, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdImagesGetAsyncWithHttpInfo
     *
     * List images of an item
     *
     * @param  int $id (required)
     * @param  string|null $updated_at Filter restricts the list of results to items updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdImagesGetAsyncWithHttpInfo(
        $id,
        $updated_at = null,
        string $contentType = self::contentTypes['restItemsIdImagesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ItemImage[]';
        $request = $this->restItemsIdImagesGetRequest($id, $updated_at, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdImagesGet'
     *
     * @param  int $id (required)
     * @param  string|null $updated_at Filter restricts the list of results to items updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdImagesGetRequest(
        $id,
        $updated_at = null,
        string $contentType = self::contentTypes['restItemsIdImagesGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdImagesGet'
            );
        }



        $resourcePath = '/rest/items/{id}/images';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_at,
            'updatedAt', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdImagesImageIdAttributeValueMarketsPost
     *
     * Create an attribute value image link
     *
     * @param  int $id id (required)
     * @param  int $image_id image_id (required)
     * @param  \ck\Model\RestItemsIdImagesImageIdAttributeValueMarketsPostRequest|null $_rest_items_id_images_image_id_attribute_value_markets _rest_items_id_images_image_id_attribute_value_markets (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdAttributeValueMarketsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\AttributeValueImage
     */
    public function restItemsIdImagesImageIdAttributeValueMarketsPost(
        int $id,
        int $image_id,
        ?\ck\Model\RestItemsIdImagesImageIdAttributeValueMarketsPostRequest $_rest_items_id_images_image_id_attribute_value_markets = null,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdAttributeValueMarketsPost'][0]
    ): \ck\Model\AttributeValueImage
    {
        list($response) = $this->restItemsIdImagesImageIdAttributeValueMarketsPostWithHttpInfo($id, $image_id, $_rest_items_id_images_image_id_attribute_value_markets, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdImagesImageIdAttributeValueMarketsPostWithHttpInfo
     *
     * Create an attribute value image link
     *
     * @param  int $id (required)
     * @param  int $image_id (required)
     * @param  \ck\Model\RestItemsIdImagesImageIdAttributeValueMarketsPostRequest|null $_rest_items_id_images_image_id_attribute_value_markets (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdAttributeValueMarketsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\AttributeValueImage, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdImagesImageIdAttributeValueMarketsPostWithHttpInfo(
        int $id,
        int $image_id,
        ?\ck\Model\RestItemsIdImagesImageIdAttributeValueMarketsPostRequest $_rest_items_id_images_image_id_attribute_value_markets = null,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdAttributeValueMarketsPost'][0]
    ): array
    {
        $request = $this->restItemsIdImagesImageIdAttributeValueMarketsPostRequest($id, $image_id, $_rest_items_id_images_image_id_attribute_value_markets, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\AttributeValueImage' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\AttributeValueImage' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\AttributeValueImage', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\AttributeValueImage';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\AttributeValueImage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdImagesImageIdAttributeValueMarketsPostAsync
     *
     * Create an attribute value image link
     *
     * @param  int $id (required)
     * @param  int $image_id (required)
     * @param  \ck\Model\RestItemsIdImagesImageIdAttributeValueMarketsPostRequest|null $_rest_items_id_images_image_id_attribute_value_markets (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdAttributeValueMarketsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdImagesImageIdAttributeValueMarketsPostAsync(
        int $id,
        int $image_id,
        ?\ck\Model\RestItemsIdImagesImageIdAttributeValueMarketsPostRequest $_rest_items_id_images_image_id_attribute_value_markets = null,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdAttributeValueMarketsPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdImagesImageIdAttributeValueMarketsPostAsyncWithHttpInfo($id, $image_id, $_rest_items_id_images_image_id_attribute_value_markets, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdImagesImageIdAttributeValueMarketsPostAsyncWithHttpInfo
     *
     * Create an attribute value image link
     *
     * @param  int $id (required)
     * @param  int $image_id (required)
     * @param  \ck\Model\RestItemsIdImagesImageIdAttributeValueMarketsPostRequest|null $_rest_items_id_images_image_id_attribute_value_markets (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdAttributeValueMarketsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdImagesImageIdAttributeValueMarketsPostAsyncWithHttpInfo(
        $id,
        $image_id,
        $_rest_items_id_images_image_id_attribute_value_markets = null,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdAttributeValueMarketsPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\AttributeValueImage';
        $request = $this->restItemsIdImagesImageIdAttributeValueMarketsPostRequest($id, $image_id, $_rest_items_id_images_image_id_attribute_value_markets, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdImagesImageIdAttributeValueMarketsPost'
     *
     * @param  int $id (required)
     * @param  int $image_id (required)
     * @param  \ck\Model\RestItemsIdImagesImageIdAttributeValueMarketsPostRequest|null $_rest_items_id_images_image_id_attribute_value_markets (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdAttributeValueMarketsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdImagesImageIdAttributeValueMarketsPostRequest(
        $id,
        $image_id,
        $_rest_items_id_images_image_id_attribute_value_markets = null,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdAttributeValueMarketsPost'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdImagesImageIdAttributeValueMarketsPost'
            );
        }

        // verify the required parameter 'image_id' is set
        if ($image_id === null || (is_array($image_id) && count($image_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $image_id when calling restItemsIdImagesImageIdAttributeValueMarketsPost'
            );
        }



        $resourcePath = '/rest/items/{id}/images/{imageId}/attribute_value_markets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($image_id !== null) {
            $resourcePath = str_replace(
                '{' . 'imageId' . '}',
                ObjectSerializer::toPathValue($image_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_id_images_image_id_attribute_value_markets)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_id_images_image_id_attribute_value_markets));
            } else {
                $httpBody = $_rest_items_id_images_image_id_attribute_value_markets;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdImagesImageIdAttributeValueMarketsValueIdDelete
     *
     * Delete an attribute value image link
     *
     * @param  int $image_id The unique ID of the image (required)
     * @param  int $item_id The unique ID of the item (required)
     * @param  int $value_id The unique ID of the attribute value (required)
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdAttributeValueMarketsValueIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restItemsIdImagesImageIdAttributeValueMarketsValueIdDelete(
        int $image_id,
        int $item_id,
        int $value_id,
        int $id,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdAttributeValueMarketsValueIdDelete'][0]
    ): void
    {
        $this->restItemsIdImagesImageIdAttributeValueMarketsValueIdDeleteWithHttpInfo($image_id, $item_id, $value_id, $id, $contentType);
    }

    /**
     * Operation restItemsIdImagesImageIdAttributeValueMarketsValueIdDeleteWithHttpInfo
     *
     * Delete an attribute value image link
     *
     * @param  int $image_id The unique ID of the image (required)
     * @param  int $item_id The unique ID of the item (required)
     * @param  int $value_id The unique ID of the attribute value (required)
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdAttributeValueMarketsValueIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdImagesImageIdAttributeValueMarketsValueIdDeleteWithHttpInfo(
        int $image_id,
        int $item_id,
        int $value_id,
        int $id,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdAttributeValueMarketsValueIdDelete'][0]
    ): array
    {
        $request = $this->restItemsIdImagesImageIdAttributeValueMarketsValueIdDeleteRequest($image_id, $item_id, $value_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdImagesImageIdAttributeValueMarketsValueIdDeleteAsync
     *
     * Delete an attribute value image link
     *
     * @param  int $image_id The unique ID of the image (required)
     * @param  int $item_id The unique ID of the item (required)
     * @param  int $value_id The unique ID of the attribute value (required)
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdAttributeValueMarketsValueIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdImagesImageIdAttributeValueMarketsValueIdDeleteAsync(
        int $image_id,
        int $item_id,
        int $value_id,
        int $id,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdAttributeValueMarketsValueIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdImagesImageIdAttributeValueMarketsValueIdDeleteAsyncWithHttpInfo($image_id, $item_id, $value_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdImagesImageIdAttributeValueMarketsValueIdDeleteAsyncWithHttpInfo
     *
     * Delete an attribute value image link
     *
     * @param  int $image_id The unique ID of the image (required)
     * @param  int $item_id The unique ID of the item (required)
     * @param  int $value_id The unique ID of the attribute value (required)
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdAttributeValueMarketsValueIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdImagesImageIdAttributeValueMarketsValueIdDeleteAsyncWithHttpInfo(
        $image_id,
        $item_id,
        $value_id,
        $id,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdAttributeValueMarketsValueIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restItemsIdImagesImageIdAttributeValueMarketsValueIdDeleteRequest($image_id, $item_id, $value_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdImagesImageIdAttributeValueMarketsValueIdDelete'
     *
     * @param  int $image_id The unique ID of the image (required)
     * @param  int $item_id The unique ID of the item (required)
     * @param  int $value_id The unique ID of the attribute value (required)
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdAttributeValueMarketsValueIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdImagesImageIdAttributeValueMarketsValueIdDeleteRequest(
        $image_id,
        $item_id,
        $value_id,
        $id,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdAttributeValueMarketsValueIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'image_id' is set
        if ($image_id === null || (is_array($image_id) && count($image_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $image_id when calling restItemsIdImagesImageIdAttributeValueMarketsValueIdDelete'
            );
        }

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $item_id when calling restItemsIdImagesImageIdAttributeValueMarketsValueIdDelete'
            );
        }

        // verify the required parameter 'value_id' is set
        if ($value_id === null || (is_array($value_id) && count($value_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $value_id when calling restItemsIdImagesImageIdAttributeValueMarketsValueIdDelete'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdImagesImageIdAttributeValueMarketsValueIdDelete'
            );
        }


        $resourcePath = '/rest/items/{id}/images/{imageId}/attribute_value_markets/{valueId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $item_id,
            'itemId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);


        // path params
        if ($image_id !== null) {
            $resourcePath = str_replace(
                '{' . 'imageId' . '}',
                ObjectSerializer::toPathValue($image_id),
                $resourcePath
            );
        }
        // path params
        if ($value_id !== null) {
            $resourcePath = str_replace(
                '{' . 'valueId' . '}',
                ObjectSerializer::toPathValue($value_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdImagesImageIdAttributeValueMarketsValueIdGet
     *
     * Get an attribute value image link
     *
     * @param  int $image_id The unique ID of the image (required)
     * @param  int $item_id The unique ID of the item (required)
     * @param  int $value_id The unique ID of the value (required)
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdAttributeValueMarketsValueIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\AttributeValueImage
     */
    public function restItemsIdImagesImageIdAttributeValueMarketsValueIdGet(
        int $image_id,
        int $item_id,
        int $value_id,
        int $id,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdAttributeValueMarketsValueIdGet'][0]
    ): \ck\Model\AttributeValueImage
    {
        list($response) = $this->restItemsIdImagesImageIdAttributeValueMarketsValueIdGetWithHttpInfo($image_id, $item_id, $value_id, $id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdImagesImageIdAttributeValueMarketsValueIdGetWithHttpInfo
     *
     * Get an attribute value image link
     *
     * @param  int $image_id The unique ID of the image (required)
     * @param  int $item_id The unique ID of the item (required)
     * @param  int $value_id The unique ID of the value (required)
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdAttributeValueMarketsValueIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\AttributeValueImage, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdImagesImageIdAttributeValueMarketsValueIdGetWithHttpInfo(
        int $image_id,
        int $item_id,
        int $value_id,
        int $id,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdAttributeValueMarketsValueIdGet'][0]
    ): array
    {
        $request = $this->restItemsIdImagesImageIdAttributeValueMarketsValueIdGetRequest($image_id, $item_id, $value_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\AttributeValueImage' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\AttributeValueImage' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\AttributeValueImage', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\AttributeValueImage';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\AttributeValueImage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdImagesImageIdAttributeValueMarketsValueIdGetAsync
     *
     * Get an attribute value image link
     *
     * @param  int $image_id The unique ID of the image (required)
     * @param  int $item_id The unique ID of the item (required)
     * @param  int $value_id The unique ID of the value (required)
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdAttributeValueMarketsValueIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdImagesImageIdAttributeValueMarketsValueIdGetAsync(
        int $image_id,
        int $item_id,
        int $value_id,
        int $id,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdAttributeValueMarketsValueIdGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdImagesImageIdAttributeValueMarketsValueIdGetAsyncWithHttpInfo($image_id, $item_id, $value_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdImagesImageIdAttributeValueMarketsValueIdGetAsyncWithHttpInfo
     *
     * Get an attribute value image link
     *
     * @param  int $image_id The unique ID of the image (required)
     * @param  int $item_id The unique ID of the item (required)
     * @param  int $value_id The unique ID of the value (required)
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdAttributeValueMarketsValueIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdImagesImageIdAttributeValueMarketsValueIdGetAsyncWithHttpInfo(
        $image_id,
        $item_id,
        $value_id,
        $id,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdAttributeValueMarketsValueIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\AttributeValueImage';
        $request = $this->restItemsIdImagesImageIdAttributeValueMarketsValueIdGetRequest($image_id, $item_id, $value_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdImagesImageIdAttributeValueMarketsValueIdGet'
     *
     * @param  int $image_id The unique ID of the image (required)
     * @param  int $item_id The unique ID of the item (required)
     * @param  int $value_id The unique ID of the value (required)
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdAttributeValueMarketsValueIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdImagesImageIdAttributeValueMarketsValueIdGetRequest(
        $image_id,
        $item_id,
        $value_id,
        $id,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdAttributeValueMarketsValueIdGet'][0]
    ): Request
    {

        // verify the required parameter 'image_id' is set
        if ($image_id === null || (is_array($image_id) && count($image_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $image_id when calling restItemsIdImagesImageIdAttributeValueMarketsValueIdGet'
            );
        }

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $item_id when calling restItemsIdImagesImageIdAttributeValueMarketsValueIdGet'
            );
        }

        // verify the required parameter 'value_id' is set
        if ($value_id === null || (is_array($value_id) && count($value_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $value_id when calling restItemsIdImagesImageIdAttributeValueMarketsValueIdGet'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdImagesImageIdAttributeValueMarketsValueIdGet'
            );
        }


        $resourcePath = '/rest/items/{id}/images/{imageId}/attribute_value_markets/{valueId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $item_id,
            'itemId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);


        // path params
        if ($image_id !== null) {
            $resourcePath = str_replace(
                '{' . 'imageId' . '}',
                ObjectSerializer::toPathValue($image_id),
                $resourcePath
            );
        }
        // path params
        if ($value_id !== null) {
            $resourcePath = str_replace(
                '{' . 'valueId' . '}',
                ObjectSerializer::toPathValue($value_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdImagesImageIdAttributeValueMarketsValueIdPut
     *
     * Update an attribute value image link
     *
     * @param  int $image_id The unique ID of the image (required)
     * @param  int $item_id The unique ID of the item (required)
     * @param  int $value_id The unique ID of the attribute value (required)
     * @param  int $attribute_id The unique ID of the attribute (required)
     * @param  int $id id (required)
     * @param  \ck\Model\RestItemsIdImagesImageIdAttributeValueMarketsPostRequest|null $_rest_items_id_images_image_id_attribute_value_markets_value_id _rest_items_id_images_image_id_attribute_value_markets_value_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdAttributeValueMarketsValueIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\AttributeValueImage
     */
    public function restItemsIdImagesImageIdAttributeValueMarketsValueIdPut(
        int $image_id,
        int $item_id,
        int $value_id,
        int $attribute_id,
        int $id,
        ?\ck\Model\RestItemsIdImagesImageIdAttributeValueMarketsPostRequest $_rest_items_id_images_image_id_attribute_value_markets_value_id = null,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdAttributeValueMarketsValueIdPut'][0]
    ): \ck\Model\AttributeValueImage
    {
        list($response) = $this->restItemsIdImagesImageIdAttributeValueMarketsValueIdPutWithHttpInfo($image_id, $item_id, $value_id, $attribute_id, $id, $_rest_items_id_images_image_id_attribute_value_markets_value_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdImagesImageIdAttributeValueMarketsValueIdPutWithHttpInfo
     *
     * Update an attribute value image link
     *
     * @param  int $image_id The unique ID of the image (required)
     * @param  int $item_id The unique ID of the item (required)
     * @param  int $value_id The unique ID of the attribute value (required)
     * @param  int $attribute_id The unique ID of the attribute (required)
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsIdImagesImageIdAttributeValueMarketsPostRequest|null $_rest_items_id_images_image_id_attribute_value_markets_value_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdAttributeValueMarketsValueIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\AttributeValueImage, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdImagesImageIdAttributeValueMarketsValueIdPutWithHttpInfo(
        int $image_id,
        int $item_id,
        int $value_id,
        int $attribute_id,
        int $id,
        ?\ck\Model\RestItemsIdImagesImageIdAttributeValueMarketsPostRequest $_rest_items_id_images_image_id_attribute_value_markets_value_id = null,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdAttributeValueMarketsValueIdPut'][0]
    ): array
    {
        $request = $this->restItemsIdImagesImageIdAttributeValueMarketsValueIdPutRequest($image_id, $item_id, $value_id, $attribute_id, $id, $_rest_items_id_images_image_id_attribute_value_markets_value_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\AttributeValueImage' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\AttributeValueImage' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\AttributeValueImage', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\AttributeValueImage';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\AttributeValueImage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdImagesImageIdAttributeValueMarketsValueIdPutAsync
     *
     * Update an attribute value image link
     *
     * @param  int $image_id The unique ID of the image (required)
     * @param  int $item_id The unique ID of the item (required)
     * @param  int $value_id The unique ID of the attribute value (required)
     * @param  int $attribute_id The unique ID of the attribute (required)
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsIdImagesImageIdAttributeValueMarketsPostRequest|null $_rest_items_id_images_image_id_attribute_value_markets_value_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdAttributeValueMarketsValueIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdImagesImageIdAttributeValueMarketsValueIdPutAsync(
        int $image_id,
        int $item_id,
        int $value_id,
        int $attribute_id,
        int $id,
        ?\ck\Model\RestItemsIdImagesImageIdAttributeValueMarketsPostRequest $_rest_items_id_images_image_id_attribute_value_markets_value_id = null,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdAttributeValueMarketsValueIdPut'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdImagesImageIdAttributeValueMarketsValueIdPutAsyncWithHttpInfo($image_id, $item_id, $value_id, $attribute_id, $id, $_rest_items_id_images_image_id_attribute_value_markets_value_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdImagesImageIdAttributeValueMarketsValueIdPutAsyncWithHttpInfo
     *
     * Update an attribute value image link
     *
     * @param  int $image_id The unique ID of the image (required)
     * @param  int $item_id The unique ID of the item (required)
     * @param  int $value_id The unique ID of the attribute value (required)
     * @param  int $attribute_id The unique ID of the attribute (required)
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsIdImagesImageIdAttributeValueMarketsPostRequest|null $_rest_items_id_images_image_id_attribute_value_markets_value_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdAttributeValueMarketsValueIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdImagesImageIdAttributeValueMarketsValueIdPutAsyncWithHttpInfo(
        $image_id,
        $item_id,
        $value_id,
        $attribute_id,
        $id,
        $_rest_items_id_images_image_id_attribute_value_markets_value_id = null,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdAttributeValueMarketsValueIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\AttributeValueImage';
        $request = $this->restItemsIdImagesImageIdAttributeValueMarketsValueIdPutRequest($image_id, $item_id, $value_id, $attribute_id, $id, $_rest_items_id_images_image_id_attribute_value_markets_value_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdImagesImageIdAttributeValueMarketsValueIdPut'
     *
     * @param  int $image_id The unique ID of the image (required)
     * @param  int $item_id The unique ID of the item (required)
     * @param  int $value_id The unique ID of the attribute value (required)
     * @param  int $attribute_id The unique ID of the attribute (required)
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsIdImagesImageIdAttributeValueMarketsPostRequest|null $_rest_items_id_images_image_id_attribute_value_markets_value_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdAttributeValueMarketsValueIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdImagesImageIdAttributeValueMarketsValueIdPutRequest(
        $image_id,
        $item_id,
        $value_id,
        $attribute_id,
        $id,
        $_rest_items_id_images_image_id_attribute_value_markets_value_id = null,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdAttributeValueMarketsValueIdPut'][0]
    ): Request
    {

        // verify the required parameter 'image_id' is set
        if ($image_id === null || (is_array($image_id) && count($image_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $image_id when calling restItemsIdImagesImageIdAttributeValueMarketsValueIdPut'
            );
        }

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $item_id when calling restItemsIdImagesImageIdAttributeValueMarketsValueIdPut'
            );
        }

        // verify the required parameter 'value_id' is set
        if ($value_id === null || (is_array($value_id) && count($value_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $value_id when calling restItemsIdImagesImageIdAttributeValueMarketsValueIdPut'
            );
        }

        // verify the required parameter 'attribute_id' is set
        if ($attribute_id === null || (is_array($attribute_id) && count($attribute_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $attribute_id when calling restItemsIdImagesImageIdAttributeValueMarketsValueIdPut'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdImagesImageIdAttributeValueMarketsValueIdPut'
            );
        }



        $resourcePath = '/rest/items/{id}/images/{imageId}/attribute_value_markets/{valueId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $item_id,
            'itemId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $attribute_id,
            'attributeId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);


        // path params
        if ($image_id !== null) {
            $resourcePath = str_replace(
                '{' . 'imageId' . '}',
                ObjectSerializer::toPathValue($image_id),
                $resourcePath
            );
        }
        // path params
        if ($value_id !== null) {
            $resourcePath = str_replace(
                '{' . 'valueId' . '}',
                ObjectSerializer::toPathValue($value_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_id_images_image_id_attribute_value_markets_value_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_id_images_image_id_attribute_value_markets_value_id));
            } else {
                $httpBody = $_rest_items_id_images_image_id_attribute_value_markets_value_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdImagesImageIdAvailabilitiesDelete
     *
     * Delete an availability
     *
     * @param  int $id id (required)
     * @param  int $image_id image_id (required)
     * @param  \ck\Model\RestItemsIdImagesImageIdAvailabilitiesPostRequest|null $_rest_items_id_images_image_id_availabilities _rest_items_id_images_image_id_availabilities (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdAvailabilitiesDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsIdImagesImageIdAvailabilitiesDelete(
        int $id,
        int $image_id,
        ?\ck\Model\RestItemsIdImagesImageIdAvailabilitiesPostRequest $_rest_items_id_images_image_id_availabilities = null,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdAvailabilitiesDelete'][0]
    ): object
    {
        list($response) = $this->restItemsIdImagesImageIdAvailabilitiesDeleteWithHttpInfo($id, $image_id, $_rest_items_id_images_image_id_availabilities, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdImagesImageIdAvailabilitiesDeleteWithHttpInfo
     *
     * Delete an availability
     *
     * @param  int $id (required)
     * @param  int $image_id (required)
     * @param  \ck\Model\RestItemsIdImagesImageIdAvailabilitiesPostRequest|null $_rest_items_id_images_image_id_availabilities (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdAvailabilitiesDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdImagesImageIdAvailabilitiesDeleteWithHttpInfo(
        int $id,
        int $image_id,
        ?\ck\Model\RestItemsIdImagesImageIdAvailabilitiesPostRequest $_rest_items_id_images_image_id_availabilities = null,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdAvailabilitiesDelete'][0]
    ): array
    {
        $request = $this->restItemsIdImagesImageIdAvailabilitiesDeleteRequest($id, $image_id, $_rest_items_id_images_image_id_availabilities, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdImagesImageIdAvailabilitiesDeleteAsync
     *
     * Delete an availability
     *
     * @param  int $id (required)
     * @param  int $image_id (required)
     * @param  \ck\Model\RestItemsIdImagesImageIdAvailabilitiesPostRequest|null $_rest_items_id_images_image_id_availabilities (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdAvailabilitiesDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdImagesImageIdAvailabilitiesDeleteAsync(
        int $id,
        int $image_id,
        ?\ck\Model\RestItemsIdImagesImageIdAvailabilitiesPostRequest $_rest_items_id_images_image_id_availabilities = null,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdAvailabilitiesDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdImagesImageIdAvailabilitiesDeleteAsyncWithHttpInfo($id, $image_id, $_rest_items_id_images_image_id_availabilities, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdImagesImageIdAvailabilitiesDeleteAsyncWithHttpInfo
     *
     * Delete an availability
     *
     * @param  int $id (required)
     * @param  int $image_id (required)
     * @param  \ck\Model\RestItemsIdImagesImageIdAvailabilitiesPostRequest|null $_rest_items_id_images_image_id_availabilities (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdAvailabilitiesDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdImagesImageIdAvailabilitiesDeleteAsyncWithHttpInfo(
        $id,
        $image_id,
        $_rest_items_id_images_image_id_availabilities = null,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdAvailabilitiesDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsIdImagesImageIdAvailabilitiesDeleteRequest($id, $image_id, $_rest_items_id_images_image_id_availabilities, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdImagesImageIdAvailabilitiesDelete'
     *
     * @param  int $id (required)
     * @param  int $image_id (required)
     * @param  \ck\Model\RestItemsIdImagesImageIdAvailabilitiesPostRequest|null $_rest_items_id_images_image_id_availabilities (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdAvailabilitiesDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdImagesImageIdAvailabilitiesDeleteRequest(
        $id,
        $image_id,
        $_rest_items_id_images_image_id_availabilities = null,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdAvailabilitiesDelete'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdImagesImageIdAvailabilitiesDelete'
            );
        }

        // verify the required parameter 'image_id' is set
        if ($image_id === null || (is_array($image_id) && count($image_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $image_id when calling restItemsIdImagesImageIdAvailabilitiesDelete'
            );
        }



        $resourcePath = '/rest/items/{id}/images/{imageId}/availabilities';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($image_id !== null) {
            $resourcePath = str_replace(
                '{' . 'imageId' . '}',
                ObjectSerializer::toPathValue($image_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_id_images_image_id_availabilities)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_id_images_image_id_availabilities));
            } else {
                $httpBody = $_rest_items_id_images_image_id_availabilities;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdImagesImageIdAvailabilitiesGet
     *
     * List availabilities
     *
     * @param  int $id id (required)
     * @param  int $image_id image_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdAvailabilitiesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ItemImageAvailability
     */
    public function restItemsIdImagesImageIdAvailabilitiesGet(
        int $id,
        int $image_id,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdAvailabilitiesGet'][0]
    ): \ck\Model\ItemImageAvailability
    {
        list($response) = $this->restItemsIdImagesImageIdAvailabilitiesGetWithHttpInfo($id, $image_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdImagesImageIdAvailabilitiesGetWithHttpInfo
     *
     * List availabilities
     *
     * @param  int $id (required)
     * @param  int $image_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdAvailabilitiesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ItemImageAvailability, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdImagesImageIdAvailabilitiesGetWithHttpInfo(
        int $id,
        int $image_id,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdAvailabilitiesGet'][0]
    ): array
    {
        $request = $this->restItemsIdImagesImageIdAvailabilitiesGetRequest($id, $image_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ItemImageAvailability' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ItemImageAvailability' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ItemImageAvailability', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ItemImageAvailability';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ItemImageAvailability',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdImagesImageIdAvailabilitiesGetAsync
     *
     * List availabilities
     *
     * @param  int $id (required)
     * @param  int $image_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdAvailabilitiesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdImagesImageIdAvailabilitiesGetAsync(
        int $id,
        int $image_id,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdAvailabilitiesGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdImagesImageIdAvailabilitiesGetAsyncWithHttpInfo($id, $image_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdImagesImageIdAvailabilitiesGetAsyncWithHttpInfo
     *
     * List availabilities
     *
     * @param  int $id (required)
     * @param  int $image_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdAvailabilitiesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdImagesImageIdAvailabilitiesGetAsyncWithHttpInfo(
        $id,
        $image_id,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdAvailabilitiesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ItemImageAvailability';
        $request = $this->restItemsIdImagesImageIdAvailabilitiesGetRequest($id, $image_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdImagesImageIdAvailabilitiesGet'
     *
     * @param  int $id (required)
     * @param  int $image_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdAvailabilitiesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdImagesImageIdAvailabilitiesGetRequest(
        $id,
        $image_id,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdAvailabilitiesGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdImagesImageIdAvailabilitiesGet'
            );
        }

        // verify the required parameter 'image_id' is set
        if ($image_id === null || (is_array($image_id) && count($image_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $image_id when calling restItemsIdImagesImageIdAvailabilitiesGet'
            );
        }


        $resourcePath = '/rest/items/{id}/images/{imageId}/availabilities';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($image_id !== null) {
            $resourcePath = str_replace(
                '{' . 'imageId' . '}',
                ObjectSerializer::toPathValue($image_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdImagesImageIdAvailabilitiesPost
     *
     * Create an availability
     *
     * @param  int $id id (required)
     * @param  int $image_id image_id (required)
     * @param  \ck\Model\RestItemsIdImagesImageIdAvailabilitiesPostRequest|null $_rest_items_id_images_image_id_availabilities _rest_items_id_images_image_id_availabilities (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdAvailabilitiesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ItemImageAvailability
     */
    public function restItemsIdImagesImageIdAvailabilitiesPost(
        int $id,
        int $image_id,
        ?\ck\Model\RestItemsIdImagesImageIdAvailabilitiesPostRequest $_rest_items_id_images_image_id_availabilities = null,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdAvailabilitiesPost'][0]
    ): \ck\Model\ItemImageAvailability
    {
        list($response) = $this->restItemsIdImagesImageIdAvailabilitiesPostWithHttpInfo($id, $image_id, $_rest_items_id_images_image_id_availabilities, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdImagesImageIdAvailabilitiesPostWithHttpInfo
     *
     * Create an availability
     *
     * @param  int $id (required)
     * @param  int $image_id (required)
     * @param  \ck\Model\RestItemsIdImagesImageIdAvailabilitiesPostRequest|null $_rest_items_id_images_image_id_availabilities (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdAvailabilitiesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ItemImageAvailability, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdImagesImageIdAvailabilitiesPostWithHttpInfo(
        int $id,
        int $image_id,
        ?\ck\Model\RestItemsIdImagesImageIdAvailabilitiesPostRequest $_rest_items_id_images_image_id_availabilities = null,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdAvailabilitiesPost'][0]
    ): array
    {
        $request = $this->restItemsIdImagesImageIdAvailabilitiesPostRequest($id, $image_id, $_rest_items_id_images_image_id_availabilities, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ItemImageAvailability' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ItemImageAvailability' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ItemImageAvailability', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ItemImageAvailability';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ItemImageAvailability',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdImagesImageIdAvailabilitiesPostAsync
     *
     * Create an availability
     *
     * @param  int $id (required)
     * @param  int $image_id (required)
     * @param  \ck\Model\RestItemsIdImagesImageIdAvailabilitiesPostRequest|null $_rest_items_id_images_image_id_availabilities (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdAvailabilitiesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdImagesImageIdAvailabilitiesPostAsync(
        int $id,
        int $image_id,
        ?\ck\Model\RestItemsIdImagesImageIdAvailabilitiesPostRequest $_rest_items_id_images_image_id_availabilities = null,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdAvailabilitiesPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdImagesImageIdAvailabilitiesPostAsyncWithHttpInfo($id, $image_id, $_rest_items_id_images_image_id_availabilities, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdImagesImageIdAvailabilitiesPostAsyncWithHttpInfo
     *
     * Create an availability
     *
     * @param  int $id (required)
     * @param  int $image_id (required)
     * @param  \ck\Model\RestItemsIdImagesImageIdAvailabilitiesPostRequest|null $_rest_items_id_images_image_id_availabilities (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdAvailabilitiesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdImagesImageIdAvailabilitiesPostAsyncWithHttpInfo(
        $id,
        $image_id,
        $_rest_items_id_images_image_id_availabilities = null,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdAvailabilitiesPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ItemImageAvailability';
        $request = $this->restItemsIdImagesImageIdAvailabilitiesPostRequest($id, $image_id, $_rest_items_id_images_image_id_availabilities, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdImagesImageIdAvailabilitiesPost'
     *
     * @param  int $id (required)
     * @param  int $image_id (required)
     * @param  \ck\Model\RestItemsIdImagesImageIdAvailabilitiesPostRequest|null $_rest_items_id_images_image_id_availabilities (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdAvailabilitiesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdImagesImageIdAvailabilitiesPostRequest(
        $id,
        $image_id,
        $_rest_items_id_images_image_id_availabilities = null,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdAvailabilitiesPost'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdImagesImageIdAvailabilitiesPost'
            );
        }

        // verify the required parameter 'image_id' is set
        if ($image_id === null || (is_array($image_id) && count($image_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $image_id when calling restItemsIdImagesImageIdAvailabilitiesPost'
            );
        }



        $resourcePath = '/rest/items/{id}/images/{imageId}/availabilities';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($image_id !== null) {
            $resourcePath = str_replace(
                '{' . 'imageId' . '}',
                ObjectSerializer::toPathValue($image_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_id_images_image_id_availabilities)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_id_images_image_id_availabilities));
            } else {
                $httpBody = $_rest_items_id_images_image_id_availabilities;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdImagesImageIdDelete
     *
     * Delete an image
     *
     * @param  int $id id (required)
     * @param  int $image_id image_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsIdImagesImageIdDelete(
        int $id,
        int $image_id,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdDelete'][0]
    ): object
    {
        list($response) = $this->restItemsIdImagesImageIdDeleteWithHttpInfo($id, $image_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdImagesImageIdDeleteWithHttpInfo
     *
     * Delete an image
     *
     * @param  int $id (required)
     * @param  int $image_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdImagesImageIdDeleteWithHttpInfo(
        int $id,
        int $image_id,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdDelete'][0]
    ): array
    {
        $request = $this->restItemsIdImagesImageIdDeleteRequest($id, $image_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdImagesImageIdDeleteAsync
     *
     * Delete an image
     *
     * @param  int $id (required)
     * @param  int $image_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdImagesImageIdDeleteAsync(
        int $id,
        int $image_id,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdImagesImageIdDeleteAsyncWithHttpInfo($id, $image_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdImagesImageIdDeleteAsyncWithHttpInfo
     *
     * Delete an image
     *
     * @param  int $id (required)
     * @param  int $image_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdImagesImageIdDeleteAsyncWithHttpInfo(
        $id,
        $image_id,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsIdImagesImageIdDeleteRequest($id, $image_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdImagesImageIdDelete'
     *
     * @param  int $id (required)
     * @param  int $image_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdImagesImageIdDeleteRequest(
        $id,
        $image_id,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdImagesImageIdDelete'
            );
        }

        // verify the required parameter 'image_id' is set
        if ($image_id === null || (is_array($image_id) && count($image_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $image_id when calling restItemsIdImagesImageIdDelete'
            );
        }


        $resourcePath = '/rest/items/{id}/images/{imageId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($image_id !== null) {
            $resourcePath = str_replace(
                '{' . 'imageId' . '}',
                ObjectSerializer::toPathValue($image_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdImagesImageIdGet
     *
     * Get an image
     *
     * @param  int $id id (required)
     * @param  int $image_id image_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ItemImage
     */
    public function restItemsIdImagesImageIdGet(
        int $id,
        int $image_id,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdGet'][0]
    ): \ck\Model\ItemImage
    {
        list($response) = $this->restItemsIdImagesImageIdGetWithHttpInfo($id, $image_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdImagesImageIdGetWithHttpInfo
     *
     * Get an image
     *
     * @param  int $id (required)
     * @param  int $image_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ItemImage, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdImagesImageIdGetWithHttpInfo(
        int $id,
        int $image_id,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdGet'][0]
    ): array
    {
        $request = $this->restItemsIdImagesImageIdGetRequest($id, $image_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ItemImage' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ItemImage' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ItemImage', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ItemImage';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ItemImage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdImagesImageIdGetAsync
     *
     * Get an image
     *
     * @param  int $id (required)
     * @param  int $image_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdImagesImageIdGetAsync(
        int $id,
        int $image_id,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdImagesImageIdGetAsyncWithHttpInfo($id, $image_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdImagesImageIdGetAsyncWithHttpInfo
     *
     * Get an image
     *
     * @param  int $id (required)
     * @param  int $image_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdImagesImageIdGetAsyncWithHttpInfo(
        $id,
        $image_id,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ItemImage';
        $request = $this->restItemsIdImagesImageIdGetRequest($id, $image_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdImagesImageIdGet'
     *
     * @param  int $id (required)
     * @param  int $image_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdImagesImageIdGetRequest(
        $id,
        $image_id,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdImagesImageIdGet'
            );
        }

        // verify the required parameter 'image_id' is set
        if ($image_id === null || (is_array($image_id) && count($image_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $image_id when calling restItemsIdImagesImageIdGet'
            );
        }


        $resourcePath = '/rest/items/{id}/images/{imageId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($image_id !== null) {
            $resourcePath = str_replace(
                '{' . 'imageId' . '}',
                ObjectSerializer::toPathValue($image_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdImagesImageIdNamesGet
     *
     * List names of an image
     *
     * @param  int $id id (required)
     * @param  int $image_id image_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdNamesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ItemImageName[]
     */
    public function restItemsIdImagesImageIdNamesGet(
        int $id,
        int $image_id,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdNamesGet'][0]
    ): array
    {
        list($response) = $this->restItemsIdImagesImageIdNamesGetWithHttpInfo($id, $image_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdImagesImageIdNamesGetWithHttpInfo
     *
     * List names of an image
     *
     * @param  int $id (required)
     * @param  int $image_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdNamesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ItemImageName[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdImagesImageIdNamesGetWithHttpInfo(
        int $id,
        int $image_id,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdNamesGet'][0]
    ): array
    {
        $request = $this->restItemsIdImagesImageIdNamesGetRequest($id, $image_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ItemImageName[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ItemImageName[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ItemImageName[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ItemImageName[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ItemImageName[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdImagesImageIdNamesGetAsync
     *
     * List names of an image
     *
     * @param  int $id (required)
     * @param  int $image_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdNamesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdImagesImageIdNamesGetAsync(
        int $id,
        int $image_id,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdNamesGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdImagesImageIdNamesGetAsyncWithHttpInfo($id, $image_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdImagesImageIdNamesGetAsyncWithHttpInfo
     *
     * List names of an image
     *
     * @param  int $id (required)
     * @param  int $image_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdNamesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdImagesImageIdNamesGetAsyncWithHttpInfo(
        $id,
        $image_id,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdNamesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ItemImageName[]';
        $request = $this->restItemsIdImagesImageIdNamesGetRequest($id, $image_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdImagesImageIdNamesGet'
     *
     * @param  int $id (required)
     * @param  int $image_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdNamesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdImagesImageIdNamesGetRequest(
        $id,
        $image_id,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdNamesGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdImagesImageIdNamesGet'
            );
        }

        // verify the required parameter 'image_id' is set
        if ($image_id === null || (is_array($image_id) && count($image_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $image_id when calling restItemsIdImagesImageIdNamesGet'
            );
        }


        $resourcePath = '/rest/items/{id}/images/{imageId}/names';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($image_id !== null) {
            $resourcePath = str_replace(
                '{' . 'imageId' . '}',
                ObjectSerializer::toPathValue($image_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdImagesImageIdNamesLangDelete
     *
     * Delete an image name
     *
     * @param  int $id id (required)
     * @param  int $image_id image_id (required)
     * @param  int $lang lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdNamesLangDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsIdImagesImageIdNamesLangDelete(
        int $id,
        int $image_id,
        int $lang,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdNamesLangDelete'][0]
    ): object
    {
        list($response) = $this->restItemsIdImagesImageIdNamesLangDeleteWithHttpInfo($id, $image_id, $lang, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdImagesImageIdNamesLangDeleteWithHttpInfo
     *
     * Delete an image name
     *
     * @param  int $id (required)
     * @param  int $image_id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdNamesLangDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdImagesImageIdNamesLangDeleteWithHttpInfo(
        int $id,
        int $image_id,
        int $lang,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdNamesLangDelete'][0]
    ): array
    {
        $request = $this->restItemsIdImagesImageIdNamesLangDeleteRequest($id, $image_id, $lang, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdImagesImageIdNamesLangDeleteAsync
     *
     * Delete an image name
     *
     * @param  int $id (required)
     * @param  int $image_id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdNamesLangDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdImagesImageIdNamesLangDeleteAsync(
        int $id,
        int $image_id,
        int $lang,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdNamesLangDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdImagesImageIdNamesLangDeleteAsyncWithHttpInfo($id, $image_id, $lang, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdImagesImageIdNamesLangDeleteAsyncWithHttpInfo
     *
     * Delete an image name
     *
     * @param  int $id (required)
     * @param  int $image_id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdNamesLangDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdImagesImageIdNamesLangDeleteAsyncWithHttpInfo(
        $id,
        $image_id,
        $lang,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdNamesLangDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsIdImagesImageIdNamesLangDeleteRequest($id, $image_id, $lang, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdImagesImageIdNamesLangDelete'
     *
     * @param  int $id (required)
     * @param  int $image_id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdNamesLangDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdImagesImageIdNamesLangDeleteRequest(
        $id,
        $image_id,
        $lang,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdNamesLangDelete'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdImagesImageIdNamesLangDelete'
            );
        }

        // verify the required parameter 'image_id' is set
        if ($image_id === null || (is_array($image_id) && count($image_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $image_id when calling restItemsIdImagesImageIdNamesLangDelete'
            );
        }

        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $lang when calling restItemsIdImagesImageIdNamesLangDelete'
            );
        }


        $resourcePath = '/rest/items/{id}/images/{imageId}/names/{lang}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($image_id !== null) {
            $resourcePath = str_replace(
                '{' . 'imageId' . '}',
                ObjectSerializer::toPathValue($image_id),
                $resourcePath
            );
        }
        // path params
        if ($lang !== null) {
            $resourcePath = str_replace(
                '{' . 'lang' . '}',
                ObjectSerializer::toPathValue($lang),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdImagesImageIdNamesLangGet
     *
     * Get an image name
     *
     * @param  int $id id (required)
     * @param  int $image_id image_id (required)
     * @param  int $lang lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdNamesLangGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ItemImageName
     */
    public function restItemsIdImagesImageIdNamesLangGet(
        int $id,
        int $image_id,
        int $lang,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdNamesLangGet'][0]
    ): \ck\Model\ItemImageName
    {
        list($response) = $this->restItemsIdImagesImageIdNamesLangGetWithHttpInfo($id, $image_id, $lang, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdImagesImageIdNamesLangGetWithHttpInfo
     *
     * Get an image name
     *
     * @param  int $id (required)
     * @param  int $image_id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdNamesLangGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ItemImageName, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdImagesImageIdNamesLangGetWithHttpInfo(
        int $id,
        int $image_id,
        int $lang,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdNamesLangGet'][0]
    ): array
    {
        $request = $this->restItemsIdImagesImageIdNamesLangGetRequest($id, $image_id, $lang, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ItemImageName' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ItemImageName' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ItemImageName', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ItemImageName';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ItemImageName',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdImagesImageIdNamesLangGetAsync
     *
     * Get an image name
     *
     * @param  int $id (required)
     * @param  int $image_id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdNamesLangGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdImagesImageIdNamesLangGetAsync(
        int $id,
        int $image_id,
        int $lang,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdNamesLangGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdImagesImageIdNamesLangGetAsyncWithHttpInfo($id, $image_id, $lang, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdImagesImageIdNamesLangGetAsyncWithHttpInfo
     *
     * Get an image name
     *
     * @param  int $id (required)
     * @param  int $image_id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdNamesLangGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdImagesImageIdNamesLangGetAsyncWithHttpInfo(
        $id,
        $image_id,
        $lang,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdNamesLangGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ItemImageName';
        $request = $this->restItemsIdImagesImageIdNamesLangGetRequest($id, $image_id, $lang, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdImagesImageIdNamesLangGet'
     *
     * @param  int $id (required)
     * @param  int $image_id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdNamesLangGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdImagesImageIdNamesLangGetRequest(
        $id,
        $image_id,
        $lang,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdNamesLangGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdImagesImageIdNamesLangGet'
            );
        }

        // verify the required parameter 'image_id' is set
        if ($image_id === null || (is_array($image_id) && count($image_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $image_id when calling restItemsIdImagesImageIdNamesLangGet'
            );
        }

        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $lang when calling restItemsIdImagesImageIdNamesLangGet'
            );
        }


        $resourcePath = '/rest/items/{id}/images/{imageId}/names/{lang}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($image_id !== null) {
            $resourcePath = str_replace(
                '{' . 'imageId' . '}',
                ObjectSerializer::toPathValue($image_id),
                $resourcePath
            );
        }
        // path params
        if ($lang !== null) {
            $resourcePath = str_replace(
                '{' . 'lang' . '}',
                ObjectSerializer::toPathValue($lang),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdImagesImageIdNamesLangPut
     *
     * Update an image name
     *
     * @param  int $id id (required)
     * @param  int $image_id image_id (required)
     * @param  int $lang lang (required)
     * @param  \ck\Model\RestItemsIdImagesImageIdNamesPostRequest|null $_rest_items_id_images_image_id_names_lang _rest_items_id_images_image_id_names_lang (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdNamesLangPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ItemImageName
     */
    public function restItemsIdImagesImageIdNamesLangPut(
        int $id,
        int $image_id,
        int $lang,
        ?\ck\Model\RestItemsIdImagesImageIdNamesPostRequest $_rest_items_id_images_image_id_names_lang = null,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdNamesLangPut'][0]
    ): \ck\Model\ItemImageName
    {
        list($response) = $this->restItemsIdImagesImageIdNamesLangPutWithHttpInfo($id, $image_id, $lang, $_rest_items_id_images_image_id_names_lang, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdImagesImageIdNamesLangPutWithHttpInfo
     *
     * Update an image name
     *
     * @param  int $id (required)
     * @param  int $image_id (required)
     * @param  int $lang (required)
     * @param  \ck\Model\RestItemsIdImagesImageIdNamesPostRequest|null $_rest_items_id_images_image_id_names_lang (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdNamesLangPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ItemImageName, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdImagesImageIdNamesLangPutWithHttpInfo(
        int $id,
        int $image_id,
        int $lang,
        ?\ck\Model\RestItemsIdImagesImageIdNamesPostRequest $_rest_items_id_images_image_id_names_lang = null,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdNamesLangPut'][0]
    ): array
    {
        $request = $this->restItemsIdImagesImageIdNamesLangPutRequest($id, $image_id, $lang, $_rest_items_id_images_image_id_names_lang, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ItemImageName' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ItemImageName' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ItemImageName', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ItemImageName';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ItemImageName',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdImagesImageIdNamesLangPutAsync
     *
     * Update an image name
     *
     * @param  int $id (required)
     * @param  int $image_id (required)
     * @param  int $lang (required)
     * @param  \ck\Model\RestItemsIdImagesImageIdNamesPostRequest|null $_rest_items_id_images_image_id_names_lang (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdNamesLangPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdImagesImageIdNamesLangPutAsync(
        int $id,
        int $image_id,
        int $lang,
        ?\ck\Model\RestItemsIdImagesImageIdNamesPostRequest $_rest_items_id_images_image_id_names_lang = null,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdNamesLangPut'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdImagesImageIdNamesLangPutAsyncWithHttpInfo($id, $image_id, $lang, $_rest_items_id_images_image_id_names_lang, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdImagesImageIdNamesLangPutAsyncWithHttpInfo
     *
     * Update an image name
     *
     * @param  int $id (required)
     * @param  int $image_id (required)
     * @param  int $lang (required)
     * @param  \ck\Model\RestItemsIdImagesImageIdNamesPostRequest|null $_rest_items_id_images_image_id_names_lang (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdNamesLangPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdImagesImageIdNamesLangPutAsyncWithHttpInfo(
        $id,
        $image_id,
        $lang,
        $_rest_items_id_images_image_id_names_lang = null,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdNamesLangPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ItemImageName';
        $request = $this->restItemsIdImagesImageIdNamesLangPutRequest($id, $image_id, $lang, $_rest_items_id_images_image_id_names_lang, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdImagesImageIdNamesLangPut'
     *
     * @param  int $id (required)
     * @param  int $image_id (required)
     * @param  int $lang (required)
     * @param  \ck\Model\RestItemsIdImagesImageIdNamesPostRequest|null $_rest_items_id_images_image_id_names_lang (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdNamesLangPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdImagesImageIdNamesLangPutRequest(
        $id,
        $image_id,
        $lang,
        $_rest_items_id_images_image_id_names_lang = null,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdNamesLangPut'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdImagesImageIdNamesLangPut'
            );
        }

        // verify the required parameter 'image_id' is set
        if ($image_id === null || (is_array($image_id) && count($image_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $image_id when calling restItemsIdImagesImageIdNamesLangPut'
            );
        }

        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $lang when calling restItemsIdImagesImageIdNamesLangPut'
            );
        }



        $resourcePath = '/rest/items/{id}/images/{imageId}/names/{lang}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($image_id !== null) {
            $resourcePath = str_replace(
                '{' . 'imageId' . '}',
                ObjectSerializer::toPathValue($image_id),
                $resourcePath
            );
        }
        // path params
        if ($lang !== null) {
            $resourcePath = str_replace(
                '{' . 'lang' . '}',
                ObjectSerializer::toPathValue($lang),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_id_images_image_id_names_lang)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_id_images_image_id_names_lang));
            } else {
                $httpBody = $_rest_items_id_images_image_id_names_lang;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdImagesImageIdNamesPost
     *
     * Create an image name
     *
     * @param  int $id id (required)
     * @param  int $image_id image_id (required)
     * @param  \ck\Model\RestItemsIdImagesImageIdNamesPostRequest|null $_rest_items_id_images_image_id_names _rest_items_id_images_image_id_names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdNamesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ItemImageName
     */
    public function restItemsIdImagesImageIdNamesPost(
        int $id,
        int $image_id,
        ?\ck\Model\RestItemsIdImagesImageIdNamesPostRequest $_rest_items_id_images_image_id_names = null,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdNamesPost'][0]
    ): \ck\Model\ItemImageName
    {
        list($response) = $this->restItemsIdImagesImageIdNamesPostWithHttpInfo($id, $image_id, $_rest_items_id_images_image_id_names, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdImagesImageIdNamesPostWithHttpInfo
     *
     * Create an image name
     *
     * @param  int $id (required)
     * @param  int $image_id (required)
     * @param  \ck\Model\RestItemsIdImagesImageIdNamesPostRequest|null $_rest_items_id_images_image_id_names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdNamesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ItemImageName, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdImagesImageIdNamesPostWithHttpInfo(
        int $id,
        int $image_id,
        ?\ck\Model\RestItemsIdImagesImageIdNamesPostRequest $_rest_items_id_images_image_id_names = null,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdNamesPost'][0]
    ): array
    {
        $request = $this->restItemsIdImagesImageIdNamesPostRequest($id, $image_id, $_rest_items_id_images_image_id_names, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ItemImageName' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ItemImageName' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ItemImageName', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ItemImageName';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ItemImageName',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdImagesImageIdNamesPostAsync
     *
     * Create an image name
     *
     * @param  int $id (required)
     * @param  int $image_id (required)
     * @param  \ck\Model\RestItemsIdImagesImageIdNamesPostRequest|null $_rest_items_id_images_image_id_names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdNamesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdImagesImageIdNamesPostAsync(
        int $id,
        int $image_id,
        ?\ck\Model\RestItemsIdImagesImageIdNamesPostRequest $_rest_items_id_images_image_id_names = null,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdNamesPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdImagesImageIdNamesPostAsyncWithHttpInfo($id, $image_id, $_rest_items_id_images_image_id_names, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdImagesImageIdNamesPostAsyncWithHttpInfo
     *
     * Create an image name
     *
     * @param  int $id (required)
     * @param  int $image_id (required)
     * @param  \ck\Model\RestItemsIdImagesImageIdNamesPostRequest|null $_rest_items_id_images_image_id_names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdNamesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdImagesImageIdNamesPostAsyncWithHttpInfo(
        $id,
        $image_id,
        $_rest_items_id_images_image_id_names = null,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdNamesPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ItemImageName';
        $request = $this->restItemsIdImagesImageIdNamesPostRequest($id, $image_id, $_rest_items_id_images_image_id_names, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdImagesImageIdNamesPost'
     *
     * @param  int $id (required)
     * @param  int $image_id (required)
     * @param  \ck\Model\RestItemsIdImagesImageIdNamesPostRequest|null $_rest_items_id_images_image_id_names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdNamesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdImagesImageIdNamesPostRequest(
        $id,
        $image_id,
        $_rest_items_id_images_image_id_names = null,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdNamesPost'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdImagesImageIdNamesPost'
            );
        }

        // verify the required parameter 'image_id' is set
        if ($image_id === null || (is_array($image_id) && count($image_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $image_id when calling restItemsIdImagesImageIdNamesPost'
            );
        }



        $resourcePath = '/rest/items/{id}/images/{imageId}/names';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($image_id !== null) {
            $resourcePath = str_replace(
                '{' . 'imageId' . '}',
                ObjectSerializer::toPathValue($image_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_id_images_image_id_names)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_id_images_image_id_names));
            } else {
                $httpBody = $_rest_items_id_images_image_id_names;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdImagesImageIdPut
     *
     * Update an image
     *
     * @param  int $id id (required)
     * @param  int $image_id image_id (required)
     * @param  \ck\Model\RestItemsIdImagesImageIdPutRequest|null $_rest_items_id_images_image_id _rest_items_id_images_image_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ItemImage
     */
    public function restItemsIdImagesImageIdPut(
        int $id,
        int $image_id,
        ?\ck\Model\RestItemsIdImagesImageIdPutRequest $_rest_items_id_images_image_id = null,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdPut'][0]
    ): \ck\Model\ItemImage
    {
        list($response) = $this->restItemsIdImagesImageIdPutWithHttpInfo($id, $image_id, $_rest_items_id_images_image_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdImagesImageIdPutWithHttpInfo
     *
     * Update an image
     *
     * @param  int $id (required)
     * @param  int $image_id (required)
     * @param  \ck\Model\RestItemsIdImagesImageIdPutRequest|null $_rest_items_id_images_image_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ItemImage, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdImagesImageIdPutWithHttpInfo(
        int $id,
        int $image_id,
        ?\ck\Model\RestItemsIdImagesImageIdPutRequest $_rest_items_id_images_image_id = null,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdPut'][0]
    ): array
    {
        $request = $this->restItemsIdImagesImageIdPutRequest($id, $image_id, $_rest_items_id_images_image_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ItemImage' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ItemImage' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ItemImage', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ItemImage';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ItemImage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdImagesImageIdPutAsync
     *
     * Update an image
     *
     * @param  int $id (required)
     * @param  int $image_id (required)
     * @param  \ck\Model\RestItemsIdImagesImageIdPutRequest|null $_rest_items_id_images_image_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdImagesImageIdPutAsync(
        int $id,
        int $image_id,
        ?\ck\Model\RestItemsIdImagesImageIdPutRequest $_rest_items_id_images_image_id = null,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdPut'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdImagesImageIdPutAsyncWithHttpInfo($id, $image_id, $_rest_items_id_images_image_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdImagesImageIdPutAsyncWithHttpInfo
     *
     * Update an image
     *
     * @param  int $id (required)
     * @param  int $image_id (required)
     * @param  \ck\Model\RestItemsIdImagesImageIdPutRequest|null $_rest_items_id_images_image_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdImagesImageIdPutAsyncWithHttpInfo(
        $id,
        $image_id,
        $_rest_items_id_images_image_id = null,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ItemImage';
        $request = $this->restItemsIdImagesImageIdPutRequest($id, $image_id, $_rest_items_id_images_image_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdImagesImageIdPut'
     *
     * @param  int $id (required)
     * @param  int $image_id (required)
     * @param  \ck\Model\RestItemsIdImagesImageIdPutRequest|null $_rest_items_id_images_image_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdImagesImageIdPutRequest(
        $id,
        $image_id,
        $_rest_items_id_images_image_id = null,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdPut'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdImagesImageIdPut'
            );
        }

        // verify the required parameter 'image_id' is set
        if ($image_id === null || (is_array($image_id) && count($image_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $image_id when calling restItemsIdImagesImageIdPut'
            );
        }



        $resourcePath = '/rest/items/{id}/images/{imageId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($image_id !== null) {
            $resourcePath = str_replace(
                '{' . 'imageId' . '}',
                ObjectSerializer::toPathValue($image_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_id_images_image_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_id_images_image_id));
            } else {
                $httpBody = $_rest_items_id_images_image_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdImagesImageIdVariationImagesGet
     *
     * List image links of an image
     *
     * @param  int $id id (required)
     * @param  int $image_id image_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdVariationImagesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationImage
     */
    public function restItemsIdImagesImageIdVariationImagesGet(
        int $id,
        int $image_id,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdVariationImagesGet'][0]
    ): \ck\Model\VariationImage
    {
        list($response) = $this->restItemsIdImagesImageIdVariationImagesGetWithHttpInfo($id, $image_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdImagesImageIdVariationImagesGetWithHttpInfo
     *
     * List image links of an image
     *
     * @param  int $id (required)
     * @param  int $image_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdVariationImagesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationImage, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdImagesImageIdVariationImagesGetWithHttpInfo(
        int $id,
        int $image_id,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdVariationImagesGet'][0]
    ): array
    {
        $request = $this->restItemsIdImagesImageIdVariationImagesGetRequest($id, $image_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationImage' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationImage' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationImage', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationImage';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationImage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdImagesImageIdVariationImagesGetAsync
     *
     * List image links of an image
     *
     * @param  int $id (required)
     * @param  int $image_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdVariationImagesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdImagesImageIdVariationImagesGetAsync(
        int $id,
        int $image_id,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdVariationImagesGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdImagesImageIdVariationImagesGetAsyncWithHttpInfo($id, $image_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdImagesImageIdVariationImagesGetAsyncWithHttpInfo
     *
     * List image links of an image
     *
     * @param  int $id (required)
     * @param  int $image_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdVariationImagesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdImagesImageIdVariationImagesGetAsyncWithHttpInfo(
        $id,
        $image_id,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdVariationImagesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationImage';
        $request = $this->restItemsIdImagesImageIdVariationImagesGetRequest($id, $image_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdImagesImageIdVariationImagesGet'
     *
     * @param  int $id (required)
     * @param  int $image_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesImageIdVariationImagesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdImagesImageIdVariationImagesGetRequest(
        $id,
        $image_id,
        string $contentType = self::contentTypes['restItemsIdImagesImageIdVariationImagesGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdImagesImageIdVariationImagesGet'
            );
        }

        // verify the required parameter 'image_id' is set
        if ($image_id === null || (is_array($image_id) && count($image_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $image_id when calling restItemsIdImagesImageIdVariationImagesGet'
            );
        }


        $resourcePath = '/rest/items/{id}/images/{imageId}/variation_images';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($image_id !== null) {
            $resourcePath = str_replace(
                '{' . 'imageId' . '}',
                ObjectSerializer::toPathValue($image_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdImagesUploadPost
     *
     * Upload a new image
     *
     * @param  int $id id (required)
     * @param  \ck\Model\RestItemsIdImagesUploadPostRequest|null $_rest_items_id_images_upload _rest_items_id_images_upload (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesUploadPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ItemImage
     */
    public function restItemsIdImagesUploadPost(
        int $id,
        ?\ck\Model\RestItemsIdImagesUploadPostRequest $_rest_items_id_images_upload = null,
        string $contentType = self::contentTypes['restItemsIdImagesUploadPost'][0]
    ): \ck\Model\ItemImage
    {
        list($response) = $this->restItemsIdImagesUploadPostWithHttpInfo($id, $_rest_items_id_images_upload, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdImagesUploadPostWithHttpInfo
     *
     * Upload a new image
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsIdImagesUploadPostRequest|null $_rest_items_id_images_upload (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesUploadPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ItemImage, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdImagesUploadPostWithHttpInfo(
        int $id,
        ?\ck\Model\RestItemsIdImagesUploadPostRequest $_rest_items_id_images_upload = null,
        string $contentType = self::contentTypes['restItemsIdImagesUploadPost'][0]
    ): array
    {
        $request = $this->restItemsIdImagesUploadPostRequest($id, $_rest_items_id_images_upload, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ItemImage' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ItemImage' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ItemImage', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ItemImage';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ItemImage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdImagesUploadPostAsync
     *
     * Upload a new image
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsIdImagesUploadPostRequest|null $_rest_items_id_images_upload (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesUploadPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdImagesUploadPostAsync(
        int $id,
        ?\ck\Model\RestItemsIdImagesUploadPostRequest $_rest_items_id_images_upload = null,
        string $contentType = self::contentTypes['restItemsIdImagesUploadPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdImagesUploadPostAsyncWithHttpInfo($id, $_rest_items_id_images_upload, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdImagesUploadPostAsyncWithHttpInfo
     *
     * Upload a new image
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsIdImagesUploadPostRequest|null $_rest_items_id_images_upload (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesUploadPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdImagesUploadPostAsyncWithHttpInfo(
        $id,
        $_rest_items_id_images_upload = null,
        string $contentType = self::contentTypes['restItemsIdImagesUploadPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ItemImage';
        $request = $this->restItemsIdImagesUploadPostRequest($id, $_rest_items_id_images_upload, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdImagesUploadPost'
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsIdImagesUploadPostRequest|null $_rest_items_id_images_upload (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdImagesUploadPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdImagesUploadPostRequest(
        $id,
        $_rest_items_id_images_upload = null,
        string $contentType = self::contentTypes['restItemsIdImagesUploadPost'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdImagesUploadPost'
            );
        }



        $resourcePath = '/rest/items/{id}/images/upload';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_id_images_upload)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_id_images_upload));
            } else {
                $httpBody = $_rest_items_id_images_upload;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdItemCrossSellingCrossItemIdDelete
     *
     * Delete a cross-selling link
     *
     * @param  int $id id (required)
     * @param  int $cross_item_id cross_item_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdItemCrossSellingCrossItemIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsIdItemCrossSellingCrossItemIdDelete(
        int $id,
        int $cross_item_id,
        string $contentType = self::contentTypes['restItemsIdItemCrossSellingCrossItemIdDelete'][0]
    ): object
    {
        list($response) = $this->restItemsIdItemCrossSellingCrossItemIdDeleteWithHttpInfo($id, $cross_item_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdItemCrossSellingCrossItemIdDeleteWithHttpInfo
     *
     * Delete a cross-selling link
     *
     * @param  int $id (required)
     * @param  int $cross_item_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdItemCrossSellingCrossItemIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdItemCrossSellingCrossItemIdDeleteWithHttpInfo(
        int $id,
        int $cross_item_id,
        string $contentType = self::contentTypes['restItemsIdItemCrossSellingCrossItemIdDelete'][0]
    ): array
    {
        $request = $this->restItemsIdItemCrossSellingCrossItemIdDeleteRequest($id, $cross_item_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdItemCrossSellingCrossItemIdDeleteAsync
     *
     * Delete a cross-selling link
     *
     * @param  int $id (required)
     * @param  int $cross_item_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdItemCrossSellingCrossItemIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdItemCrossSellingCrossItemIdDeleteAsync(
        int $id,
        int $cross_item_id,
        string $contentType = self::contentTypes['restItemsIdItemCrossSellingCrossItemIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdItemCrossSellingCrossItemIdDeleteAsyncWithHttpInfo($id, $cross_item_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdItemCrossSellingCrossItemIdDeleteAsyncWithHttpInfo
     *
     * Delete a cross-selling link
     *
     * @param  int $id (required)
     * @param  int $cross_item_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdItemCrossSellingCrossItemIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdItemCrossSellingCrossItemIdDeleteAsyncWithHttpInfo(
        $id,
        $cross_item_id,
        string $contentType = self::contentTypes['restItemsIdItemCrossSellingCrossItemIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsIdItemCrossSellingCrossItemIdDeleteRequest($id, $cross_item_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdItemCrossSellingCrossItemIdDelete'
     *
     * @param  int $id (required)
     * @param  int $cross_item_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdItemCrossSellingCrossItemIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdItemCrossSellingCrossItemIdDeleteRequest(
        $id,
        $cross_item_id,
        string $contentType = self::contentTypes['restItemsIdItemCrossSellingCrossItemIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdItemCrossSellingCrossItemIdDelete'
            );
        }

        // verify the required parameter 'cross_item_id' is set
        if ($cross_item_id === null || (is_array($cross_item_id) && count($cross_item_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $cross_item_id when calling restItemsIdItemCrossSellingCrossItemIdDelete'
            );
        }


        $resourcePath = '/rest/items/{id}/item_cross_selling/{crossItemId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($cross_item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'crossItemId' . '}',
                ObjectSerializer::toPathValue($cross_item_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdItemCrossSellingGet
     *
     * List cross-selling links
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdItemCrossSellingGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ItemCrossSelling
     */
    public function restItemsIdItemCrossSellingGet(
        int $id,
        string $contentType = self::contentTypes['restItemsIdItemCrossSellingGet'][0]
    ): \ck\Model\ItemCrossSelling
    {
        list($response) = $this->restItemsIdItemCrossSellingGetWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdItemCrossSellingGetWithHttpInfo
     *
     * List cross-selling links
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdItemCrossSellingGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ItemCrossSelling, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdItemCrossSellingGetWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restItemsIdItemCrossSellingGet'][0]
    ): array
    {
        $request = $this->restItemsIdItemCrossSellingGetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ItemCrossSelling' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ItemCrossSelling' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ItemCrossSelling', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ItemCrossSelling';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ItemCrossSelling',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdItemCrossSellingGetAsync
     *
     * List cross-selling links
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdItemCrossSellingGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdItemCrossSellingGetAsync(
        int $id,
        string $contentType = self::contentTypes['restItemsIdItemCrossSellingGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdItemCrossSellingGetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdItemCrossSellingGetAsyncWithHttpInfo
     *
     * List cross-selling links
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdItemCrossSellingGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdItemCrossSellingGetAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restItemsIdItemCrossSellingGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ItemCrossSelling';
        $request = $this->restItemsIdItemCrossSellingGetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdItemCrossSellingGet'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdItemCrossSellingGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdItemCrossSellingGetRequest(
        $id,
        string $contentType = self::contentTypes['restItemsIdItemCrossSellingGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdItemCrossSellingGet'
            );
        }


        $resourcePath = '/rest/items/{id}/item_cross_selling';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdItemCrossSellingPost
     *
     * Create a cross-selling link
     *
     * @param  int $id id (required)
     * @param  \ck\Model\RestItemsIdItemCrossSellingPostRequest|null $_rest_items_id_item_cross_selling _rest_items_id_item_cross_selling (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdItemCrossSellingPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ItemCrossSelling
     */
    public function restItemsIdItemCrossSellingPost(
        int $id,
        ?\ck\Model\RestItemsIdItemCrossSellingPostRequest $_rest_items_id_item_cross_selling = null,
        string $contentType = self::contentTypes['restItemsIdItemCrossSellingPost'][0]
    ): \ck\Model\ItemCrossSelling
    {
        list($response) = $this->restItemsIdItemCrossSellingPostWithHttpInfo($id, $_rest_items_id_item_cross_selling, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdItemCrossSellingPostWithHttpInfo
     *
     * Create a cross-selling link
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsIdItemCrossSellingPostRequest|null $_rest_items_id_item_cross_selling (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdItemCrossSellingPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ItemCrossSelling, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdItemCrossSellingPostWithHttpInfo(
        int $id,
        ?\ck\Model\RestItemsIdItemCrossSellingPostRequest $_rest_items_id_item_cross_selling = null,
        string $contentType = self::contentTypes['restItemsIdItemCrossSellingPost'][0]
    ): array
    {
        $request = $this->restItemsIdItemCrossSellingPostRequest($id, $_rest_items_id_item_cross_selling, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ItemCrossSelling' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ItemCrossSelling' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ItemCrossSelling', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ItemCrossSelling';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ItemCrossSelling',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdItemCrossSellingPostAsync
     *
     * Create a cross-selling link
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsIdItemCrossSellingPostRequest|null $_rest_items_id_item_cross_selling (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdItemCrossSellingPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdItemCrossSellingPostAsync(
        int $id,
        ?\ck\Model\RestItemsIdItemCrossSellingPostRequest $_rest_items_id_item_cross_selling = null,
        string $contentType = self::contentTypes['restItemsIdItemCrossSellingPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdItemCrossSellingPostAsyncWithHttpInfo($id, $_rest_items_id_item_cross_selling, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdItemCrossSellingPostAsyncWithHttpInfo
     *
     * Create a cross-selling link
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsIdItemCrossSellingPostRequest|null $_rest_items_id_item_cross_selling (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdItemCrossSellingPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdItemCrossSellingPostAsyncWithHttpInfo(
        $id,
        $_rest_items_id_item_cross_selling = null,
        string $contentType = self::contentTypes['restItemsIdItemCrossSellingPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ItemCrossSelling';
        $request = $this->restItemsIdItemCrossSellingPostRequest($id, $_rest_items_id_item_cross_selling, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdItemCrossSellingPost'
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsIdItemCrossSellingPostRequest|null $_rest_items_id_item_cross_selling (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdItemCrossSellingPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdItemCrossSellingPostRequest(
        $id,
        $_rest_items_id_item_cross_selling = null,
        string $contentType = self::contentTypes['restItemsIdItemCrossSellingPost'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdItemCrossSellingPost'
            );
        }



        $resourcePath = '/rest/items/{id}/item_cross_selling';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_id_item_cross_selling)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_id_item_cross_selling));
            } else {
                $httpBody = $_rest_items_id_item_cross_selling;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationImagesGet
     *
     * List image links of an item
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationImagesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationImage
     */
    public function restItemsIdVariationImagesGet(
        int $id,
        string $contentType = self::contentTypes['restItemsIdVariationImagesGet'][0]
    ): \ck\Model\VariationImage
    {
        list($response) = $this->restItemsIdVariationImagesGetWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationImagesGetWithHttpInfo
     *
     * List image links of an item
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationImagesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationImage, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationImagesGetWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restItemsIdVariationImagesGet'][0]
    ): array
    {
        $request = $this->restItemsIdVariationImagesGetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationImage' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationImage' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationImage', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationImage';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationImage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationImagesGetAsync
     *
     * List image links of an item
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationImagesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationImagesGetAsync(
        int $id,
        string $contentType = self::contentTypes['restItemsIdVariationImagesGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationImagesGetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationImagesGetAsyncWithHttpInfo
     *
     * List image links of an item
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationImagesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationImagesGetAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restItemsIdVariationImagesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationImage';
        $request = $this->restItemsIdVariationImagesGetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationImagesGet'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationImagesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationImagesGetRequest(
        $id,
        string $contentType = self::contentTypes['restItemsIdVariationImagesGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationImagesGet'
            );
        }


        $resourcePath = '/rest/items/{id}/variation_images';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdDescriptionsGet
     *
     * List texts
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdDescriptionsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationDescription[]
     */
    public function restItemsIdVariationsVariationIdDescriptionsGet(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdDescriptionsGet'][0]
    ): array
    {
        list($response) = $this->restItemsIdVariationsVariationIdDescriptionsGetWithHttpInfo($id, $variation_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdDescriptionsGetWithHttpInfo
     *
     * List texts
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdDescriptionsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationDescription[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdDescriptionsGetWithHttpInfo(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdDescriptionsGet'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdDescriptionsGetRequest($id, $variation_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationDescription[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationDescription[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationDescription[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationDescription[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationDescription[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdDescriptionsGetAsync
     *
     * List texts
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdDescriptionsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdDescriptionsGetAsync(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdDescriptionsGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdDescriptionsGetAsyncWithHttpInfo($id, $variation_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdDescriptionsGetAsyncWithHttpInfo
     *
     * List texts
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdDescriptionsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdDescriptionsGetAsyncWithHttpInfo(
        $id,
        $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdDescriptionsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationDescription[]';
        $request = $this->restItemsIdVariationsVariationIdDescriptionsGetRequest($id, $variation_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdDescriptionsGet'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdDescriptionsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdDescriptionsGetRequest(
        $id,
        $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdDescriptionsGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdDescriptionsGet'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdDescriptionsGet'
            );
        }


        $resourcePath = '/rest/items/{id}/variations/{variationId}/descriptions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdDescriptionsLangDelete
     *
     * Delete texts
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  int $lang lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdDescriptionsLangDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsIdVariationsVariationIdDescriptionsLangDelete(
        int $id,
        int $variation_id,
        int $lang,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdDescriptionsLangDelete'][0]
    ): object
    {
        list($response) = $this->restItemsIdVariationsVariationIdDescriptionsLangDeleteWithHttpInfo($id, $variation_id, $lang, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdDescriptionsLangDeleteWithHttpInfo
     *
     * Delete texts
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdDescriptionsLangDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdDescriptionsLangDeleteWithHttpInfo(
        int $id,
        int $variation_id,
        int $lang,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdDescriptionsLangDelete'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdDescriptionsLangDeleteRequest($id, $variation_id, $lang, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdDescriptionsLangDeleteAsync
     *
     * Delete texts
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdDescriptionsLangDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdDescriptionsLangDeleteAsync(
        int $id,
        int $variation_id,
        int $lang,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdDescriptionsLangDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdDescriptionsLangDeleteAsyncWithHttpInfo($id, $variation_id, $lang, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdDescriptionsLangDeleteAsyncWithHttpInfo
     *
     * Delete texts
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdDescriptionsLangDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdDescriptionsLangDeleteAsyncWithHttpInfo(
        $id,
        $variation_id,
        $lang,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdDescriptionsLangDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsIdVariationsVariationIdDescriptionsLangDeleteRequest($id, $variation_id, $lang, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdDescriptionsLangDelete'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdDescriptionsLangDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdDescriptionsLangDeleteRequest(
        $id,
        $variation_id,
        $lang,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdDescriptionsLangDelete'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdDescriptionsLangDelete'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdDescriptionsLangDelete'
            );
        }

        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $lang when calling restItemsIdVariationsVariationIdDescriptionsLangDelete'
            );
        }


        $resourcePath = '/rest/items/{id}/variations/{variationId}/descriptions/{lang}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }
        // path params
        if ($lang !== null) {
            $resourcePath = str_replace(
                '{' . 'lang' . '}',
                ObjectSerializer::toPathValue($lang),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdDescriptionsLangGet
     *
     * Get texts
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  int $lang lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdDescriptionsLangGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationDescription
     */
    public function restItemsIdVariationsVariationIdDescriptionsLangGet(
        int $id,
        int $variation_id,
        int $lang,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdDescriptionsLangGet'][0]
    ): \ck\Model\VariationDescription
    {
        list($response) = $this->restItemsIdVariationsVariationIdDescriptionsLangGetWithHttpInfo($id, $variation_id, $lang, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdDescriptionsLangGetWithHttpInfo
     *
     * Get texts
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdDescriptionsLangGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationDescription, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdDescriptionsLangGetWithHttpInfo(
        int $id,
        int $variation_id,
        int $lang,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdDescriptionsLangGet'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdDescriptionsLangGetRequest($id, $variation_id, $lang, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationDescription' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationDescription' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationDescription', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationDescription';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationDescription',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdDescriptionsLangGetAsync
     *
     * Get texts
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdDescriptionsLangGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdDescriptionsLangGetAsync(
        int $id,
        int $variation_id,
        int $lang,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdDescriptionsLangGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdDescriptionsLangGetAsyncWithHttpInfo($id, $variation_id, $lang, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdDescriptionsLangGetAsyncWithHttpInfo
     *
     * Get texts
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdDescriptionsLangGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdDescriptionsLangGetAsyncWithHttpInfo(
        $id,
        $variation_id,
        $lang,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdDescriptionsLangGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationDescription';
        $request = $this->restItemsIdVariationsVariationIdDescriptionsLangGetRequest($id, $variation_id, $lang, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdDescriptionsLangGet'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdDescriptionsLangGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdDescriptionsLangGetRequest(
        $id,
        $variation_id,
        $lang,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdDescriptionsLangGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdDescriptionsLangGet'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdDescriptionsLangGet'
            );
        }

        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $lang when calling restItemsIdVariationsVariationIdDescriptionsLangGet'
            );
        }


        $resourcePath = '/rest/items/{id}/variations/{variationId}/descriptions/{lang}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }
        // path params
        if ($lang !== null) {
            $resourcePath = str_replace(
                '{' . 'lang' . '}',
                ObjectSerializer::toPathValue($lang),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdDescriptionsLangPut
     *
     * Update texts
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  int $lang lang (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdDescriptionsPostRequest|null $_rest_items_id_variations_variation_id_descriptions_lang _rest_items_id_variations_variation_id_descriptions_lang (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdDescriptionsLangPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationDescription
     */
    public function restItemsIdVariationsVariationIdDescriptionsLangPut(
        int $id,
        int $variation_id,
        int $lang,
        ?\ck\Model\RestItemsIdVariationsVariationIdDescriptionsPostRequest $_rest_items_id_variations_variation_id_descriptions_lang = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdDescriptionsLangPut'][0]
    ): \ck\Model\VariationDescription
    {
        list($response) = $this->restItemsIdVariationsVariationIdDescriptionsLangPutWithHttpInfo($id, $variation_id, $lang, $_rest_items_id_variations_variation_id_descriptions_lang, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdDescriptionsLangPutWithHttpInfo
     *
     * Update texts
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $lang (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdDescriptionsPostRequest|null $_rest_items_id_variations_variation_id_descriptions_lang (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdDescriptionsLangPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationDescription, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdDescriptionsLangPutWithHttpInfo(
        int $id,
        int $variation_id,
        int $lang,
        ?\ck\Model\RestItemsIdVariationsVariationIdDescriptionsPostRequest $_rest_items_id_variations_variation_id_descriptions_lang = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdDescriptionsLangPut'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdDescriptionsLangPutRequest($id, $variation_id, $lang, $_rest_items_id_variations_variation_id_descriptions_lang, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationDescription' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationDescription' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationDescription', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationDescription';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationDescription',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdDescriptionsLangPutAsync
     *
     * Update texts
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $lang (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdDescriptionsPostRequest|null $_rest_items_id_variations_variation_id_descriptions_lang (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdDescriptionsLangPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdDescriptionsLangPutAsync(
        int $id,
        int $variation_id,
        int $lang,
        ?\ck\Model\RestItemsIdVariationsVariationIdDescriptionsPostRequest $_rest_items_id_variations_variation_id_descriptions_lang = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdDescriptionsLangPut'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdDescriptionsLangPutAsyncWithHttpInfo($id, $variation_id, $lang, $_rest_items_id_variations_variation_id_descriptions_lang, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdDescriptionsLangPutAsyncWithHttpInfo
     *
     * Update texts
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $lang (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdDescriptionsPostRequest|null $_rest_items_id_variations_variation_id_descriptions_lang (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdDescriptionsLangPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdDescriptionsLangPutAsyncWithHttpInfo(
        $id,
        $variation_id,
        $lang,
        $_rest_items_id_variations_variation_id_descriptions_lang = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdDescriptionsLangPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationDescription';
        $request = $this->restItemsIdVariationsVariationIdDescriptionsLangPutRequest($id, $variation_id, $lang, $_rest_items_id_variations_variation_id_descriptions_lang, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdDescriptionsLangPut'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $lang (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdDescriptionsPostRequest|null $_rest_items_id_variations_variation_id_descriptions_lang (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdDescriptionsLangPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdDescriptionsLangPutRequest(
        $id,
        $variation_id,
        $lang,
        $_rest_items_id_variations_variation_id_descriptions_lang = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdDescriptionsLangPut'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdDescriptionsLangPut'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdDescriptionsLangPut'
            );
        }

        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $lang when calling restItemsIdVariationsVariationIdDescriptionsLangPut'
            );
        }



        $resourcePath = '/rest/items/{id}/variations/{variationId}/descriptions/{lang}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }
        // path params
        if ($lang !== null) {
            $resourcePath = str_replace(
                '{' . 'lang' . '}',
                ObjectSerializer::toPathValue($lang),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_id_variations_variation_id_descriptions_lang)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_id_variations_variation_id_descriptions_lang));
            } else {
                $httpBody = $_rest_items_id_variations_variation_id_descriptions_lang;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdDescriptionsPost
     *
     * Create texts
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdDescriptionsPostRequest|null $_rest_items_id_variations_variation_id_descriptions _rest_items_id_variations_variation_id_descriptions (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdDescriptionsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationDescription
     */
    public function restItemsIdVariationsVariationIdDescriptionsPost(
        int $id,
        int $variation_id,
        ?\ck\Model\RestItemsIdVariationsVariationIdDescriptionsPostRequest $_rest_items_id_variations_variation_id_descriptions = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdDescriptionsPost'][0]
    ): \ck\Model\VariationDescription
    {
        list($response) = $this->restItemsIdVariationsVariationIdDescriptionsPostWithHttpInfo($id, $variation_id, $_rest_items_id_variations_variation_id_descriptions, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdDescriptionsPostWithHttpInfo
     *
     * Create texts
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdDescriptionsPostRequest|null $_rest_items_id_variations_variation_id_descriptions (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdDescriptionsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationDescription, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdDescriptionsPostWithHttpInfo(
        int $id,
        int $variation_id,
        ?\ck\Model\RestItemsIdVariationsVariationIdDescriptionsPostRequest $_rest_items_id_variations_variation_id_descriptions = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdDescriptionsPost'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdDescriptionsPostRequest($id, $variation_id, $_rest_items_id_variations_variation_id_descriptions, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationDescription' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationDescription' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationDescription', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationDescription';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationDescription',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdDescriptionsPostAsync
     *
     * Create texts
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdDescriptionsPostRequest|null $_rest_items_id_variations_variation_id_descriptions (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdDescriptionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdDescriptionsPostAsync(
        int $id,
        int $variation_id,
        ?\ck\Model\RestItemsIdVariationsVariationIdDescriptionsPostRequest $_rest_items_id_variations_variation_id_descriptions = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdDescriptionsPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdDescriptionsPostAsyncWithHttpInfo($id, $variation_id, $_rest_items_id_variations_variation_id_descriptions, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdDescriptionsPostAsyncWithHttpInfo
     *
     * Create texts
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdDescriptionsPostRequest|null $_rest_items_id_variations_variation_id_descriptions (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdDescriptionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdDescriptionsPostAsyncWithHttpInfo(
        $id,
        $variation_id,
        $_rest_items_id_variations_variation_id_descriptions = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdDescriptionsPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationDescription';
        $request = $this->restItemsIdVariationsVariationIdDescriptionsPostRequest($id, $variation_id, $_rest_items_id_variations_variation_id_descriptions, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdDescriptionsPost'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdDescriptionsPostRequest|null $_rest_items_id_variations_variation_id_descriptions (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdDescriptionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdDescriptionsPostRequest(
        $id,
        $variation_id,
        $_rest_items_id_variations_variation_id_descriptions = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdDescriptionsPost'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdDescriptionsPost'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdDescriptionsPost'
            );
        }



        $resourcePath = '/rest/items/{id}/variations/{variationId}/descriptions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_id_variations_variation_id_descriptions)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_id_variations_variation_id_descriptions));
            } else {
                $httpBody = $_rest_items_id_variations_variation_id_descriptions;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdImagesGet
     *
     * List images of a variation
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdImagesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ItemImage[]
     */
    public function restItemsIdVariationsVariationIdImagesGet(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdImagesGet'][0]
    ): array
    {
        list($response) = $this->restItemsIdVariationsVariationIdImagesGetWithHttpInfo($id, $variation_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdImagesGetWithHttpInfo
     *
     * List images of a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdImagesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ItemImage[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdImagesGetWithHttpInfo(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdImagesGet'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdImagesGetRequest($id, $variation_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ItemImage[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ItemImage[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ItemImage[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ItemImage[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ItemImage[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdImagesGetAsync
     *
     * List images of a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdImagesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdImagesGetAsync(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdImagesGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdImagesGetAsyncWithHttpInfo($id, $variation_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdImagesGetAsyncWithHttpInfo
     *
     * List images of a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdImagesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdImagesGetAsyncWithHttpInfo(
        $id,
        $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdImagesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ItemImage[]';
        $request = $this->restItemsIdVariationsVariationIdImagesGetRequest($id, $variation_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdImagesGet'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdImagesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdImagesGetRequest(
        $id,
        $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdImagesGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdImagesGet'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdImagesGet'
            );
        }


        $resourcePath = '/rest/items/{id}/variations/{variationId}/images';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdLabelsPost
     *
     * Get a variation label
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdLabelsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object[]
     */
    public function restItemsIdVariationsVariationIdLabelsPost(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdLabelsPost'][0]
    ): array
    {
        list($response) = $this->restItemsIdVariationsVariationIdLabelsPostWithHttpInfo($id, $variation_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdLabelsPostWithHttpInfo
     *
     * Get a variation label
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdLabelsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdLabelsPostWithHttpInfo(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdLabelsPost'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdLabelsPostRequest($id, $variation_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdLabelsPostAsync
     *
     * Get a variation label
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdLabelsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdLabelsPostAsync(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdLabelsPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdLabelsPostAsyncWithHttpInfo($id, $variation_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdLabelsPostAsyncWithHttpInfo
     *
     * Get a variation label
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdLabelsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdLabelsPostAsyncWithHttpInfo(
        $id,
        $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdLabelsPost'][0]
    ): PromiseInterface
    {
        $returnType = 'object[]';
        $request = $this->restItemsIdVariationsVariationIdLabelsPostRequest($id, $variation_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdLabelsPost'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdLabelsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdLabelsPostRequest(
        $id,
        $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdLabelsPost'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdLabelsPost'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdLabelsPost'
            );
        }


        $resourcePath = '/rest/items/{id}/variations/{variationId}/labels';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdMarketIdentNumbersGet
     *
     * List ident number of a variation
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdMarketIdentNumbersGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationMarketIdentNumber[]
     */
    public function restItemsIdVariationsVariationIdMarketIdentNumbersGet(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdMarketIdentNumbersGet'][0]
    ): array
    {
        list($response) = $this->restItemsIdVariationsVariationIdMarketIdentNumbersGetWithHttpInfo($id, $variation_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdMarketIdentNumbersGetWithHttpInfo
     *
     * List ident number of a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdMarketIdentNumbersGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationMarketIdentNumber[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdMarketIdentNumbersGetWithHttpInfo(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdMarketIdentNumbersGet'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdMarketIdentNumbersGetRequest($id, $variation_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationMarketIdentNumber[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationMarketIdentNumber[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationMarketIdentNumber[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationMarketIdentNumber[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationMarketIdentNumber[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdMarketIdentNumbersGetAsync
     *
     * List ident number of a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdMarketIdentNumbersGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdMarketIdentNumbersGetAsync(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdMarketIdentNumbersGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdMarketIdentNumbersGetAsyncWithHttpInfo($id, $variation_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdMarketIdentNumbersGetAsyncWithHttpInfo
     *
     * List ident number of a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdMarketIdentNumbersGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdMarketIdentNumbersGetAsyncWithHttpInfo(
        $id,
        $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdMarketIdentNumbersGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationMarketIdentNumber[]';
        $request = $this->restItemsIdVariationsVariationIdMarketIdentNumbersGetRequest($id, $variation_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdMarketIdentNumbersGet'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdMarketIdentNumbersGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdMarketIdentNumbersGetRequest(
        $id,
        $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdMarketIdentNumbersGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdMarketIdentNumbersGet'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdMarketIdentNumbersGet'
            );
        }


        $resourcePath = '/rest/items/{id}/variations/{variationId}/market_ident_numbers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdDelete
     *
     * Deletes a market ident number
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  int $market_ident_number_id market_ident_number_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdDelete(
        int $id,
        int $variation_id,
        int $market_ident_number_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdDelete'][0]
    ): object
    {
        list($response) = $this->restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdDeleteWithHttpInfo($id, $variation_id, $market_ident_number_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdDeleteWithHttpInfo
     *
     * Deletes a market ident number
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $market_ident_number_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdDeleteWithHttpInfo(
        int $id,
        int $variation_id,
        int $market_ident_number_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdDelete'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdDeleteRequest($id, $variation_id, $market_ident_number_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdDeleteAsync
     *
     * Deletes a market ident number
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $market_ident_number_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdDeleteAsync(
        int $id,
        int $variation_id,
        int $market_ident_number_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdDeleteAsyncWithHttpInfo($id, $variation_id, $market_ident_number_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdDeleteAsyncWithHttpInfo
     *
     * Deletes a market ident number
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $market_ident_number_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdDeleteAsyncWithHttpInfo(
        $id,
        $variation_id,
        $market_ident_number_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdDeleteRequest($id, $variation_id, $market_ident_number_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdDelete'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $market_ident_number_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdDeleteRequest(
        $id,
        $variation_id,
        $market_ident_number_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdDelete'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdDelete'
            );
        }

        // verify the required parameter 'market_ident_number_id' is set
        if ($market_ident_number_id === null || (is_array($market_ident_number_id) && count($market_ident_number_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $market_ident_number_id when calling restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdDelete'
            );
        }


        $resourcePath = '/rest/items/{id}/variations/{variationId}/market_ident_numbers/{marketIdentNumberId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }
        // path params
        if ($market_ident_number_id !== null) {
            $resourcePath = str_replace(
                '{' . 'marketIdentNumberId' . '}',
                ObjectSerializer::toPathValue($market_ident_number_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdGet
     *
     * Get a market ident number
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  int $market_ident_number_id market_ident_number_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationMarketIdentNumber
     */
    public function restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdGet(
        int $id,
        int $variation_id,
        int $market_ident_number_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdGet'][0]
    ): \ck\Model\VariationMarketIdentNumber
    {
        list($response) = $this->restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdGetWithHttpInfo($id, $variation_id, $market_ident_number_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdGetWithHttpInfo
     *
     * Get a market ident number
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $market_ident_number_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationMarketIdentNumber, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdGetWithHttpInfo(
        int $id,
        int $variation_id,
        int $market_ident_number_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdGet'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdGetRequest($id, $variation_id, $market_ident_number_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationMarketIdentNumber' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationMarketIdentNumber' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationMarketIdentNumber', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationMarketIdentNumber';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationMarketIdentNumber',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdGetAsync
     *
     * Get a market ident number
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $market_ident_number_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdGetAsync(
        int $id,
        int $variation_id,
        int $market_ident_number_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdGetAsyncWithHttpInfo($id, $variation_id, $market_ident_number_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdGetAsyncWithHttpInfo
     *
     * Get a market ident number
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $market_ident_number_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdGetAsyncWithHttpInfo(
        $id,
        $variation_id,
        $market_ident_number_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationMarketIdentNumber';
        $request = $this->restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdGetRequest($id, $variation_id, $market_ident_number_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdGet'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $market_ident_number_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdGetRequest(
        $id,
        $variation_id,
        $market_ident_number_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdGet'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdGet'
            );
        }

        // verify the required parameter 'market_ident_number_id' is set
        if ($market_ident_number_id === null || (is_array($market_ident_number_id) && count($market_ident_number_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $market_ident_number_id when calling restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdGet'
            );
        }


        $resourcePath = '/rest/items/{id}/variations/{variationId}/market_ident_numbers/{marketIdentNumberId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }
        // path params
        if ($market_ident_number_id !== null) {
            $resourcePath = str_replace(
                '{' . 'marketIdentNumberId' . '}',
                ObjectSerializer::toPathValue($market_ident_number_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdPut
     *
     * Updates a market ident number
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  int $market_ident_number_id market_ident_number_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdMarketIdentNumbersPostRequest|null $_rest_items_id_variations_variation_id_market_ident_numbers_market_ident_number_id _rest_items_id_variations_variation_id_market_ident_numbers_market_ident_number_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationMarketIdentNumber
     */
    public function restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdPut(
        int $id,
        int $variation_id,
        int $market_ident_number_id,
        ?\ck\Model\RestItemsIdVariationsVariationIdMarketIdentNumbersPostRequest $_rest_items_id_variations_variation_id_market_ident_numbers_market_ident_number_id = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdPut'][0]
    ): \ck\Model\VariationMarketIdentNumber
    {
        list($response) = $this->restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdPutWithHttpInfo($id, $variation_id, $market_ident_number_id, $_rest_items_id_variations_variation_id_market_ident_numbers_market_ident_number_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdPutWithHttpInfo
     *
     * Updates a market ident number
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $market_ident_number_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdMarketIdentNumbersPostRequest|null $_rest_items_id_variations_variation_id_market_ident_numbers_market_ident_number_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationMarketIdentNumber, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdPutWithHttpInfo(
        int $id,
        int $variation_id,
        int $market_ident_number_id,
        ?\ck\Model\RestItemsIdVariationsVariationIdMarketIdentNumbersPostRequest $_rest_items_id_variations_variation_id_market_ident_numbers_market_ident_number_id = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdPut'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdPutRequest($id, $variation_id, $market_ident_number_id, $_rest_items_id_variations_variation_id_market_ident_numbers_market_ident_number_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationMarketIdentNumber' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationMarketIdentNumber' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationMarketIdentNumber', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationMarketIdentNumber';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationMarketIdentNumber',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdPutAsync
     *
     * Updates a market ident number
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $market_ident_number_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdMarketIdentNumbersPostRequest|null $_rest_items_id_variations_variation_id_market_ident_numbers_market_ident_number_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdPutAsync(
        int $id,
        int $variation_id,
        int $market_ident_number_id,
        ?\ck\Model\RestItemsIdVariationsVariationIdMarketIdentNumbersPostRequest $_rest_items_id_variations_variation_id_market_ident_numbers_market_ident_number_id = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdPut'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdPutAsyncWithHttpInfo($id, $variation_id, $market_ident_number_id, $_rest_items_id_variations_variation_id_market_ident_numbers_market_ident_number_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdPutAsyncWithHttpInfo
     *
     * Updates a market ident number
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $market_ident_number_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdMarketIdentNumbersPostRequest|null $_rest_items_id_variations_variation_id_market_ident_numbers_market_ident_number_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdPutAsyncWithHttpInfo(
        $id,
        $variation_id,
        $market_ident_number_id,
        $_rest_items_id_variations_variation_id_market_ident_numbers_market_ident_number_id = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationMarketIdentNumber';
        $request = $this->restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdPutRequest($id, $variation_id, $market_ident_number_id, $_rest_items_id_variations_variation_id_market_ident_numbers_market_ident_number_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdPut'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $market_ident_number_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdMarketIdentNumbersPostRequest|null $_rest_items_id_variations_variation_id_market_ident_numbers_market_ident_number_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdPutRequest(
        $id,
        $variation_id,
        $market_ident_number_id,
        $_rest_items_id_variations_variation_id_market_ident_numbers_market_ident_number_id = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdPut'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdPut'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdPut'
            );
        }

        // verify the required parameter 'market_ident_number_id' is set
        if ($market_ident_number_id === null || (is_array($market_ident_number_id) && count($market_ident_number_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $market_ident_number_id when calling restItemsIdVariationsVariationIdMarketIdentNumbersMarketIdentNumberIdPut'
            );
        }



        $resourcePath = '/rest/items/{id}/variations/{variationId}/market_ident_numbers/{marketIdentNumberId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }
        // path params
        if ($market_ident_number_id !== null) {
            $resourcePath = str_replace(
                '{' . 'marketIdentNumberId' . '}',
                ObjectSerializer::toPathValue($market_ident_number_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_id_variations_variation_id_market_ident_numbers_market_ident_number_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_id_variations_variation_id_market_ident_numbers_market_ident_number_id));
            } else {
                $httpBody = $_rest_items_id_variations_variation_id_market_ident_numbers_market_ident_number_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdMarketIdentNumbersPost
     *
     * Create a market ident number
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdMarketIdentNumbersPostRequest|null $_rest_items_id_variations_variation_id_market_ident_numbers _rest_items_id_variations_variation_id_market_ident_numbers (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdMarketIdentNumbersPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationMarketIdentNumber
     */
    public function restItemsIdVariationsVariationIdMarketIdentNumbersPost(
        int $id,
        int $variation_id,
        ?\ck\Model\RestItemsIdVariationsVariationIdMarketIdentNumbersPostRequest $_rest_items_id_variations_variation_id_market_ident_numbers = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdMarketIdentNumbersPost'][0]
    ): \ck\Model\VariationMarketIdentNumber
    {
        list($response) = $this->restItemsIdVariationsVariationIdMarketIdentNumbersPostWithHttpInfo($id, $variation_id, $_rest_items_id_variations_variation_id_market_ident_numbers, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdMarketIdentNumbersPostWithHttpInfo
     *
     * Create a market ident number
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdMarketIdentNumbersPostRequest|null $_rest_items_id_variations_variation_id_market_ident_numbers (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdMarketIdentNumbersPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationMarketIdentNumber, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdMarketIdentNumbersPostWithHttpInfo(
        int $id,
        int $variation_id,
        ?\ck\Model\RestItemsIdVariationsVariationIdMarketIdentNumbersPostRequest $_rest_items_id_variations_variation_id_market_ident_numbers = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdMarketIdentNumbersPost'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdMarketIdentNumbersPostRequest($id, $variation_id, $_rest_items_id_variations_variation_id_market_ident_numbers, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationMarketIdentNumber' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationMarketIdentNumber' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationMarketIdentNumber', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationMarketIdentNumber';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationMarketIdentNumber',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdMarketIdentNumbersPostAsync
     *
     * Create a market ident number
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdMarketIdentNumbersPostRequest|null $_rest_items_id_variations_variation_id_market_ident_numbers (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdMarketIdentNumbersPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdMarketIdentNumbersPostAsync(
        int $id,
        int $variation_id,
        ?\ck\Model\RestItemsIdVariationsVariationIdMarketIdentNumbersPostRequest $_rest_items_id_variations_variation_id_market_ident_numbers = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdMarketIdentNumbersPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdMarketIdentNumbersPostAsyncWithHttpInfo($id, $variation_id, $_rest_items_id_variations_variation_id_market_ident_numbers, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdMarketIdentNumbersPostAsyncWithHttpInfo
     *
     * Create a market ident number
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdMarketIdentNumbersPostRequest|null $_rest_items_id_variations_variation_id_market_ident_numbers (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdMarketIdentNumbersPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdMarketIdentNumbersPostAsyncWithHttpInfo(
        $id,
        $variation_id,
        $_rest_items_id_variations_variation_id_market_ident_numbers = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdMarketIdentNumbersPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationMarketIdentNumber';
        $request = $this->restItemsIdVariationsVariationIdMarketIdentNumbersPostRequest($id, $variation_id, $_rest_items_id_variations_variation_id_market_ident_numbers, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdMarketIdentNumbersPost'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdMarketIdentNumbersPostRequest|null $_rest_items_id_variations_variation_id_market_ident_numbers (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdMarketIdentNumbersPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdMarketIdentNumbersPostRequest(
        $id,
        $variation_id,
        $_rest_items_id_variations_variation_id_market_ident_numbers = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdMarketIdentNumbersPost'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdMarketIdentNumbersPost'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdMarketIdentNumbersPost'
            );
        }



        $resourcePath = '/rest/items/{id}/variations/{variationId}/market_ident_numbers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_id_variations_variation_id_market_ident_numbers)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_id_variations_variation_id_market_ident_numbers));
            } else {
                $httpBody = $_rest_items_id_variations_variation_id_market_ident_numbers;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdStockBookIncomingItemsPut
     *
     * Book incoming stock
     *
     * @param  int $item_id The ID of the item (required)
     * @param  int $variation_id The ID of the variation (required)
     * @param  int $id id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdStockBookIncomingItemsPutRequest|null $_rest_items_id_variations_variation_id_stock_book_incoming_items _rest_items_id_variations_variation_id_stock_book_incoming_items (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdStockBookIncomingItemsPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationStock[]
     */
    public function restItemsIdVariationsVariationIdStockBookIncomingItemsPut(
        int $item_id,
        int $variation_id,
        int $id,
        ?\ck\Model\RestItemsIdVariationsVariationIdStockBookIncomingItemsPutRequest $_rest_items_id_variations_variation_id_stock_book_incoming_items = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdStockBookIncomingItemsPut'][0]
    ): array
    {
        list($response) = $this->restItemsIdVariationsVariationIdStockBookIncomingItemsPutWithHttpInfo($item_id, $variation_id, $id, $_rest_items_id_variations_variation_id_stock_book_incoming_items, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdStockBookIncomingItemsPutWithHttpInfo
     *
     * Book incoming stock
     *
     * @param  int $item_id The ID of the item (required)
     * @param  int $variation_id The ID of the variation (required)
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdStockBookIncomingItemsPutRequest|null $_rest_items_id_variations_variation_id_stock_book_incoming_items (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdStockBookIncomingItemsPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationStock[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdStockBookIncomingItemsPutWithHttpInfo(
        int $item_id,
        int $variation_id,
        int $id,
        ?\ck\Model\RestItemsIdVariationsVariationIdStockBookIncomingItemsPutRequest $_rest_items_id_variations_variation_id_stock_book_incoming_items = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdStockBookIncomingItemsPut'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdStockBookIncomingItemsPutRequest($item_id, $variation_id, $id, $_rest_items_id_variations_variation_id_stock_book_incoming_items, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationStock[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationStock[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationStock[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationStock[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationStock[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdStockBookIncomingItemsPutAsync
     *
     * Book incoming stock
     *
     * @param  int $item_id The ID of the item (required)
     * @param  int $variation_id The ID of the variation (required)
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdStockBookIncomingItemsPutRequest|null $_rest_items_id_variations_variation_id_stock_book_incoming_items (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdStockBookIncomingItemsPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdStockBookIncomingItemsPutAsync(
        int $item_id,
        int $variation_id,
        int $id,
        ?\ck\Model\RestItemsIdVariationsVariationIdStockBookIncomingItemsPutRequest $_rest_items_id_variations_variation_id_stock_book_incoming_items = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdStockBookIncomingItemsPut'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdStockBookIncomingItemsPutAsyncWithHttpInfo($item_id, $variation_id, $id, $_rest_items_id_variations_variation_id_stock_book_incoming_items, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdStockBookIncomingItemsPutAsyncWithHttpInfo
     *
     * Book incoming stock
     *
     * @param  int $item_id The ID of the item (required)
     * @param  int $variation_id The ID of the variation (required)
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdStockBookIncomingItemsPutRequest|null $_rest_items_id_variations_variation_id_stock_book_incoming_items (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdStockBookIncomingItemsPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdStockBookIncomingItemsPutAsyncWithHttpInfo(
        $item_id,
        $variation_id,
        $id,
        $_rest_items_id_variations_variation_id_stock_book_incoming_items = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdStockBookIncomingItemsPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationStock[]';
        $request = $this->restItemsIdVariationsVariationIdStockBookIncomingItemsPutRequest($item_id, $variation_id, $id, $_rest_items_id_variations_variation_id_stock_book_incoming_items, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdStockBookIncomingItemsPut'
     *
     * @param  int $item_id The ID of the item (required)
     * @param  int $variation_id The ID of the variation (required)
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdStockBookIncomingItemsPutRequest|null $_rest_items_id_variations_variation_id_stock_book_incoming_items (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdStockBookIncomingItemsPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdStockBookIncomingItemsPutRequest(
        $item_id,
        $variation_id,
        $id,
        $_rest_items_id_variations_variation_id_stock_book_incoming_items = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdStockBookIncomingItemsPut'][0]
    ): Request
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $item_id when calling restItemsIdVariationsVariationIdStockBookIncomingItemsPut'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdStockBookIncomingItemsPut'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdStockBookIncomingItemsPut'
            );
        }



        $resourcePath = '/rest/items/{id}/variations/{variationId}/stock/bookIncomingItems';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $item_id,
            'itemId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);


        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_id_variations_variation_id_stock_book_incoming_items)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_id_variations_variation_id_stock_book_incoming_items));
            } else {
                $httpBody = $_rest_items_id_variations_variation_id_stock_book_incoming_items;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdStockBookOutgoingItemsPut
     *
     * Book outgoing stock
     *
     * @param  int $item_id The ID of the item (required)
     * @param  int $variation_id The ID of the variation (required)
     * @param  int $id id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdStockBookOutgoingItemsPutRequest|null $_rest_items_id_variations_variation_id_stock_book_outgoing_items _rest_items_id_variations_variation_id_stock_book_outgoing_items (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdStockBookOutgoingItemsPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationStock[]
     */
    public function restItemsIdVariationsVariationIdStockBookOutgoingItemsPut(
        int $item_id,
        int $variation_id,
        int $id,
        ?\ck\Model\RestItemsIdVariationsVariationIdStockBookOutgoingItemsPutRequest $_rest_items_id_variations_variation_id_stock_book_outgoing_items = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdStockBookOutgoingItemsPut'][0]
    ): array
    {
        list($response) = $this->restItemsIdVariationsVariationIdStockBookOutgoingItemsPutWithHttpInfo($item_id, $variation_id, $id, $_rest_items_id_variations_variation_id_stock_book_outgoing_items, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdStockBookOutgoingItemsPutWithHttpInfo
     *
     * Book outgoing stock
     *
     * @param  int $item_id The ID of the item (required)
     * @param  int $variation_id The ID of the variation (required)
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdStockBookOutgoingItemsPutRequest|null $_rest_items_id_variations_variation_id_stock_book_outgoing_items (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdStockBookOutgoingItemsPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationStock[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdStockBookOutgoingItemsPutWithHttpInfo(
        int $item_id,
        int $variation_id,
        int $id,
        ?\ck\Model\RestItemsIdVariationsVariationIdStockBookOutgoingItemsPutRequest $_rest_items_id_variations_variation_id_stock_book_outgoing_items = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdStockBookOutgoingItemsPut'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdStockBookOutgoingItemsPutRequest($item_id, $variation_id, $id, $_rest_items_id_variations_variation_id_stock_book_outgoing_items, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationStock[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationStock[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationStock[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationStock[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationStock[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdStockBookOutgoingItemsPutAsync
     *
     * Book outgoing stock
     *
     * @param  int $item_id The ID of the item (required)
     * @param  int $variation_id The ID of the variation (required)
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdStockBookOutgoingItemsPutRequest|null $_rest_items_id_variations_variation_id_stock_book_outgoing_items (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdStockBookOutgoingItemsPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdStockBookOutgoingItemsPutAsync(
        int $item_id,
        int $variation_id,
        int $id,
        ?\ck\Model\RestItemsIdVariationsVariationIdStockBookOutgoingItemsPutRequest $_rest_items_id_variations_variation_id_stock_book_outgoing_items = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdStockBookOutgoingItemsPut'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdStockBookOutgoingItemsPutAsyncWithHttpInfo($item_id, $variation_id, $id, $_rest_items_id_variations_variation_id_stock_book_outgoing_items, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdStockBookOutgoingItemsPutAsyncWithHttpInfo
     *
     * Book outgoing stock
     *
     * @param  int $item_id The ID of the item (required)
     * @param  int $variation_id The ID of the variation (required)
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdStockBookOutgoingItemsPutRequest|null $_rest_items_id_variations_variation_id_stock_book_outgoing_items (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdStockBookOutgoingItemsPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdStockBookOutgoingItemsPutAsyncWithHttpInfo(
        $item_id,
        $variation_id,
        $id,
        $_rest_items_id_variations_variation_id_stock_book_outgoing_items = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdStockBookOutgoingItemsPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationStock[]';
        $request = $this->restItemsIdVariationsVariationIdStockBookOutgoingItemsPutRequest($item_id, $variation_id, $id, $_rest_items_id_variations_variation_id_stock_book_outgoing_items, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdStockBookOutgoingItemsPut'
     *
     * @param  int $item_id The ID of the item (required)
     * @param  int $variation_id The ID of the variation (required)
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdStockBookOutgoingItemsPutRequest|null $_rest_items_id_variations_variation_id_stock_book_outgoing_items (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdStockBookOutgoingItemsPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdStockBookOutgoingItemsPutRequest(
        $item_id,
        $variation_id,
        $id,
        $_rest_items_id_variations_variation_id_stock_book_outgoing_items = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdStockBookOutgoingItemsPut'][0]
    ): Request
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $item_id when calling restItemsIdVariationsVariationIdStockBookOutgoingItemsPut'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdStockBookOutgoingItemsPut'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdStockBookOutgoingItemsPut'
            );
        }



        $resourcePath = '/rest/items/{id}/variations/{variationId}/stock/bookOutgoingItems';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $item_id,
            'itemId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);


        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_id_variations_variation_id_stock_book_outgoing_items)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_id_variations_variation_id_stock_book_outgoing_items));
            } else {
                $httpBody = $_rest_items_id_variations_variation_id_stock_book_outgoing_items;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdStockCorrectionPut
     *
     * Correct stock
     *
     * @param  int $item_id The ID of the item (required)
     * @param  int $variation_id The ID of the variation (required)
     * @param  int $id id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdStockCorrectionPutRequest|null $_rest_items_id_variations_variation_id_stock_correction _rest_items_id_variations_variation_id_stock_correction (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdStockCorrectionPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationStock[]
     */
    public function restItemsIdVariationsVariationIdStockCorrectionPut(
        int $item_id,
        int $variation_id,
        int $id,
        ?\ck\Model\RestItemsIdVariationsVariationIdStockCorrectionPutRequest $_rest_items_id_variations_variation_id_stock_correction = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdStockCorrectionPut'][0]
    ): array
    {
        list($response) = $this->restItemsIdVariationsVariationIdStockCorrectionPutWithHttpInfo($item_id, $variation_id, $id, $_rest_items_id_variations_variation_id_stock_correction, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdStockCorrectionPutWithHttpInfo
     *
     * Correct stock
     *
     * @param  int $item_id The ID of the item (required)
     * @param  int $variation_id The ID of the variation (required)
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdStockCorrectionPutRequest|null $_rest_items_id_variations_variation_id_stock_correction (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdStockCorrectionPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationStock[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdStockCorrectionPutWithHttpInfo(
        int $item_id,
        int $variation_id,
        int $id,
        ?\ck\Model\RestItemsIdVariationsVariationIdStockCorrectionPutRequest $_rest_items_id_variations_variation_id_stock_correction = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdStockCorrectionPut'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdStockCorrectionPutRequest($item_id, $variation_id, $id, $_rest_items_id_variations_variation_id_stock_correction, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationStock[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationStock[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationStock[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationStock[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationStock[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdStockCorrectionPutAsync
     *
     * Correct stock
     *
     * @param  int $item_id The ID of the item (required)
     * @param  int $variation_id The ID of the variation (required)
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdStockCorrectionPutRequest|null $_rest_items_id_variations_variation_id_stock_correction (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdStockCorrectionPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdStockCorrectionPutAsync(
        int $item_id,
        int $variation_id,
        int $id,
        ?\ck\Model\RestItemsIdVariationsVariationIdStockCorrectionPutRequest $_rest_items_id_variations_variation_id_stock_correction = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdStockCorrectionPut'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdStockCorrectionPutAsyncWithHttpInfo($item_id, $variation_id, $id, $_rest_items_id_variations_variation_id_stock_correction, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdStockCorrectionPutAsyncWithHttpInfo
     *
     * Correct stock
     *
     * @param  int $item_id The ID of the item (required)
     * @param  int $variation_id The ID of the variation (required)
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdStockCorrectionPutRequest|null $_rest_items_id_variations_variation_id_stock_correction (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdStockCorrectionPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdStockCorrectionPutAsyncWithHttpInfo(
        $item_id,
        $variation_id,
        $id,
        $_rest_items_id_variations_variation_id_stock_correction = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdStockCorrectionPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationStock[]';
        $request = $this->restItemsIdVariationsVariationIdStockCorrectionPutRequest($item_id, $variation_id, $id, $_rest_items_id_variations_variation_id_stock_correction, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdStockCorrectionPut'
     *
     * @param  int $item_id The ID of the item (required)
     * @param  int $variation_id The ID of the variation (required)
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdStockCorrectionPutRequest|null $_rest_items_id_variations_variation_id_stock_correction (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdStockCorrectionPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdStockCorrectionPutRequest(
        $item_id,
        $variation_id,
        $id,
        $_rest_items_id_variations_variation_id_stock_correction = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdStockCorrectionPut'][0]
    ): Request
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $item_id when calling restItemsIdVariationsVariationIdStockCorrectionPut'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdStockCorrectionPut'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdStockCorrectionPut'
            );
        }



        $resourcePath = '/rest/items/{id}/variations/{variationId}/stock/correction';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $item_id,
            'itemId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);


        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_id_variations_variation_id_stock_correction)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_id_variations_variation_id_stock_correction));
            } else {
                $httpBody = $_rest_items_id_variations_variation_id_stock_correction;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdStockGet
     *
     * List stock of a variation per warehouse
     *
     * @param  int $item_id The ID of the item (required)
     * @param  int $variation_id The ID of the variation (required)
     * @param  int $id id (required)
     * @param  int|null $columns The properties to be loaded (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdStockGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationStock[]
     */
    public function restItemsIdVariationsVariationIdStockGet(
        int $item_id,
        int $variation_id,
        int $id,
        ?int $columns = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdStockGet'][0]
    ): array
    {
        list($response) = $this->restItemsIdVariationsVariationIdStockGetWithHttpInfo($item_id, $variation_id, $id, $columns, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdStockGetWithHttpInfo
     *
     * List stock of a variation per warehouse
     *
     * @param  int $item_id The ID of the item (required)
     * @param  int $variation_id The ID of the variation (required)
     * @param  int $id (required)
     * @param  int|null $columns The properties to be loaded (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdStockGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationStock[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdStockGetWithHttpInfo(
        int $item_id,
        int $variation_id,
        int $id,
        ?int $columns = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdStockGet'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdStockGetRequest($item_id, $variation_id, $id, $columns, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationStock[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationStock[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationStock[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationStock[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationStock[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdStockGetAsync
     *
     * List stock of a variation per warehouse
     *
     * @param  int $item_id The ID of the item (required)
     * @param  int $variation_id The ID of the variation (required)
     * @param  int $id (required)
     * @param  int|null $columns The properties to be loaded (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdStockGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdStockGetAsync(
        int $item_id,
        int $variation_id,
        int $id,
        ?int $columns = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdStockGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdStockGetAsyncWithHttpInfo($item_id, $variation_id, $id, $columns, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdStockGetAsyncWithHttpInfo
     *
     * List stock of a variation per warehouse
     *
     * @param  int $item_id The ID of the item (required)
     * @param  int $variation_id The ID of the variation (required)
     * @param  int $id (required)
     * @param  int|null $columns The properties to be loaded (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdStockGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdStockGetAsyncWithHttpInfo(
        $item_id,
        $variation_id,
        $id,
        $columns = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdStockGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationStock[]';
        $request = $this->restItemsIdVariationsVariationIdStockGetRequest($item_id, $variation_id, $id, $columns, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdStockGet'
     *
     * @param  int $item_id The ID of the item (required)
     * @param  int $variation_id The ID of the variation (required)
     * @param  int $id (required)
     * @param  int|null $columns The properties to be loaded (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdStockGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdStockGetRequest(
        $item_id,
        $variation_id,
        $id,
        $columns = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdStockGet'][0]
    ): Request
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $item_id when calling restItemsIdVariationsVariationIdStockGet'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdStockGet'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdStockGet'
            );
        }



        $resourcePath = '/rest/items/{id}/variations/{variationId}/stock';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $item_id,
            'itemId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $columns,
            'columns', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdStockMovementsGet
     *
     * List stock movements
     *
     * @param  int $item_id The ID of the item (required)
     * @param  int $variation_id The ID of the variation (required)
     * @param  int $page The requested page. The default page that will be returned is page 1. (required)
     * @param  int $items_per_page The number of items per page. The default number per page is 50. (required)
     * @param  int $id id (required)
     * @param  int|null $warehouse_id The ID of the warehouse (optional)
     * @param  string|null $created_at_from Get entries with createdAt date after this date (optional)
     * @param  string|null $created_at_to Get entries with createdAt date before this date (optional)
     * @param  int|null $year Get entries from the archive for the given year. All movements older than 3 months are stored in the archive. (optional)
     * @param  int|null $columns The properties to be loaded (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdStockMovementsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestItemsIdVariationsVariationIdStockMovementsGet200Response
     */
    public function restItemsIdVariationsVariationIdStockMovementsGet(
        int $item_id,
        int $variation_id,
        int $page,
        int $items_per_page,
        int $id,
        ?int $warehouse_id = null,
        ?string $created_at_from = null,
        ?string $created_at_to = null,
        ?int $year = null,
        ?int $columns = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdStockMovementsGet'][0]
    ): \ck\Model\RestItemsIdVariationsVariationIdStockMovementsGet200Response
    {
        list($response) = $this->restItemsIdVariationsVariationIdStockMovementsGetWithHttpInfo($item_id, $variation_id, $page, $items_per_page, $id, $warehouse_id, $created_at_from, $created_at_to, $year, $columns, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdStockMovementsGetWithHttpInfo
     *
     * List stock movements
     *
     * @param  int $item_id The ID of the item (required)
     * @param  int $variation_id The ID of the variation (required)
     * @param  int $page The requested page. The default page that will be returned is page 1. (required)
     * @param  int $items_per_page The number of items per page. The default number per page is 50. (required)
     * @param  int $id (required)
     * @param  int|null $warehouse_id The ID of the warehouse (optional)
     * @param  string|null $created_at_from Get entries with createdAt date after this date (optional)
     * @param  string|null $created_at_to Get entries with createdAt date before this date (optional)
     * @param  int|null $year Get entries from the archive for the given year. All movements older than 3 months are stored in the archive. (optional)
     * @param  int|null $columns The properties to be loaded (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdStockMovementsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestItemsIdVariationsVariationIdStockMovementsGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdStockMovementsGetWithHttpInfo(
        int $item_id,
        int $variation_id,
        int $page,
        int $items_per_page,
        int $id,
        ?int $warehouse_id = null,
        ?string $created_at_from = null,
        ?string $created_at_to = null,
        ?int $year = null,
        ?int $columns = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdStockMovementsGet'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdStockMovementsGetRequest($item_id, $variation_id, $page, $items_per_page, $id, $warehouse_id, $created_at_from, $created_at_to, $year, $columns, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestItemsIdVariationsVariationIdStockMovementsGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestItemsIdVariationsVariationIdStockMovementsGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestItemsIdVariationsVariationIdStockMovementsGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestItemsIdVariationsVariationIdStockMovementsGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestItemsIdVariationsVariationIdStockMovementsGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdStockMovementsGetAsync
     *
     * List stock movements
     *
     * @param  int $item_id The ID of the item (required)
     * @param  int $variation_id The ID of the variation (required)
     * @param  int $page The requested page. The default page that will be returned is page 1. (required)
     * @param  int $items_per_page The number of items per page. The default number per page is 50. (required)
     * @param  int $id (required)
     * @param  int|null $warehouse_id The ID of the warehouse (optional)
     * @param  string|null $created_at_from Get entries with createdAt date after this date (optional)
     * @param  string|null $created_at_to Get entries with createdAt date before this date (optional)
     * @param  int|null $year Get entries from the archive for the given year. All movements older than 3 months are stored in the archive. (optional)
     * @param  int|null $columns The properties to be loaded (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdStockMovementsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdStockMovementsGetAsync(
        int $item_id,
        int $variation_id,
        int $page,
        int $items_per_page,
        int $id,
        ?int $warehouse_id = null,
        ?string $created_at_from = null,
        ?string $created_at_to = null,
        ?int $year = null,
        ?int $columns = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdStockMovementsGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdStockMovementsGetAsyncWithHttpInfo($item_id, $variation_id, $page, $items_per_page, $id, $warehouse_id, $created_at_from, $created_at_to, $year, $columns, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdStockMovementsGetAsyncWithHttpInfo
     *
     * List stock movements
     *
     * @param  int $item_id The ID of the item (required)
     * @param  int $variation_id The ID of the variation (required)
     * @param  int $page The requested page. The default page that will be returned is page 1. (required)
     * @param  int $items_per_page The number of items per page. The default number per page is 50. (required)
     * @param  int $id (required)
     * @param  int|null $warehouse_id The ID of the warehouse (optional)
     * @param  string|null $created_at_from Get entries with createdAt date after this date (optional)
     * @param  string|null $created_at_to Get entries with createdAt date before this date (optional)
     * @param  int|null $year Get entries from the archive for the given year. All movements older than 3 months are stored in the archive. (optional)
     * @param  int|null $columns The properties to be loaded (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdStockMovementsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdStockMovementsGetAsyncWithHttpInfo(
        $item_id,
        $variation_id,
        $page,
        $items_per_page,
        $id,
        $warehouse_id = null,
        $created_at_from = null,
        $created_at_to = null,
        $year = null,
        $columns = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdStockMovementsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestItemsIdVariationsVariationIdStockMovementsGet200Response';
        $request = $this->restItemsIdVariationsVariationIdStockMovementsGetRequest($item_id, $variation_id, $page, $items_per_page, $id, $warehouse_id, $created_at_from, $created_at_to, $year, $columns, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdStockMovementsGet'
     *
     * @param  int $item_id The ID of the item (required)
     * @param  int $variation_id The ID of the variation (required)
     * @param  int $page The requested page. The default page that will be returned is page 1. (required)
     * @param  int $items_per_page The number of items per page. The default number per page is 50. (required)
     * @param  int $id (required)
     * @param  int|null $warehouse_id The ID of the warehouse (optional)
     * @param  string|null $created_at_from Get entries with createdAt date after this date (optional)
     * @param  string|null $created_at_to Get entries with createdAt date before this date (optional)
     * @param  int|null $year Get entries from the archive for the given year. All movements older than 3 months are stored in the archive. (optional)
     * @param  int|null $columns The properties to be loaded (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdStockMovementsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdStockMovementsGetRequest(
        $item_id,
        $variation_id,
        $page,
        $items_per_page,
        $id,
        $warehouse_id = null,
        $created_at_from = null,
        $created_at_to = null,
        $year = null,
        $columns = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdStockMovementsGet'][0]
    ): Request
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $item_id when calling restItemsIdVariationsVariationIdStockMovementsGet'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdStockMovementsGet'
            );
        }

        // verify the required parameter 'page' is set
        if ($page === null || (is_array($page) && count($page) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $page when calling restItemsIdVariationsVariationIdStockMovementsGet'
            );
        }

        // verify the required parameter 'items_per_page' is set
        if ($items_per_page === null || (is_array($items_per_page) && count($items_per_page) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $items_per_page when calling restItemsIdVariationsVariationIdStockMovementsGet'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdStockMovementsGet'
            );
        }







        $resourcePath = '/rest/items/{id}/variations/{variationId}/stock/movements';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $item_id,
            'itemId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $warehouse_id,
            'warehouseId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_at_from,
            'createdAtFrom', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_at_to,
            'createdAtTo', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $year,
            'year', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $items_per_page,
            'itemsPerPage', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $columns,
            'columns', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdStockRedistributePut
     *
     * Redistribute stock
     *
     * @param  int $item_id The ID of the item (required)
     * @param  int $variation_id The ID of the variation (required)
     * @param  int $id id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdStockRedistributePutRequest|null $_rest_items_id_variations_variation_id_stock_redistribute _rest_items_id_variations_variation_id_stock_redistribute (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdStockRedistributePut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestItemsIdVariationsVariationIdStockRedistributePut200Response
     */
    public function restItemsIdVariationsVariationIdStockRedistributePut(
        int $item_id,
        int $variation_id,
        int $id,
        ?\ck\Model\RestItemsIdVariationsVariationIdStockRedistributePutRequest $_rest_items_id_variations_variation_id_stock_redistribute = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdStockRedistributePut'][0]
    ): \ck\Model\RestItemsIdVariationsVariationIdStockRedistributePut200Response
    {
        list($response) = $this->restItemsIdVariationsVariationIdStockRedistributePutWithHttpInfo($item_id, $variation_id, $id, $_rest_items_id_variations_variation_id_stock_redistribute, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdStockRedistributePutWithHttpInfo
     *
     * Redistribute stock
     *
     * @param  int $item_id The ID of the item (required)
     * @param  int $variation_id The ID of the variation (required)
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdStockRedistributePutRequest|null $_rest_items_id_variations_variation_id_stock_redistribute (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdStockRedistributePut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestItemsIdVariationsVariationIdStockRedistributePut200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdStockRedistributePutWithHttpInfo(
        int $item_id,
        int $variation_id,
        int $id,
        ?\ck\Model\RestItemsIdVariationsVariationIdStockRedistributePutRequest $_rest_items_id_variations_variation_id_stock_redistribute = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdStockRedistributePut'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdStockRedistributePutRequest($item_id, $variation_id, $id, $_rest_items_id_variations_variation_id_stock_redistribute, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestItemsIdVariationsVariationIdStockRedistributePut200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestItemsIdVariationsVariationIdStockRedistributePut200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestItemsIdVariationsVariationIdStockRedistributePut200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestItemsIdVariationsVariationIdStockRedistributePut200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestItemsIdVariationsVariationIdStockRedistributePut200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdStockRedistributePutAsync
     *
     * Redistribute stock
     *
     * @param  int $item_id The ID of the item (required)
     * @param  int $variation_id The ID of the variation (required)
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdStockRedistributePutRequest|null $_rest_items_id_variations_variation_id_stock_redistribute (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdStockRedistributePut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdStockRedistributePutAsync(
        int $item_id,
        int $variation_id,
        int $id,
        ?\ck\Model\RestItemsIdVariationsVariationIdStockRedistributePutRequest $_rest_items_id_variations_variation_id_stock_redistribute = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdStockRedistributePut'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdStockRedistributePutAsyncWithHttpInfo($item_id, $variation_id, $id, $_rest_items_id_variations_variation_id_stock_redistribute, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdStockRedistributePutAsyncWithHttpInfo
     *
     * Redistribute stock
     *
     * @param  int $item_id The ID of the item (required)
     * @param  int $variation_id The ID of the variation (required)
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdStockRedistributePutRequest|null $_rest_items_id_variations_variation_id_stock_redistribute (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdStockRedistributePut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdStockRedistributePutAsyncWithHttpInfo(
        $item_id,
        $variation_id,
        $id,
        $_rest_items_id_variations_variation_id_stock_redistribute = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdStockRedistributePut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestItemsIdVariationsVariationIdStockRedistributePut200Response';
        $request = $this->restItemsIdVariationsVariationIdStockRedistributePutRequest($item_id, $variation_id, $id, $_rest_items_id_variations_variation_id_stock_redistribute, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdStockRedistributePut'
     *
     * @param  int $item_id The ID of the item (required)
     * @param  int $variation_id The ID of the variation (required)
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdStockRedistributePutRequest|null $_rest_items_id_variations_variation_id_stock_redistribute (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdStockRedistributePut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdStockRedistributePutRequest(
        $item_id,
        $variation_id,
        $id,
        $_rest_items_id_variations_variation_id_stock_redistribute = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdStockRedistributePut'][0]
    ): Request
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $item_id when calling restItemsIdVariationsVariationIdStockRedistributePut'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdStockRedistributePut'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdStockRedistributePut'
            );
        }



        $resourcePath = '/rest/items/{id}/variations/{variationId}/stock/redistribute';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $item_id,
            'itemId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);


        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_id_variations_variation_id_stock_redistribute)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_id_variations_variation_id_stock_redistribute));
            } else {
                $httpBody = $_rest_items_id_variations_variation_id_stock_redistribute;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdStockStorageLocationsGet
     *
     * List stock of a variation per storage locations
     *
     * @param  int $item_id The ID of the item (required)
     * @param  int $variation_id The ID of the variation (required)
     * @param  int $page The requested page (required)
     * @param  int $items_per_page The number of items per page (required)
     * @param  int $id id (required)
     * @param  int|null $columns The properties to be loaded (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdStockStorageLocationsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestItemsIdVariationsVariationIdStockRedistributePut200Response
     */
    public function restItemsIdVariationsVariationIdStockStorageLocationsGet(
        int $item_id,
        int $variation_id,
        int $page,
        int $items_per_page,
        int $id,
        ?int $columns = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdStockStorageLocationsGet'][0]
    ): \ck\Model\RestItemsIdVariationsVariationIdStockRedistributePut200Response
    {
        list($response) = $this->restItemsIdVariationsVariationIdStockStorageLocationsGetWithHttpInfo($item_id, $variation_id, $page, $items_per_page, $id, $columns, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdStockStorageLocationsGetWithHttpInfo
     *
     * List stock of a variation per storage locations
     *
     * @param  int $item_id The ID of the item (required)
     * @param  int $variation_id The ID of the variation (required)
     * @param  int $page The requested page (required)
     * @param  int $items_per_page The number of items per page (required)
     * @param  int $id (required)
     * @param  int|null $columns The properties to be loaded (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdStockStorageLocationsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestItemsIdVariationsVariationIdStockRedistributePut200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdStockStorageLocationsGetWithHttpInfo(
        int $item_id,
        int $variation_id,
        int $page,
        int $items_per_page,
        int $id,
        ?int $columns = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdStockStorageLocationsGet'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdStockStorageLocationsGetRequest($item_id, $variation_id, $page, $items_per_page, $id, $columns, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestItemsIdVariationsVariationIdStockRedistributePut200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestItemsIdVariationsVariationIdStockRedistributePut200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestItemsIdVariationsVariationIdStockRedistributePut200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestItemsIdVariationsVariationIdStockRedistributePut200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestItemsIdVariationsVariationIdStockRedistributePut200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdStockStorageLocationsGetAsync
     *
     * List stock of a variation per storage locations
     *
     * @param  int $item_id The ID of the item (required)
     * @param  int $variation_id The ID of the variation (required)
     * @param  int $page The requested page (required)
     * @param  int $items_per_page The number of items per page (required)
     * @param  int $id (required)
     * @param  int|null $columns The properties to be loaded (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdStockStorageLocationsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdStockStorageLocationsGetAsync(
        int $item_id,
        int $variation_id,
        int $page,
        int $items_per_page,
        int $id,
        ?int $columns = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdStockStorageLocationsGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdStockStorageLocationsGetAsyncWithHttpInfo($item_id, $variation_id, $page, $items_per_page, $id, $columns, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdStockStorageLocationsGetAsyncWithHttpInfo
     *
     * List stock of a variation per storage locations
     *
     * @param  int $item_id The ID of the item (required)
     * @param  int $variation_id The ID of the variation (required)
     * @param  int $page The requested page (required)
     * @param  int $items_per_page The number of items per page (required)
     * @param  int $id (required)
     * @param  int|null $columns The properties to be loaded (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdStockStorageLocationsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdStockStorageLocationsGetAsyncWithHttpInfo(
        $item_id,
        $variation_id,
        $page,
        $items_per_page,
        $id,
        $columns = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdStockStorageLocationsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestItemsIdVariationsVariationIdStockRedistributePut200Response';
        $request = $this->restItemsIdVariationsVariationIdStockStorageLocationsGetRequest($item_id, $variation_id, $page, $items_per_page, $id, $columns, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdStockStorageLocationsGet'
     *
     * @param  int $item_id The ID of the item (required)
     * @param  int $variation_id The ID of the variation (required)
     * @param  int $page The requested page (required)
     * @param  int $items_per_page The number of items per page (required)
     * @param  int $id (required)
     * @param  int|null $columns The properties to be loaded (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdStockStorageLocationsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdStockStorageLocationsGetRequest(
        $item_id,
        $variation_id,
        $page,
        $items_per_page,
        $id,
        $columns = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdStockStorageLocationsGet'][0]
    ): Request
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $item_id when calling restItemsIdVariationsVariationIdStockStorageLocationsGet'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdStockStorageLocationsGet'
            );
        }

        // verify the required parameter 'page' is set
        if ($page === null || (is_array($page) && count($page) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $page when calling restItemsIdVariationsVariationIdStockStorageLocationsGet'
            );
        }

        // verify the required parameter 'items_per_page' is set
        if ($items_per_page === null || (is_array($items_per_page) && count($items_per_page) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $items_per_page when calling restItemsIdVariationsVariationIdStockStorageLocationsGet'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdStockStorageLocationsGet'
            );
        }



        $resourcePath = '/rest/items/{id}/variations/{variationId}/stock/storageLocations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $item_id,
            'itemId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $items_per_page,
            'itemsPerPage', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $columns,
            'columns', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdDelete
     *
     * Delete an additional SKU
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  int $additional_sku_id additional_sku_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdDelete(
        int $id,
        int $variation_id,
        int $additional_sku_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdDelete'][0]
    ): object
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdDeleteWithHttpInfo($id, $variation_id, $additional_sku_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdDeleteWithHttpInfo
     *
     * Delete an additional SKU
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $additional_sku_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdDeleteWithHttpInfo(
        int $id,
        int $variation_id,
        int $additional_sku_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdDelete'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdDeleteRequest($id, $variation_id, $additional_sku_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdDeleteAsync
     *
     * Delete an additional SKU
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $additional_sku_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdDeleteAsync(
        int $id,
        int $variation_id,
        int $additional_sku_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdDeleteAsyncWithHttpInfo($id, $variation_id, $additional_sku_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdDeleteAsyncWithHttpInfo
     *
     * Delete an additional SKU
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $additional_sku_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdDeleteAsyncWithHttpInfo(
        $id,
        $variation_id,
        $additional_sku_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdDeleteRequest($id, $variation_id, $additional_sku_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdDelete'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $additional_sku_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdDeleteRequest(
        $id,
        $variation_id,
        $additional_sku_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdDelete'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdDelete'
            );
        }

        // verify the required parameter 'additional_sku_id' is set
        if ($additional_sku_id === null || (is_array($additional_sku_id) && count($additional_sku_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $additional_sku_id when calling restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdDelete'
            );
        }


        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_additional_skus/{additionalSkuId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }
        // path params
        if ($additional_sku_id !== null) {
            $resourcePath = str_replace(
                '{' . 'additionalSkuId' . '}',
                ObjectSerializer::toPathValue($additional_sku_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdGet
     *
     * Gets an additional SKU
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  int $additional_sku_id additional_sku_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationAdditionalSku
     */
    public function restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdGet(
        int $id,
        int $variation_id,
        int $additional_sku_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdGet'][0]
    ): \ck\Model\VariationAdditionalSku
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdGetWithHttpInfo($id, $variation_id, $additional_sku_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdGetWithHttpInfo
     *
     * Gets an additional SKU
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $additional_sku_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationAdditionalSku, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdGetWithHttpInfo(
        int $id,
        int $variation_id,
        int $additional_sku_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdGet'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdGetRequest($id, $variation_id, $additional_sku_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationAdditionalSku' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationAdditionalSku' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationAdditionalSku', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationAdditionalSku';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationAdditionalSku',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdGetAsync
     *
     * Gets an additional SKU
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $additional_sku_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdGetAsync(
        int $id,
        int $variation_id,
        int $additional_sku_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdGetAsyncWithHttpInfo($id, $variation_id, $additional_sku_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdGetAsyncWithHttpInfo
     *
     * Gets an additional SKU
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $additional_sku_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdGetAsyncWithHttpInfo(
        $id,
        $variation_id,
        $additional_sku_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationAdditionalSku';
        $request = $this->restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdGetRequest($id, $variation_id, $additional_sku_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdGet'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $additional_sku_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdGetRequest(
        $id,
        $variation_id,
        $additional_sku_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdGet'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdGet'
            );
        }

        // verify the required parameter 'additional_sku_id' is set
        if ($additional_sku_id === null || (is_array($additional_sku_id) && count($additional_sku_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $additional_sku_id when calling restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdGet'
            );
        }


        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_additional_skus/{additionalSkuId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }
        // path params
        if ($additional_sku_id !== null) {
            $resourcePath = str_replace(
                '{' . 'additionalSkuId' . '}',
                ObjectSerializer::toPathValue($additional_sku_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdPut
     *
     * Update an additional SKU
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  int $additional_sku_id additional_sku_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdVariationAdditionalSkusGetRequest|null $_rest_items_id_variations_variation_id_variation_additional_skus_additional_sku_id _rest_items_id_variations_variation_id_variation_additional_skus_additional_sku_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationAdditionalSku
     */
    public function restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdPut(
        int $id,
        int $variation_id,
        int $additional_sku_id,
        ?\ck\Model\RestItemsIdVariationsVariationIdVariationAdditionalSkusGetRequest $_rest_items_id_variations_variation_id_variation_additional_skus_additional_sku_id = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdPut'][0]
    ): \ck\Model\VariationAdditionalSku
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdPutWithHttpInfo($id, $variation_id, $additional_sku_id, $_rest_items_id_variations_variation_id_variation_additional_skus_additional_sku_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdPutWithHttpInfo
     *
     * Update an additional SKU
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $additional_sku_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdVariationAdditionalSkusGetRequest|null $_rest_items_id_variations_variation_id_variation_additional_skus_additional_sku_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationAdditionalSku, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdPutWithHttpInfo(
        int $id,
        int $variation_id,
        int $additional_sku_id,
        ?\ck\Model\RestItemsIdVariationsVariationIdVariationAdditionalSkusGetRequest $_rest_items_id_variations_variation_id_variation_additional_skus_additional_sku_id = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdPut'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdPutRequest($id, $variation_id, $additional_sku_id, $_rest_items_id_variations_variation_id_variation_additional_skus_additional_sku_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationAdditionalSku' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationAdditionalSku' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationAdditionalSku', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationAdditionalSku';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationAdditionalSku',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdPutAsync
     *
     * Update an additional SKU
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $additional_sku_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdVariationAdditionalSkusGetRequest|null $_rest_items_id_variations_variation_id_variation_additional_skus_additional_sku_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdPutAsync(
        int $id,
        int $variation_id,
        int $additional_sku_id,
        ?\ck\Model\RestItemsIdVariationsVariationIdVariationAdditionalSkusGetRequest $_rest_items_id_variations_variation_id_variation_additional_skus_additional_sku_id = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdPut'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdPutAsyncWithHttpInfo($id, $variation_id, $additional_sku_id, $_rest_items_id_variations_variation_id_variation_additional_skus_additional_sku_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdPutAsyncWithHttpInfo
     *
     * Update an additional SKU
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $additional_sku_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdVariationAdditionalSkusGetRequest|null $_rest_items_id_variations_variation_id_variation_additional_skus_additional_sku_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdPutAsyncWithHttpInfo(
        $id,
        $variation_id,
        $additional_sku_id,
        $_rest_items_id_variations_variation_id_variation_additional_skus_additional_sku_id = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationAdditionalSku';
        $request = $this->restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdPutRequest($id, $variation_id, $additional_sku_id, $_rest_items_id_variations_variation_id_variation_additional_skus_additional_sku_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdPut'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $additional_sku_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdVariationAdditionalSkusGetRequest|null $_rest_items_id_variations_variation_id_variation_additional_skus_additional_sku_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdPutRequest(
        $id,
        $variation_id,
        $additional_sku_id,
        $_rest_items_id_variations_variation_id_variation_additional_skus_additional_sku_id = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdPut'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdPut'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdPut'
            );
        }

        // verify the required parameter 'additional_sku_id' is set
        if ($additional_sku_id === null || (is_array($additional_sku_id) && count($additional_sku_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $additional_sku_id when calling restItemsIdVariationsVariationIdVariationAdditionalSkusAdditionalSkuIdPut'
            );
        }



        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_additional_skus/{additionalSkuId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }
        // path params
        if ($additional_sku_id !== null) {
            $resourcePath = str_replace(
                '{' . 'additionalSkuId' . '}',
                ObjectSerializer::toPathValue($additional_sku_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_id_variations_variation_id_variation_additional_skus_additional_sku_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_id_variations_variation_id_variation_additional_skus_additional_sku_id));
            } else {
                $httpBody = $_rest_items_id_variations_variation_id_variation_additional_skus_additional_sku_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationAdditionalSkusGet
     *
     * List additional SKUs
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdVariationAdditionalSkusGetRequest|null $_rest_items_id_variations_variation_id_variation_additional_skus _rest_items_id_variations_variation_id_variation_additional_skus (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationAdditionalSkusGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationAdditionalSku[]
     */
    public function restItemsIdVariationsVariationIdVariationAdditionalSkusGet(
        int $id,
        int $variation_id,
        ?\ck\Model\RestItemsIdVariationsVariationIdVariationAdditionalSkusGetRequest $_rest_items_id_variations_variation_id_variation_additional_skus = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationAdditionalSkusGet'][0]
    ): array
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationAdditionalSkusGetWithHttpInfo($id, $variation_id, $_rest_items_id_variations_variation_id_variation_additional_skus, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationAdditionalSkusGetWithHttpInfo
     *
     * List additional SKUs
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdVariationAdditionalSkusGetRequest|null $_rest_items_id_variations_variation_id_variation_additional_skus (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationAdditionalSkusGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationAdditionalSku[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationAdditionalSkusGetWithHttpInfo(
        int $id,
        int $variation_id,
        ?\ck\Model\RestItemsIdVariationsVariationIdVariationAdditionalSkusGetRequest $_rest_items_id_variations_variation_id_variation_additional_skus = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationAdditionalSkusGet'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationAdditionalSkusGetRequest($id, $variation_id, $_rest_items_id_variations_variation_id_variation_additional_skus, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationAdditionalSku[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationAdditionalSku[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationAdditionalSku[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationAdditionalSku[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationAdditionalSku[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationAdditionalSkusGetAsync
     *
     * List additional SKUs
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdVariationAdditionalSkusGetRequest|null $_rest_items_id_variations_variation_id_variation_additional_skus (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationAdditionalSkusGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationAdditionalSkusGetAsync(
        int $id,
        int $variation_id,
        ?\ck\Model\RestItemsIdVariationsVariationIdVariationAdditionalSkusGetRequest $_rest_items_id_variations_variation_id_variation_additional_skus = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationAdditionalSkusGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationAdditionalSkusGetAsyncWithHttpInfo($id, $variation_id, $_rest_items_id_variations_variation_id_variation_additional_skus, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationAdditionalSkusGetAsyncWithHttpInfo
     *
     * List additional SKUs
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdVariationAdditionalSkusGetRequest|null $_rest_items_id_variations_variation_id_variation_additional_skus (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationAdditionalSkusGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationAdditionalSkusGetAsyncWithHttpInfo(
        $id,
        $variation_id,
        $_rest_items_id_variations_variation_id_variation_additional_skus = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationAdditionalSkusGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationAdditionalSku[]';
        $request = $this->restItemsIdVariationsVariationIdVariationAdditionalSkusGetRequest($id, $variation_id, $_rest_items_id_variations_variation_id_variation_additional_skus, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationAdditionalSkusGet'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdVariationAdditionalSkusGetRequest|null $_rest_items_id_variations_variation_id_variation_additional_skus (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationAdditionalSkusGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationAdditionalSkusGetRequest(
        $id,
        $variation_id,
        $_rest_items_id_variations_variation_id_variation_additional_skus = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationAdditionalSkusGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationAdditionalSkusGet'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationAdditionalSkusGet'
            );
        }



        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_additional_skus';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_id_variations_variation_id_variation_additional_skus)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_id_variations_variation_id_variation_additional_skus));
            } else {
                $httpBody = $_rest_items_id_variations_variation_id_variation_additional_skus;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationAdditionalSkusPost
     *
     * Create an additional SKU
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdVariationAdditionalSkusGetRequest|null $_rest_items_id_variations_variation_id_variation_additional_skus _rest_items_id_variations_variation_id_variation_additional_skus (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationAdditionalSkusPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationAdditionalSku
     */
    public function restItemsIdVariationsVariationIdVariationAdditionalSkusPost(
        int $id,
        int $variation_id,
        ?\ck\Model\RestItemsIdVariationsVariationIdVariationAdditionalSkusGetRequest $_rest_items_id_variations_variation_id_variation_additional_skus = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationAdditionalSkusPost'][0]
    ): \ck\Model\VariationAdditionalSku
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationAdditionalSkusPostWithHttpInfo($id, $variation_id, $_rest_items_id_variations_variation_id_variation_additional_skus, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationAdditionalSkusPostWithHttpInfo
     *
     * Create an additional SKU
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdVariationAdditionalSkusGetRequest|null $_rest_items_id_variations_variation_id_variation_additional_skus (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationAdditionalSkusPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationAdditionalSku, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationAdditionalSkusPostWithHttpInfo(
        int $id,
        int $variation_id,
        ?\ck\Model\RestItemsIdVariationsVariationIdVariationAdditionalSkusGetRequest $_rest_items_id_variations_variation_id_variation_additional_skus = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationAdditionalSkusPost'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationAdditionalSkusPostRequest($id, $variation_id, $_rest_items_id_variations_variation_id_variation_additional_skus, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationAdditionalSku' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationAdditionalSku' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationAdditionalSku', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationAdditionalSku';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationAdditionalSku',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationAdditionalSkusPostAsync
     *
     * Create an additional SKU
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdVariationAdditionalSkusGetRequest|null $_rest_items_id_variations_variation_id_variation_additional_skus (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationAdditionalSkusPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationAdditionalSkusPostAsync(
        int $id,
        int $variation_id,
        ?\ck\Model\RestItemsIdVariationsVariationIdVariationAdditionalSkusGetRequest $_rest_items_id_variations_variation_id_variation_additional_skus = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationAdditionalSkusPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationAdditionalSkusPostAsyncWithHttpInfo($id, $variation_id, $_rest_items_id_variations_variation_id_variation_additional_skus, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationAdditionalSkusPostAsyncWithHttpInfo
     *
     * Create an additional SKU
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdVariationAdditionalSkusGetRequest|null $_rest_items_id_variations_variation_id_variation_additional_skus (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationAdditionalSkusPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationAdditionalSkusPostAsyncWithHttpInfo(
        $id,
        $variation_id,
        $_rest_items_id_variations_variation_id_variation_additional_skus = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationAdditionalSkusPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationAdditionalSku';
        $request = $this->restItemsIdVariationsVariationIdVariationAdditionalSkusPostRequest($id, $variation_id, $_rest_items_id_variations_variation_id_variation_additional_skus, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationAdditionalSkusPost'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdVariationAdditionalSkusGetRequest|null $_rest_items_id_variations_variation_id_variation_additional_skus (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationAdditionalSkusPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationAdditionalSkusPostRequest(
        $id,
        $variation_id,
        $_rest_items_id_variations_variation_id_variation_additional_skus = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationAdditionalSkusPost'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationAdditionalSkusPost'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationAdditionalSkusPost'
            );
        }



        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_additional_skus';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_id_variations_variation_id_variation_additional_skus)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_id_variations_variation_id_variation_additional_skus));
            } else {
                $httpBody = $_rest_items_id_variations_variation_id_variation_additional_skus;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdDelete
     *
     * Delete a variation barcode
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  int $barcode_id barcode_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdDelete(
        int $id,
        int $variation_id,
        int $barcode_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdDelete'][0]
    ): object
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdDeleteWithHttpInfo($id, $variation_id, $barcode_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdDeleteWithHttpInfo
     *
     * Delete a variation barcode
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $barcode_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdDeleteWithHttpInfo(
        int $id,
        int $variation_id,
        int $barcode_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdDelete'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdDeleteRequest($id, $variation_id, $barcode_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdDeleteAsync
     *
     * Delete a variation barcode
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $barcode_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdDeleteAsync(
        int $id,
        int $variation_id,
        int $barcode_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdDeleteAsyncWithHttpInfo($id, $variation_id, $barcode_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdDeleteAsyncWithHttpInfo
     *
     * Delete a variation barcode
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $barcode_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdDeleteAsyncWithHttpInfo(
        $id,
        $variation_id,
        $barcode_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdDeleteRequest($id, $variation_id, $barcode_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdDelete'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $barcode_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdDeleteRequest(
        $id,
        $variation_id,
        $barcode_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdDelete'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdDelete'
            );
        }

        // verify the required parameter 'barcode_id' is set
        if ($barcode_id === null || (is_array($barcode_id) && count($barcode_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $barcode_id when calling restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdDelete'
            );
        }


        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_barcodes/{barcodeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }
        // path params
        if ($barcode_id !== null) {
            $resourcePath = str_replace(
                '{' . 'barcodeId' . '}',
                ObjectSerializer::toPathValue($barcode_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdGet
     *
     * Get a variation barcode
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  int $barcode_id barcode_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationBarcode
     */
    public function restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdGet(
        int $id,
        int $variation_id,
        int $barcode_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdGet'][0]
    ): \ck\Model\VariationBarcode
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdGetWithHttpInfo($id, $variation_id, $barcode_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdGetWithHttpInfo
     *
     * Get a variation barcode
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $barcode_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationBarcode, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdGetWithHttpInfo(
        int $id,
        int $variation_id,
        int $barcode_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdGet'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdGetRequest($id, $variation_id, $barcode_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationBarcode' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationBarcode' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationBarcode', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationBarcode';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationBarcode',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdGetAsync
     *
     * Get a variation barcode
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $barcode_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdGetAsync(
        int $id,
        int $variation_id,
        int $barcode_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdGetAsyncWithHttpInfo($id, $variation_id, $barcode_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdGetAsyncWithHttpInfo
     *
     * Get a variation barcode
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $barcode_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdGetAsyncWithHttpInfo(
        $id,
        $variation_id,
        $barcode_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationBarcode';
        $request = $this->restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdGetRequest($id, $variation_id, $barcode_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdGet'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $barcode_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdGetRequest(
        $id,
        $variation_id,
        $barcode_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdGet'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdGet'
            );
        }

        // verify the required parameter 'barcode_id' is set
        if ($barcode_id === null || (is_array($barcode_id) && count($barcode_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $barcode_id when calling restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdGet'
            );
        }


        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_barcodes/{barcodeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }
        // path params
        if ($barcode_id !== null) {
            $resourcePath = str_replace(
                '{' . 'barcodeId' . '}',
                ObjectSerializer::toPathValue($barcode_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdPut
     *
     * Update a variation barcode
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  int $barcode_id barcode_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdVariationBarcodesPostRequest|null $_rest_items_id_variations_variation_id_variation_barcodes_barcode_id _rest_items_id_variations_variation_id_variation_barcodes_barcode_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationBarcode
     */
    public function restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdPut(
        int $id,
        int $variation_id,
        int $barcode_id,
        ?\ck\Model\RestItemsIdVariationsVariationIdVariationBarcodesPostRequest $_rest_items_id_variations_variation_id_variation_barcodes_barcode_id = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdPut'][0]
    ): \ck\Model\VariationBarcode
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdPutWithHttpInfo($id, $variation_id, $barcode_id, $_rest_items_id_variations_variation_id_variation_barcodes_barcode_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdPutWithHttpInfo
     *
     * Update a variation barcode
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $barcode_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdVariationBarcodesPostRequest|null $_rest_items_id_variations_variation_id_variation_barcodes_barcode_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationBarcode, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdPutWithHttpInfo(
        int $id,
        int $variation_id,
        int $barcode_id,
        ?\ck\Model\RestItemsIdVariationsVariationIdVariationBarcodesPostRequest $_rest_items_id_variations_variation_id_variation_barcodes_barcode_id = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdPut'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdPutRequest($id, $variation_id, $barcode_id, $_rest_items_id_variations_variation_id_variation_barcodes_barcode_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationBarcode' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationBarcode' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationBarcode', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationBarcode';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationBarcode',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdPutAsync
     *
     * Update a variation barcode
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $barcode_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdVariationBarcodesPostRequest|null $_rest_items_id_variations_variation_id_variation_barcodes_barcode_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdPutAsync(
        int $id,
        int $variation_id,
        int $barcode_id,
        ?\ck\Model\RestItemsIdVariationsVariationIdVariationBarcodesPostRequest $_rest_items_id_variations_variation_id_variation_barcodes_barcode_id = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdPut'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdPutAsyncWithHttpInfo($id, $variation_id, $barcode_id, $_rest_items_id_variations_variation_id_variation_barcodes_barcode_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdPutAsyncWithHttpInfo
     *
     * Update a variation barcode
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $barcode_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdVariationBarcodesPostRequest|null $_rest_items_id_variations_variation_id_variation_barcodes_barcode_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdPutAsyncWithHttpInfo(
        $id,
        $variation_id,
        $barcode_id,
        $_rest_items_id_variations_variation_id_variation_barcodes_barcode_id = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationBarcode';
        $request = $this->restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdPutRequest($id, $variation_id, $barcode_id, $_rest_items_id_variations_variation_id_variation_barcodes_barcode_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdPut'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $barcode_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdVariationBarcodesPostRequest|null $_rest_items_id_variations_variation_id_variation_barcodes_barcode_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdPutRequest(
        $id,
        $variation_id,
        $barcode_id,
        $_rest_items_id_variations_variation_id_variation_barcodes_barcode_id = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdPut'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdPut'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdPut'
            );
        }

        // verify the required parameter 'barcode_id' is set
        if ($barcode_id === null || (is_array($barcode_id) && count($barcode_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $barcode_id when calling restItemsIdVariationsVariationIdVariationBarcodesBarcodeIdPut'
            );
        }



        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_barcodes/{barcodeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }
        // path params
        if ($barcode_id !== null) {
            $resourcePath = str_replace(
                '{' . 'barcodeId' . '}',
                ObjectSerializer::toPathValue($barcode_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_id_variations_variation_id_variation_barcodes_barcode_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_id_variations_variation_id_variation_barcodes_barcode_id));
            } else {
                $httpBody = $_rest_items_id_variations_variation_id_variation_barcodes_barcode_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationBarcodesGet
     *
     * List variation barcodes
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  string|null $with Includes the specified variation barcode information in the results. The following parameter is available: &lt;ul&gt;&lt;li&gt;barcode&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationBarcodesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationBarcode[]
     */
    public function restItemsIdVariationsVariationIdVariationBarcodesGet(
        int $id,
        int $variation_id,
        ?string $with = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationBarcodesGet'][0]
    ): array
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationBarcodesGetWithHttpInfo($id, $variation_id, $with, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationBarcodesGetWithHttpInfo
     *
     * List variation barcodes
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string|null $with Includes the specified variation barcode information in the results. The following parameter is available: &lt;ul&gt;&lt;li&gt;barcode&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationBarcodesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationBarcode[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationBarcodesGetWithHttpInfo(
        int $id,
        int $variation_id,
        ?string $with = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationBarcodesGet'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationBarcodesGetRequest($id, $variation_id, $with, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationBarcode[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationBarcode[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationBarcode[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationBarcode[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationBarcode[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationBarcodesGetAsync
     *
     * List variation barcodes
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string|null $with Includes the specified variation barcode information in the results. The following parameter is available: &lt;ul&gt;&lt;li&gt;barcode&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationBarcodesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationBarcodesGetAsync(
        int $id,
        int $variation_id,
        ?string $with = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationBarcodesGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationBarcodesGetAsyncWithHttpInfo($id, $variation_id, $with, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationBarcodesGetAsyncWithHttpInfo
     *
     * List variation barcodes
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string|null $with Includes the specified variation barcode information in the results. The following parameter is available: &lt;ul&gt;&lt;li&gt;barcode&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationBarcodesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationBarcodesGetAsyncWithHttpInfo(
        $id,
        $variation_id,
        $with = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationBarcodesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationBarcode[]';
        $request = $this->restItemsIdVariationsVariationIdVariationBarcodesGetRequest($id, $variation_id, $with, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationBarcodesGet'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string|null $with Includes the specified variation barcode information in the results. The following parameter is available: &lt;ul&gt;&lt;li&gt;barcode&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationBarcodesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationBarcodesGetRequest(
        $id,
        $variation_id,
        $with = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationBarcodesGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationBarcodesGet'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationBarcodesGet'
            );
        }



        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_barcodes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationBarcodesPost
     *
     * Create a variation barcode
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdVariationBarcodesPostRequest|null $_rest_items_id_variations_variation_id_variation_barcodes _rest_items_id_variations_variation_id_variation_barcodes (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationBarcodesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationBarcode
     */
    public function restItemsIdVariationsVariationIdVariationBarcodesPost(
        int $id,
        int $variation_id,
        ?\ck\Model\RestItemsIdVariationsVariationIdVariationBarcodesPostRequest $_rest_items_id_variations_variation_id_variation_barcodes = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationBarcodesPost'][0]
    ): \ck\Model\VariationBarcode
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationBarcodesPostWithHttpInfo($id, $variation_id, $_rest_items_id_variations_variation_id_variation_barcodes, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationBarcodesPostWithHttpInfo
     *
     * Create a variation barcode
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdVariationBarcodesPostRequest|null $_rest_items_id_variations_variation_id_variation_barcodes (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationBarcodesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationBarcode, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationBarcodesPostWithHttpInfo(
        int $id,
        int $variation_id,
        ?\ck\Model\RestItemsIdVariationsVariationIdVariationBarcodesPostRequest $_rest_items_id_variations_variation_id_variation_barcodes = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationBarcodesPost'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationBarcodesPostRequest($id, $variation_id, $_rest_items_id_variations_variation_id_variation_barcodes, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationBarcode' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationBarcode' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationBarcode', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationBarcode';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationBarcode',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationBarcodesPostAsync
     *
     * Create a variation barcode
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdVariationBarcodesPostRequest|null $_rest_items_id_variations_variation_id_variation_barcodes (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationBarcodesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationBarcodesPostAsync(
        int $id,
        int $variation_id,
        ?\ck\Model\RestItemsIdVariationsVariationIdVariationBarcodesPostRequest $_rest_items_id_variations_variation_id_variation_barcodes = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationBarcodesPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationBarcodesPostAsyncWithHttpInfo($id, $variation_id, $_rest_items_id_variations_variation_id_variation_barcodes, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationBarcodesPostAsyncWithHttpInfo
     *
     * Create a variation barcode
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdVariationBarcodesPostRequest|null $_rest_items_id_variations_variation_id_variation_barcodes (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationBarcodesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationBarcodesPostAsyncWithHttpInfo(
        $id,
        $variation_id,
        $_rest_items_id_variations_variation_id_variation_barcodes = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationBarcodesPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationBarcode';
        $request = $this->restItemsIdVariationsVariationIdVariationBarcodesPostRequest($id, $variation_id, $_rest_items_id_variations_variation_id_variation_barcodes, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationBarcodesPost'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdVariationBarcodesPostRequest|null $_rest_items_id_variations_variation_id_variation_barcodes (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationBarcodesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationBarcodesPostRequest(
        $id,
        $variation_id,
        $_rest_items_id_variations_variation_id_variation_barcodes = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationBarcodesPost'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationBarcodesPost'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationBarcodesPost'
            );
        }



        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_barcodes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_id_variations_variation_id_variation_barcodes)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_id_variations_variation_id_variation_barcodes));
            } else {
                $httpBody = $_rest_items_id_variations_variation_id_variation_barcodes;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationBundlesBundleIdDelete
     *
     * Remove a bundle component
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  int $bundle_id bundle_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationBundlesBundleIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsIdVariationsVariationIdVariationBundlesBundleIdDelete(
        int $id,
        int $variation_id,
        int $bundle_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationBundlesBundleIdDelete'][0]
    ): object
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationBundlesBundleIdDeleteWithHttpInfo($id, $variation_id, $bundle_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationBundlesBundleIdDeleteWithHttpInfo
     *
     * Remove a bundle component
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $bundle_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationBundlesBundleIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationBundlesBundleIdDeleteWithHttpInfo(
        int $id,
        int $variation_id,
        int $bundle_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationBundlesBundleIdDelete'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationBundlesBundleIdDeleteRequest($id, $variation_id, $bundle_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationBundlesBundleIdDeleteAsync
     *
     * Remove a bundle component
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $bundle_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationBundlesBundleIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationBundlesBundleIdDeleteAsync(
        int $id,
        int $variation_id,
        int $bundle_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationBundlesBundleIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationBundlesBundleIdDeleteAsyncWithHttpInfo($id, $variation_id, $bundle_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationBundlesBundleIdDeleteAsyncWithHttpInfo
     *
     * Remove a bundle component
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $bundle_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationBundlesBundleIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationBundlesBundleIdDeleteAsyncWithHttpInfo(
        $id,
        $variation_id,
        $bundle_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationBundlesBundleIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsIdVariationsVariationIdVariationBundlesBundleIdDeleteRequest($id, $variation_id, $bundle_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationBundlesBundleIdDelete'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $bundle_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationBundlesBundleIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationBundlesBundleIdDeleteRequest(
        $id,
        $variation_id,
        $bundle_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationBundlesBundleIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationBundlesBundleIdDelete'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationBundlesBundleIdDelete'
            );
        }

        // verify the required parameter 'bundle_id' is set
        if ($bundle_id === null || (is_array($bundle_id) && count($bundle_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $bundle_id when calling restItemsIdVariationsVariationIdVariationBundlesBundleIdDelete'
            );
        }


        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_bundles/{bundleId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }
        // path params
        if ($bundle_id !== null) {
            $resourcePath = str_replace(
                '{' . 'bundleId' . '}',
                ObjectSerializer::toPathValue($bundle_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationBundlesBundleIdGet
     *
     * Get a variation bundle
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  int $bundle_id bundle_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationBundlesBundleIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationBundle
     */
    public function restItemsIdVariationsVariationIdVariationBundlesBundleIdGet(
        int $id,
        int $variation_id,
        int $bundle_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationBundlesBundleIdGet'][0]
    ): \ck\Model\VariationBundle
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationBundlesBundleIdGetWithHttpInfo($id, $variation_id, $bundle_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationBundlesBundleIdGetWithHttpInfo
     *
     * Get a variation bundle
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $bundle_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationBundlesBundleIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationBundle, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationBundlesBundleIdGetWithHttpInfo(
        int $id,
        int $variation_id,
        int $bundle_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationBundlesBundleIdGet'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationBundlesBundleIdGetRequest($id, $variation_id, $bundle_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationBundle' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationBundle' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationBundle', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationBundle';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationBundle',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationBundlesBundleIdGetAsync
     *
     * Get a variation bundle
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $bundle_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationBundlesBundleIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationBundlesBundleIdGetAsync(
        int $id,
        int $variation_id,
        int $bundle_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationBundlesBundleIdGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationBundlesBundleIdGetAsyncWithHttpInfo($id, $variation_id, $bundle_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationBundlesBundleIdGetAsyncWithHttpInfo
     *
     * Get a variation bundle
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $bundle_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationBundlesBundleIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationBundlesBundleIdGetAsyncWithHttpInfo(
        $id,
        $variation_id,
        $bundle_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationBundlesBundleIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationBundle';
        $request = $this->restItemsIdVariationsVariationIdVariationBundlesBundleIdGetRequest($id, $variation_id, $bundle_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationBundlesBundleIdGet'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $bundle_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationBundlesBundleIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationBundlesBundleIdGetRequest(
        $id,
        $variation_id,
        $bundle_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationBundlesBundleIdGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationBundlesBundleIdGet'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationBundlesBundleIdGet'
            );
        }

        // verify the required parameter 'bundle_id' is set
        if ($bundle_id === null || (is_array($bundle_id) && count($bundle_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $bundle_id when calling restItemsIdVariationsVariationIdVariationBundlesBundleIdGet'
            );
        }


        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_bundles/{bundleId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }
        // path params
        if ($bundle_id !== null) {
            $resourcePath = str_replace(
                '{' . 'bundleId' . '}',
                ObjectSerializer::toPathValue($bundle_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationBundlesBundleIdPut
     *
     * Update a variation bundle
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  int $bundle_id bundle_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdVariationBundlesPostRequest|null $_rest_items_id_variations_variation_id_variation_bundles_bundle_id _rest_items_id_variations_variation_id_variation_bundles_bundle_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationBundlesBundleIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationBundle
     */
    public function restItemsIdVariationsVariationIdVariationBundlesBundleIdPut(
        int $id,
        int $variation_id,
        int $bundle_id,
        ?\ck\Model\RestItemsIdVariationsVariationIdVariationBundlesPostRequest $_rest_items_id_variations_variation_id_variation_bundles_bundle_id = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationBundlesBundleIdPut'][0]
    ): \ck\Model\VariationBundle
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationBundlesBundleIdPutWithHttpInfo($id, $variation_id, $bundle_id, $_rest_items_id_variations_variation_id_variation_bundles_bundle_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationBundlesBundleIdPutWithHttpInfo
     *
     * Update a variation bundle
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $bundle_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdVariationBundlesPostRequest|null $_rest_items_id_variations_variation_id_variation_bundles_bundle_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationBundlesBundleIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationBundle, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationBundlesBundleIdPutWithHttpInfo(
        int $id,
        int $variation_id,
        int $bundle_id,
        ?\ck\Model\RestItemsIdVariationsVariationIdVariationBundlesPostRequest $_rest_items_id_variations_variation_id_variation_bundles_bundle_id = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationBundlesBundleIdPut'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationBundlesBundleIdPutRequest($id, $variation_id, $bundle_id, $_rest_items_id_variations_variation_id_variation_bundles_bundle_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationBundle' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationBundle' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationBundle', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationBundle';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationBundle',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationBundlesBundleIdPutAsync
     *
     * Update a variation bundle
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $bundle_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdVariationBundlesPostRequest|null $_rest_items_id_variations_variation_id_variation_bundles_bundle_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationBundlesBundleIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationBundlesBundleIdPutAsync(
        int $id,
        int $variation_id,
        int $bundle_id,
        ?\ck\Model\RestItemsIdVariationsVariationIdVariationBundlesPostRequest $_rest_items_id_variations_variation_id_variation_bundles_bundle_id = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationBundlesBundleIdPut'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationBundlesBundleIdPutAsyncWithHttpInfo($id, $variation_id, $bundle_id, $_rest_items_id_variations_variation_id_variation_bundles_bundle_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationBundlesBundleIdPutAsyncWithHttpInfo
     *
     * Update a variation bundle
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $bundle_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdVariationBundlesPostRequest|null $_rest_items_id_variations_variation_id_variation_bundles_bundle_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationBundlesBundleIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationBundlesBundleIdPutAsyncWithHttpInfo(
        $id,
        $variation_id,
        $bundle_id,
        $_rest_items_id_variations_variation_id_variation_bundles_bundle_id = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationBundlesBundleIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationBundle';
        $request = $this->restItemsIdVariationsVariationIdVariationBundlesBundleIdPutRequest($id, $variation_id, $bundle_id, $_rest_items_id_variations_variation_id_variation_bundles_bundle_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationBundlesBundleIdPut'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $bundle_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdVariationBundlesPostRequest|null $_rest_items_id_variations_variation_id_variation_bundles_bundle_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationBundlesBundleIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationBundlesBundleIdPutRequest(
        $id,
        $variation_id,
        $bundle_id,
        $_rest_items_id_variations_variation_id_variation_bundles_bundle_id = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationBundlesBundleIdPut'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationBundlesBundleIdPut'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationBundlesBundleIdPut'
            );
        }

        // verify the required parameter 'bundle_id' is set
        if ($bundle_id === null || (is_array($bundle_id) && count($bundle_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $bundle_id when calling restItemsIdVariationsVariationIdVariationBundlesBundleIdPut'
            );
        }



        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_bundles/{bundleId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }
        // path params
        if ($bundle_id !== null) {
            $resourcePath = str_replace(
                '{' . 'bundleId' . '}',
                ObjectSerializer::toPathValue($bundle_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_id_variations_variation_id_variation_bundles_bundle_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_id_variations_variation_id_variation_bundles_bundle_id));
            } else {
                $httpBody = $_rest_items_id_variations_variation_id_variation_bundles_bundle_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationBundlesGet
     *
     * List bundle components
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationBundlesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationBundle[]
     */
    public function restItemsIdVariationsVariationIdVariationBundlesGet(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationBundlesGet'][0]
    ): array
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationBundlesGetWithHttpInfo($id, $variation_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationBundlesGetWithHttpInfo
     *
     * List bundle components
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationBundlesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationBundle[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationBundlesGetWithHttpInfo(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationBundlesGet'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationBundlesGetRequest($id, $variation_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationBundle[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationBundle[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationBundle[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationBundle[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationBundle[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationBundlesGetAsync
     *
     * List bundle components
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationBundlesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationBundlesGetAsync(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationBundlesGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationBundlesGetAsyncWithHttpInfo($id, $variation_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationBundlesGetAsyncWithHttpInfo
     *
     * List bundle components
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationBundlesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationBundlesGetAsyncWithHttpInfo(
        $id,
        $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationBundlesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationBundle[]';
        $request = $this->restItemsIdVariationsVariationIdVariationBundlesGetRequest($id, $variation_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationBundlesGet'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationBundlesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationBundlesGetRequest(
        $id,
        $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationBundlesGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationBundlesGet'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationBundlesGet'
            );
        }


        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_bundles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationBundlesPost
     *
     * Add a variation to a bundle
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdVariationBundlesPostRequest|null $_rest_items_id_variations_variation_id_variation_bundles _rest_items_id_variations_variation_id_variation_bundles (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationBundlesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationBundle
     */
    public function restItemsIdVariationsVariationIdVariationBundlesPost(
        int $id,
        int $variation_id,
        ?\ck\Model\RestItemsIdVariationsVariationIdVariationBundlesPostRequest $_rest_items_id_variations_variation_id_variation_bundles = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationBundlesPost'][0]
    ): \ck\Model\VariationBundle
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationBundlesPostWithHttpInfo($id, $variation_id, $_rest_items_id_variations_variation_id_variation_bundles, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationBundlesPostWithHttpInfo
     *
     * Add a variation to a bundle
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdVariationBundlesPostRequest|null $_rest_items_id_variations_variation_id_variation_bundles (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationBundlesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationBundle, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationBundlesPostWithHttpInfo(
        int $id,
        int $variation_id,
        ?\ck\Model\RestItemsIdVariationsVariationIdVariationBundlesPostRequest $_rest_items_id_variations_variation_id_variation_bundles = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationBundlesPost'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationBundlesPostRequest($id, $variation_id, $_rest_items_id_variations_variation_id_variation_bundles, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationBundle' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationBundle' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationBundle', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationBundle';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationBundle',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationBundlesPostAsync
     *
     * Add a variation to a bundle
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdVariationBundlesPostRequest|null $_rest_items_id_variations_variation_id_variation_bundles (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationBundlesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationBundlesPostAsync(
        int $id,
        int $variation_id,
        ?\ck\Model\RestItemsIdVariationsVariationIdVariationBundlesPostRequest $_rest_items_id_variations_variation_id_variation_bundles = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationBundlesPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationBundlesPostAsyncWithHttpInfo($id, $variation_id, $_rest_items_id_variations_variation_id_variation_bundles, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationBundlesPostAsyncWithHttpInfo
     *
     * Add a variation to a bundle
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdVariationBundlesPostRequest|null $_rest_items_id_variations_variation_id_variation_bundles (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationBundlesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationBundlesPostAsyncWithHttpInfo(
        $id,
        $variation_id,
        $_rest_items_id_variations_variation_id_variation_bundles = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationBundlesPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationBundle';
        $request = $this->restItemsIdVariationsVariationIdVariationBundlesPostRequest($id, $variation_id, $_rest_items_id_variations_variation_id_variation_bundles, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationBundlesPost'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdVariationBundlesPostRequest|null $_rest_items_id_variations_variation_id_variation_bundles (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationBundlesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationBundlesPostRequest(
        $id,
        $variation_id,
        $_rest_items_id_variations_variation_id_variation_bundles = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationBundlesPost'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationBundlesPost'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationBundlesPost'
            );
        }



        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_bundles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_id_variations_variation_id_variation_bundles)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_id_variations_variation_id_variation_bundles));
            } else {
                $httpBody = $_rest_items_id_variations_variation_id_variation_bundles;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationCategoriesCatIdDelete
     *
     * Remove a category from a variation
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  int $cat_id cat_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationCategoriesCatIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsIdVariationsVariationIdVariationCategoriesCatIdDelete(
        int $id,
        int $variation_id,
        int $cat_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationCategoriesCatIdDelete'][0]
    ): object
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationCategoriesCatIdDeleteWithHttpInfo($id, $variation_id, $cat_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationCategoriesCatIdDeleteWithHttpInfo
     *
     * Remove a category from a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $cat_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationCategoriesCatIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationCategoriesCatIdDeleteWithHttpInfo(
        int $id,
        int $variation_id,
        int $cat_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationCategoriesCatIdDelete'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationCategoriesCatIdDeleteRequest($id, $variation_id, $cat_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationCategoriesCatIdDeleteAsync
     *
     * Remove a category from a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $cat_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationCategoriesCatIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationCategoriesCatIdDeleteAsync(
        int $id,
        int $variation_id,
        int $cat_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationCategoriesCatIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationCategoriesCatIdDeleteAsyncWithHttpInfo($id, $variation_id, $cat_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationCategoriesCatIdDeleteAsyncWithHttpInfo
     *
     * Remove a category from a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $cat_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationCategoriesCatIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationCategoriesCatIdDeleteAsyncWithHttpInfo(
        $id,
        $variation_id,
        $cat_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationCategoriesCatIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsIdVariationsVariationIdVariationCategoriesCatIdDeleteRequest($id, $variation_id, $cat_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationCategoriesCatIdDelete'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $cat_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationCategoriesCatIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationCategoriesCatIdDeleteRequest(
        $id,
        $variation_id,
        $cat_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationCategoriesCatIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationCategoriesCatIdDelete'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationCategoriesCatIdDelete'
            );
        }

        // verify the required parameter 'cat_id' is set
        if ($cat_id === null || (is_array($cat_id) && count($cat_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $cat_id when calling restItemsIdVariationsVariationIdVariationCategoriesCatIdDelete'
            );
        }


        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_categories/{catId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }
        // path params
        if ($cat_id !== null) {
            $resourcePath = str_replace(
                '{' . 'catId' . '}',
                ObjectSerializer::toPathValue($cat_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationCategoriesCatIdGet
     *
     * Get link between category and variation
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  int $cat_id cat_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationCategoriesCatIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationCategory
     */
    public function restItemsIdVariationsVariationIdVariationCategoriesCatIdGet(
        int $id,
        int $variation_id,
        int $cat_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationCategoriesCatIdGet'][0]
    ): \ck\Model\VariationCategory
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationCategoriesCatIdGetWithHttpInfo($id, $variation_id, $cat_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationCategoriesCatIdGetWithHttpInfo
     *
     * Get link between category and variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $cat_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationCategoriesCatIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationCategory, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationCategoriesCatIdGetWithHttpInfo(
        int $id,
        int $variation_id,
        int $cat_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationCategoriesCatIdGet'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationCategoriesCatIdGetRequest($id, $variation_id, $cat_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationCategory' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationCategory' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationCategory', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationCategory';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationCategory',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationCategoriesCatIdGetAsync
     *
     * Get link between category and variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $cat_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationCategoriesCatIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationCategoriesCatIdGetAsync(
        int $id,
        int $variation_id,
        int $cat_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationCategoriesCatIdGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationCategoriesCatIdGetAsyncWithHttpInfo($id, $variation_id, $cat_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationCategoriesCatIdGetAsyncWithHttpInfo
     *
     * Get link between category and variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $cat_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationCategoriesCatIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationCategoriesCatIdGetAsyncWithHttpInfo(
        $id,
        $variation_id,
        $cat_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationCategoriesCatIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationCategory';
        $request = $this->restItemsIdVariationsVariationIdVariationCategoriesCatIdGetRequest($id, $variation_id, $cat_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationCategoriesCatIdGet'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $cat_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationCategoriesCatIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationCategoriesCatIdGetRequest(
        $id,
        $variation_id,
        $cat_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationCategoriesCatIdGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationCategoriesCatIdGet'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationCategoriesCatIdGet'
            );
        }

        // verify the required parameter 'cat_id' is set
        if ($cat_id === null || (is_array($cat_id) && count($cat_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $cat_id when calling restItemsIdVariationsVariationIdVariationCategoriesCatIdGet'
            );
        }


        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_categories/{catId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }
        // path params
        if ($cat_id !== null) {
            $resourcePath = str_replace(
                '{' . 'catId' . '}',
                ObjectSerializer::toPathValue($cat_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationCategoriesCatIdPut
     *
     * Update variation category link
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  int $cat_id cat_id (required)
     * @param  \ck\Model\RestItemsVariationsVariationCategoriesPutRequest|null $_rest_items_id_variations_variation_id_variation_categories_cat_id _rest_items_id_variations_variation_id_variation_categories_cat_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationCategoriesCatIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationCategory
     */
    public function restItemsIdVariationsVariationIdVariationCategoriesCatIdPut(
        int $id,
        int $variation_id,
        int $cat_id,
        ?\ck\Model\RestItemsVariationsVariationCategoriesPutRequest $_rest_items_id_variations_variation_id_variation_categories_cat_id = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationCategoriesCatIdPut'][0]
    ): \ck\Model\VariationCategory
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationCategoriesCatIdPutWithHttpInfo($id, $variation_id, $cat_id, $_rest_items_id_variations_variation_id_variation_categories_cat_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationCategoriesCatIdPutWithHttpInfo
     *
     * Update variation category link
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $cat_id (required)
     * @param  \ck\Model\RestItemsVariationsVariationCategoriesPutRequest|null $_rest_items_id_variations_variation_id_variation_categories_cat_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationCategoriesCatIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationCategory, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationCategoriesCatIdPutWithHttpInfo(
        int $id,
        int $variation_id,
        int $cat_id,
        ?\ck\Model\RestItemsVariationsVariationCategoriesPutRequest $_rest_items_id_variations_variation_id_variation_categories_cat_id = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationCategoriesCatIdPut'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationCategoriesCatIdPutRequest($id, $variation_id, $cat_id, $_rest_items_id_variations_variation_id_variation_categories_cat_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationCategory' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationCategory' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationCategory', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationCategory';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationCategory',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationCategoriesCatIdPutAsync
     *
     * Update variation category link
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $cat_id (required)
     * @param  \ck\Model\RestItemsVariationsVariationCategoriesPutRequest|null $_rest_items_id_variations_variation_id_variation_categories_cat_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationCategoriesCatIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationCategoriesCatIdPutAsync(
        int $id,
        int $variation_id,
        int $cat_id,
        ?\ck\Model\RestItemsVariationsVariationCategoriesPutRequest $_rest_items_id_variations_variation_id_variation_categories_cat_id = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationCategoriesCatIdPut'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationCategoriesCatIdPutAsyncWithHttpInfo($id, $variation_id, $cat_id, $_rest_items_id_variations_variation_id_variation_categories_cat_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationCategoriesCatIdPutAsyncWithHttpInfo
     *
     * Update variation category link
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $cat_id (required)
     * @param  \ck\Model\RestItemsVariationsVariationCategoriesPutRequest|null $_rest_items_id_variations_variation_id_variation_categories_cat_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationCategoriesCatIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationCategoriesCatIdPutAsyncWithHttpInfo(
        $id,
        $variation_id,
        $cat_id,
        $_rest_items_id_variations_variation_id_variation_categories_cat_id = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationCategoriesCatIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationCategory';
        $request = $this->restItemsIdVariationsVariationIdVariationCategoriesCatIdPutRequest($id, $variation_id, $cat_id, $_rest_items_id_variations_variation_id_variation_categories_cat_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationCategoriesCatIdPut'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $cat_id (required)
     * @param  \ck\Model\RestItemsVariationsVariationCategoriesPutRequest|null $_rest_items_id_variations_variation_id_variation_categories_cat_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationCategoriesCatIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationCategoriesCatIdPutRequest(
        $id,
        $variation_id,
        $cat_id,
        $_rest_items_id_variations_variation_id_variation_categories_cat_id = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationCategoriesCatIdPut'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationCategoriesCatIdPut'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationCategoriesCatIdPut'
            );
        }

        // verify the required parameter 'cat_id' is set
        if ($cat_id === null || (is_array($cat_id) && count($cat_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $cat_id when calling restItemsIdVariationsVariationIdVariationCategoriesCatIdPut'
            );
        }



        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_categories/{catId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }
        // path params
        if ($cat_id !== null) {
            $resourcePath = str_replace(
                '{' . 'catId' . '}',
                ObjectSerializer::toPathValue($cat_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_id_variations_variation_id_variation_categories_cat_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_id_variations_variation_id_variation_categories_cat_id));
            } else {
                $httpBody = $_rest_items_id_variations_variation_id_variation_categories_cat_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationCategoriesGet
     *
     * List categories linked to a variation
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationCategoriesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationCategory
     */
    public function restItemsIdVariationsVariationIdVariationCategoriesGet(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationCategoriesGet'][0]
    ): \ck\Model\VariationCategory
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationCategoriesGetWithHttpInfo($id, $variation_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationCategoriesGetWithHttpInfo
     *
     * List categories linked to a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationCategoriesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationCategory, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationCategoriesGetWithHttpInfo(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationCategoriesGet'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationCategoriesGetRequest($id, $variation_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationCategory' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationCategory' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationCategory', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationCategory';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationCategory',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationCategoriesGetAsync
     *
     * List categories linked to a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationCategoriesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationCategoriesGetAsync(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationCategoriesGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationCategoriesGetAsyncWithHttpInfo($id, $variation_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationCategoriesGetAsyncWithHttpInfo
     *
     * List categories linked to a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationCategoriesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationCategoriesGetAsyncWithHttpInfo(
        $id,
        $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationCategoriesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationCategory';
        $request = $this->restItemsIdVariationsVariationIdVariationCategoriesGetRequest($id, $variation_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationCategoriesGet'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationCategoriesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationCategoriesGetRequest(
        $id,
        $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationCategoriesGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationCategoriesGet'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationCategoriesGet'
            );
        }


        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_categories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationCategoriesPost
     *
     * Link a category to a variation
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  \ck\Model\RestItemsVariationsVariationCategoriesPutRequest|null $_rest_items_id_variations_variation_id_variation_categories _rest_items_id_variations_variation_id_variation_categories (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationCategoriesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationCategory
     */
    public function restItemsIdVariationsVariationIdVariationCategoriesPost(
        int $id,
        int $variation_id,
        ?\ck\Model\RestItemsVariationsVariationCategoriesPutRequest $_rest_items_id_variations_variation_id_variation_categories = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationCategoriesPost'][0]
    ): \ck\Model\VariationCategory
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationCategoriesPostWithHttpInfo($id, $variation_id, $_rest_items_id_variations_variation_id_variation_categories, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationCategoriesPostWithHttpInfo
     *
     * Link a category to a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  \ck\Model\RestItemsVariationsVariationCategoriesPutRequest|null $_rest_items_id_variations_variation_id_variation_categories (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationCategoriesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationCategory, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationCategoriesPostWithHttpInfo(
        int $id,
        int $variation_id,
        ?\ck\Model\RestItemsVariationsVariationCategoriesPutRequest $_rest_items_id_variations_variation_id_variation_categories = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationCategoriesPost'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationCategoriesPostRequest($id, $variation_id, $_rest_items_id_variations_variation_id_variation_categories, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationCategory' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationCategory' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationCategory', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationCategory';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationCategory',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationCategoriesPostAsync
     *
     * Link a category to a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  \ck\Model\RestItemsVariationsVariationCategoriesPutRequest|null $_rest_items_id_variations_variation_id_variation_categories (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationCategoriesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationCategoriesPostAsync(
        int $id,
        int $variation_id,
        ?\ck\Model\RestItemsVariationsVariationCategoriesPutRequest $_rest_items_id_variations_variation_id_variation_categories = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationCategoriesPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationCategoriesPostAsyncWithHttpInfo($id, $variation_id, $_rest_items_id_variations_variation_id_variation_categories, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationCategoriesPostAsyncWithHttpInfo
     *
     * Link a category to a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  \ck\Model\RestItemsVariationsVariationCategoriesPutRequest|null $_rest_items_id_variations_variation_id_variation_categories (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationCategoriesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationCategoriesPostAsyncWithHttpInfo(
        $id,
        $variation_id,
        $_rest_items_id_variations_variation_id_variation_categories = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationCategoriesPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationCategory';
        $request = $this->restItemsIdVariationsVariationIdVariationCategoriesPostRequest($id, $variation_id, $_rest_items_id_variations_variation_id_variation_categories, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationCategoriesPost'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  \ck\Model\RestItemsVariationsVariationCategoriesPutRequest|null $_rest_items_id_variations_variation_id_variation_categories (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationCategoriesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationCategoriesPostRequest(
        $id,
        $variation_id,
        $_rest_items_id_variations_variation_id_variation_categories = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationCategoriesPost'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationCategoriesPost'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationCategoriesPost'
            );
        }



        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_categories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_id_variations_variation_id_variation_categories)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_id_variations_variation_id_variation_categories));
            } else {
                $httpBody = $_rest_items_id_variations_variation_id_variation_categories;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationClientsGet
     *
     * List clients linked to a variation
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationClientsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationClient[]
     */
    public function restItemsIdVariationsVariationIdVariationClientsGet(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationClientsGet'][0]
    ): array
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationClientsGetWithHttpInfo($id, $variation_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationClientsGetWithHttpInfo
     *
     * List clients linked to a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationClientsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationClient[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationClientsGetWithHttpInfo(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationClientsGet'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationClientsGetRequest($id, $variation_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationClient[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationClient[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationClient[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationClient[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationClient[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationClientsGetAsync
     *
     * List clients linked to a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationClientsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationClientsGetAsync(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationClientsGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationClientsGetAsyncWithHttpInfo($id, $variation_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationClientsGetAsyncWithHttpInfo
     *
     * List clients linked to a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationClientsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationClientsGetAsyncWithHttpInfo(
        $id,
        $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationClientsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationClient[]';
        $request = $this->restItemsIdVariationsVariationIdVariationClientsGetRequest($id, $variation_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationClientsGet'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationClientsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationClientsGetRequest(
        $id,
        $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationClientsGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationClientsGet'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationClientsGet'
            );
        }


        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_clients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationClientsPlentyIdDelete
     *
     * Unlink a client from a variation
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  int $plenty_id plenty_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationClientsPlentyIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsIdVariationsVariationIdVariationClientsPlentyIdDelete(
        int $id,
        int $variation_id,
        int $plenty_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationClientsPlentyIdDelete'][0]
    ): object
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationClientsPlentyIdDeleteWithHttpInfo($id, $variation_id, $plenty_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationClientsPlentyIdDeleteWithHttpInfo
     *
     * Unlink a client from a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $plenty_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationClientsPlentyIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationClientsPlentyIdDeleteWithHttpInfo(
        int $id,
        int $variation_id,
        int $plenty_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationClientsPlentyIdDelete'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationClientsPlentyIdDeleteRequest($id, $variation_id, $plenty_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationClientsPlentyIdDeleteAsync
     *
     * Unlink a client from a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $plenty_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationClientsPlentyIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationClientsPlentyIdDeleteAsync(
        int $id,
        int $variation_id,
        int $plenty_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationClientsPlentyIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationClientsPlentyIdDeleteAsyncWithHttpInfo($id, $variation_id, $plenty_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationClientsPlentyIdDeleteAsyncWithHttpInfo
     *
     * Unlink a client from a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $plenty_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationClientsPlentyIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationClientsPlentyIdDeleteAsyncWithHttpInfo(
        $id,
        $variation_id,
        $plenty_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationClientsPlentyIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsIdVariationsVariationIdVariationClientsPlentyIdDeleteRequest($id, $variation_id, $plenty_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationClientsPlentyIdDelete'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $plenty_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationClientsPlentyIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationClientsPlentyIdDeleteRequest(
        $id,
        $variation_id,
        $plenty_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationClientsPlentyIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationClientsPlentyIdDelete'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationClientsPlentyIdDelete'
            );
        }

        // verify the required parameter 'plenty_id' is set
        if ($plenty_id === null || (is_array($plenty_id) && count($plenty_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $plenty_id when calling restItemsIdVariationsVariationIdVariationClientsPlentyIdDelete'
            );
        }


        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_clients/{plentyId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }
        // path params
        if ($plenty_id !== null) {
            $resourcePath = str_replace(
                '{' . 'plentyId' . '}',
                ObjectSerializer::toPathValue($plenty_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationClientsPost
     *
     * Link a client to a variation
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdVariationClientsPostRequest|null $_rest_items_id_variations_variation_id_variation_clients _rest_items_id_variations_variation_id_variation_clients (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationClientsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationClient
     */
    public function restItemsIdVariationsVariationIdVariationClientsPost(
        int $id,
        int $variation_id,
        ?\ck\Model\RestItemsIdVariationsVariationIdVariationClientsPostRequest $_rest_items_id_variations_variation_id_variation_clients = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationClientsPost'][0]
    ): \ck\Model\VariationClient
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationClientsPostWithHttpInfo($id, $variation_id, $_rest_items_id_variations_variation_id_variation_clients, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationClientsPostWithHttpInfo
     *
     * Link a client to a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdVariationClientsPostRequest|null $_rest_items_id_variations_variation_id_variation_clients (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationClientsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationClient, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationClientsPostWithHttpInfo(
        int $id,
        int $variation_id,
        ?\ck\Model\RestItemsIdVariationsVariationIdVariationClientsPostRequest $_rest_items_id_variations_variation_id_variation_clients = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationClientsPost'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationClientsPostRequest($id, $variation_id, $_rest_items_id_variations_variation_id_variation_clients, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationClient' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationClient' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationClient', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationClient';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationClient',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationClientsPostAsync
     *
     * Link a client to a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdVariationClientsPostRequest|null $_rest_items_id_variations_variation_id_variation_clients (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationClientsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationClientsPostAsync(
        int $id,
        int $variation_id,
        ?\ck\Model\RestItemsIdVariationsVariationIdVariationClientsPostRequest $_rest_items_id_variations_variation_id_variation_clients = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationClientsPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationClientsPostAsyncWithHttpInfo($id, $variation_id, $_rest_items_id_variations_variation_id_variation_clients, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationClientsPostAsyncWithHttpInfo
     *
     * Link a client to a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdVariationClientsPostRequest|null $_rest_items_id_variations_variation_id_variation_clients (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationClientsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationClientsPostAsyncWithHttpInfo(
        $id,
        $variation_id,
        $_rest_items_id_variations_variation_id_variation_clients = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationClientsPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationClient';
        $request = $this->restItemsIdVariationsVariationIdVariationClientsPostRequest($id, $variation_id, $_rest_items_id_variations_variation_id_variation_clients, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationClientsPost'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdVariationClientsPostRequest|null $_rest_items_id_variations_variation_id_variation_clients (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationClientsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationClientsPostRequest(
        $id,
        $variation_id,
        $_rest_items_id_variations_variation_id_variation_clients = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationClientsPost'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationClientsPost'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationClientsPost'
            );
        }



        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_clients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_id_variations_variation_id_variation_clients)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_id_variations_variation_id_variation_clients));
            } else {
                $httpBody = $_rest_items_id_variations_variation_id_variation_clients;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationComponentBundlesGet
     *
     * List bundles
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationComponentBundlesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationBundle[]
     */
    public function restItemsIdVariationsVariationIdVariationComponentBundlesGet(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationComponentBundlesGet'][0]
    ): array
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationComponentBundlesGetWithHttpInfo($id, $variation_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationComponentBundlesGetWithHttpInfo
     *
     * List bundles
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationComponentBundlesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationBundle[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationComponentBundlesGetWithHttpInfo(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationComponentBundlesGet'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationComponentBundlesGetRequest($id, $variation_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationBundle[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationBundle[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationBundle[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationBundle[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationBundle[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationComponentBundlesGetAsync
     *
     * List bundles
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationComponentBundlesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationComponentBundlesGetAsync(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationComponentBundlesGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationComponentBundlesGetAsyncWithHttpInfo($id, $variation_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationComponentBundlesGetAsyncWithHttpInfo
     *
     * List bundles
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationComponentBundlesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationComponentBundlesGetAsyncWithHttpInfo(
        $id,
        $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationComponentBundlesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationBundle[]';
        $request = $this->restItemsIdVariationsVariationIdVariationComponentBundlesGetRequest($id, $variation_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationComponentBundlesGet'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationComponentBundlesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationComponentBundlesGetRequest(
        $id,
        $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationComponentBundlesGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationComponentBundlesGet'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationComponentBundlesGet'
            );
        }


        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_component_bundles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationDefaultCategoriesGet
     *
     * List default category links
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationDefaultCategoriesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationDefaultCategory[]
     */
    public function restItemsIdVariationsVariationIdVariationDefaultCategoriesGet(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationDefaultCategoriesGet'][0]
    ): array
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationDefaultCategoriesGetWithHttpInfo($id, $variation_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationDefaultCategoriesGetWithHttpInfo
     *
     * List default category links
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationDefaultCategoriesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationDefaultCategory[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationDefaultCategoriesGetWithHttpInfo(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationDefaultCategoriesGet'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationDefaultCategoriesGetRequest($id, $variation_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationDefaultCategory[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationDefaultCategory[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationDefaultCategory[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationDefaultCategory[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationDefaultCategory[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationDefaultCategoriesGetAsync
     *
     * List default category links
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationDefaultCategoriesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationDefaultCategoriesGetAsync(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationDefaultCategoriesGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationDefaultCategoriesGetAsyncWithHttpInfo($id, $variation_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationDefaultCategoriesGetAsyncWithHttpInfo
     *
     * List default category links
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationDefaultCategoriesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationDefaultCategoriesGetAsyncWithHttpInfo(
        $id,
        $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationDefaultCategoriesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationDefaultCategory[]';
        $request = $this->restItemsIdVariationsVariationIdVariationDefaultCategoriesGetRequest($id, $variation_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationDefaultCategoriesGet'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationDefaultCategoriesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationDefaultCategoriesGetRequest(
        $id,
        $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationDefaultCategoriesGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationDefaultCategoriesGet'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationDefaultCategoriesGet'
            );
        }


        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_default_categories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationDefaultCategoriesPlentyIdDelete
     *
     * Delete a default category link
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  int $plenty_id plenty_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationDefaultCategoriesPlentyIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsIdVariationsVariationIdVariationDefaultCategoriesPlentyIdDelete(
        int $id,
        int $variation_id,
        int $plenty_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationDefaultCategoriesPlentyIdDelete'][0]
    ): object
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationDefaultCategoriesPlentyIdDeleteWithHttpInfo($id, $variation_id, $plenty_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationDefaultCategoriesPlentyIdDeleteWithHttpInfo
     *
     * Delete a default category link
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $plenty_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationDefaultCategoriesPlentyIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationDefaultCategoriesPlentyIdDeleteWithHttpInfo(
        int $id,
        int $variation_id,
        int $plenty_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationDefaultCategoriesPlentyIdDelete'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationDefaultCategoriesPlentyIdDeleteRequest($id, $variation_id, $plenty_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationDefaultCategoriesPlentyIdDeleteAsync
     *
     * Delete a default category link
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $plenty_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationDefaultCategoriesPlentyIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationDefaultCategoriesPlentyIdDeleteAsync(
        int $id,
        int $variation_id,
        int $plenty_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationDefaultCategoriesPlentyIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationDefaultCategoriesPlentyIdDeleteAsyncWithHttpInfo($id, $variation_id, $plenty_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationDefaultCategoriesPlentyIdDeleteAsyncWithHttpInfo
     *
     * Delete a default category link
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $plenty_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationDefaultCategoriesPlentyIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationDefaultCategoriesPlentyIdDeleteAsyncWithHttpInfo(
        $id,
        $variation_id,
        $plenty_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationDefaultCategoriesPlentyIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsIdVariationsVariationIdVariationDefaultCategoriesPlentyIdDeleteRequest($id, $variation_id, $plenty_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationDefaultCategoriesPlentyIdDelete'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $plenty_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationDefaultCategoriesPlentyIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationDefaultCategoriesPlentyIdDeleteRequest(
        $id,
        $variation_id,
        $plenty_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationDefaultCategoriesPlentyIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationDefaultCategoriesPlentyIdDelete'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationDefaultCategoriesPlentyIdDelete'
            );
        }

        // verify the required parameter 'plenty_id' is set
        if ($plenty_id === null || (is_array($plenty_id) && count($plenty_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $plenty_id when calling restItemsIdVariationsVariationIdVariationDefaultCategoriesPlentyIdDelete'
            );
        }


        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_default_categories/{plentyId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }
        // path params
        if ($plenty_id !== null) {
            $resourcePath = str_replace(
                '{' . 'plentyId' . '}',
                ObjectSerializer::toPathValue($plenty_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationDefaultCategoriesPlentyIdGet
     *
     * Gets a default category link
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  int $plenty_id plenty_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationDefaultCategoriesPlentyIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationDefaultCategory
     */
    public function restItemsIdVariationsVariationIdVariationDefaultCategoriesPlentyIdGet(
        int $id,
        int $variation_id,
        int $plenty_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationDefaultCategoriesPlentyIdGet'][0]
    ): \ck\Model\VariationDefaultCategory
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationDefaultCategoriesPlentyIdGetWithHttpInfo($id, $variation_id, $plenty_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationDefaultCategoriesPlentyIdGetWithHttpInfo
     *
     * Gets a default category link
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $plenty_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationDefaultCategoriesPlentyIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationDefaultCategory, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationDefaultCategoriesPlentyIdGetWithHttpInfo(
        int $id,
        int $variation_id,
        int $plenty_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationDefaultCategoriesPlentyIdGet'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationDefaultCategoriesPlentyIdGetRequest($id, $variation_id, $plenty_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationDefaultCategory' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationDefaultCategory' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationDefaultCategory', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationDefaultCategory';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationDefaultCategory',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationDefaultCategoriesPlentyIdGetAsync
     *
     * Gets a default category link
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $plenty_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationDefaultCategoriesPlentyIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationDefaultCategoriesPlentyIdGetAsync(
        int $id,
        int $variation_id,
        int $plenty_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationDefaultCategoriesPlentyIdGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationDefaultCategoriesPlentyIdGetAsyncWithHttpInfo($id, $variation_id, $plenty_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationDefaultCategoriesPlentyIdGetAsyncWithHttpInfo
     *
     * Gets a default category link
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $plenty_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationDefaultCategoriesPlentyIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationDefaultCategoriesPlentyIdGetAsyncWithHttpInfo(
        $id,
        $variation_id,
        $plenty_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationDefaultCategoriesPlentyIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationDefaultCategory';
        $request = $this->restItemsIdVariationsVariationIdVariationDefaultCategoriesPlentyIdGetRequest($id, $variation_id, $plenty_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationDefaultCategoriesPlentyIdGet'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $plenty_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationDefaultCategoriesPlentyIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationDefaultCategoriesPlentyIdGetRequest(
        $id,
        $variation_id,
        $plenty_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationDefaultCategoriesPlentyIdGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationDefaultCategoriesPlentyIdGet'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationDefaultCategoriesPlentyIdGet'
            );
        }

        // verify the required parameter 'plenty_id' is set
        if ($plenty_id === null || (is_array($plenty_id) && count($plenty_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $plenty_id when calling restItemsIdVariationsVariationIdVariationDefaultCategoriesPlentyIdGet'
            );
        }


        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_default_categories/{plentyId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }
        // path params
        if ($plenty_id !== null) {
            $resourcePath = str_replace(
                '{' . 'plentyId' . '}',
                ObjectSerializer::toPathValue($plenty_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationDefaultCategoriesPost
     *
     * Create a default category link
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationDefaultCategoriesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationDefaultCategory
     */
    public function restItemsIdVariationsVariationIdVariationDefaultCategoriesPost(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationDefaultCategoriesPost'][0]
    ): \ck\Model\VariationDefaultCategory
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationDefaultCategoriesPostWithHttpInfo($id, $variation_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationDefaultCategoriesPostWithHttpInfo
     *
     * Create a default category link
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationDefaultCategoriesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationDefaultCategory, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationDefaultCategoriesPostWithHttpInfo(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationDefaultCategoriesPost'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationDefaultCategoriesPostRequest($id, $variation_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationDefaultCategory' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationDefaultCategory' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationDefaultCategory', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationDefaultCategory';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationDefaultCategory',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationDefaultCategoriesPostAsync
     *
     * Create a default category link
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationDefaultCategoriesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationDefaultCategoriesPostAsync(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationDefaultCategoriesPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationDefaultCategoriesPostAsyncWithHttpInfo($id, $variation_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationDefaultCategoriesPostAsyncWithHttpInfo
     *
     * Create a default category link
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationDefaultCategoriesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationDefaultCategoriesPostAsyncWithHttpInfo(
        $id,
        $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationDefaultCategoriesPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationDefaultCategory';
        $request = $this->restItemsIdVariationsVariationIdVariationDefaultCategoriesPostRequest($id, $variation_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationDefaultCategoriesPost'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationDefaultCategoriesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationDefaultCategoriesPostRequest(
        $id,
        $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationDefaultCategoriesPost'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationDefaultCategoriesPost'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationDefaultCategoriesPost'
            );
        }


        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_default_categories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationImagesGet
     *
     * List image links of a variation
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  string|null $updated_at Filter restricts the list of results to variation images updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationImagesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationImage
     */
    public function restItemsIdVariationsVariationIdVariationImagesGet(
        int $id,
        int $variation_id,
        ?string $updated_at = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationImagesGet'][0]
    ): \ck\Model\VariationImage
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationImagesGetWithHttpInfo($id, $variation_id, $updated_at, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationImagesGetWithHttpInfo
     *
     * List image links of a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string|null $updated_at Filter restricts the list of results to variation images updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationImagesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationImage, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationImagesGetWithHttpInfo(
        int $id,
        int $variation_id,
        ?string $updated_at = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationImagesGet'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationImagesGetRequest($id, $variation_id, $updated_at, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationImage' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationImage' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationImage', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationImage';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationImage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationImagesGetAsync
     *
     * List image links of a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string|null $updated_at Filter restricts the list of results to variation images updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationImagesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationImagesGetAsync(
        int $id,
        int $variation_id,
        ?string $updated_at = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationImagesGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationImagesGetAsyncWithHttpInfo($id, $variation_id, $updated_at, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationImagesGetAsyncWithHttpInfo
     *
     * List image links of a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string|null $updated_at Filter restricts the list of results to variation images updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationImagesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationImagesGetAsyncWithHttpInfo(
        $id,
        $variation_id,
        $updated_at = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationImagesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationImage';
        $request = $this->restItemsIdVariationsVariationIdVariationImagesGetRequest($id, $variation_id, $updated_at, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationImagesGet'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string|null $updated_at Filter restricts the list of results to variation images updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationImagesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationImagesGetRequest(
        $id,
        $variation_id,
        $updated_at = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationImagesGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationImagesGet'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationImagesGet'
            );
        }



        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_images';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_at,
            'updatedAt', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationImagesImageIdDelete
     *
     * Delete an image link
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  int $image_id image_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationImagesImageIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsIdVariationsVariationIdVariationImagesImageIdDelete(
        int $id,
        int $variation_id,
        int $image_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationImagesImageIdDelete'][0]
    ): object
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationImagesImageIdDeleteWithHttpInfo($id, $variation_id, $image_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationImagesImageIdDeleteWithHttpInfo
     *
     * Delete an image link
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $image_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationImagesImageIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationImagesImageIdDeleteWithHttpInfo(
        int $id,
        int $variation_id,
        int $image_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationImagesImageIdDelete'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationImagesImageIdDeleteRequest($id, $variation_id, $image_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationImagesImageIdDeleteAsync
     *
     * Delete an image link
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $image_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationImagesImageIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationImagesImageIdDeleteAsync(
        int $id,
        int $variation_id,
        int $image_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationImagesImageIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationImagesImageIdDeleteAsyncWithHttpInfo($id, $variation_id, $image_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationImagesImageIdDeleteAsyncWithHttpInfo
     *
     * Delete an image link
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $image_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationImagesImageIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationImagesImageIdDeleteAsyncWithHttpInfo(
        $id,
        $variation_id,
        $image_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationImagesImageIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsIdVariationsVariationIdVariationImagesImageIdDeleteRequest($id, $variation_id, $image_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationImagesImageIdDelete'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $image_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationImagesImageIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationImagesImageIdDeleteRequest(
        $id,
        $variation_id,
        $image_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationImagesImageIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationImagesImageIdDelete'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationImagesImageIdDelete'
            );
        }

        // verify the required parameter 'image_id' is set
        if ($image_id === null || (is_array($image_id) && count($image_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $image_id when calling restItemsIdVariationsVariationIdVariationImagesImageIdDelete'
            );
        }


        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_images/{imageId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }
        // path params
        if ($image_id !== null) {
            $resourcePath = str_replace(
                '{' . 'imageId' . '}',
                ObjectSerializer::toPathValue($image_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationImagesPost
     *
     * Create an image link
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdVariationImagesPostRequest|null $_rest_items_id_variations_variation_id_variation_images _rest_items_id_variations_variation_id_variation_images (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationImagesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationImage
     */
    public function restItemsIdVariationsVariationIdVariationImagesPost(
        int $id,
        int $variation_id,
        ?\ck\Model\RestItemsIdVariationsVariationIdVariationImagesPostRequest $_rest_items_id_variations_variation_id_variation_images = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationImagesPost'][0]
    ): \ck\Model\VariationImage
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationImagesPostWithHttpInfo($id, $variation_id, $_rest_items_id_variations_variation_id_variation_images, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationImagesPostWithHttpInfo
     *
     * Create an image link
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdVariationImagesPostRequest|null $_rest_items_id_variations_variation_id_variation_images (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationImagesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationImage, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationImagesPostWithHttpInfo(
        int $id,
        int $variation_id,
        ?\ck\Model\RestItemsIdVariationsVariationIdVariationImagesPostRequest $_rest_items_id_variations_variation_id_variation_images = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationImagesPost'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationImagesPostRequest($id, $variation_id, $_rest_items_id_variations_variation_id_variation_images, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationImage' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationImage' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationImage', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationImage';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationImage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationImagesPostAsync
     *
     * Create an image link
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdVariationImagesPostRequest|null $_rest_items_id_variations_variation_id_variation_images (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationImagesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationImagesPostAsync(
        int $id,
        int $variation_id,
        ?\ck\Model\RestItemsIdVariationsVariationIdVariationImagesPostRequest $_rest_items_id_variations_variation_id_variation_images = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationImagesPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationImagesPostAsyncWithHttpInfo($id, $variation_id, $_rest_items_id_variations_variation_id_variation_images, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationImagesPostAsyncWithHttpInfo
     *
     * Create an image link
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdVariationImagesPostRequest|null $_rest_items_id_variations_variation_id_variation_images (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationImagesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationImagesPostAsyncWithHttpInfo(
        $id,
        $variation_id,
        $_rest_items_id_variations_variation_id_variation_images = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationImagesPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationImage';
        $request = $this->restItemsIdVariationsVariationIdVariationImagesPostRequest($id, $variation_id, $_rest_items_id_variations_variation_id_variation_images, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationImagesPost'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdVariationImagesPostRequest|null $_rest_items_id_variations_variation_id_variation_images (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationImagesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationImagesPostRequest(
        $id,
        $variation_id,
        $_rest_items_id_variations_variation_id_variation_images = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationImagesPost'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationImagesPost'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationImagesPost'
            );
        }



        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_images';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_id_variations_variation_id_variation_images)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_id_variations_variation_id_variation_images));
            } else {
                $httpBody = $_rest_items_id_variations_variation_id_variation_images;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationMarketsDelete
     *
     * Delete all market links of one variation
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationMarketsDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restItemsIdVariationsVariationIdVariationMarketsDelete(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationMarketsDelete'][0]
    ): void
    {
        $this->restItemsIdVariationsVariationIdVariationMarketsDeleteWithHttpInfo($id, $variation_id, $contentType);
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationMarketsDeleteWithHttpInfo
     *
     * Delete all market links of one variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationMarketsDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationMarketsDeleteWithHttpInfo(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationMarketsDelete'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationMarketsDeleteRequest($id, $variation_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationMarketsDeleteAsync
     *
     * Delete all market links of one variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationMarketsDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationMarketsDeleteAsync(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationMarketsDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationMarketsDeleteAsyncWithHttpInfo($id, $variation_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationMarketsDeleteAsyncWithHttpInfo
     *
     * Delete all market links of one variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationMarketsDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationMarketsDeleteAsyncWithHttpInfo(
        $id,
        $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationMarketsDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restItemsIdVariationsVariationIdVariationMarketsDeleteRequest($id, $variation_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationMarketsDelete'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationMarketsDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationMarketsDeleteRequest(
        $id,
        $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationMarketsDelete'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationMarketsDelete'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationMarketsDelete'
            );
        }


        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_markets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationMarketsGet
     *
     * List markets linked to a variation
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationMarketsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationMarket[]
     */
    public function restItemsIdVariationsVariationIdVariationMarketsGet(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationMarketsGet'][0]
    ): array
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationMarketsGetWithHttpInfo($id, $variation_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationMarketsGetWithHttpInfo
     *
     * List markets linked to a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationMarketsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationMarket[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationMarketsGetWithHttpInfo(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationMarketsGet'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationMarketsGetRequest($id, $variation_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationMarket[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationMarket[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationMarket[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationMarket[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationMarket[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationMarketsGetAsync
     *
     * List markets linked to a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationMarketsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationMarketsGetAsync(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationMarketsGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationMarketsGetAsyncWithHttpInfo($id, $variation_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationMarketsGetAsyncWithHttpInfo
     *
     * List markets linked to a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationMarketsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationMarketsGetAsyncWithHttpInfo(
        $id,
        $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationMarketsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationMarket[]';
        $request = $this->restItemsIdVariationsVariationIdVariationMarketsGetRequest($id, $variation_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationMarketsGet'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationMarketsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationMarketsGetRequest(
        $id,
        $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationMarketsGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationMarketsGet'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationMarketsGet'
            );
        }


        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_markets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationMarketsMarketplaceIdDelete
     *
     * Delete link between variation and market
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  int $marketplace_id marketplace_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationMarketsMarketplaceIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsIdVariationsVariationIdVariationMarketsMarketplaceIdDelete(
        int $id,
        int $variation_id,
        int $marketplace_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationMarketsMarketplaceIdDelete'][0]
    ): object
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationMarketsMarketplaceIdDeleteWithHttpInfo($id, $variation_id, $marketplace_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationMarketsMarketplaceIdDeleteWithHttpInfo
     *
     * Delete link between variation and market
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $marketplace_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationMarketsMarketplaceIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationMarketsMarketplaceIdDeleteWithHttpInfo(
        int $id,
        int $variation_id,
        int $marketplace_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationMarketsMarketplaceIdDelete'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationMarketsMarketplaceIdDeleteRequest($id, $variation_id, $marketplace_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationMarketsMarketplaceIdDeleteAsync
     *
     * Delete link between variation and market
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $marketplace_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationMarketsMarketplaceIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationMarketsMarketplaceIdDeleteAsync(
        int $id,
        int $variation_id,
        int $marketplace_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationMarketsMarketplaceIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationMarketsMarketplaceIdDeleteAsyncWithHttpInfo($id, $variation_id, $marketplace_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationMarketsMarketplaceIdDeleteAsyncWithHttpInfo
     *
     * Delete link between variation and market
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $marketplace_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationMarketsMarketplaceIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationMarketsMarketplaceIdDeleteAsyncWithHttpInfo(
        $id,
        $variation_id,
        $marketplace_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationMarketsMarketplaceIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsIdVariationsVariationIdVariationMarketsMarketplaceIdDeleteRequest($id, $variation_id, $marketplace_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationMarketsMarketplaceIdDelete'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $marketplace_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationMarketsMarketplaceIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationMarketsMarketplaceIdDeleteRequest(
        $id,
        $variation_id,
        $marketplace_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationMarketsMarketplaceIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationMarketsMarketplaceIdDelete'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationMarketsMarketplaceIdDelete'
            );
        }

        // verify the required parameter 'marketplace_id' is set
        if ($marketplace_id === null || (is_array($marketplace_id) && count($marketplace_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $marketplace_id when calling restItemsIdVariationsVariationIdVariationMarketsMarketplaceIdDelete'
            );
        }


        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_markets/{marketplaceId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }
        // path params
        if ($marketplace_id !== null) {
            $resourcePath = str_replace(
                '{' . 'marketplaceId' . '}',
                ObjectSerializer::toPathValue($marketplace_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationMarketsPost
     *
     * Create link between variation and market
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  \ck\Model\RestItemsVariationsVariationMarketsPostRequest|null $_rest_items_id_variations_variation_id_variation_markets _rest_items_id_variations_variation_id_variation_markets (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationMarketsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationMarket
     */
    public function restItemsIdVariationsVariationIdVariationMarketsPost(
        int $id,
        int $variation_id,
        ?\ck\Model\RestItemsVariationsVariationMarketsPostRequest $_rest_items_id_variations_variation_id_variation_markets = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationMarketsPost'][0]
    ): \ck\Model\VariationMarket
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationMarketsPostWithHttpInfo($id, $variation_id, $_rest_items_id_variations_variation_id_variation_markets, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationMarketsPostWithHttpInfo
     *
     * Create link between variation and market
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  \ck\Model\RestItemsVariationsVariationMarketsPostRequest|null $_rest_items_id_variations_variation_id_variation_markets (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationMarketsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationMarket, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationMarketsPostWithHttpInfo(
        int $id,
        int $variation_id,
        ?\ck\Model\RestItemsVariationsVariationMarketsPostRequest $_rest_items_id_variations_variation_id_variation_markets = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationMarketsPost'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationMarketsPostRequest($id, $variation_id, $_rest_items_id_variations_variation_id_variation_markets, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationMarket' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationMarket' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationMarket', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationMarket';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationMarket',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationMarketsPostAsync
     *
     * Create link between variation and market
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  \ck\Model\RestItemsVariationsVariationMarketsPostRequest|null $_rest_items_id_variations_variation_id_variation_markets (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationMarketsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationMarketsPostAsync(
        int $id,
        int $variation_id,
        ?\ck\Model\RestItemsVariationsVariationMarketsPostRequest $_rest_items_id_variations_variation_id_variation_markets = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationMarketsPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationMarketsPostAsyncWithHttpInfo($id, $variation_id, $_rest_items_id_variations_variation_id_variation_markets, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationMarketsPostAsyncWithHttpInfo
     *
     * Create link between variation and market
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  \ck\Model\RestItemsVariationsVariationMarketsPostRequest|null $_rest_items_id_variations_variation_id_variation_markets (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationMarketsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationMarketsPostAsyncWithHttpInfo(
        $id,
        $variation_id,
        $_rest_items_id_variations_variation_id_variation_markets = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationMarketsPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationMarket';
        $request = $this->restItemsIdVariationsVariationIdVariationMarketsPostRequest($id, $variation_id, $_rest_items_id_variations_variation_id_variation_markets, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationMarketsPost'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  \ck\Model\RestItemsVariationsVariationMarketsPostRequest|null $_rest_items_id_variations_variation_id_variation_markets (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationMarketsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationMarketsPostRequest(
        $id,
        $variation_id,
        $_rest_items_id_variations_variation_id_variation_markets = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationMarketsPost'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationMarketsPost'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationMarketsPost'
            );
        }



        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_markets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_id_variations_variation_id_variation_markets)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_id_variations_variation_id_variation_markets));
            } else {
                $httpBody = $_rest_items_id_variations_variation_id_variation_markets;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationPropertiesDelete
     *
     * Deletes all links between a variation and its property values
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsIdVariationsVariationIdVariationPropertiesDelete(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesDelete'][0]
    ): object
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationPropertiesDeleteWithHttpInfo($id, $variation_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationPropertiesDeleteWithHttpInfo
     *
     * Deletes all links between a variation and its property values
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationPropertiesDeleteWithHttpInfo(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesDelete'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationPropertiesDeleteRequest($id, $variation_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationPropertiesDeleteAsync
     *
     * Deletes all links between a variation and its property values
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationPropertiesDeleteAsync(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationPropertiesDeleteAsyncWithHttpInfo($id, $variation_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationPropertiesDeleteAsyncWithHttpInfo
     *
     * Deletes all links between a variation and its property values
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationPropertiesDeleteAsyncWithHttpInfo(
        $id,
        $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsIdVariationsVariationIdVariationPropertiesDeleteRequest($id, $variation_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationPropertiesDelete'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationPropertiesDeleteRequest(
        $id,
        $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesDelete'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationPropertiesDelete'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationPropertiesDelete'
            );
        }


        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_properties';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationPropertiesGet
     *
     * List property values linked to a variation
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationPropertyValue[]
     */
    public function restItemsIdVariationsVariationIdVariationPropertiesGet(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesGet'][0]
    ): array
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationPropertiesGetWithHttpInfo($id, $variation_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationPropertiesGetWithHttpInfo
     *
     * List property values linked to a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationPropertyValue[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationPropertiesGetWithHttpInfo(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesGet'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationPropertiesGetRequest($id, $variation_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationPropertyValue[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationPropertyValue[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationPropertyValue[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationPropertyValue[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationPropertyValue[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationPropertiesGetAsync
     *
     * List property values linked to a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationPropertiesGetAsync(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationPropertiesGetAsyncWithHttpInfo($id, $variation_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationPropertiesGetAsyncWithHttpInfo
     *
     * List property values linked to a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationPropertiesGetAsyncWithHttpInfo(
        $id,
        $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationPropertyValue[]';
        $request = $this->restItemsIdVariationsVariationIdVariationPropertiesGetRequest($id, $variation_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationPropertiesGet'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationPropertiesGetRequest(
        $id,
        $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationPropertiesGet'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationPropertiesGet'
            );
        }


        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_properties';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationPropertiesPost
     *
     * Create link between variation and property value
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  \ck\Model\RestItemsVariationsVariationPropertiesPutRequest|null $_rest_items_id_variations_variation_id_variation_properties _rest_items_id_variations_variation_id_variation_properties (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationPropertyValue
     */
    public function restItemsIdVariationsVariationIdVariationPropertiesPost(
        int $id,
        int $variation_id,
        ?\ck\Model\RestItemsVariationsVariationPropertiesPutRequest $_rest_items_id_variations_variation_id_variation_properties = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesPost'][0]
    ): \ck\Model\VariationPropertyValue
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationPropertiesPostWithHttpInfo($id, $variation_id, $_rest_items_id_variations_variation_id_variation_properties, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationPropertiesPostWithHttpInfo
     *
     * Create link between variation and property value
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  \ck\Model\RestItemsVariationsVariationPropertiesPutRequest|null $_rest_items_id_variations_variation_id_variation_properties (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationPropertyValue, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationPropertiesPostWithHttpInfo(
        int $id,
        int $variation_id,
        ?\ck\Model\RestItemsVariationsVariationPropertiesPutRequest $_rest_items_id_variations_variation_id_variation_properties = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesPost'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationPropertiesPostRequest($id, $variation_id, $_rest_items_id_variations_variation_id_variation_properties, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationPropertyValue' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationPropertyValue' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationPropertyValue', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationPropertyValue';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationPropertyValue',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationPropertiesPostAsync
     *
     * Create link between variation and property value
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  \ck\Model\RestItemsVariationsVariationPropertiesPutRequest|null $_rest_items_id_variations_variation_id_variation_properties (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationPropertiesPostAsync(
        int $id,
        int $variation_id,
        ?\ck\Model\RestItemsVariationsVariationPropertiesPutRequest $_rest_items_id_variations_variation_id_variation_properties = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationPropertiesPostAsyncWithHttpInfo($id, $variation_id, $_rest_items_id_variations_variation_id_variation_properties, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationPropertiesPostAsyncWithHttpInfo
     *
     * Create link between variation and property value
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  \ck\Model\RestItemsVariationsVariationPropertiesPutRequest|null $_rest_items_id_variations_variation_id_variation_properties (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationPropertiesPostAsyncWithHttpInfo(
        $id,
        $variation_id,
        $_rest_items_id_variations_variation_id_variation_properties = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationPropertyValue';
        $request = $this->restItemsIdVariationsVariationIdVariationPropertiesPostRequest($id, $variation_id, $_rest_items_id_variations_variation_id_variation_properties, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationPropertiesPost'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  \ck\Model\RestItemsVariationsVariationPropertiesPutRequest|null $_rest_items_id_variations_variation_id_variation_properties (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationPropertiesPostRequest(
        $id,
        $variation_id,
        $_rest_items_id_variations_variation_id_variation_properties = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesPost'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationPropertiesPost'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationPropertiesPost'
            );
        }



        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_properties';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_id_variations_variation_id_variation_properties)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_id_variations_variation_id_variation_properties));
            } else {
                $httpBody = $_rest_items_id_variations_variation_id_variation_properties;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationPropertiesPropertyIdDelete
     *
     * Delete link between variation and property value
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  int $property_id property_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesPropertyIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsIdVariationsVariationIdVariationPropertiesPropertyIdDelete(
        int $id,
        int $variation_id,
        int $property_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesPropertyIdDelete'][0]
    ): object
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationPropertiesPropertyIdDeleteWithHttpInfo($id, $variation_id, $property_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationPropertiesPropertyIdDeleteWithHttpInfo
     *
     * Delete link between variation and property value
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $property_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesPropertyIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationPropertiesPropertyIdDeleteWithHttpInfo(
        int $id,
        int $variation_id,
        int $property_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesPropertyIdDelete'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationPropertiesPropertyIdDeleteRequest($id, $variation_id, $property_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationPropertiesPropertyIdDeleteAsync
     *
     * Delete link between variation and property value
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $property_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesPropertyIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationPropertiesPropertyIdDeleteAsync(
        int $id,
        int $variation_id,
        int $property_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesPropertyIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationPropertiesPropertyIdDeleteAsyncWithHttpInfo($id, $variation_id, $property_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationPropertiesPropertyIdDeleteAsyncWithHttpInfo
     *
     * Delete link between variation and property value
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $property_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesPropertyIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationPropertiesPropertyIdDeleteAsyncWithHttpInfo(
        $id,
        $variation_id,
        $property_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesPropertyIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsIdVariationsVariationIdVariationPropertiesPropertyIdDeleteRequest($id, $variation_id, $property_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationPropertiesPropertyIdDelete'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $property_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesPropertyIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationPropertiesPropertyIdDeleteRequest(
        $id,
        $variation_id,
        $property_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesPropertyIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationPropertiesPropertyIdDelete'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationPropertiesPropertyIdDelete'
            );
        }

        // verify the required parameter 'property_id' is set
        if ($property_id === null || (is_array($property_id) && count($property_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $property_id when calling restItemsIdVariationsVariationIdVariationPropertiesPropertyIdDelete'
            );
        }


        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_properties/{propertyId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }
        // path params
        if ($property_id !== null) {
            $resourcePath = str_replace(
                '{' . 'propertyId' . '}',
                ObjectSerializer::toPathValue($property_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationPropertiesPropertyIdGet
     *
     * Get a property value
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  int $property_id property_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesPropertyIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationPropertyValue
     */
    public function restItemsIdVariationsVariationIdVariationPropertiesPropertyIdGet(
        int $id,
        int $variation_id,
        int $property_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesPropertyIdGet'][0]
    ): \ck\Model\VariationPropertyValue
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationPropertiesPropertyIdGetWithHttpInfo($id, $variation_id, $property_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationPropertiesPropertyIdGetWithHttpInfo
     *
     * Get a property value
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $property_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesPropertyIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationPropertyValue, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationPropertiesPropertyIdGetWithHttpInfo(
        int $id,
        int $variation_id,
        int $property_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesPropertyIdGet'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationPropertiesPropertyIdGetRequest($id, $variation_id, $property_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationPropertyValue' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationPropertyValue' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationPropertyValue', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationPropertyValue';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationPropertyValue',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationPropertiesPropertyIdGetAsync
     *
     * Get a property value
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $property_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesPropertyIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationPropertiesPropertyIdGetAsync(
        int $id,
        int $variation_id,
        int $property_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesPropertyIdGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationPropertiesPropertyIdGetAsyncWithHttpInfo($id, $variation_id, $property_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationPropertiesPropertyIdGetAsyncWithHttpInfo
     *
     * Get a property value
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $property_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesPropertyIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationPropertiesPropertyIdGetAsyncWithHttpInfo(
        $id,
        $variation_id,
        $property_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesPropertyIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationPropertyValue';
        $request = $this->restItemsIdVariationsVariationIdVariationPropertiesPropertyIdGetRequest($id, $variation_id, $property_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationPropertiesPropertyIdGet'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $property_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesPropertyIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationPropertiesPropertyIdGetRequest(
        $id,
        $variation_id,
        $property_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesPropertyIdGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationPropertiesPropertyIdGet'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationPropertiesPropertyIdGet'
            );
        }

        // verify the required parameter 'property_id' is set
        if ($property_id === null || (is_array($property_id) && count($property_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $property_id when calling restItemsIdVariationsVariationIdVariationPropertiesPropertyIdGet'
            );
        }


        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_properties/{propertyId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }
        // path params
        if ($property_id !== null) {
            $resourcePath = str_replace(
                '{' . 'propertyId' . '}',
                ObjectSerializer::toPathValue($property_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationPropertiesPropertyIdPut
     *
     * Update a property value
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  int $property_id property_id (required)
     * @param  \ck\Model\RestItemsVariationsVariationPropertiesPutRequest|null $_rest_items_id_variations_variation_id_variation_properties_property_id _rest_items_id_variations_variation_id_variation_properties_property_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesPropertyIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationPropertyValue
     */
    public function restItemsIdVariationsVariationIdVariationPropertiesPropertyIdPut(
        int $id,
        int $variation_id,
        int $property_id,
        ?\ck\Model\RestItemsVariationsVariationPropertiesPutRequest $_rest_items_id_variations_variation_id_variation_properties_property_id = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesPropertyIdPut'][0]
    ): \ck\Model\VariationPropertyValue
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationPropertiesPropertyIdPutWithHttpInfo($id, $variation_id, $property_id, $_rest_items_id_variations_variation_id_variation_properties_property_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationPropertiesPropertyIdPutWithHttpInfo
     *
     * Update a property value
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $property_id (required)
     * @param  \ck\Model\RestItemsVariationsVariationPropertiesPutRequest|null $_rest_items_id_variations_variation_id_variation_properties_property_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesPropertyIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationPropertyValue, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationPropertiesPropertyIdPutWithHttpInfo(
        int $id,
        int $variation_id,
        int $property_id,
        ?\ck\Model\RestItemsVariationsVariationPropertiesPutRequest $_rest_items_id_variations_variation_id_variation_properties_property_id = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesPropertyIdPut'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationPropertiesPropertyIdPutRequest($id, $variation_id, $property_id, $_rest_items_id_variations_variation_id_variation_properties_property_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationPropertyValue' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationPropertyValue' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationPropertyValue', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationPropertyValue';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationPropertyValue',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationPropertiesPropertyIdPutAsync
     *
     * Update a property value
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $property_id (required)
     * @param  \ck\Model\RestItemsVariationsVariationPropertiesPutRequest|null $_rest_items_id_variations_variation_id_variation_properties_property_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesPropertyIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationPropertiesPropertyIdPutAsync(
        int $id,
        int $variation_id,
        int $property_id,
        ?\ck\Model\RestItemsVariationsVariationPropertiesPutRequest $_rest_items_id_variations_variation_id_variation_properties_property_id = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesPropertyIdPut'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationPropertiesPropertyIdPutAsyncWithHttpInfo($id, $variation_id, $property_id, $_rest_items_id_variations_variation_id_variation_properties_property_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationPropertiesPropertyIdPutAsyncWithHttpInfo
     *
     * Update a property value
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $property_id (required)
     * @param  \ck\Model\RestItemsVariationsVariationPropertiesPutRequest|null $_rest_items_id_variations_variation_id_variation_properties_property_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesPropertyIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationPropertiesPropertyIdPutAsyncWithHttpInfo(
        $id,
        $variation_id,
        $property_id,
        $_rest_items_id_variations_variation_id_variation_properties_property_id = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesPropertyIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationPropertyValue';
        $request = $this->restItemsIdVariationsVariationIdVariationPropertiesPropertyIdPutRequest($id, $variation_id, $property_id, $_rest_items_id_variations_variation_id_variation_properties_property_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationPropertiesPropertyIdPut'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $property_id (required)
     * @param  \ck\Model\RestItemsVariationsVariationPropertiesPutRequest|null $_rest_items_id_variations_variation_id_variation_properties_property_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesPropertyIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationPropertiesPropertyIdPutRequest(
        $id,
        $variation_id,
        $property_id,
        $_rest_items_id_variations_variation_id_variation_properties_property_id = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationPropertiesPropertyIdPut'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationPropertiesPropertyIdPut'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationPropertiesPropertyIdPut'
            );
        }

        // verify the required parameter 'property_id' is set
        if ($property_id === null || (is_array($property_id) && count($property_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $property_id when calling restItemsIdVariationsVariationIdVariationPropertiesPropertyIdPut'
            );
        }



        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_properties/{propertyId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }
        // path params
        if ($property_id !== null) {
            $resourcePath = str_replace(
                '{' . 'propertyId' . '}',
                ObjectSerializer::toPathValue($property_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_id_variations_variation_id_variation_properties_property_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_id_variations_variation_id_variation_properties_property_id));
            } else {
                $httpBody = $_rest_items_id_variations_variation_id_variation_properties_property_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSalesPricesDelete
     *
     * Delete all links between a variation and its sales prices
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsIdVariationsVariationIdVariationSalesPricesDelete(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesDelete'][0]
    ): object
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationSalesPricesDeleteWithHttpInfo($id, $variation_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSalesPricesDeleteWithHttpInfo
     *
     * Delete all links between a variation and its sales prices
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationSalesPricesDeleteWithHttpInfo(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesDelete'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationSalesPricesDeleteRequest($id, $variation_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSalesPricesDeleteAsync
     *
     * Delete all links between a variation and its sales prices
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationSalesPricesDeleteAsync(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationSalesPricesDeleteAsyncWithHttpInfo($id, $variation_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSalesPricesDeleteAsyncWithHttpInfo
     *
     * Delete all links between a variation and its sales prices
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationSalesPricesDeleteAsyncWithHttpInfo(
        $id,
        $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsIdVariationsVariationIdVariationSalesPricesDeleteRequest($id, $variation_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationSalesPricesDelete'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationSalesPricesDeleteRequest(
        $id,
        $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesDelete'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationSalesPricesDelete'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationSalesPricesDelete'
            );
        }


        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_sales_prices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSalesPricesGet
     *
     * List sales prices of a variation
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationSalesPrice[]
     */
    public function restItemsIdVariationsVariationIdVariationSalesPricesGet(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesGet'][0]
    ): array
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationSalesPricesGetWithHttpInfo($id, $variation_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSalesPricesGetWithHttpInfo
     *
     * List sales prices of a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationSalesPrice[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationSalesPricesGetWithHttpInfo(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesGet'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationSalesPricesGetRequest($id, $variation_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationSalesPrice[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationSalesPrice[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationSalesPrice[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationSalesPrice[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationSalesPrice[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSalesPricesGetAsync
     *
     * List sales prices of a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationSalesPricesGetAsync(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationSalesPricesGetAsyncWithHttpInfo($id, $variation_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSalesPricesGetAsyncWithHttpInfo
     *
     * List sales prices of a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationSalesPricesGetAsyncWithHttpInfo(
        $id,
        $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationSalesPrice[]';
        $request = $this->restItemsIdVariationsVariationIdVariationSalesPricesGetRequest($id, $variation_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationSalesPricesGet'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationSalesPricesGetRequest(
        $id,
        $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationSalesPricesGet'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationSalesPricesGet'
            );
        }


        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_sales_prices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSalesPricesPost
     *
     * Create link between variation and sales price
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  \ck\Model\RestItemsVariationsVariationSalesPricesPutRequest|null $_rest_items_id_variations_variation_id_variation_sales_prices _rest_items_id_variations_variation_id_variation_sales_prices (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationSalesPrice
     */
    public function restItemsIdVariationsVariationIdVariationSalesPricesPost(
        int $id,
        int $variation_id,
        ?\ck\Model\RestItemsVariationsVariationSalesPricesPutRequest $_rest_items_id_variations_variation_id_variation_sales_prices = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesPost'][0]
    ): \ck\Model\VariationSalesPrice
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationSalesPricesPostWithHttpInfo($id, $variation_id, $_rest_items_id_variations_variation_id_variation_sales_prices, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSalesPricesPostWithHttpInfo
     *
     * Create link between variation and sales price
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  \ck\Model\RestItemsVariationsVariationSalesPricesPutRequest|null $_rest_items_id_variations_variation_id_variation_sales_prices (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationSalesPrice, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationSalesPricesPostWithHttpInfo(
        int $id,
        int $variation_id,
        ?\ck\Model\RestItemsVariationsVariationSalesPricesPutRequest $_rest_items_id_variations_variation_id_variation_sales_prices = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesPost'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationSalesPricesPostRequest($id, $variation_id, $_rest_items_id_variations_variation_id_variation_sales_prices, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationSalesPrice' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationSalesPrice' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationSalesPrice', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationSalesPrice';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationSalesPrice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSalesPricesPostAsync
     *
     * Create link between variation and sales price
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  \ck\Model\RestItemsVariationsVariationSalesPricesPutRequest|null $_rest_items_id_variations_variation_id_variation_sales_prices (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationSalesPricesPostAsync(
        int $id,
        int $variation_id,
        ?\ck\Model\RestItemsVariationsVariationSalesPricesPutRequest $_rest_items_id_variations_variation_id_variation_sales_prices = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationSalesPricesPostAsyncWithHttpInfo($id, $variation_id, $_rest_items_id_variations_variation_id_variation_sales_prices, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSalesPricesPostAsyncWithHttpInfo
     *
     * Create link between variation and sales price
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  \ck\Model\RestItemsVariationsVariationSalesPricesPutRequest|null $_rest_items_id_variations_variation_id_variation_sales_prices (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationSalesPricesPostAsyncWithHttpInfo(
        $id,
        $variation_id,
        $_rest_items_id_variations_variation_id_variation_sales_prices = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationSalesPrice';
        $request = $this->restItemsIdVariationsVariationIdVariationSalesPricesPostRequest($id, $variation_id, $_rest_items_id_variations_variation_id_variation_sales_prices, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationSalesPricesPost'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  \ck\Model\RestItemsVariationsVariationSalesPricesPutRequest|null $_rest_items_id_variations_variation_id_variation_sales_prices (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationSalesPricesPostRequest(
        $id,
        $variation_id,
        $_rest_items_id_variations_variation_id_variation_sales_prices = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesPost'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationSalesPricesPost'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationSalesPricesPost'
            );
        }



        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_sales_prices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_id_variations_variation_id_variation_sales_prices)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_id_variations_variation_id_variation_sales_prices));
            } else {
                $httpBody = $_rest_items_id_variations_variation_id_variation_sales_prices;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSalesPricesPriceIdDelete
     *
     * Delete link between variation and sales price
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  int $price_id price_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesPriceIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsIdVariationsVariationIdVariationSalesPricesPriceIdDelete(
        int $id,
        int $variation_id,
        int $price_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesPriceIdDelete'][0]
    ): object
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationSalesPricesPriceIdDeleteWithHttpInfo($id, $variation_id, $price_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSalesPricesPriceIdDeleteWithHttpInfo
     *
     * Delete link between variation and sales price
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $price_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesPriceIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationSalesPricesPriceIdDeleteWithHttpInfo(
        int $id,
        int $variation_id,
        int $price_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesPriceIdDelete'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationSalesPricesPriceIdDeleteRequest($id, $variation_id, $price_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSalesPricesPriceIdDeleteAsync
     *
     * Delete link between variation and sales price
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $price_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesPriceIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationSalesPricesPriceIdDeleteAsync(
        int $id,
        int $variation_id,
        int $price_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesPriceIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationSalesPricesPriceIdDeleteAsyncWithHttpInfo($id, $variation_id, $price_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSalesPricesPriceIdDeleteAsyncWithHttpInfo
     *
     * Delete link between variation and sales price
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $price_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesPriceIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationSalesPricesPriceIdDeleteAsyncWithHttpInfo(
        $id,
        $variation_id,
        $price_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesPriceIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsIdVariationsVariationIdVariationSalesPricesPriceIdDeleteRequest($id, $variation_id, $price_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationSalesPricesPriceIdDelete'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $price_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesPriceIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationSalesPricesPriceIdDeleteRequest(
        $id,
        $variation_id,
        $price_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesPriceIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationSalesPricesPriceIdDelete'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationSalesPricesPriceIdDelete'
            );
        }

        // verify the required parameter 'price_id' is set
        if ($price_id === null || (is_array($price_id) && count($price_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $price_id when calling restItemsIdVariationsVariationIdVariationSalesPricesPriceIdDelete'
            );
        }


        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_sales_prices/{priceId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }
        // path params
        if ($price_id !== null) {
            $resourcePath = str_replace(
                '{' . 'priceId' . '}',
                ObjectSerializer::toPathValue($price_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSalesPricesPriceIdGet
     *
     * Get sales price data for a variation
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  int $price_id price_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesPriceIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationSalesPrice
     */
    public function restItemsIdVariationsVariationIdVariationSalesPricesPriceIdGet(
        int $id,
        int $variation_id,
        int $price_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesPriceIdGet'][0]
    ): \ck\Model\VariationSalesPrice
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationSalesPricesPriceIdGetWithHttpInfo($id, $variation_id, $price_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSalesPricesPriceIdGetWithHttpInfo
     *
     * Get sales price data for a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $price_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesPriceIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationSalesPrice, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationSalesPricesPriceIdGetWithHttpInfo(
        int $id,
        int $variation_id,
        int $price_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesPriceIdGet'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationSalesPricesPriceIdGetRequest($id, $variation_id, $price_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationSalesPrice' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationSalesPrice' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationSalesPrice', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationSalesPrice';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationSalesPrice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSalesPricesPriceIdGetAsync
     *
     * Get sales price data for a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $price_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesPriceIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationSalesPricesPriceIdGetAsync(
        int $id,
        int $variation_id,
        int $price_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesPriceIdGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationSalesPricesPriceIdGetAsyncWithHttpInfo($id, $variation_id, $price_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSalesPricesPriceIdGetAsyncWithHttpInfo
     *
     * Get sales price data for a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $price_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesPriceIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationSalesPricesPriceIdGetAsyncWithHttpInfo(
        $id,
        $variation_id,
        $price_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesPriceIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationSalesPrice';
        $request = $this->restItemsIdVariationsVariationIdVariationSalesPricesPriceIdGetRequest($id, $variation_id, $price_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationSalesPricesPriceIdGet'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $price_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesPriceIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationSalesPricesPriceIdGetRequest(
        $id,
        $variation_id,
        $price_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesPriceIdGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationSalesPricesPriceIdGet'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationSalesPricesPriceIdGet'
            );
        }

        // verify the required parameter 'price_id' is set
        if ($price_id === null || (is_array($price_id) && count($price_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $price_id when calling restItemsIdVariationsVariationIdVariationSalesPricesPriceIdGet'
            );
        }


        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_sales_prices/{priceId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }
        // path params
        if ($price_id !== null) {
            $resourcePath = str_replace(
                '{' . 'priceId' . '}',
                ObjectSerializer::toPathValue($price_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSalesPricesPriceIdPut
     *
     * Update sales price data
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  int $price_id price_id (required)
     * @param  \ck\Model\RestItemsVariationsVariationSalesPricesPutRequest|null $_rest_items_id_variations_variation_id_variation_sales_prices_price_id _rest_items_id_variations_variation_id_variation_sales_prices_price_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesPriceIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationSalesPrice
     */
    public function restItemsIdVariationsVariationIdVariationSalesPricesPriceIdPut(
        int $id,
        int $variation_id,
        int $price_id,
        ?\ck\Model\RestItemsVariationsVariationSalesPricesPutRequest $_rest_items_id_variations_variation_id_variation_sales_prices_price_id = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesPriceIdPut'][0]
    ): \ck\Model\VariationSalesPrice
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationSalesPricesPriceIdPutWithHttpInfo($id, $variation_id, $price_id, $_rest_items_id_variations_variation_id_variation_sales_prices_price_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSalesPricesPriceIdPutWithHttpInfo
     *
     * Update sales price data
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $price_id (required)
     * @param  \ck\Model\RestItemsVariationsVariationSalesPricesPutRequest|null $_rest_items_id_variations_variation_id_variation_sales_prices_price_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesPriceIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationSalesPrice, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationSalesPricesPriceIdPutWithHttpInfo(
        int $id,
        int $variation_id,
        int $price_id,
        ?\ck\Model\RestItemsVariationsVariationSalesPricesPutRequest $_rest_items_id_variations_variation_id_variation_sales_prices_price_id = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesPriceIdPut'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationSalesPricesPriceIdPutRequest($id, $variation_id, $price_id, $_rest_items_id_variations_variation_id_variation_sales_prices_price_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationSalesPrice' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationSalesPrice' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationSalesPrice', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationSalesPrice';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationSalesPrice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSalesPricesPriceIdPutAsync
     *
     * Update sales price data
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $price_id (required)
     * @param  \ck\Model\RestItemsVariationsVariationSalesPricesPutRequest|null $_rest_items_id_variations_variation_id_variation_sales_prices_price_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesPriceIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationSalesPricesPriceIdPutAsync(
        int $id,
        int $variation_id,
        int $price_id,
        ?\ck\Model\RestItemsVariationsVariationSalesPricesPutRequest $_rest_items_id_variations_variation_id_variation_sales_prices_price_id = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesPriceIdPut'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationSalesPricesPriceIdPutAsyncWithHttpInfo($id, $variation_id, $price_id, $_rest_items_id_variations_variation_id_variation_sales_prices_price_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSalesPricesPriceIdPutAsyncWithHttpInfo
     *
     * Update sales price data
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $price_id (required)
     * @param  \ck\Model\RestItemsVariationsVariationSalesPricesPutRequest|null $_rest_items_id_variations_variation_id_variation_sales_prices_price_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesPriceIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationSalesPricesPriceIdPutAsyncWithHttpInfo(
        $id,
        $variation_id,
        $price_id,
        $_rest_items_id_variations_variation_id_variation_sales_prices_price_id = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesPriceIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationSalesPrice';
        $request = $this->restItemsIdVariationsVariationIdVariationSalesPricesPriceIdPutRequest($id, $variation_id, $price_id, $_rest_items_id_variations_variation_id_variation_sales_prices_price_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationSalesPricesPriceIdPut'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $price_id (required)
     * @param  \ck\Model\RestItemsVariationsVariationSalesPricesPutRequest|null $_rest_items_id_variations_variation_id_variation_sales_prices_price_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesPriceIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationSalesPricesPriceIdPutRequest(
        $id,
        $variation_id,
        $price_id,
        $_rest_items_id_variations_variation_id_variation_sales_prices_price_id = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSalesPricesPriceIdPut'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationSalesPricesPriceIdPut'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationSalesPricesPriceIdPut'
            );
        }

        // verify the required parameter 'price_id' is set
        if ($price_id === null || (is_array($price_id) && count($price_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $price_id when calling restItemsIdVariationsVariationIdVariationSalesPricesPriceIdPut'
            );
        }



        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_sales_prices/{priceId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }
        // path params
        if ($price_id !== null) {
            $resourcePath = str_replace(
                '{' . 'priceId' . '}',
                ObjectSerializer::toPathValue($price_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_id_variations_variation_id_variation_sales_prices_price_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_id_variations_variation_id_variation_sales_prices_price_id));
            } else {
                $httpBody = $_rest_items_id_variations_variation_id_variation_sales_prices_price_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSkusGet
     *
     * List SKUs
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSkusGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationSku[]
     */
    public function restItemsIdVariationsVariationIdVariationSkusGet(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSkusGet'][0]
    ): array
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationSkusGetWithHttpInfo($id, $variation_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSkusGetWithHttpInfo
     *
     * List SKUs
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSkusGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationSku[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationSkusGetWithHttpInfo(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSkusGet'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationSkusGetRequest($id, $variation_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationSku[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationSku[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationSku[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationSku[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationSku[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSkusGetAsync
     *
     * List SKUs
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSkusGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationSkusGetAsync(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSkusGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationSkusGetAsyncWithHttpInfo($id, $variation_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSkusGetAsyncWithHttpInfo
     *
     * List SKUs
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSkusGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationSkusGetAsyncWithHttpInfo(
        $id,
        $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSkusGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationSku[]';
        $request = $this->restItemsIdVariationsVariationIdVariationSkusGetRequest($id, $variation_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationSkusGet'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSkusGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationSkusGetRequest(
        $id,
        $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSkusGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationSkusGet'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationSkusGet'
            );
        }


        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_skus';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSkusPost
     *
     * Create an SKU
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdVariationSkusPostRequest|null $_rest_items_id_variations_variation_id_variation_skus _rest_items_id_variations_variation_id_variation_skus (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSkusPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationSku
     */
    public function restItemsIdVariationsVariationIdVariationSkusPost(
        int $id,
        int $variation_id,
        ?\ck\Model\RestItemsIdVariationsVariationIdVariationSkusPostRequest $_rest_items_id_variations_variation_id_variation_skus = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSkusPost'][0]
    ): \ck\Model\VariationSku
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationSkusPostWithHttpInfo($id, $variation_id, $_rest_items_id_variations_variation_id_variation_skus, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSkusPostWithHttpInfo
     *
     * Create an SKU
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdVariationSkusPostRequest|null $_rest_items_id_variations_variation_id_variation_skus (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSkusPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationSku, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationSkusPostWithHttpInfo(
        int $id,
        int $variation_id,
        ?\ck\Model\RestItemsIdVariationsVariationIdVariationSkusPostRequest $_rest_items_id_variations_variation_id_variation_skus = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSkusPost'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationSkusPostRequest($id, $variation_id, $_rest_items_id_variations_variation_id_variation_skus, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationSku' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationSku' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationSku', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationSku';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationSku',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSkusPostAsync
     *
     * Create an SKU
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdVariationSkusPostRequest|null $_rest_items_id_variations_variation_id_variation_skus (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSkusPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationSkusPostAsync(
        int $id,
        int $variation_id,
        ?\ck\Model\RestItemsIdVariationsVariationIdVariationSkusPostRequest $_rest_items_id_variations_variation_id_variation_skus = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSkusPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationSkusPostAsyncWithHttpInfo($id, $variation_id, $_rest_items_id_variations_variation_id_variation_skus, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSkusPostAsyncWithHttpInfo
     *
     * Create an SKU
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdVariationSkusPostRequest|null $_rest_items_id_variations_variation_id_variation_skus (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSkusPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationSkusPostAsyncWithHttpInfo(
        $id,
        $variation_id,
        $_rest_items_id_variations_variation_id_variation_skus = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSkusPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationSku';
        $request = $this->restItemsIdVariationsVariationIdVariationSkusPostRequest($id, $variation_id, $_rest_items_id_variations_variation_id_variation_skus, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationSkusPost'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdVariationSkusPostRequest|null $_rest_items_id_variations_variation_id_variation_skus (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSkusPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationSkusPostRequest(
        $id,
        $variation_id,
        $_rest_items_id_variations_variation_id_variation_skus = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSkusPost'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationSkusPost'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationSkusPost'
            );
        }



        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_skus';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_id_variations_variation_id_variation_skus)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_id_variations_variation_id_variation_skus));
            } else {
                $httpBody = $_rest_items_id_variations_variation_id_variation_skus;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSkusSkuIdDelete
     *
     * Delete an SKU
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  int $sku_id sku_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSkusSkuIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsIdVariationsVariationIdVariationSkusSkuIdDelete(
        int $id,
        int $variation_id,
        int $sku_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSkusSkuIdDelete'][0]
    ): object
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationSkusSkuIdDeleteWithHttpInfo($id, $variation_id, $sku_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSkusSkuIdDeleteWithHttpInfo
     *
     * Delete an SKU
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $sku_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSkusSkuIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationSkusSkuIdDeleteWithHttpInfo(
        int $id,
        int $variation_id,
        int $sku_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSkusSkuIdDelete'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationSkusSkuIdDeleteRequest($id, $variation_id, $sku_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSkusSkuIdDeleteAsync
     *
     * Delete an SKU
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $sku_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSkusSkuIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationSkusSkuIdDeleteAsync(
        int $id,
        int $variation_id,
        int $sku_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSkusSkuIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationSkusSkuIdDeleteAsyncWithHttpInfo($id, $variation_id, $sku_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSkusSkuIdDeleteAsyncWithHttpInfo
     *
     * Delete an SKU
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $sku_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSkusSkuIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationSkusSkuIdDeleteAsyncWithHttpInfo(
        $id,
        $variation_id,
        $sku_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSkusSkuIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsIdVariationsVariationIdVariationSkusSkuIdDeleteRequest($id, $variation_id, $sku_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationSkusSkuIdDelete'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $sku_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSkusSkuIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationSkusSkuIdDeleteRequest(
        $id,
        $variation_id,
        $sku_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSkusSkuIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationSkusSkuIdDelete'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationSkusSkuIdDelete'
            );
        }

        // verify the required parameter 'sku_id' is set
        if ($sku_id === null || (is_array($sku_id) && count($sku_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $sku_id when calling restItemsIdVariationsVariationIdVariationSkusSkuIdDelete'
            );
        }


        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_skus/{skuId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }
        // path params
        if ($sku_id !== null) {
            $resourcePath = str_replace(
                '{' . 'skuId' . '}',
                ObjectSerializer::toPathValue($sku_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSkusSkuIdGet
     *
     * Get an SKU
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  int $sku_id sku_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSkusSkuIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationSku
     */
    public function restItemsIdVariationsVariationIdVariationSkusSkuIdGet(
        int $id,
        int $variation_id,
        int $sku_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSkusSkuIdGet'][0]
    ): \ck\Model\VariationSku
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationSkusSkuIdGetWithHttpInfo($id, $variation_id, $sku_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSkusSkuIdGetWithHttpInfo
     *
     * Get an SKU
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $sku_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSkusSkuIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationSku, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationSkusSkuIdGetWithHttpInfo(
        int $id,
        int $variation_id,
        int $sku_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSkusSkuIdGet'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationSkusSkuIdGetRequest($id, $variation_id, $sku_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationSku' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationSku' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationSku', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationSku';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationSku',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSkusSkuIdGetAsync
     *
     * Get an SKU
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $sku_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSkusSkuIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationSkusSkuIdGetAsync(
        int $id,
        int $variation_id,
        int $sku_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSkusSkuIdGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationSkusSkuIdGetAsyncWithHttpInfo($id, $variation_id, $sku_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSkusSkuIdGetAsyncWithHttpInfo
     *
     * Get an SKU
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $sku_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSkusSkuIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationSkusSkuIdGetAsyncWithHttpInfo(
        $id,
        $variation_id,
        $sku_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSkusSkuIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationSku';
        $request = $this->restItemsIdVariationsVariationIdVariationSkusSkuIdGetRequest($id, $variation_id, $sku_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationSkusSkuIdGet'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $sku_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSkusSkuIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationSkusSkuIdGetRequest(
        $id,
        $variation_id,
        $sku_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSkusSkuIdGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationSkusSkuIdGet'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationSkusSkuIdGet'
            );
        }

        // verify the required parameter 'sku_id' is set
        if ($sku_id === null || (is_array($sku_id) && count($sku_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $sku_id when calling restItemsIdVariationsVariationIdVariationSkusSkuIdGet'
            );
        }


        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_skus/{skuId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }
        // path params
        if ($sku_id !== null) {
            $resourcePath = str_replace(
                '{' . 'skuId' . '}',
                ObjectSerializer::toPathValue($sku_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSkusSkuIdPut
     *
     * Update an SKU
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  int $sku_id sku_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdVariationSkusPostRequest|null $_rest_items_id_variations_variation_id_variation_skus_sku_id _rest_items_id_variations_variation_id_variation_skus_sku_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSkusSkuIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationSku
     */
    public function restItemsIdVariationsVariationIdVariationSkusSkuIdPut(
        int $id,
        int $variation_id,
        int $sku_id,
        ?\ck\Model\RestItemsIdVariationsVariationIdVariationSkusPostRequest $_rest_items_id_variations_variation_id_variation_skus_sku_id = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSkusSkuIdPut'][0]
    ): \ck\Model\VariationSku
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationSkusSkuIdPutWithHttpInfo($id, $variation_id, $sku_id, $_rest_items_id_variations_variation_id_variation_skus_sku_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSkusSkuIdPutWithHttpInfo
     *
     * Update an SKU
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $sku_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdVariationSkusPostRequest|null $_rest_items_id_variations_variation_id_variation_skus_sku_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSkusSkuIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationSku, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationSkusSkuIdPutWithHttpInfo(
        int $id,
        int $variation_id,
        int $sku_id,
        ?\ck\Model\RestItemsIdVariationsVariationIdVariationSkusPostRequest $_rest_items_id_variations_variation_id_variation_skus_sku_id = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSkusSkuIdPut'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationSkusSkuIdPutRequest($id, $variation_id, $sku_id, $_rest_items_id_variations_variation_id_variation_skus_sku_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationSku' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationSku' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationSku', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationSku';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationSku',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSkusSkuIdPutAsync
     *
     * Update an SKU
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $sku_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdVariationSkusPostRequest|null $_rest_items_id_variations_variation_id_variation_skus_sku_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSkusSkuIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationSkusSkuIdPutAsync(
        int $id,
        int $variation_id,
        int $sku_id,
        ?\ck\Model\RestItemsIdVariationsVariationIdVariationSkusPostRequest $_rest_items_id_variations_variation_id_variation_skus_sku_id = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSkusSkuIdPut'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationSkusSkuIdPutAsyncWithHttpInfo($id, $variation_id, $sku_id, $_rest_items_id_variations_variation_id_variation_skus_sku_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSkusSkuIdPutAsyncWithHttpInfo
     *
     * Update an SKU
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $sku_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdVariationSkusPostRequest|null $_rest_items_id_variations_variation_id_variation_skus_sku_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSkusSkuIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationSkusSkuIdPutAsyncWithHttpInfo(
        $id,
        $variation_id,
        $sku_id,
        $_rest_items_id_variations_variation_id_variation_skus_sku_id = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSkusSkuIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationSku';
        $request = $this->restItemsIdVariationsVariationIdVariationSkusSkuIdPutRequest($id, $variation_id, $sku_id, $_rest_items_id_variations_variation_id_variation_skus_sku_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationSkusSkuIdPut'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $sku_id (required)
     * @param  \ck\Model\RestItemsIdVariationsVariationIdVariationSkusPostRequest|null $_rest_items_id_variations_variation_id_variation_skus_sku_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSkusSkuIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationSkusSkuIdPutRequest(
        $id,
        $variation_id,
        $sku_id,
        $_rest_items_id_variations_variation_id_variation_skus_sku_id = null,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSkusSkuIdPut'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationSkusSkuIdPut'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationSkusSkuIdPut'
            );
        }

        // verify the required parameter 'sku_id' is set
        if ($sku_id === null || (is_array($sku_id) && count($sku_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $sku_id when calling restItemsIdVariationsVariationIdVariationSkusSkuIdPut'
            );
        }



        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_skus/{skuId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }
        // path params
        if ($sku_id !== null) {
            $resourcePath = str_replace(
                '{' . 'skuId' . '}',
                ObjectSerializer::toPathValue($sku_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_id_variations_variation_id_variation_skus_sku_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_id_variations_variation_id_variation_skus_sku_id));
            } else {
                $httpBody = $_rest_items_id_variations_variation_id_variation_skus_sku_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSuppliersGet
     *
     * Lists suppliers for a variation
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSuppliersGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationSupplier[]
     */
    public function restItemsIdVariationsVariationIdVariationSuppliersGet(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSuppliersGet'][0]
    ): array
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationSuppliersGetWithHttpInfo($id, $variation_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSuppliersGetWithHttpInfo
     *
     * Lists suppliers for a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSuppliersGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationSupplier[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationSuppliersGetWithHttpInfo(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSuppliersGet'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationSuppliersGetRequest($id, $variation_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationSupplier[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationSupplier[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationSupplier[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationSupplier[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationSupplier[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSuppliersGetAsync
     *
     * Lists suppliers for a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSuppliersGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationSuppliersGetAsync(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSuppliersGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationSuppliersGetAsyncWithHttpInfo($id, $variation_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSuppliersGetAsyncWithHttpInfo
     *
     * Lists suppliers for a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSuppliersGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationSuppliersGetAsyncWithHttpInfo(
        $id,
        $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSuppliersGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationSupplier[]';
        $request = $this->restItemsIdVariationsVariationIdVariationSuppliersGetRequest($id, $variation_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationSuppliersGet'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSuppliersGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationSuppliersGetRequest(
        $id,
        $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSuppliersGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationSuppliersGet'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationSuppliersGet'
            );
        }


        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_suppliers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSuppliersPost
     *
     * Create a link between variation and supplier
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSuppliersPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationSupplier
     */
    public function restItemsIdVariationsVariationIdVariationSuppliersPost(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSuppliersPost'][0]
    ): \ck\Model\VariationSupplier
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationSuppliersPostWithHttpInfo($id, $variation_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSuppliersPostWithHttpInfo
     *
     * Create a link between variation and supplier
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSuppliersPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationSupplier, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationSuppliersPostWithHttpInfo(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSuppliersPost'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationSuppliersPostRequest($id, $variation_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationSupplier' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationSupplier' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationSupplier', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationSupplier';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationSupplier',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSuppliersPostAsync
     *
     * Create a link between variation and supplier
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSuppliersPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationSuppliersPostAsync(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSuppliersPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationSuppliersPostAsyncWithHttpInfo($id, $variation_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSuppliersPostAsyncWithHttpInfo
     *
     * Create a link between variation and supplier
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSuppliersPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationSuppliersPostAsyncWithHttpInfo(
        $id,
        $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSuppliersPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationSupplier';
        $request = $this->restItemsIdVariationsVariationIdVariationSuppliersPostRequest($id, $variation_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationSuppliersPost'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSuppliersPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationSuppliersPostRequest(
        $id,
        $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSuppliersPost'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationSuppliersPost'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationSuppliersPost'
            );
        }


        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_suppliers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdDelete
     *
     * Delete link between variation and supplier
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  int $variation_supplier_id variation_supplier_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdDelete(
        int $id,
        int $variation_id,
        int $variation_supplier_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdDelete'][0]
    ): object
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdDeleteWithHttpInfo($id, $variation_id, $variation_supplier_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdDeleteWithHttpInfo
     *
     * Delete link between variation and supplier
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $variation_supplier_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdDeleteWithHttpInfo(
        int $id,
        int $variation_id,
        int $variation_supplier_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdDelete'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdDeleteRequest($id, $variation_id, $variation_supplier_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdDeleteAsync
     *
     * Delete link between variation and supplier
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $variation_supplier_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdDeleteAsync(
        int $id,
        int $variation_id,
        int $variation_supplier_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdDeleteAsyncWithHttpInfo($id, $variation_id, $variation_supplier_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdDeleteAsyncWithHttpInfo
     *
     * Delete link between variation and supplier
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $variation_supplier_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdDeleteAsyncWithHttpInfo(
        $id,
        $variation_id,
        $variation_supplier_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdDeleteRequest($id, $variation_id, $variation_supplier_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdDelete'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $variation_supplier_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdDeleteRequest(
        $id,
        $variation_id,
        $variation_supplier_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdDelete'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdDelete'
            );
        }

        // verify the required parameter 'variation_supplier_id' is set
        if ($variation_supplier_id === null || (is_array($variation_supplier_id) && count($variation_supplier_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_supplier_id when calling restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdDelete'
            );
        }


        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_suppliers/{variationSupplierId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }
        // path params
        if ($variation_supplier_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationSupplierId' . '}',
                ObjectSerializer::toPathValue($variation_supplier_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdGet
     *
     * Get supplier data for a variation
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  int $variation_supplier_id variation_supplier_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationSupplier
     */
    public function restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdGet(
        int $id,
        int $variation_id,
        int $variation_supplier_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdGet'][0]
    ): \ck\Model\VariationSupplier
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdGetWithHttpInfo($id, $variation_id, $variation_supplier_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdGetWithHttpInfo
     *
     * Get supplier data for a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $variation_supplier_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationSupplier, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdGetWithHttpInfo(
        int $id,
        int $variation_id,
        int $variation_supplier_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdGet'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdGetRequest($id, $variation_id, $variation_supplier_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationSupplier' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationSupplier' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationSupplier', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationSupplier';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationSupplier',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdGetAsync
     *
     * Get supplier data for a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $variation_supplier_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdGetAsync(
        int $id,
        int $variation_id,
        int $variation_supplier_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdGetAsyncWithHttpInfo($id, $variation_id, $variation_supplier_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdGetAsyncWithHttpInfo
     *
     * Get supplier data for a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $variation_supplier_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdGetAsyncWithHttpInfo(
        $id,
        $variation_id,
        $variation_supplier_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationSupplier';
        $request = $this->restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdGetRequest($id, $variation_id, $variation_supplier_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdGet'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $variation_supplier_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdGetRequest(
        $id,
        $variation_id,
        $variation_supplier_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdGet'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdGet'
            );
        }

        // verify the required parameter 'variation_supplier_id' is set
        if ($variation_supplier_id === null || (is_array($variation_supplier_id) && count($variation_supplier_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_supplier_id when calling restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdGet'
            );
        }


        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_suppliers/{variationSupplierId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }
        // path params
        if ($variation_supplier_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationSupplierId' . '}',
                ObjectSerializer::toPathValue($variation_supplier_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdPut
     *
     * Updates supplier data for a variation
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  int $variation_supplier_id variation_supplier_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationSupplier
     */
    public function restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdPut(
        int $id,
        int $variation_id,
        int $variation_supplier_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdPut'][0]
    ): \ck\Model\VariationSupplier
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdPutWithHttpInfo($id, $variation_id, $variation_supplier_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdPutWithHttpInfo
     *
     * Updates supplier data for a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $variation_supplier_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationSupplier, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdPutWithHttpInfo(
        int $id,
        int $variation_id,
        int $variation_supplier_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdPut'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdPutRequest($id, $variation_id, $variation_supplier_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationSupplier' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationSupplier' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationSupplier', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationSupplier';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationSupplier',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdPutAsync
     *
     * Updates supplier data for a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $variation_supplier_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdPutAsync(
        int $id,
        int $variation_id,
        int $variation_supplier_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdPut'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdPutAsyncWithHttpInfo($id, $variation_id, $variation_supplier_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdPutAsyncWithHttpInfo
     *
     * Updates supplier data for a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $variation_supplier_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdPutAsyncWithHttpInfo(
        $id,
        $variation_id,
        $variation_supplier_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationSupplier';
        $request = $this->restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdPutRequest($id, $variation_id, $variation_supplier_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdPut'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $variation_supplier_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdPutRequest(
        $id,
        $variation_id,
        $variation_supplier_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdPut'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdPut'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdPut'
            );
        }

        // verify the required parameter 'variation_supplier_id' is set
        if ($variation_supplier_id === null || (is_array($variation_supplier_id) && count($variation_supplier_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_supplier_id when calling restItemsIdVariationsVariationIdVariationSuppliersVariationSupplierIdPut'
            );
        }


        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_suppliers/{variationSupplierId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }
        // path params
        if ($variation_supplier_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationSupplierId' . '}',
                ObjectSerializer::toPathValue($variation_supplier_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationWarehousesGet
     *
     * List the warehouses linked to a variation
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationWarehousesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationWarehouse[]
     */
    public function restItemsIdVariationsVariationIdVariationWarehousesGet(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationWarehousesGet'][0]
    ): array
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationWarehousesGetWithHttpInfo($id, $variation_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationWarehousesGetWithHttpInfo
     *
     * List the warehouses linked to a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationWarehousesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationWarehouse[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationWarehousesGetWithHttpInfo(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationWarehousesGet'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationWarehousesGetRequest($id, $variation_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationWarehouse[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationWarehouse[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationWarehouse[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationWarehouse[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationWarehouse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationWarehousesGetAsync
     *
     * List the warehouses linked to a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationWarehousesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationWarehousesGetAsync(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationWarehousesGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationWarehousesGetAsyncWithHttpInfo($id, $variation_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationWarehousesGetAsyncWithHttpInfo
     *
     * List the warehouses linked to a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationWarehousesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationWarehousesGetAsyncWithHttpInfo(
        $id,
        $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationWarehousesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationWarehouse[]';
        $request = $this->restItemsIdVariationsVariationIdVariationWarehousesGetRequest($id, $variation_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationWarehousesGet'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationWarehousesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationWarehousesGetRequest(
        $id,
        $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationWarehousesGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationWarehousesGet'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationWarehousesGet'
            );
        }


        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_warehouses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationWarehousesPost
     *
     * Create link between a variation and a warehouse
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationWarehousesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationWarehouse
     */
    public function restItemsIdVariationsVariationIdVariationWarehousesPost(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationWarehousesPost'][0]
    ): \ck\Model\VariationWarehouse
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationWarehousesPostWithHttpInfo($id, $variation_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationWarehousesPostWithHttpInfo
     *
     * Create link between a variation and a warehouse
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationWarehousesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationWarehouse, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationWarehousesPostWithHttpInfo(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationWarehousesPost'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationWarehousesPostRequest($id, $variation_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationWarehouse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationWarehouse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationWarehouse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationWarehouse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationWarehouse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationWarehousesPostAsync
     *
     * Create link between a variation and a warehouse
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationWarehousesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationWarehousesPostAsync(
        int $id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationWarehousesPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationWarehousesPostAsyncWithHttpInfo($id, $variation_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationWarehousesPostAsyncWithHttpInfo
     *
     * Create link between a variation and a warehouse
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationWarehousesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationWarehousesPostAsyncWithHttpInfo(
        $id,
        $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationWarehousesPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationWarehouse';
        $request = $this->restItemsIdVariationsVariationIdVariationWarehousesPostRequest($id, $variation_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationWarehousesPost'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationWarehousesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationWarehousesPostRequest(
        $id,
        $variation_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationWarehousesPost'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationWarehousesPost'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationWarehousesPost'
            );
        }


        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_warehouses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdDelete
     *
     * Delete link between a warehouse and a variation
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  int $warehouse_id warehouse_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdDelete(
        int $id,
        int $variation_id,
        int $warehouse_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdDelete'][0]
    ): object
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdDeleteWithHttpInfo($id, $variation_id, $warehouse_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdDeleteWithHttpInfo
     *
     * Delete link between a warehouse and a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $warehouse_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdDeleteWithHttpInfo(
        int $id,
        int $variation_id,
        int $warehouse_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdDelete'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdDeleteRequest($id, $variation_id, $warehouse_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdDeleteAsync
     *
     * Delete link between a warehouse and a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $warehouse_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdDeleteAsync(
        int $id,
        int $variation_id,
        int $warehouse_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdDeleteAsyncWithHttpInfo($id, $variation_id, $warehouse_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdDeleteAsyncWithHttpInfo
     *
     * Delete link between a warehouse and a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $warehouse_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdDeleteAsyncWithHttpInfo(
        $id,
        $variation_id,
        $warehouse_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdDeleteRequest($id, $variation_id, $warehouse_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdDelete'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $warehouse_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdDeleteRequest(
        $id,
        $variation_id,
        $warehouse_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdDelete'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdDelete'
            );
        }

        // verify the required parameter 'warehouse_id' is set
        if ($warehouse_id === null || (is_array($warehouse_id) && count($warehouse_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $warehouse_id when calling restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdDelete'
            );
        }


        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_warehouses/{warehouseId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }
        // path params
        if ($warehouse_id !== null) {
            $resourcePath = str_replace(
                '{' . 'warehouseId' . '}',
                ObjectSerializer::toPathValue($warehouse_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdGet
     *
     * Get warehouse data for a variation
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  int $warehouse_id warehouse_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationWarehouse
     */
    public function restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdGet(
        int $id,
        int $variation_id,
        int $warehouse_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdGet'][0]
    ): \ck\Model\VariationWarehouse
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdGetWithHttpInfo($id, $variation_id, $warehouse_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdGetWithHttpInfo
     *
     * Get warehouse data for a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $warehouse_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationWarehouse, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdGetWithHttpInfo(
        int $id,
        int $variation_id,
        int $warehouse_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdGet'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdGetRequest($id, $variation_id, $warehouse_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationWarehouse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationWarehouse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationWarehouse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationWarehouse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationWarehouse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdGetAsync
     *
     * Get warehouse data for a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $warehouse_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdGetAsync(
        int $id,
        int $variation_id,
        int $warehouse_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdGetAsyncWithHttpInfo($id, $variation_id, $warehouse_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdGetAsyncWithHttpInfo
     *
     * Get warehouse data for a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $warehouse_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdGetAsyncWithHttpInfo(
        $id,
        $variation_id,
        $warehouse_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationWarehouse';
        $request = $this->restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdGetRequest($id, $variation_id, $warehouse_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdGet'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $warehouse_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdGetRequest(
        $id,
        $variation_id,
        $warehouse_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdGet'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdGet'
            );
        }

        // verify the required parameter 'warehouse_id' is set
        if ($warehouse_id === null || (is_array($warehouse_id) && count($warehouse_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $warehouse_id when calling restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdGet'
            );
        }


        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_warehouses/{warehouseId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }
        // path params
        if ($warehouse_id !== null) {
            $resourcePath = str_replace(
                '{' . 'warehouseId' . '}',
                ObjectSerializer::toPathValue($warehouse_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdPut
     *
     * Update warehouse data of a variation
     *
     * @param  int $id id (required)
     * @param  int $variation_id variation_id (required)
     * @param  int $warehouse_id warehouse_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationWarehouse
     */
    public function restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdPut(
        int $id,
        int $variation_id,
        int $warehouse_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdPut'][0]
    ): \ck\Model\VariationWarehouse
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdPutWithHttpInfo($id, $variation_id, $warehouse_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdPutWithHttpInfo
     *
     * Update warehouse data of a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $warehouse_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationWarehouse, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdPutWithHttpInfo(
        int $id,
        int $variation_id,
        int $warehouse_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdPut'][0]
    ): array
    {
        $request = $this->restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdPutRequest($id, $variation_id, $warehouse_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationWarehouse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationWarehouse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationWarehouse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationWarehouse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationWarehouse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdPutAsync
     *
     * Update warehouse data of a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $warehouse_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdPutAsync(
        int $id,
        int $variation_id,
        int $warehouse_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdPut'][0]
    ): PromiseInterface
    {
        return $this->restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdPutAsyncWithHttpInfo($id, $variation_id, $warehouse_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdPutAsyncWithHttpInfo
     *
     * Update warehouse data of a variation
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $warehouse_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdPutAsyncWithHttpInfo(
        $id,
        $variation_id,
        $warehouse_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationWarehouse';
        $request = $this->restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdPutRequest($id, $variation_id, $warehouse_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdPut'
     *
     * @param  int $id (required)
     * @param  int $variation_id (required)
     * @param  int $warehouse_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdPutRequest(
        $id,
        $variation_id,
        $warehouse_id,
        string $contentType = self::contentTypes['restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdPut'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdPut'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdPut'
            );
        }

        // verify the required parameter 'warehouse_id' is set
        if ($warehouse_id === null || (is_array($warehouse_id) && count($warehouse_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $warehouse_id when calling restItemsIdVariationsVariationIdVariationWarehousesWarehouseIdPut'
            );
        }


        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_warehouses/{warehouseId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }
        // path params
        if ($warehouse_id !== null) {
            $resourcePath = str_replace(
                '{' . 'warehouseId' . '}',
                ObjectSerializer::toPathValue($warehouse_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsItemIdDelete
     *
     * Delete an item
     *
     * @param  int $item_id item_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsItemIdDelete(
        int $item_id,
        string $contentType = self::contentTypes['restItemsItemIdDelete'][0]
    ): object
    {
        list($response) = $this->restItemsItemIdDeleteWithHttpInfo($item_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsItemIdDeleteWithHttpInfo
     *
     * Delete an item
     *
     * @param  int $item_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsItemIdDeleteWithHttpInfo(
        int $item_id,
        string $contentType = self::contentTypes['restItemsItemIdDelete'][0]
    ): array
    {
        $request = $this->restItemsItemIdDeleteRequest($item_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsItemIdDeleteAsync
     *
     * Delete an item
     *
     * @param  int $item_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsItemIdDeleteAsync(
        int $item_id,
        string $contentType = self::contentTypes['restItemsItemIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemsItemIdDeleteAsyncWithHttpInfo($item_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsItemIdDeleteAsyncWithHttpInfo
     *
     * Delete an item
     *
     * @param  int $item_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsItemIdDeleteAsyncWithHttpInfo(
        $item_id,
        string $contentType = self::contentTypes['restItemsItemIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsItemIdDeleteRequest($item_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsItemIdDelete'
     *
     * @param  int $item_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsItemIdDeleteRequest(
        $item_id,
        string $contentType = self::contentTypes['restItemsItemIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $item_id when calling restItemsItemIdDelete'
            );
        }


        $resourcePath = '/rest/items/{itemId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsItemIdFillPost
     *
     * Fill item to es
     *
     * @param  int $item_id item_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdFillPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restItemsItemIdFillPost(
        int $item_id,
        string $contentType = self::contentTypes['restItemsItemIdFillPost'][0]
    ): void
    {
        $this->restItemsItemIdFillPostWithHttpInfo($item_id, $contentType);
    }

    /**
     * Operation restItemsItemIdFillPostWithHttpInfo
     *
     * Fill item to es
     *
     * @param  int $item_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdFillPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsItemIdFillPostWithHttpInfo(
        int $item_id,
        string $contentType = self::contentTypes['restItemsItemIdFillPost'][0]
    ): array
    {
        $request = $this->restItemsItemIdFillPostRequest($item_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsItemIdFillPostAsync
     *
     * Fill item to es
     *
     * @param  int $item_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdFillPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsItemIdFillPostAsync(
        int $item_id,
        string $contentType = self::contentTypes['restItemsItemIdFillPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsItemIdFillPostAsyncWithHttpInfo($item_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsItemIdFillPostAsyncWithHttpInfo
     *
     * Fill item to es
     *
     * @param  int $item_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdFillPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsItemIdFillPostAsyncWithHttpInfo(
        $item_id,
        string $contentType = self::contentTypes['restItemsItemIdFillPost'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restItemsItemIdFillPostRequest($item_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsItemIdFillPost'
     *
     * @param  int $item_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdFillPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsItemIdFillPostRequest(
        $item_id,
        string $contentType = self::contentTypes['restItemsItemIdFillPost'][0]
    ): Request
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $item_id when calling restItemsItemIdFillPost'
            );
        }


        $resourcePath = '/rest/items/{itemId}/fill';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsItemIdGet
     *
     * Show an item
     *
     * @param  int $item_id item_id (required)
     * @param  string|null $lang The &lt;a href&#x3D;&#39;https://developers.plentymarkets.com/rest-doc/introduction#countries&#39; target&#x3D;&#39;_blank&#39;&gt;language&lt;/a&gt; of the variation information. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Item
     */
    public function restItemsItemIdGet(
        int $item_id,
        ?string $lang = null,
        string $contentType = self::contentTypes['restItemsItemIdGet'][0]
    ): \ck\Model\Item
    {
        list($response) = $this->restItemsItemIdGetWithHttpInfo($item_id, $lang, $contentType);
        return $response;
    }

    /**
     * Operation restItemsItemIdGetWithHttpInfo
     *
     * Show an item
     *
     * @param  int $item_id (required)
     * @param  string|null $lang The &lt;a href&#x3D;&#39;https://developers.plentymarkets.com/rest-doc/introduction#countries&#39; target&#x3D;&#39;_blank&#39;&gt;language&lt;/a&gt; of the variation information. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Item, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsItemIdGetWithHttpInfo(
        int $item_id,
        ?string $lang = null,
        string $contentType = self::contentTypes['restItemsItemIdGet'][0]
    ): array
    {
        $request = $this->restItemsItemIdGetRequest($item_id, $lang, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Item' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Item' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Item', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Item';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Item',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsItemIdGetAsync
     *
     * Show an item
     *
     * @param  int $item_id (required)
     * @param  string|null $lang The &lt;a href&#x3D;&#39;https://developers.plentymarkets.com/rest-doc/introduction#countries&#39; target&#x3D;&#39;_blank&#39;&gt;language&lt;/a&gt; of the variation information. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsItemIdGetAsync(
        int $item_id,
        ?string $lang = null,
        string $contentType = self::contentTypes['restItemsItemIdGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsItemIdGetAsyncWithHttpInfo($item_id, $lang, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsItemIdGetAsyncWithHttpInfo
     *
     * Show an item
     *
     * @param  int $item_id (required)
     * @param  string|null $lang The &lt;a href&#x3D;&#39;https://developers.plentymarkets.com/rest-doc/introduction#countries&#39; target&#x3D;&#39;_blank&#39;&gt;language&lt;/a&gt; of the variation information. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsItemIdGetAsyncWithHttpInfo(
        $item_id,
        $lang = null,
        string $contentType = self::contentTypes['restItemsItemIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Item';
        $request = $this->restItemsItemIdGetRequest($item_id, $lang, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsItemIdGet'
     *
     * @param  int $item_id (required)
     * @param  string|null $lang The &lt;a href&#x3D;&#39;https://developers.plentymarkets.com/rest-doc/introduction#countries&#39; target&#x3D;&#39;_blank&#39;&gt;language&lt;/a&gt; of the variation information. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsItemIdGetRequest(
        $item_id,
        $lang = null,
        string $contentType = self::contentTypes['restItemsItemIdGet'][0]
    ): Request
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $item_id when calling restItemsItemIdGet'
            );
        }



        $resourcePath = '/rest/items/{itemId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $lang,
            'lang', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsItemIdItemShippingProfilesDelete
     *
     * Deactivate shipping profiles of an item
     *
     * @param  int $item_id item_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdItemShippingProfilesDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restItemsItemIdItemShippingProfilesDelete(
        int $item_id,
        string $contentType = self::contentTypes['restItemsItemIdItemShippingProfilesDelete'][0]
    ): void
    {
        $this->restItemsItemIdItemShippingProfilesDeleteWithHttpInfo($item_id, $contentType);
    }

    /**
     * Operation restItemsItemIdItemShippingProfilesDeleteWithHttpInfo
     *
     * Deactivate shipping profiles of an item
     *
     * @param  int $item_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdItemShippingProfilesDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsItemIdItemShippingProfilesDeleteWithHttpInfo(
        int $item_id,
        string $contentType = self::contentTypes['restItemsItemIdItemShippingProfilesDelete'][0]
    ): array
    {
        $request = $this->restItemsItemIdItemShippingProfilesDeleteRequest($item_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsItemIdItemShippingProfilesDeleteAsync
     *
     * Deactivate shipping profiles of an item
     *
     * @param  int $item_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdItemShippingProfilesDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsItemIdItemShippingProfilesDeleteAsync(
        int $item_id,
        string $contentType = self::contentTypes['restItemsItemIdItemShippingProfilesDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemsItemIdItemShippingProfilesDeleteAsyncWithHttpInfo($item_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsItemIdItemShippingProfilesDeleteAsyncWithHttpInfo
     *
     * Deactivate shipping profiles of an item
     *
     * @param  int $item_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdItemShippingProfilesDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsItemIdItemShippingProfilesDeleteAsyncWithHttpInfo(
        $item_id,
        string $contentType = self::contentTypes['restItemsItemIdItemShippingProfilesDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restItemsItemIdItemShippingProfilesDeleteRequest($item_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsItemIdItemShippingProfilesDelete'
     *
     * @param  int $item_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdItemShippingProfilesDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsItemIdItemShippingProfilesDeleteRequest(
        $item_id,
        string $contentType = self::contentTypes['restItemsItemIdItemShippingProfilesDelete'][0]
    ): Request
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $item_id when calling restItemsItemIdItemShippingProfilesDelete'
            );
        }


        $resourcePath = '/rest/items/{itemId}/item_shipping_profiles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsItemIdItemShippingProfilesGet
     *
     * List shipping profiles of an item
     *
     * @param  int $item_id item_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdItemShippingProfilesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ItemShippingProfiles[]
     */
    public function restItemsItemIdItemShippingProfilesGet(
        int $item_id,
        string $contentType = self::contentTypes['restItemsItemIdItemShippingProfilesGet'][0]
    ): array
    {
        list($response) = $this->restItemsItemIdItemShippingProfilesGetWithHttpInfo($item_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsItemIdItemShippingProfilesGetWithHttpInfo
     *
     * List shipping profiles of an item
     *
     * @param  int $item_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdItemShippingProfilesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ItemShippingProfiles[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsItemIdItemShippingProfilesGetWithHttpInfo(
        int $item_id,
        string $contentType = self::contentTypes['restItemsItemIdItemShippingProfilesGet'][0]
    ): array
    {
        $request = $this->restItemsItemIdItemShippingProfilesGetRequest($item_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ItemShippingProfiles[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ItemShippingProfiles[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ItemShippingProfiles[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ItemShippingProfiles[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ItemShippingProfiles[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsItemIdItemShippingProfilesGetAsync
     *
     * List shipping profiles of an item
     *
     * @param  int $item_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdItemShippingProfilesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsItemIdItemShippingProfilesGetAsync(
        int $item_id,
        string $contentType = self::contentTypes['restItemsItemIdItemShippingProfilesGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsItemIdItemShippingProfilesGetAsyncWithHttpInfo($item_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsItemIdItemShippingProfilesGetAsyncWithHttpInfo
     *
     * List shipping profiles of an item
     *
     * @param  int $item_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdItemShippingProfilesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsItemIdItemShippingProfilesGetAsyncWithHttpInfo(
        $item_id,
        string $contentType = self::contentTypes['restItemsItemIdItemShippingProfilesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ItemShippingProfiles[]';
        $request = $this->restItemsItemIdItemShippingProfilesGetRequest($item_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsItemIdItemShippingProfilesGet'
     *
     * @param  int $item_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdItemShippingProfilesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsItemIdItemShippingProfilesGetRequest(
        $item_id,
        string $contentType = self::contentTypes['restItemsItemIdItemShippingProfilesGet'][0]
    ): Request
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $item_id when calling restItemsItemIdItemShippingProfilesGet'
            );
        }


        $resourcePath = '/rest/items/{itemId}/item_shipping_profiles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsItemIdItemShippingProfilesIdDelete
     *
     * Deactivate a shipping profile
     *
     * @param  int $item_id The unique ID of the item (required)
     * @param  int $id The unique ID of the link between item and shipping profile (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdItemShippingProfilesIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsItemIdItemShippingProfilesIdDelete(
        int $item_id,
        int $id,
        string $contentType = self::contentTypes['restItemsItemIdItemShippingProfilesIdDelete'][0]
    ): object
    {
        list($response) = $this->restItemsItemIdItemShippingProfilesIdDeleteWithHttpInfo($item_id, $id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsItemIdItemShippingProfilesIdDeleteWithHttpInfo
     *
     * Deactivate a shipping profile
     *
     * @param  int $item_id The unique ID of the item (required)
     * @param  int $id The unique ID of the link between item and shipping profile (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdItemShippingProfilesIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsItemIdItemShippingProfilesIdDeleteWithHttpInfo(
        int $item_id,
        int $id,
        string $contentType = self::contentTypes['restItemsItemIdItemShippingProfilesIdDelete'][0]
    ): array
    {
        $request = $this->restItemsItemIdItemShippingProfilesIdDeleteRequest($item_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsItemIdItemShippingProfilesIdDeleteAsync
     *
     * Deactivate a shipping profile
     *
     * @param  int $item_id The unique ID of the item (required)
     * @param  int $id The unique ID of the link between item and shipping profile (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdItemShippingProfilesIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsItemIdItemShippingProfilesIdDeleteAsync(
        int $item_id,
        int $id,
        string $contentType = self::contentTypes['restItemsItemIdItemShippingProfilesIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemsItemIdItemShippingProfilesIdDeleteAsyncWithHttpInfo($item_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsItemIdItemShippingProfilesIdDeleteAsyncWithHttpInfo
     *
     * Deactivate a shipping profile
     *
     * @param  int $item_id The unique ID of the item (required)
     * @param  int $id The unique ID of the link between item and shipping profile (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdItemShippingProfilesIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsItemIdItemShippingProfilesIdDeleteAsyncWithHttpInfo(
        $item_id,
        $id,
        string $contentType = self::contentTypes['restItemsItemIdItemShippingProfilesIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsItemIdItemShippingProfilesIdDeleteRequest($item_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsItemIdItemShippingProfilesIdDelete'
     *
     * @param  int $item_id The unique ID of the item (required)
     * @param  int $id The unique ID of the link between item and shipping profile (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdItemShippingProfilesIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsItemIdItemShippingProfilesIdDeleteRequest(
        $item_id,
        $id,
        string $contentType = self::contentTypes['restItemsItemIdItemShippingProfilesIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $item_id when calling restItemsItemIdItemShippingProfilesIdDelete'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsItemIdItemShippingProfilesIdDelete'
            );
        }


        $resourcePath = '/rest/items/{itemId}/item_shipping_profiles/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsItemIdItemShippingProfilesPost
     *
     * Activate a shipping profile
     *
     * @param  int $item_id item_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdItemShippingProfilesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ItemShippingProfiles
     */
    public function restItemsItemIdItemShippingProfilesPost(
        int $item_id,
        string $contentType = self::contentTypes['restItemsItemIdItemShippingProfilesPost'][0]
    ): \ck\Model\ItemShippingProfiles
    {
        list($response) = $this->restItemsItemIdItemShippingProfilesPostWithHttpInfo($item_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsItemIdItemShippingProfilesPostWithHttpInfo
     *
     * Activate a shipping profile
     *
     * @param  int $item_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdItemShippingProfilesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ItemShippingProfiles, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsItemIdItemShippingProfilesPostWithHttpInfo(
        int $item_id,
        string $contentType = self::contentTypes['restItemsItemIdItemShippingProfilesPost'][0]
    ): array
    {
        $request = $this->restItemsItemIdItemShippingProfilesPostRequest($item_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ItemShippingProfiles' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ItemShippingProfiles' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ItemShippingProfiles', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ItemShippingProfiles';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ItemShippingProfiles',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsItemIdItemShippingProfilesPostAsync
     *
     * Activate a shipping profile
     *
     * @param  int $item_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdItemShippingProfilesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsItemIdItemShippingProfilesPostAsync(
        int $item_id,
        string $contentType = self::contentTypes['restItemsItemIdItemShippingProfilesPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsItemIdItemShippingProfilesPostAsyncWithHttpInfo($item_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsItemIdItemShippingProfilesPostAsyncWithHttpInfo
     *
     * Activate a shipping profile
     *
     * @param  int $item_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdItemShippingProfilesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsItemIdItemShippingProfilesPostAsyncWithHttpInfo(
        $item_id,
        string $contentType = self::contentTypes['restItemsItemIdItemShippingProfilesPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ItemShippingProfiles';
        $request = $this->restItemsItemIdItemShippingProfilesPostRequest($item_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsItemIdItemShippingProfilesPost'
     *
     * @param  int $item_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdItemShippingProfilesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsItemIdItemShippingProfilesPostRequest(
        $item_id,
        string $contentType = self::contentTypes['restItemsItemIdItemShippingProfilesPost'][0]
    ): Request
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $item_id when calling restItemsItemIdItemShippingProfilesPost'
            );
        }


        $resourcePath = '/rest/items/{itemId}/item_shipping_profiles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsItemIdPut
     *
     * Update a item
     *
     * @param  int $item_id item_id (required)
     * @param  \ck\Model\RestItemsItemIdPutRequest|null $_rest_items_item_id _rest_items_item_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Item
     */
    public function restItemsItemIdPut(
        int $item_id,
        ?\ck\Model\RestItemsItemIdPutRequest $_rest_items_item_id = null,
        string $contentType = self::contentTypes['restItemsItemIdPut'][0]
    ): \ck\Model\Item
    {
        list($response) = $this->restItemsItemIdPutWithHttpInfo($item_id, $_rest_items_item_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsItemIdPutWithHttpInfo
     *
     * Update a item
     *
     * @param  int $item_id (required)
     * @param  \ck\Model\RestItemsItemIdPutRequest|null $_rest_items_item_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Item, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsItemIdPutWithHttpInfo(
        int $item_id,
        ?\ck\Model\RestItemsItemIdPutRequest $_rest_items_item_id = null,
        string $contentType = self::contentTypes['restItemsItemIdPut'][0]
    ): array
    {
        $request = $this->restItemsItemIdPutRequest($item_id, $_rest_items_item_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Item' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Item' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Item', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Item';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Item',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsItemIdPutAsync
     *
     * Update a item
     *
     * @param  int $item_id (required)
     * @param  \ck\Model\RestItemsItemIdPutRequest|null $_rest_items_item_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsItemIdPutAsync(
        int $item_id,
        ?\ck\Model\RestItemsItemIdPutRequest $_rest_items_item_id = null,
        string $contentType = self::contentTypes['restItemsItemIdPut'][0]
    ): PromiseInterface
    {
        return $this->restItemsItemIdPutAsyncWithHttpInfo($item_id, $_rest_items_item_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsItemIdPutAsyncWithHttpInfo
     *
     * Update a item
     *
     * @param  int $item_id (required)
     * @param  \ck\Model\RestItemsItemIdPutRequest|null $_rest_items_item_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsItemIdPutAsyncWithHttpInfo(
        $item_id,
        $_rest_items_item_id = null,
        string $contentType = self::contentTypes['restItemsItemIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Item';
        $request = $this->restItemsItemIdPutRequest($item_id, $_rest_items_item_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsItemIdPut'
     *
     * @param  int $item_id (required)
     * @param  \ck\Model\RestItemsItemIdPutRequest|null $_rest_items_item_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsItemIdPutRequest(
        $item_id,
        $_rest_items_item_id = null,
        string $contentType = self::contentTypes['restItemsItemIdPut'][0]
    ): Request
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $item_id when calling restItemsItemIdPut'
            );
        }



        $resourcePath = '/rest/items/{itemId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_item_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_item_id));
            } else {
                $httpBody = $_rest_items_item_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsItemIdVariationsGet
     *
     * List variations of an item
     *
     * @param  int $item_id item_id (required)
     * @param  string|null $with Includes the specified variation information in the results. The following parameters are available: &lt;ul&gt;&lt;li&gt;properties&lt;/b&gt; &#x3D; The properties linked to the variation&lt;/li&gt;&lt;li&gt;variationProperties&lt;/b&gt; &#x3D; The properties linked to the variation&lt;/li&gt;&lt;li&gt;variationBarcodes&lt;/b&gt; &#x3D; The barcode linked to the variation and the saved code&lt;/li&gt;&lt;li&gt;variationBundleComponents&lt;/b&gt; &#x3D; The bundle components of the variation and their quantities&lt;/li&gt;&lt;li&gt;variationComponentBundles&lt;/b&gt; &#x3D; The bundles that this variation is a component of&lt;/li&gt;&lt;li&gt;variationSalesPrices&lt;/b&gt; &#x3D; The sales prices linked to the variation and the saved price&lt;/li&gt;&lt;li&gt;marketItemNumbers&lt;/b&gt; &#x3D; The market ident number of the variation&lt;/li&gt;&lt;li&gt;variationCategories&lt;/b&gt; &#x3D; The categories linked to the variation&lt;/li&gt;&lt;li&gt;variationClients&lt;/b&gt; &#x3D; The clients (stores) for which the variation is activated&lt;/li&gt;&lt;li&gt;variationMarkets&lt;/b&gt; &#x3D; The markets for which the variation is activated &lt;/li&gt;&lt;li&gt;variationDefaultCategory&lt;/b&gt; &#x3D; The default category of the variation&lt;/li&gt;&lt;li&gt;variationSuppliers&lt;/b&gt; &#x3D; The supplier data associated with the variation&lt;/li&gt;&lt;li&gt;variationWarehouses&lt;/b&gt; &#x3D; The warehouse data associated with the variation&lt;/li&gt;&lt;li&gt;images&lt;/b&gt; &#x3D; The images linked to the variation&lt;/li&gt;&lt;li&gt;itemImages&lt;/b&gt; &#x3D; The images linked to the item&lt;/li&gt;&lt;li&gt;variationAttributeValues&lt;/b&gt; &#x3D; The attribute values of the variation&lt;/li&gt;&lt;li&gt;variationSkus&lt;/b&gt; &#x3D; The SKU data associated with the variation&lt;/li&gt;&lt;li&gt;variationAdditionalSkus&lt;/b&gt; &#x3D; The additional SKU data associated with the variation&lt;/li&gt;&lt;li&gt;unit&lt;/b&gt; &#x3D; The unit assigned to the variation&lt;/li&gt;&lt;li&gt;parent&lt;/b&gt; &#x3D; The main variation of the variation. Value is null if this variation is the item&#39;s main variation.&lt;/li&gt;&lt;li&gt;item&lt;/b&gt; &#x3D; The item of the variation&lt;/li&gt;&lt;li&gt;stock&lt;/b&gt; &#x3D; The stock data of the variation&lt;/li&gt;&lt;/ul&gt; For example, specifying the parameters variationCategories and variationDefaultCategory will include the default category and all other categories the variations are linked to. More than one parameter should be separated by commas. (optional)
     * @param  string|null $lang The &lt;a href&#x3D;&#39;https://developers.plentymarkets.com/rest-doc/introduction#countries&#39; target&#x3D;&#39;_blank&#39;&gt;language&lt;/a&gt; of the variation information. (optional)
     * @param  int|null $page Limits the results to a specific page. The page number must be specified. (optional)
     * @param  int|null $items_per_page Limits the number of results listed per page to a specific number. The number of variations to be listed per page must be specified. (optional)
     * @param  bool|null $is_main Filter restricts the list of results to variations that are main variations. (optional)
     * @param  bool|null $is_active Filter restricts the list of results to variations that are active. (optional)
     * @param  string|null $barcode Filter restricts the list of results to variations with the specified barcode. A barcode must be specified. (optional)
     * @param  string|null $number_exact Filter restricts the list of results to the variation with the variation number specified. (optional)
     * @param  string|null $number_fuzzy Filter restricts the list of results to variations with numbers that contain the variation number specified (SQL LIKE operator). For example, if variations with variation numbers 1 to 400 exist in the system, filtering by 12 will list variation numbers 12, 112, 120-129, 212 and 312. (optional)
     * @param  bool|null $is_bundle Filter restricts the list of results to variations to which variations were added to create a bundle. (optional)
     * @param  string|null $supplier_number Filter restricts the list of results to variations with the specified supplier number. A supplier number must be specified. (optional)
     * @param  int|null $manufacturer_id Filter restricts the list of results to variations with the specified manufacturer ID. (optional)
     * @param  string|null $updated_between Filter restricts the list of results to variations updated during the specified period. The end date (to) is optional. If no end date is specified, variations updated between the start date (from) and the present will be listed. The dates can be specified as unix timestamps or in the ISO 8601 date format. Start date and optional end date are separated by a comma. For example, .../variations?updatedBetween&#x3D;1451606400,1456790400 will list variations updated between 2016-01-01 and 2016-03-01. .../variations?updatedBetween&#x3D;1451606400 will list variations updated since 2016-01-01. The PHP function strtotime is also supported. (optional)
     * @param  string|null $created_between Filter restricts the list of results to variations created during the specified period. The end date (to) is optional. If no end date is specified, variations created between the start date (from) and the present will be listed. The dates can be specified as unix timestamps or in the ISO 8601 date format. Start date and optional end date are separated by a comma. For example, .../variations?createdBetween&#x3D;1451606400,1456790400 will list variations created between 2016-01-01 and 2016-03-01. .../variations?createdBetween&#x3D;1451606400 will list variations created since 2016-01-01. The PHP function strtotime is also supported. (optional)
     * @param  string|null $related_updated_between Filter restricts the list of results to those variations for which related information was updated during the specified period. Related information is defined as information linked to the variation, i.e. barcodes, categories, images, markets, clients (stores), prices, suppliers, warehouses and the default category. See variationUpdatedBetween for supported formats. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdVariationsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestItemsVariationsGet200Response
     */
    public function restItemsItemIdVariationsGet(
        int $item_id,
        ?string $with = null,
        ?string $lang = null,
        ?int $page = null,
        ?int $items_per_page = null,
        ?bool $is_main = null,
        ?bool $is_active = null,
        ?string $barcode = null,
        ?string $number_exact = null,
        ?string $number_fuzzy = null,
        ?bool $is_bundle = null,
        ?string $supplier_number = null,
        ?int $manufacturer_id = null,
        ?string $updated_between = null,
        ?string $created_between = null,
        ?string $related_updated_between = null,
        string $contentType = self::contentTypes['restItemsItemIdVariationsGet'][0]
    ): \ck\Model\RestItemsVariationsGet200Response
    {
        list($response) = $this->restItemsItemIdVariationsGetWithHttpInfo($item_id, $with, $lang, $page, $items_per_page, $is_main, $is_active, $barcode, $number_exact, $number_fuzzy, $is_bundle, $supplier_number, $manufacturer_id, $updated_between, $created_between, $related_updated_between, $contentType);
        return $response;
    }

    /**
     * Operation restItemsItemIdVariationsGetWithHttpInfo
     *
     * List variations of an item
     *
     * @param  int $item_id (required)
     * @param  string|null $with Includes the specified variation information in the results. The following parameters are available: &lt;ul&gt;&lt;li&gt;properties&lt;/b&gt; &#x3D; The properties linked to the variation&lt;/li&gt;&lt;li&gt;variationProperties&lt;/b&gt; &#x3D; The properties linked to the variation&lt;/li&gt;&lt;li&gt;variationBarcodes&lt;/b&gt; &#x3D; The barcode linked to the variation and the saved code&lt;/li&gt;&lt;li&gt;variationBundleComponents&lt;/b&gt; &#x3D; The bundle components of the variation and their quantities&lt;/li&gt;&lt;li&gt;variationComponentBundles&lt;/b&gt; &#x3D; The bundles that this variation is a component of&lt;/li&gt;&lt;li&gt;variationSalesPrices&lt;/b&gt; &#x3D; The sales prices linked to the variation and the saved price&lt;/li&gt;&lt;li&gt;marketItemNumbers&lt;/b&gt; &#x3D; The market ident number of the variation&lt;/li&gt;&lt;li&gt;variationCategories&lt;/b&gt; &#x3D; The categories linked to the variation&lt;/li&gt;&lt;li&gt;variationClients&lt;/b&gt; &#x3D; The clients (stores) for which the variation is activated&lt;/li&gt;&lt;li&gt;variationMarkets&lt;/b&gt; &#x3D; The markets for which the variation is activated &lt;/li&gt;&lt;li&gt;variationDefaultCategory&lt;/b&gt; &#x3D; The default category of the variation&lt;/li&gt;&lt;li&gt;variationSuppliers&lt;/b&gt; &#x3D; The supplier data associated with the variation&lt;/li&gt;&lt;li&gt;variationWarehouses&lt;/b&gt; &#x3D; The warehouse data associated with the variation&lt;/li&gt;&lt;li&gt;images&lt;/b&gt; &#x3D; The images linked to the variation&lt;/li&gt;&lt;li&gt;itemImages&lt;/b&gt; &#x3D; The images linked to the item&lt;/li&gt;&lt;li&gt;variationAttributeValues&lt;/b&gt; &#x3D; The attribute values of the variation&lt;/li&gt;&lt;li&gt;variationSkus&lt;/b&gt; &#x3D; The SKU data associated with the variation&lt;/li&gt;&lt;li&gt;variationAdditionalSkus&lt;/b&gt; &#x3D; The additional SKU data associated with the variation&lt;/li&gt;&lt;li&gt;unit&lt;/b&gt; &#x3D; The unit assigned to the variation&lt;/li&gt;&lt;li&gt;parent&lt;/b&gt; &#x3D; The main variation of the variation. Value is null if this variation is the item&#39;s main variation.&lt;/li&gt;&lt;li&gt;item&lt;/b&gt; &#x3D; The item of the variation&lt;/li&gt;&lt;li&gt;stock&lt;/b&gt; &#x3D; The stock data of the variation&lt;/li&gt;&lt;/ul&gt; For example, specifying the parameters variationCategories and variationDefaultCategory will include the default category and all other categories the variations are linked to. More than one parameter should be separated by commas. (optional)
     * @param  string|null $lang The &lt;a href&#x3D;&#39;https://developers.plentymarkets.com/rest-doc/introduction#countries&#39; target&#x3D;&#39;_blank&#39;&gt;language&lt;/a&gt; of the variation information. (optional)
     * @param  int|null $page Limits the results to a specific page. The page number must be specified. (optional)
     * @param  int|null $items_per_page Limits the number of results listed per page to a specific number. The number of variations to be listed per page must be specified. (optional)
     * @param  bool|null $is_main Filter restricts the list of results to variations that are main variations. (optional)
     * @param  bool|null $is_active Filter restricts the list of results to variations that are active. (optional)
     * @param  string|null $barcode Filter restricts the list of results to variations with the specified barcode. A barcode must be specified. (optional)
     * @param  string|null $number_exact Filter restricts the list of results to the variation with the variation number specified. (optional)
     * @param  string|null $number_fuzzy Filter restricts the list of results to variations with numbers that contain the variation number specified (SQL LIKE operator). For example, if variations with variation numbers 1 to 400 exist in the system, filtering by 12 will list variation numbers 12, 112, 120-129, 212 and 312. (optional)
     * @param  bool|null $is_bundle Filter restricts the list of results to variations to which variations were added to create a bundle. (optional)
     * @param  string|null $supplier_number Filter restricts the list of results to variations with the specified supplier number. A supplier number must be specified. (optional)
     * @param  int|null $manufacturer_id Filter restricts the list of results to variations with the specified manufacturer ID. (optional)
     * @param  string|null $updated_between Filter restricts the list of results to variations updated during the specified period. The end date (to) is optional. If no end date is specified, variations updated between the start date (from) and the present will be listed. The dates can be specified as unix timestamps or in the ISO 8601 date format. Start date and optional end date are separated by a comma. For example, .../variations?updatedBetween&#x3D;1451606400,1456790400 will list variations updated between 2016-01-01 and 2016-03-01. .../variations?updatedBetween&#x3D;1451606400 will list variations updated since 2016-01-01. The PHP function strtotime is also supported. (optional)
     * @param  string|null $created_between Filter restricts the list of results to variations created during the specified period. The end date (to) is optional. If no end date is specified, variations created between the start date (from) and the present will be listed. The dates can be specified as unix timestamps or in the ISO 8601 date format. Start date and optional end date are separated by a comma. For example, .../variations?createdBetween&#x3D;1451606400,1456790400 will list variations created between 2016-01-01 and 2016-03-01. .../variations?createdBetween&#x3D;1451606400 will list variations created since 2016-01-01. The PHP function strtotime is also supported. (optional)
     * @param  string|null $related_updated_between Filter restricts the list of results to those variations for which related information was updated during the specified period. Related information is defined as information linked to the variation, i.e. barcodes, categories, images, markets, clients (stores), prices, suppliers, warehouses and the default category. See variationUpdatedBetween for supported formats. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdVariationsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestItemsVariationsGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsItemIdVariationsGetWithHttpInfo(
        int $item_id,
        ?string $with = null,
        ?string $lang = null,
        ?int $page = null,
        ?int $items_per_page = null,
        ?bool $is_main = null,
        ?bool $is_active = null,
        ?string $barcode = null,
        ?string $number_exact = null,
        ?string $number_fuzzy = null,
        ?bool $is_bundle = null,
        ?string $supplier_number = null,
        ?int $manufacturer_id = null,
        ?string $updated_between = null,
        ?string $created_between = null,
        ?string $related_updated_between = null,
        string $contentType = self::contentTypes['restItemsItemIdVariationsGet'][0]
    ): array
    {
        $request = $this->restItemsItemIdVariationsGetRequest($item_id, $with, $lang, $page, $items_per_page, $is_main, $is_active, $barcode, $number_exact, $number_fuzzy, $is_bundle, $supplier_number, $manufacturer_id, $updated_between, $created_between, $related_updated_between, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestItemsVariationsGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestItemsVariationsGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestItemsVariationsGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestItemsVariationsGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestItemsVariationsGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsItemIdVariationsGetAsync
     *
     * List variations of an item
     *
     * @param  int $item_id (required)
     * @param  string|null $with Includes the specified variation information in the results. The following parameters are available: &lt;ul&gt;&lt;li&gt;properties&lt;/b&gt; &#x3D; The properties linked to the variation&lt;/li&gt;&lt;li&gt;variationProperties&lt;/b&gt; &#x3D; The properties linked to the variation&lt;/li&gt;&lt;li&gt;variationBarcodes&lt;/b&gt; &#x3D; The barcode linked to the variation and the saved code&lt;/li&gt;&lt;li&gt;variationBundleComponents&lt;/b&gt; &#x3D; The bundle components of the variation and their quantities&lt;/li&gt;&lt;li&gt;variationComponentBundles&lt;/b&gt; &#x3D; The bundles that this variation is a component of&lt;/li&gt;&lt;li&gt;variationSalesPrices&lt;/b&gt; &#x3D; The sales prices linked to the variation and the saved price&lt;/li&gt;&lt;li&gt;marketItemNumbers&lt;/b&gt; &#x3D; The market ident number of the variation&lt;/li&gt;&lt;li&gt;variationCategories&lt;/b&gt; &#x3D; The categories linked to the variation&lt;/li&gt;&lt;li&gt;variationClients&lt;/b&gt; &#x3D; The clients (stores) for which the variation is activated&lt;/li&gt;&lt;li&gt;variationMarkets&lt;/b&gt; &#x3D; The markets for which the variation is activated &lt;/li&gt;&lt;li&gt;variationDefaultCategory&lt;/b&gt; &#x3D; The default category of the variation&lt;/li&gt;&lt;li&gt;variationSuppliers&lt;/b&gt; &#x3D; The supplier data associated with the variation&lt;/li&gt;&lt;li&gt;variationWarehouses&lt;/b&gt; &#x3D; The warehouse data associated with the variation&lt;/li&gt;&lt;li&gt;images&lt;/b&gt; &#x3D; The images linked to the variation&lt;/li&gt;&lt;li&gt;itemImages&lt;/b&gt; &#x3D; The images linked to the item&lt;/li&gt;&lt;li&gt;variationAttributeValues&lt;/b&gt; &#x3D; The attribute values of the variation&lt;/li&gt;&lt;li&gt;variationSkus&lt;/b&gt; &#x3D; The SKU data associated with the variation&lt;/li&gt;&lt;li&gt;variationAdditionalSkus&lt;/b&gt; &#x3D; The additional SKU data associated with the variation&lt;/li&gt;&lt;li&gt;unit&lt;/b&gt; &#x3D; The unit assigned to the variation&lt;/li&gt;&lt;li&gt;parent&lt;/b&gt; &#x3D; The main variation of the variation. Value is null if this variation is the item&#39;s main variation.&lt;/li&gt;&lt;li&gt;item&lt;/b&gt; &#x3D; The item of the variation&lt;/li&gt;&lt;li&gt;stock&lt;/b&gt; &#x3D; The stock data of the variation&lt;/li&gt;&lt;/ul&gt; For example, specifying the parameters variationCategories and variationDefaultCategory will include the default category and all other categories the variations are linked to. More than one parameter should be separated by commas. (optional)
     * @param  string|null $lang The &lt;a href&#x3D;&#39;https://developers.plentymarkets.com/rest-doc/introduction#countries&#39; target&#x3D;&#39;_blank&#39;&gt;language&lt;/a&gt; of the variation information. (optional)
     * @param  int|null $page Limits the results to a specific page. The page number must be specified. (optional)
     * @param  int|null $items_per_page Limits the number of results listed per page to a specific number. The number of variations to be listed per page must be specified. (optional)
     * @param  bool|null $is_main Filter restricts the list of results to variations that are main variations. (optional)
     * @param  bool|null $is_active Filter restricts the list of results to variations that are active. (optional)
     * @param  string|null $barcode Filter restricts the list of results to variations with the specified barcode. A barcode must be specified. (optional)
     * @param  string|null $number_exact Filter restricts the list of results to the variation with the variation number specified. (optional)
     * @param  string|null $number_fuzzy Filter restricts the list of results to variations with numbers that contain the variation number specified (SQL LIKE operator). For example, if variations with variation numbers 1 to 400 exist in the system, filtering by 12 will list variation numbers 12, 112, 120-129, 212 and 312. (optional)
     * @param  bool|null $is_bundle Filter restricts the list of results to variations to which variations were added to create a bundle. (optional)
     * @param  string|null $supplier_number Filter restricts the list of results to variations with the specified supplier number. A supplier number must be specified. (optional)
     * @param  int|null $manufacturer_id Filter restricts the list of results to variations with the specified manufacturer ID. (optional)
     * @param  string|null $updated_between Filter restricts the list of results to variations updated during the specified period. The end date (to) is optional. If no end date is specified, variations updated between the start date (from) and the present will be listed. The dates can be specified as unix timestamps or in the ISO 8601 date format. Start date and optional end date are separated by a comma. For example, .../variations?updatedBetween&#x3D;1451606400,1456790400 will list variations updated between 2016-01-01 and 2016-03-01. .../variations?updatedBetween&#x3D;1451606400 will list variations updated since 2016-01-01. The PHP function strtotime is also supported. (optional)
     * @param  string|null $created_between Filter restricts the list of results to variations created during the specified period. The end date (to) is optional. If no end date is specified, variations created between the start date (from) and the present will be listed. The dates can be specified as unix timestamps or in the ISO 8601 date format. Start date and optional end date are separated by a comma. For example, .../variations?createdBetween&#x3D;1451606400,1456790400 will list variations created between 2016-01-01 and 2016-03-01. .../variations?createdBetween&#x3D;1451606400 will list variations created since 2016-01-01. The PHP function strtotime is also supported. (optional)
     * @param  string|null $related_updated_between Filter restricts the list of results to those variations for which related information was updated during the specified period. Related information is defined as information linked to the variation, i.e. barcodes, categories, images, markets, clients (stores), prices, suppliers, warehouses and the default category. See variationUpdatedBetween for supported formats. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdVariationsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsItemIdVariationsGetAsync(
        int $item_id,
        ?string $with = null,
        ?string $lang = null,
        ?int $page = null,
        ?int $items_per_page = null,
        ?bool $is_main = null,
        ?bool $is_active = null,
        ?string $barcode = null,
        ?string $number_exact = null,
        ?string $number_fuzzy = null,
        ?bool $is_bundle = null,
        ?string $supplier_number = null,
        ?int $manufacturer_id = null,
        ?string $updated_between = null,
        ?string $created_between = null,
        ?string $related_updated_between = null,
        string $contentType = self::contentTypes['restItemsItemIdVariationsGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsItemIdVariationsGetAsyncWithHttpInfo($item_id, $with, $lang, $page, $items_per_page, $is_main, $is_active, $barcode, $number_exact, $number_fuzzy, $is_bundle, $supplier_number, $manufacturer_id, $updated_between, $created_between, $related_updated_between, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsItemIdVariationsGetAsyncWithHttpInfo
     *
     * List variations of an item
     *
     * @param  int $item_id (required)
     * @param  string|null $with Includes the specified variation information in the results. The following parameters are available: &lt;ul&gt;&lt;li&gt;properties&lt;/b&gt; &#x3D; The properties linked to the variation&lt;/li&gt;&lt;li&gt;variationProperties&lt;/b&gt; &#x3D; The properties linked to the variation&lt;/li&gt;&lt;li&gt;variationBarcodes&lt;/b&gt; &#x3D; The barcode linked to the variation and the saved code&lt;/li&gt;&lt;li&gt;variationBundleComponents&lt;/b&gt; &#x3D; The bundle components of the variation and their quantities&lt;/li&gt;&lt;li&gt;variationComponentBundles&lt;/b&gt; &#x3D; The bundles that this variation is a component of&lt;/li&gt;&lt;li&gt;variationSalesPrices&lt;/b&gt; &#x3D; The sales prices linked to the variation and the saved price&lt;/li&gt;&lt;li&gt;marketItemNumbers&lt;/b&gt; &#x3D; The market ident number of the variation&lt;/li&gt;&lt;li&gt;variationCategories&lt;/b&gt; &#x3D; The categories linked to the variation&lt;/li&gt;&lt;li&gt;variationClients&lt;/b&gt; &#x3D; The clients (stores) for which the variation is activated&lt;/li&gt;&lt;li&gt;variationMarkets&lt;/b&gt; &#x3D; The markets for which the variation is activated &lt;/li&gt;&lt;li&gt;variationDefaultCategory&lt;/b&gt; &#x3D; The default category of the variation&lt;/li&gt;&lt;li&gt;variationSuppliers&lt;/b&gt; &#x3D; The supplier data associated with the variation&lt;/li&gt;&lt;li&gt;variationWarehouses&lt;/b&gt; &#x3D; The warehouse data associated with the variation&lt;/li&gt;&lt;li&gt;images&lt;/b&gt; &#x3D; The images linked to the variation&lt;/li&gt;&lt;li&gt;itemImages&lt;/b&gt; &#x3D; The images linked to the item&lt;/li&gt;&lt;li&gt;variationAttributeValues&lt;/b&gt; &#x3D; The attribute values of the variation&lt;/li&gt;&lt;li&gt;variationSkus&lt;/b&gt; &#x3D; The SKU data associated with the variation&lt;/li&gt;&lt;li&gt;variationAdditionalSkus&lt;/b&gt; &#x3D; The additional SKU data associated with the variation&lt;/li&gt;&lt;li&gt;unit&lt;/b&gt; &#x3D; The unit assigned to the variation&lt;/li&gt;&lt;li&gt;parent&lt;/b&gt; &#x3D; The main variation of the variation. Value is null if this variation is the item&#39;s main variation.&lt;/li&gt;&lt;li&gt;item&lt;/b&gt; &#x3D; The item of the variation&lt;/li&gt;&lt;li&gt;stock&lt;/b&gt; &#x3D; The stock data of the variation&lt;/li&gt;&lt;/ul&gt; For example, specifying the parameters variationCategories and variationDefaultCategory will include the default category and all other categories the variations are linked to. More than one parameter should be separated by commas. (optional)
     * @param  string|null $lang The &lt;a href&#x3D;&#39;https://developers.plentymarkets.com/rest-doc/introduction#countries&#39; target&#x3D;&#39;_blank&#39;&gt;language&lt;/a&gt; of the variation information. (optional)
     * @param  int|null $page Limits the results to a specific page. The page number must be specified. (optional)
     * @param  int|null $items_per_page Limits the number of results listed per page to a specific number. The number of variations to be listed per page must be specified. (optional)
     * @param  bool|null $is_main Filter restricts the list of results to variations that are main variations. (optional)
     * @param  bool|null $is_active Filter restricts the list of results to variations that are active. (optional)
     * @param  string|null $barcode Filter restricts the list of results to variations with the specified barcode. A barcode must be specified. (optional)
     * @param  string|null $number_exact Filter restricts the list of results to the variation with the variation number specified. (optional)
     * @param  string|null $number_fuzzy Filter restricts the list of results to variations with numbers that contain the variation number specified (SQL LIKE operator). For example, if variations with variation numbers 1 to 400 exist in the system, filtering by 12 will list variation numbers 12, 112, 120-129, 212 and 312. (optional)
     * @param  bool|null $is_bundle Filter restricts the list of results to variations to which variations were added to create a bundle. (optional)
     * @param  string|null $supplier_number Filter restricts the list of results to variations with the specified supplier number. A supplier number must be specified. (optional)
     * @param  int|null $manufacturer_id Filter restricts the list of results to variations with the specified manufacturer ID. (optional)
     * @param  string|null $updated_between Filter restricts the list of results to variations updated during the specified period. The end date (to) is optional. If no end date is specified, variations updated between the start date (from) and the present will be listed. The dates can be specified as unix timestamps or in the ISO 8601 date format. Start date and optional end date are separated by a comma. For example, .../variations?updatedBetween&#x3D;1451606400,1456790400 will list variations updated between 2016-01-01 and 2016-03-01. .../variations?updatedBetween&#x3D;1451606400 will list variations updated since 2016-01-01. The PHP function strtotime is also supported. (optional)
     * @param  string|null $created_between Filter restricts the list of results to variations created during the specified period. The end date (to) is optional. If no end date is specified, variations created between the start date (from) and the present will be listed. The dates can be specified as unix timestamps or in the ISO 8601 date format. Start date and optional end date are separated by a comma. For example, .../variations?createdBetween&#x3D;1451606400,1456790400 will list variations created between 2016-01-01 and 2016-03-01. .../variations?createdBetween&#x3D;1451606400 will list variations created since 2016-01-01. The PHP function strtotime is also supported. (optional)
     * @param  string|null $related_updated_between Filter restricts the list of results to those variations for which related information was updated during the specified period. Related information is defined as information linked to the variation, i.e. barcodes, categories, images, markets, clients (stores), prices, suppliers, warehouses and the default category. See variationUpdatedBetween for supported formats. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdVariationsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsItemIdVariationsGetAsyncWithHttpInfo(
        $item_id,
        $with = null,
        $lang = null,
        $page = null,
        $items_per_page = null,
        $is_main = null,
        $is_active = null,
        $barcode = null,
        $number_exact = null,
        $number_fuzzy = null,
        $is_bundle = null,
        $supplier_number = null,
        $manufacturer_id = null,
        $updated_between = null,
        $created_between = null,
        $related_updated_between = null,
        string $contentType = self::contentTypes['restItemsItemIdVariationsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestItemsVariationsGet200Response';
        $request = $this->restItemsItemIdVariationsGetRequest($item_id, $with, $lang, $page, $items_per_page, $is_main, $is_active, $barcode, $number_exact, $number_fuzzy, $is_bundle, $supplier_number, $manufacturer_id, $updated_between, $created_between, $related_updated_between, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsItemIdVariationsGet'
     *
     * @param  int $item_id (required)
     * @param  string|null $with Includes the specified variation information in the results. The following parameters are available: &lt;ul&gt;&lt;li&gt;properties&lt;/b&gt; &#x3D; The properties linked to the variation&lt;/li&gt;&lt;li&gt;variationProperties&lt;/b&gt; &#x3D; The properties linked to the variation&lt;/li&gt;&lt;li&gt;variationBarcodes&lt;/b&gt; &#x3D; The barcode linked to the variation and the saved code&lt;/li&gt;&lt;li&gt;variationBundleComponents&lt;/b&gt; &#x3D; The bundle components of the variation and their quantities&lt;/li&gt;&lt;li&gt;variationComponentBundles&lt;/b&gt; &#x3D; The bundles that this variation is a component of&lt;/li&gt;&lt;li&gt;variationSalesPrices&lt;/b&gt; &#x3D; The sales prices linked to the variation and the saved price&lt;/li&gt;&lt;li&gt;marketItemNumbers&lt;/b&gt; &#x3D; The market ident number of the variation&lt;/li&gt;&lt;li&gt;variationCategories&lt;/b&gt; &#x3D; The categories linked to the variation&lt;/li&gt;&lt;li&gt;variationClients&lt;/b&gt; &#x3D; The clients (stores) for which the variation is activated&lt;/li&gt;&lt;li&gt;variationMarkets&lt;/b&gt; &#x3D; The markets for which the variation is activated &lt;/li&gt;&lt;li&gt;variationDefaultCategory&lt;/b&gt; &#x3D; The default category of the variation&lt;/li&gt;&lt;li&gt;variationSuppliers&lt;/b&gt; &#x3D; The supplier data associated with the variation&lt;/li&gt;&lt;li&gt;variationWarehouses&lt;/b&gt; &#x3D; The warehouse data associated with the variation&lt;/li&gt;&lt;li&gt;images&lt;/b&gt; &#x3D; The images linked to the variation&lt;/li&gt;&lt;li&gt;itemImages&lt;/b&gt; &#x3D; The images linked to the item&lt;/li&gt;&lt;li&gt;variationAttributeValues&lt;/b&gt; &#x3D; The attribute values of the variation&lt;/li&gt;&lt;li&gt;variationSkus&lt;/b&gt; &#x3D; The SKU data associated with the variation&lt;/li&gt;&lt;li&gt;variationAdditionalSkus&lt;/b&gt; &#x3D; The additional SKU data associated with the variation&lt;/li&gt;&lt;li&gt;unit&lt;/b&gt; &#x3D; The unit assigned to the variation&lt;/li&gt;&lt;li&gt;parent&lt;/b&gt; &#x3D; The main variation of the variation. Value is null if this variation is the item&#39;s main variation.&lt;/li&gt;&lt;li&gt;item&lt;/b&gt; &#x3D; The item of the variation&lt;/li&gt;&lt;li&gt;stock&lt;/b&gt; &#x3D; The stock data of the variation&lt;/li&gt;&lt;/ul&gt; For example, specifying the parameters variationCategories and variationDefaultCategory will include the default category and all other categories the variations are linked to. More than one parameter should be separated by commas. (optional)
     * @param  string|null $lang The &lt;a href&#x3D;&#39;https://developers.plentymarkets.com/rest-doc/introduction#countries&#39; target&#x3D;&#39;_blank&#39;&gt;language&lt;/a&gt; of the variation information. (optional)
     * @param  int|null $page Limits the results to a specific page. The page number must be specified. (optional)
     * @param  int|null $items_per_page Limits the number of results listed per page to a specific number. The number of variations to be listed per page must be specified. (optional)
     * @param  bool|null $is_main Filter restricts the list of results to variations that are main variations. (optional)
     * @param  bool|null $is_active Filter restricts the list of results to variations that are active. (optional)
     * @param  string|null $barcode Filter restricts the list of results to variations with the specified barcode. A barcode must be specified. (optional)
     * @param  string|null $number_exact Filter restricts the list of results to the variation with the variation number specified. (optional)
     * @param  string|null $number_fuzzy Filter restricts the list of results to variations with numbers that contain the variation number specified (SQL LIKE operator). For example, if variations with variation numbers 1 to 400 exist in the system, filtering by 12 will list variation numbers 12, 112, 120-129, 212 and 312. (optional)
     * @param  bool|null $is_bundle Filter restricts the list of results to variations to which variations were added to create a bundle. (optional)
     * @param  string|null $supplier_number Filter restricts the list of results to variations with the specified supplier number. A supplier number must be specified. (optional)
     * @param  int|null $manufacturer_id Filter restricts the list of results to variations with the specified manufacturer ID. (optional)
     * @param  string|null $updated_between Filter restricts the list of results to variations updated during the specified period. The end date (to) is optional. If no end date is specified, variations updated between the start date (from) and the present will be listed. The dates can be specified as unix timestamps or in the ISO 8601 date format. Start date and optional end date are separated by a comma. For example, .../variations?updatedBetween&#x3D;1451606400,1456790400 will list variations updated between 2016-01-01 and 2016-03-01. .../variations?updatedBetween&#x3D;1451606400 will list variations updated since 2016-01-01. The PHP function strtotime is also supported. (optional)
     * @param  string|null $created_between Filter restricts the list of results to variations created during the specified period. The end date (to) is optional. If no end date is specified, variations created between the start date (from) and the present will be listed. The dates can be specified as unix timestamps or in the ISO 8601 date format. Start date and optional end date are separated by a comma. For example, .../variations?createdBetween&#x3D;1451606400,1456790400 will list variations created between 2016-01-01 and 2016-03-01. .../variations?createdBetween&#x3D;1451606400 will list variations created since 2016-01-01. The PHP function strtotime is also supported. (optional)
     * @param  string|null $related_updated_between Filter restricts the list of results to those variations for which related information was updated during the specified period. Related information is defined as information linked to the variation, i.e. barcodes, categories, images, markets, clients (stores), prices, suppliers, warehouses and the default category. See variationUpdatedBetween for supported formats. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdVariationsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsItemIdVariationsGetRequest(
        $item_id,
        $with = null,
        $lang = null,
        $page = null,
        $items_per_page = null,
        $is_main = null,
        $is_active = null,
        $barcode = null,
        $number_exact = null,
        $number_fuzzy = null,
        $is_bundle = null,
        $supplier_number = null,
        $manufacturer_id = null,
        $updated_between = null,
        $created_between = null,
        $related_updated_between = null,
        string $contentType = self::contentTypes['restItemsItemIdVariationsGet'][0]
    ): Request
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $item_id when calling restItemsItemIdVariationsGet'
            );
        }

















        $resourcePath = '/rest/items/{itemId}/variations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $lang,
            'lang', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $items_per_page,
            'itemsPerPage', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_main,
            'isMain', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_active,
            'isActive', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $barcode,
            'barcode', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $number_exact,
            'numberExact', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $number_fuzzy,
            'numberFuzzy', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_bundle,
            'isBundle', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $supplier_number,
            'supplierNumber', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $manufacturer_id,
            'manufacturerId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_between,
            'updatedBetween', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_between,
            'createdBetween', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $related_updated_between,
            'relatedUpdatedBetween', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsItemIdVariationsPost
     *
     * Create a variation
     *
     * @param  int $item_id item_id (required)
     * @param  \ck\Model\RestItemsVariationsPutRequest|null $_rest_items_item_id_variations _rest_items_item_id_variations (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdVariationsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Variation
     */
    public function restItemsItemIdVariationsPost(
        int $item_id,
        ?\ck\Model\RestItemsVariationsPutRequest $_rest_items_item_id_variations = null,
        string $contentType = self::contentTypes['restItemsItemIdVariationsPost'][0]
    ): \ck\Model\Variation
    {
        list($response) = $this->restItemsItemIdVariationsPostWithHttpInfo($item_id, $_rest_items_item_id_variations, $contentType);
        return $response;
    }

    /**
     * Operation restItemsItemIdVariationsPostWithHttpInfo
     *
     * Create a variation
     *
     * @param  int $item_id (required)
     * @param  \ck\Model\RestItemsVariationsPutRequest|null $_rest_items_item_id_variations (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdVariationsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Variation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsItemIdVariationsPostWithHttpInfo(
        int $item_id,
        ?\ck\Model\RestItemsVariationsPutRequest $_rest_items_item_id_variations = null,
        string $contentType = self::contentTypes['restItemsItemIdVariationsPost'][0]
    ): array
    {
        $request = $this->restItemsItemIdVariationsPostRequest($item_id, $_rest_items_item_id_variations, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Variation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Variation' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Variation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Variation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Variation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsItemIdVariationsPostAsync
     *
     * Create a variation
     *
     * @param  int $item_id (required)
     * @param  \ck\Model\RestItemsVariationsPutRequest|null $_rest_items_item_id_variations (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdVariationsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsItemIdVariationsPostAsync(
        int $item_id,
        ?\ck\Model\RestItemsVariationsPutRequest $_rest_items_item_id_variations = null,
        string $contentType = self::contentTypes['restItemsItemIdVariationsPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsItemIdVariationsPostAsyncWithHttpInfo($item_id, $_rest_items_item_id_variations, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsItemIdVariationsPostAsyncWithHttpInfo
     *
     * Create a variation
     *
     * @param  int $item_id (required)
     * @param  \ck\Model\RestItemsVariationsPutRequest|null $_rest_items_item_id_variations (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdVariationsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsItemIdVariationsPostAsyncWithHttpInfo(
        $item_id,
        $_rest_items_item_id_variations = null,
        string $contentType = self::contentTypes['restItemsItemIdVariationsPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Variation';
        $request = $this->restItemsItemIdVariationsPostRequest($item_id, $_rest_items_item_id_variations, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsItemIdVariationsPost'
     *
     * @param  int $item_id (required)
     * @param  \ck\Model\RestItemsVariationsPutRequest|null $_rest_items_item_id_variations (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdVariationsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsItemIdVariationsPostRequest(
        $item_id,
        $_rest_items_item_id_variations = null,
        string $contentType = self::contentTypes['restItemsItemIdVariationsPost'][0]
    ): Request
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $item_id when calling restItemsItemIdVariationsPost'
            );
        }



        $resourcePath = '/rest/items/{itemId}/variations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_item_id_variations)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_item_id_variations));
            } else {
                $httpBody = $_rest_items_item_id_variations;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsItemIdVariationsVariationIdDelete
     *
     * Delete a variation
     *
     * @param  int $item_id item_id (required)
     * @param  int $variation_id variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdVariationsVariationIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsItemIdVariationsVariationIdDelete(
        int $item_id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsItemIdVariationsVariationIdDelete'][0]
    ): object
    {
        list($response) = $this->restItemsItemIdVariationsVariationIdDeleteWithHttpInfo($item_id, $variation_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsItemIdVariationsVariationIdDeleteWithHttpInfo
     *
     * Delete a variation
     *
     * @param  int $item_id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdVariationsVariationIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsItemIdVariationsVariationIdDeleteWithHttpInfo(
        int $item_id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsItemIdVariationsVariationIdDelete'][0]
    ): array
    {
        $request = $this->restItemsItemIdVariationsVariationIdDeleteRequest($item_id, $variation_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsItemIdVariationsVariationIdDeleteAsync
     *
     * Delete a variation
     *
     * @param  int $item_id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdVariationsVariationIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsItemIdVariationsVariationIdDeleteAsync(
        int $item_id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsItemIdVariationsVariationIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemsItemIdVariationsVariationIdDeleteAsyncWithHttpInfo($item_id, $variation_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsItemIdVariationsVariationIdDeleteAsyncWithHttpInfo
     *
     * Delete a variation
     *
     * @param  int $item_id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdVariationsVariationIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsItemIdVariationsVariationIdDeleteAsyncWithHttpInfo(
        $item_id,
        $variation_id,
        string $contentType = self::contentTypes['restItemsItemIdVariationsVariationIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsItemIdVariationsVariationIdDeleteRequest($item_id, $variation_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsItemIdVariationsVariationIdDelete'
     *
     * @param  int $item_id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdVariationsVariationIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsItemIdVariationsVariationIdDeleteRequest(
        $item_id,
        $variation_id,
        string $contentType = self::contentTypes['restItemsItemIdVariationsVariationIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $item_id when calling restItemsItemIdVariationsVariationIdDelete'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsItemIdVariationsVariationIdDelete'
            );
        }


        $resourcePath = '/rest/items/{itemId}/variations/{variationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsItemIdVariationsVariationIdFillPost
     *
     * Fill a variation
     *
     * @param  int $item_id item_id (required)
     * @param  int $variation_id variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdVariationsVariationIdFillPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restItemsItemIdVariationsVariationIdFillPost(
        int $item_id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsItemIdVariationsVariationIdFillPost'][0]
    ): void
    {
        $this->restItemsItemIdVariationsVariationIdFillPostWithHttpInfo($item_id, $variation_id, $contentType);
    }

    /**
     * Operation restItemsItemIdVariationsVariationIdFillPostWithHttpInfo
     *
     * Fill a variation
     *
     * @param  int $item_id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdVariationsVariationIdFillPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsItemIdVariationsVariationIdFillPostWithHttpInfo(
        int $item_id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsItemIdVariationsVariationIdFillPost'][0]
    ): array
    {
        $request = $this->restItemsItemIdVariationsVariationIdFillPostRequest($item_id, $variation_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsItemIdVariationsVariationIdFillPostAsync
     *
     * Fill a variation
     *
     * @param  int $item_id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdVariationsVariationIdFillPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsItemIdVariationsVariationIdFillPostAsync(
        int $item_id,
        int $variation_id,
        string $contentType = self::contentTypes['restItemsItemIdVariationsVariationIdFillPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsItemIdVariationsVariationIdFillPostAsyncWithHttpInfo($item_id, $variation_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsItemIdVariationsVariationIdFillPostAsyncWithHttpInfo
     *
     * Fill a variation
     *
     * @param  int $item_id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdVariationsVariationIdFillPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsItemIdVariationsVariationIdFillPostAsyncWithHttpInfo(
        $item_id,
        $variation_id,
        string $contentType = self::contentTypes['restItemsItemIdVariationsVariationIdFillPost'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restItemsItemIdVariationsVariationIdFillPostRequest($item_id, $variation_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsItemIdVariationsVariationIdFillPost'
     *
     * @param  int $item_id (required)
     * @param  int $variation_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdVariationsVariationIdFillPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsItemIdVariationsVariationIdFillPostRequest(
        $item_id,
        $variation_id,
        string $contentType = self::contentTypes['restItemsItemIdVariationsVariationIdFillPost'][0]
    ): Request
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $item_id when calling restItemsItemIdVariationsVariationIdFillPost'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsItemIdVariationsVariationIdFillPost'
            );
        }


        $resourcePath = '/rest/items/{itemId}/variations/{variationId}/fill';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsItemIdVariationsVariationIdGet
     *
     * Get a variation
     *
     * @param  int $item_id item_id (required)
     * @param  int $variation_id variation_id (required)
     * @param  string|null $with Includes the specified variation information in the results. The following parameters are available: &lt;ul&gt;&lt;li&gt;properties&lt;/b&gt; &#x3D; The properties linked to the variation&lt;/li&gt;&lt;li&gt;variationProperties&lt;/b&gt; &#x3D; The properties linked to the variation&lt;/li&gt;&lt;li&gt;variationBarcodes&lt;/b&gt; &#x3D; The barcode linked to the variation and the saved code&lt;/li&gt;&lt;li&gt;variationBundleComponents&lt;/b&gt; &#x3D; The bundle components of the variation and their quantities&lt;/li&gt;&lt;li&gt;variationComponentBundles&lt;/b&gt; &#x3D; The bundles that this variation is a component of&lt;/li&gt;&lt;li&gt;variationSalesPrices&lt;/b&gt; &#x3D; The sales prices linked to the variation and the saved price&lt;/li&gt;&lt;li&gt;marketItemNumbers&lt;/b&gt; &#x3D; The market ident number of the variation&lt;/li&gt;&lt;li&gt;variationCategories&lt;/b&gt; &#x3D; The categories linked to the variation&lt;/li&gt;&lt;li&gt;variationClients&lt;/b&gt; &#x3D; The clients (stores) for which the variation is activated&lt;/li&gt;&lt;li&gt;variationMarkets&lt;/b&gt; &#x3D; The markets for which the variation is activated &lt;/li&gt;&lt;li&gt;variationDefaultCategory&lt;/b&gt; &#x3D; The default category of the variation&lt;/li&gt;&lt;li&gt;variationSuppliers&lt;/b&gt; &#x3D; The supplier data associated with the variation&lt;/li&gt;&lt;li&gt;variationWarehouses&lt;/b&gt; &#x3D; The warehouse data associated with the variation&lt;/li&gt;&lt;li&gt;images&lt;/b&gt; &#x3D; The images linked to the variation&lt;/li&gt;&lt;li&gt;itemImages&lt;/b&gt; &#x3D; The images linked to the item&lt;/li&gt;&lt;li&gt;variationAttributeValues&lt;/b&gt; &#x3D; The attribute values of the variation&lt;/li&gt;&lt;li&gt;variationSkus&lt;/b&gt; &#x3D; The SKU data associated with the variation&lt;/li&gt;&lt;li&gt;variationAdditionalSkus&lt;/b&gt; &#x3D; The additional SKU data associated with the variation&lt;/li&gt;&lt;li&gt;unit&lt;/b&gt; &#x3D; The unit assigned to the variation&lt;/li&gt;&lt;li&gt;parent&lt;/b&gt; &#x3D; The main variation of the variation. Value is null if this variation is the item&#39;s main variation.&lt;/li&gt;&lt;li&gt;item&lt;/b&gt; &#x3D; The item of the variation&lt;/li&gt;&lt;li&gt;stock&lt;/b&gt; &#x3D; The stock data of the variation&lt;/li&gt;&lt;/ul&gt; For example, specifying the parameters variationCategories and variationDefaultCategory will include the default category and all other categories the variations are linked to. More than one parameter should be separated by commas. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdVariationsVariationIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Variation
     */
    public function restItemsItemIdVariationsVariationIdGet(
        int $item_id,
        int $variation_id,
        ?string $with = null,
        string $contentType = self::contentTypes['restItemsItemIdVariationsVariationIdGet'][0]
    ): \ck\Model\Variation
    {
        list($response) = $this->restItemsItemIdVariationsVariationIdGetWithHttpInfo($item_id, $variation_id, $with, $contentType);
        return $response;
    }

    /**
     * Operation restItemsItemIdVariationsVariationIdGetWithHttpInfo
     *
     * Get a variation
     *
     * @param  int $item_id (required)
     * @param  int $variation_id (required)
     * @param  string|null $with Includes the specified variation information in the results. The following parameters are available: &lt;ul&gt;&lt;li&gt;properties&lt;/b&gt; &#x3D; The properties linked to the variation&lt;/li&gt;&lt;li&gt;variationProperties&lt;/b&gt; &#x3D; The properties linked to the variation&lt;/li&gt;&lt;li&gt;variationBarcodes&lt;/b&gt; &#x3D; The barcode linked to the variation and the saved code&lt;/li&gt;&lt;li&gt;variationBundleComponents&lt;/b&gt; &#x3D; The bundle components of the variation and their quantities&lt;/li&gt;&lt;li&gt;variationComponentBundles&lt;/b&gt; &#x3D; The bundles that this variation is a component of&lt;/li&gt;&lt;li&gt;variationSalesPrices&lt;/b&gt; &#x3D; The sales prices linked to the variation and the saved price&lt;/li&gt;&lt;li&gt;marketItemNumbers&lt;/b&gt; &#x3D; The market ident number of the variation&lt;/li&gt;&lt;li&gt;variationCategories&lt;/b&gt; &#x3D; The categories linked to the variation&lt;/li&gt;&lt;li&gt;variationClients&lt;/b&gt; &#x3D; The clients (stores) for which the variation is activated&lt;/li&gt;&lt;li&gt;variationMarkets&lt;/b&gt; &#x3D; The markets for which the variation is activated &lt;/li&gt;&lt;li&gt;variationDefaultCategory&lt;/b&gt; &#x3D; The default category of the variation&lt;/li&gt;&lt;li&gt;variationSuppliers&lt;/b&gt; &#x3D; The supplier data associated with the variation&lt;/li&gt;&lt;li&gt;variationWarehouses&lt;/b&gt; &#x3D; The warehouse data associated with the variation&lt;/li&gt;&lt;li&gt;images&lt;/b&gt; &#x3D; The images linked to the variation&lt;/li&gt;&lt;li&gt;itemImages&lt;/b&gt; &#x3D; The images linked to the item&lt;/li&gt;&lt;li&gt;variationAttributeValues&lt;/b&gt; &#x3D; The attribute values of the variation&lt;/li&gt;&lt;li&gt;variationSkus&lt;/b&gt; &#x3D; The SKU data associated with the variation&lt;/li&gt;&lt;li&gt;variationAdditionalSkus&lt;/b&gt; &#x3D; The additional SKU data associated with the variation&lt;/li&gt;&lt;li&gt;unit&lt;/b&gt; &#x3D; The unit assigned to the variation&lt;/li&gt;&lt;li&gt;parent&lt;/b&gt; &#x3D; The main variation of the variation. Value is null if this variation is the item&#39;s main variation.&lt;/li&gt;&lt;li&gt;item&lt;/b&gt; &#x3D; The item of the variation&lt;/li&gt;&lt;li&gt;stock&lt;/b&gt; &#x3D; The stock data of the variation&lt;/li&gt;&lt;/ul&gt; For example, specifying the parameters variationCategories and variationDefaultCategory will include the default category and all other categories the variations are linked to. More than one parameter should be separated by commas. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdVariationsVariationIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Variation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsItemIdVariationsVariationIdGetWithHttpInfo(
        int $item_id,
        int $variation_id,
        ?string $with = null,
        string $contentType = self::contentTypes['restItemsItemIdVariationsVariationIdGet'][0]
    ): array
    {
        $request = $this->restItemsItemIdVariationsVariationIdGetRequest($item_id, $variation_id, $with, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Variation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Variation' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Variation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Variation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Variation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsItemIdVariationsVariationIdGetAsync
     *
     * Get a variation
     *
     * @param  int $item_id (required)
     * @param  int $variation_id (required)
     * @param  string|null $with Includes the specified variation information in the results. The following parameters are available: &lt;ul&gt;&lt;li&gt;properties&lt;/b&gt; &#x3D; The properties linked to the variation&lt;/li&gt;&lt;li&gt;variationProperties&lt;/b&gt; &#x3D; The properties linked to the variation&lt;/li&gt;&lt;li&gt;variationBarcodes&lt;/b&gt; &#x3D; The barcode linked to the variation and the saved code&lt;/li&gt;&lt;li&gt;variationBundleComponents&lt;/b&gt; &#x3D; The bundle components of the variation and their quantities&lt;/li&gt;&lt;li&gt;variationComponentBundles&lt;/b&gt; &#x3D; The bundles that this variation is a component of&lt;/li&gt;&lt;li&gt;variationSalesPrices&lt;/b&gt; &#x3D; The sales prices linked to the variation and the saved price&lt;/li&gt;&lt;li&gt;marketItemNumbers&lt;/b&gt; &#x3D; The market ident number of the variation&lt;/li&gt;&lt;li&gt;variationCategories&lt;/b&gt; &#x3D; The categories linked to the variation&lt;/li&gt;&lt;li&gt;variationClients&lt;/b&gt; &#x3D; The clients (stores) for which the variation is activated&lt;/li&gt;&lt;li&gt;variationMarkets&lt;/b&gt; &#x3D; The markets for which the variation is activated &lt;/li&gt;&lt;li&gt;variationDefaultCategory&lt;/b&gt; &#x3D; The default category of the variation&lt;/li&gt;&lt;li&gt;variationSuppliers&lt;/b&gt; &#x3D; The supplier data associated with the variation&lt;/li&gt;&lt;li&gt;variationWarehouses&lt;/b&gt; &#x3D; The warehouse data associated with the variation&lt;/li&gt;&lt;li&gt;images&lt;/b&gt; &#x3D; The images linked to the variation&lt;/li&gt;&lt;li&gt;itemImages&lt;/b&gt; &#x3D; The images linked to the item&lt;/li&gt;&lt;li&gt;variationAttributeValues&lt;/b&gt; &#x3D; The attribute values of the variation&lt;/li&gt;&lt;li&gt;variationSkus&lt;/b&gt; &#x3D; The SKU data associated with the variation&lt;/li&gt;&lt;li&gt;variationAdditionalSkus&lt;/b&gt; &#x3D; The additional SKU data associated with the variation&lt;/li&gt;&lt;li&gt;unit&lt;/b&gt; &#x3D; The unit assigned to the variation&lt;/li&gt;&lt;li&gt;parent&lt;/b&gt; &#x3D; The main variation of the variation. Value is null if this variation is the item&#39;s main variation.&lt;/li&gt;&lt;li&gt;item&lt;/b&gt; &#x3D; The item of the variation&lt;/li&gt;&lt;li&gt;stock&lt;/b&gt; &#x3D; The stock data of the variation&lt;/li&gt;&lt;/ul&gt; For example, specifying the parameters variationCategories and variationDefaultCategory will include the default category and all other categories the variations are linked to. More than one parameter should be separated by commas. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdVariationsVariationIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsItemIdVariationsVariationIdGetAsync(
        int $item_id,
        int $variation_id,
        ?string $with = null,
        string $contentType = self::contentTypes['restItemsItemIdVariationsVariationIdGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsItemIdVariationsVariationIdGetAsyncWithHttpInfo($item_id, $variation_id, $with, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsItemIdVariationsVariationIdGetAsyncWithHttpInfo
     *
     * Get a variation
     *
     * @param  int $item_id (required)
     * @param  int $variation_id (required)
     * @param  string|null $with Includes the specified variation information in the results. The following parameters are available: &lt;ul&gt;&lt;li&gt;properties&lt;/b&gt; &#x3D; The properties linked to the variation&lt;/li&gt;&lt;li&gt;variationProperties&lt;/b&gt; &#x3D; The properties linked to the variation&lt;/li&gt;&lt;li&gt;variationBarcodes&lt;/b&gt; &#x3D; The barcode linked to the variation and the saved code&lt;/li&gt;&lt;li&gt;variationBundleComponents&lt;/b&gt; &#x3D; The bundle components of the variation and their quantities&lt;/li&gt;&lt;li&gt;variationComponentBundles&lt;/b&gt; &#x3D; The bundles that this variation is a component of&lt;/li&gt;&lt;li&gt;variationSalesPrices&lt;/b&gt; &#x3D; The sales prices linked to the variation and the saved price&lt;/li&gt;&lt;li&gt;marketItemNumbers&lt;/b&gt; &#x3D; The market ident number of the variation&lt;/li&gt;&lt;li&gt;variationCategories&lt;/b&gt; &#x3D; The categories linked to the variation&lt;/li&gt;&lt;li&gt;variationClients&lt;/b&gt; &#x3D; The clients (stores) for which the variation is activated&lt;/li&gt;&lt;li&gt;variationMarkets&lt;/b&gt; &#x3D; The markets for which the variation is activated &lt;/li&gt;&lt;li&gt;variationDefaultCategory&lt;/b&gt; &#x3D; The default category of the variation&lt;/li&gt;&lt;li&gt;variationSuppliers&lt;/b&gt; &#x3D; The supplier data associated with the variation&lt;/li&gt;&lt;li&gt;variationWarehouses&lt;/b&gt; &#x3D; The warehouse data associated with the variation&lt;/li&gt;&lt;li&gt;images&lt;/b&gt; &#x3D; The images linked to the variation&lt;/li&gt;&lt;li&gt;itemImages&lt;/b&gt; &#x3D; The images linked to the item&lt;/li&gt;&lt;li&gt;variationAttributeValues&lt;/b&gt; &#x3D; The attribute values of the variation&lt;/li&gt;&lt;li&gt;variationSkus&lt;/b&gt; &#x3D; The SKU data associated with the variation&lt;/li&gt;&lt;li&gt;variationAdditionalSkus&lt;/b&gt; &#x3D; The additional SKU data associated with the variation&lt;/li&gt;&lt;li&gt;unit&lt;/b&gt; &#x3D; The unit assigned to the variation&lt;/li&gt;&lt;li&gt;parent&lt;/b&gt; &#x3D; The main variation of the variation. Value is null if this variation is the item&#39;s main variation.&lt;/li&gt;&lt;li&gt;item&lt;/b&gt; &#x3D; The item of the variation&lt;/li&gt;&lt;li&gt;stock&lt;/b&gt; &#x3D; The stock data of the variation&lt;/li&gt;&lt;/ul&gt; For example, specifying the parameters variationCategories and variationDefaultCategory will include the default category and all other categories the variations are linked to. More than one parameter should be separated by commas. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdVariationsVariationIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsItemIdVariationsVariationIdGetAsyncWithHttpInfo(
        $item_id,
        $variation_id,
        $with = null,
        string $contentType = self::contentTypes['restItemsItemIdVariationsVariationIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Variation';
        $request = $this->restItemsItemIdVariationsVariationIdGetRequest($item_id, $variation_id, $with, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsItemIdVariationsVariationIdGet'
     *
     * @param  int $item_id (required)
     * @param  int $variation_id (required)
     * @param  string|null $with Includes the specified variation information in the results. The following parameters are available: &lt;ul&gt;&lt;li&gt;properties&lt;/b&gt; &#x3D; The properties linked to the variation&lt;/li&gt;&lt;li&gt;variationProperties&lt;/b&gt; &#x3D; The properties linked to the variation&lt;/li&gt;&lt;li&gt;variationBarcodes&lt;/b&gt; &#x3D; The barcode linked to the variation and the saved code&lt;/li&gt;&lt;li&gt;variationBundleComponents&lt;/b&gt; &#x3D; The bundle components of the variation and their quantities&lt;/li&gt;&lt;li&gt;variationComponentBundles&lt;/b&gt; &#x3D; The bundles that this variation is a component of&lt;/li&gt;&lt;li&gt;variationSalesPrices&lt;/b&gt; &#x3D; The sales prices linked to the variation and the saved price&lt;/li&gt;&lt;li&gt;marketItemNumbers&lt;/b&gt; &#x3D; The market ident number of the variation&lt;/li&gt;&lt;li&gt;variationCategories&lt;/b&gt; &#x3D; The categories linked to the variation&lt;/li&gt;&lt;li&gt;variationClients&lt;/b&gt; &#x3D; The clients (stores) for which the variation is activated&lt;/li&gt;&lt;li&gt;variationMarkets&lt;/b&gt; &#x3D; The markets for which the variation is activated &lt;/li&gt;&lt;li&gt;variationDefaultCategory&lt;/b&gt; &#x3D; The default category of the variation&lt;/li&gt;&lt;li&gt;variationSuppliers&lt;/b&gt; &#x3D; The supplier data associated with the variation&lt;/li&gt;&lt;li&gt;variationWarehouses&lt;/b&gt; &#x3D; The warehouse data associated with the variation&lt;/li&gt;&lt;li&gt;images&lt;/b&gt; &#x3D; The images linked to the variation&lt;/li&gt;&lt;li&gt;itemImages&lt;/b&gt; &#x3D; The images linked to the item&lt;/li&gt;&lt;li&gt;variationAttributeValues&lt;/b&gt; &#x3D; The attribute values of the variation&lt;/li&gt;&lt;li&gt;variationSkus&lt;/b&gt; &#x3D; The SKU data associated with the variation&lt;/li&gt;&lt;li&gt;variationAdditionalSkus&lt;/b&gt; &#x3D; The additional SKU data associated with the variation&lt;/li&gt;&lt;li&gt;unit&lt;/b&gt; &#x3D; The unit assigned to the variation&lt;/li&gt;&lt;li&gt;parent&lt;/b&gt; &#x3D; The main variation of the variation. Value is null if this variation is the item&#39;s main variation.&lt;/li&gt;&lt;li&gt;item&lt;/b&gt; &#x3D; The item of the variation&lt;/li&gt;&lt;li&gt;stock&lt;/b&gt; &#x3D; The stock data of the variation&lt;/li&gt;&lt;/ul&gt; For example, specifying the parameters variationCategories and variationDefaultCategory will include the default category and all other categories the variations are linked to. More than one parameter should be separated by commas. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdVariationsVariationIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsItemIdVariationsVariationIdGetRequest(
        $item_id,
        $variation_id,
        $with = null,
        string $contentType = self::contentTypes['restItemsItemIdVariationsVariationIdGet'][0]
    ): Request
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $item_id when calling restItemsItemIdVariationsVariationIdGet'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsItemIdVariationsVariationIdGet'
            );
        }



        $resourcePath = '/rest/items/{itemId}/variations/{variationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsItemIdVariationsVariationIdPut
     *
     * Update a variation
     *
     * @param  int $item_id item_id (required)
     * @param  int $variation_id variation_id (required)
     * @param  \ck\Model\RestItemsItemIdVariationsVariationIdPutRequest|null $_rest_items_item_id_variations_variation_id _rest_items_item_id_variations_variation_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdVariationsVariationIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Variation
     */
    public function restItemsItemIdVariationsVariationIdPut(
        int $item_id,
        int $variation_id,
        ?\ck\Model\RestItemsItemIdVariationsVariationIdPutRequest $_rest_items_item_id_variations_variation_id = null,
        string $contentType = self::contentTypes['restItemsItemIdVariationsVariationIdPut'][0]
    ): \ck\Model\Variation
    {
        list($response) = $this->restItemsItemIdVariationsVariationIdPutWithHttpInfo($item_id, $variation_id, $_rest_items_item_id_variations_variation_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsItemIdVariationsVariationIdPutWithHttpInfo
     *
     * Update a variation
     *
     * @param  int $item_id (required)
     * @param  int $variation_id (required)
     * @param  \ck\Model\RestItemsItemIdVariationsVariationIdPutRequest|null $_rest_items_item_id_variations_variation_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdVariationsVariationIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Variation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsItemIdVariationsVariationIdPutWithHttpInfo(
        int $item_id,
        int $variation_id,
        ?\ck\Model\RestItemsItemIdVariationsVariationIdPutRequest $_rest_items_item_id_variations_variation_id = null,
        string $contentType = self::contentTypes['restItemsItemIdVariationsVariationIdPut'][0]
    ): array
    {
        $request = $this->restItemsItemIdVariationsVariationIdPutRequest($item_id, $variation_id, $_rest_items_item_id_variations_variation_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Variation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Variation' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Variation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Variation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Variation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsItemIdVariationsVariationIdPutAsync
     *
     * Update a variation
     *
     * @param  int $item_id (required)
     * @param  int $variation_id (required)
     * @param  \ck\Model\RestItemsItemIdVariationsVariationIdPutRequest|null $_rest_items_item_id_variations_variation_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdVariationsVariationIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsItemIdVariationsVariationIdPutAsync(
        int $item_id,
        int $variation_id,
        ?\ck\Model\RestItemsItemIdVariationsVariationIdPutRequest $_rest_items_item_id_variations_variation_id = null,
        string $contentType = self::contentTypes['restItemsItemIdVariationsVariationIdPut'][0]
    ): PromiseInterface
    {
        return $this->restItemsItemIdVariationsVariationIdPutAsyncWithHttpInfo($item_id, $variation_id, $_rest_items_item_id_variations_variation_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsItemIdVariationsVariationIdPutAsyncWithHttpInfo
     *
     * Update a variation
     *
     * @param  int $item_id (required)
     * @param  int $variation_id (required)
     * @param  \ck\Model\RestItemsItemIdVariationsVariationIdPutRequest|null $_rest_items_item_id_variations_variation_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdVariationsVariationIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsItemIdVariationsVariationIdPutAsyncWithHttpInfo(
        $item_id,
        $variation_id,
        $_rest_items_item_id_variations_variation_id = null,
        string $contentType = self::contentTypes['restItemsItemIdVariationsVariationIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Variation';
        $request = $this->restItemsItemIdVariationsVariationIdPutRequest($item_id, $variation_id, $_rest_items_item_id_variations_variation_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsItemIdVariationsVariationIdPut'
     *
     * @param  int $item_id (required)
     * @param  int $variation_id (required)
     * @param  \ck\Model\RestItemsItemIdVariationsVariationIdPutRequest|null $_rest_items_item_id_variations_variation_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdVariationsVariationIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsItemIdVariationsVariationIdPutRequest(
        $item_id,
        $variation_id,
        $_rest_items_item_id_variations_variation_id = null,
        string $contentType = self::contentTypes['restItemsItemIdVariationsVariationIdPut'][0]
    ): Request
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $item_id when calling restItemsItemIdVariationsVariationIdPut'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsItemIdVariationsVariationIdPut'
            );
        }



        $resourcePath = '/rest/items/{itemId}/variations/{variationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_item_id_variations_variation_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_item_id_variations_variation_id));
            } else {
                $httpBody = $_rest_items_item_id_variations_variation_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsGet
     *
     * Get property value texts
     *
     * @param  int $item_id item_id (required)
     * @param  int $variation_id variation_id (required)
     * @param  int $property_id property_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationPropertyValueText[]
     */
    public function restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsGet(
        int $item_id,
        int $variation_id,
        int $property_id,
        string $contentType = self::contentTypes['restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsGet'][0]
    ): array
    {
        list($response) = $this->restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsGetWithHttpInfo($item_id, $variation_id, $property_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsGetWithHttpInfo
     *
     * Get property value texts
     *
     * @param  int $item_id (required)
     * @param  int $variation_id (required)
     * @param  int $property_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationPropertyValueText[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsGetWithHttpInfo(
        int $item_id,
        int $variation_id,
        int $property_id,
        string $contentType = self::contentTypes['restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsGet'][0]
    ): array
    {
        $request = $this->restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsGetRequest($item_id, $variation_id, $property_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationPropertyValueText[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationPropertyValueText[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationPropertyValueText[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationPropertyValueText[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationPropertyValueText[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsGetAsync
     *
     * Get property value texts
     *
     * @param  int $item_id (required)
     * @param  int $variation_id (required)
     * @param  int $property_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsGetAsync(
        int $item_id,
        int $variation_id,
        int $property_id,
        string $contentType = self::contentTypes['restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsGetAsyncWithHttpInfo($item_id, $variation_id, $property_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsGetAsyncWithHttpInfo
     *
     * Get property value texts
     *
     * @param  int $item_id (required)
     * @param  int $variation_id (required)
     * @param  int $property_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsGetAsyncWithHttpInfo(
        $item_id,
        $variation_id,
        $property_id,
        string $contentType = self::contentTypes['restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationPropertyValueText[]';
        $request = $this->restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsGetRequest($item_id, $variation_id, $property_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsGet'
     *
     * @param  int $item_id (required)
     * @param  int $variation_id (required)
     * @param  int $property_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsGetRequest(
        $item_id,
        $variation_id,
        $property_id,
        string $contentType = self::contentTypes['restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsGet'][0]
    ): Request
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $item_id when calling restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsGet'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsGet'
            );
        }

        // verify the required parameter 'property_id' is set
        if ($property_id === null || (is_array($property_id) && count($property_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $property_id when calling restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsGet'
            );
        }


        $resourcePath = '/rest/items/{itemId}/variations/{variationId}/variation_properties/{propertyId}/texts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }
        // path params
        if ($property_id !== null) {
            $resourcePath = str_replace(
                '{' . 'propertyId' . '}',
                ObjectSerializer::toPathValue($property_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangDelete
     *
     * Delete property value text by language
     *
     * @param  int $item_id item_id (required)
     * @param  int $variation_id variation_id (required)
     * @param  int $property_id property_id (required)
     * @param  int $lang lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangDelete(
        int $item_id,
        int $variation_id,
        int $property_id,
        int $lang,
        string $contentType = self::contentTypes['restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangDelete'][0]
    ): object
    {
        list($response) = $this->restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangDeleteWithHttpInfo($item_id, $variation_id, $property_id, $lang, $contentType);
        return $response;
    }

    /**
     * Operation restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangDeleteWithHttpInfo
     *
     * Delete property value text by language
     *
     * @param  int $item_id (required)
     * @param  int $variation_id (required)
     * @param  int $property_id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangDeleteWithHttpInfo(
        int $item_id,
        int $variation_id,
        int $property_id,
        int $lang,
        string $contentType = self::contentTypes['restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangDelete'][0]
    ): array
    {
        $request = $this->restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangDeleteRequest($item_id, $variation_id, $property_id, $lang, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangDeleteAsync
     *
     * Delete property value text by language
     *
     * @param  int $item_id (required)
     * @param  int $variation_id (required)
     * @param  int $property_id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangDeleteAsync(
        int $item_id,
        int $variation_id,
        int $property_id,
        int $lang,
        string $contentType = self::contentTypes['restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangDeleteAsyncWithHttpInfo($item_id, $variation_id, $property_id, $lang, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangDeleteAsyncWithHttpInfo
     *
     * Delete property value text by language
     *
     * @param  int $item_id (required)
     * @param  int $variation_id (required)
     * @param  int $property_id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangDeleteAsyncWithHttpInfo(
        $item_id,
        $variation_id,
        $property_id,
        $lang,
        string $contentType = self::contentTypes['restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangDeleteRequest($item_id, $variation_id, $property_id, $lang, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangDelete'
     *
     * @param  int $item_id (required)
     * @param  int $variation_id (required)
     * @param  int $property_id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangDeleteRequest(
        $item_id,
        $variation_id,
        $property_id,
        $lang,
        string $contentType = self::contentTypes['restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangDelete'][0]
    ): Request
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $item_id when calling restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangDelete'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangDelete'
            );
        }

        // verify the required parameter 'property_id' is set
        if ($property_id === null || (is_array($property_id) && count($property_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $property_id when calling restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangDelete'
            );
        }

        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $lang when calling restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangDelete'
            );
        }


        $resourcePath = '/rest/items/{itemId}/variations/{variationId}/variation_properties/{propertyId}/texts/{lang}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }
        // path params
        if ($property_id !== null) {
            $resourcePath = str_replace(
                '{' . 'propertyId' . '}',
                ObjectSerializer::toPathValue($property_id),
                $resourcePath
            );
        }
        // path params
        if ($lang !== null) {
            $resourcePath = str_replace(
                '{' . 'lang' . '}',
                ObjectSerializer::toPathValue($lang),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangGet
     *
     * Get property value text by language
     *
     * @param  int $item_id item_id (required)
     * @param  int $variation_id variation_id (required)
     * @param  int $property_id property_id (required)
     * @param  int $lang lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationPropertyValueText
     */
    public function restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangGet(
        int $item_id,
        int $variation_id,
        int $property_id,
        int $lang,
        string $contentType = self::contentTypes['restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangGet'][0]
    ): \ck\Model\VariationPropertyValueText
    {
        list($response) = $this->restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangGetWithHttpInfo($item_id, $variation_id, $property_id, $lang, $contentType);
        return $response;
    }

    /**
     * Operation restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangGetWithHttpInfo
     *
     * Get property value text by language
     *
     * @param  int $item_id (required)
     * @param  int $variation_id (required)
     * @param  int $property_id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationPropertyValueText, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangGetWithHttpInfo(
        int $item_id,
        int $variation_id,
        int $property_id,
        int $lang,
        string $contentType = self::contentTypes['restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangGet'][0]
    ): array
    {
        $request = $this->restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangGetRequest($item_id, $variation_id, $property_id, $lang, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationPropertyValueText' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationPropertyValueText' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationPropertyValueText', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationPropertyValueText';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationPropertyValueText',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangGetAsync
     *
     * Get property value text by language
     *
     * @param  int $item_id (required)
     * @param  int $variation_id (required)
     * @param  int $property_id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangGetAsync(
        int $item_id,
        int $variation_id,
        int $property_id,
        int $lang,
        string $contentType = self::contentTypes['restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangGetAsyncWithHttpInfo($item_id, $variation_id, $property_id, $lang, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangGetAsyncWithHttpInfo
     *
     * Get property value text by language
     *
     * @param  int $item_id (required)
     * @param  int $variation_id (required)
     * @param  int $property_id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangGetAsyncWithHttpInfo(
        $item_id,
        $variation_id,
        $property_id,
        $lang,
        string $contentType = self::contentTypes['restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationPropertyValueText';
        $request = $this->restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangGetRequest($item_id, $variation_id, $property_id, $lang, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangGet'
     *
     * @param  int $item_id (required)
     * @param  int $variation_id (required)
     * @param  int $property_id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangGetRequest(
        $item_id,
        $variation_id,
        $property_id,
        $lang,
        string $contentType = self::contentTypes['restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangGet'][0]
    ): Request
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $item_id when calling restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangGet'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangGet'
            );
        }

        // verify the required parameter 'property_id' is set
        if ($property_id === null || (is_array($property_id) && count($property_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $property_id when calling restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangGet'
            );
        }

        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $lang when calling restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangGet'
            );
        }


        $resourcePath = '/rest/items/{itemId}/variations/{variationId}/variation_properties/{propertyId}/texts/{lang}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }
        // path params
        if ($property_id !== null) {
            $resourcePath = str_replace(
                '{' . 'propertyId' . '}',
                ObjectSerializer::toPathValue($property_id),
                $resourcePath
            );
        }
        // path params
        if ($lang !== null) {
            $resourcePath = str_replace(
                '{' . 'lang' . '}',
                ObjectSerializer::toPathValue($lang),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangPut
     *
     * Update property value text by language
     *
     * @param  int $item_id item_id (required)
     * @param  int $variation_id variation_id (required)
     * @param  int $property_id property_id (required)
     * @param  int $lang lang (required)
     * @param  \ck\Model\RestItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsPostRequest|null $_rest_items_item_id_variations_variation_id_variation_properties_property_id_texts_lang _rest_items_item_id_variations_variation_id_variation_properties_property_id_texts_lang (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationPropertyValueText
     */
    public function restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangPut(
        int $item_id,
        int $variation_id,
        int $property_id,
        int $lang,
        ?\ck\Model\RestItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsPostRequest $_rest_items_item_id_variations_variation_id_variation_properties_property_id_texts_lang = null,
        string $contentType = self::contentTypes['restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangPut'][0]
    ): \ck\Model\VariationPropertyValueText
    {
        list($response) = $this->restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangPutWithHttpInfo($item_id, $variation_id, $property_id, $lang, $_rest_items_item_id_variations_variation_id_variation_properties_property_id_texts_lang, $contentType);
        return $response;
    }

    /**
     * Operation restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangPutWithHttpInfo
     *
     * Update property value text by language
     *
     * @param  int $item_id (required)
     * @param  int $variation_id (required)
     * @param  int $property_id (required)
     * @param  int $lang (required)
     * @param  \ck\Model\RestItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsPostRequest|null $_rest_items_item_id_variations_variation_id_variation_properties_property_id_texts_lang (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationPropertyValueText, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangPutWithHttpInfo(
        int $item_id,
        int $variation_id,
        int $property_id,
        int $lang,
        ?\ck\Model\RestItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsPostRequest $_rest_items_item_id_variations_variation_id_variation_properties_property_id_texts_lang = null,
        string $contentType = self::contentTypes['restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangPut'][0]
    ): array
    {
        $request = $this->restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangPutRequest($item_id, $variation_id, $property_id, $lang, $_rest_items_item_id_variations_variation_id_variation_properties_property_id_texts_lang, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationPropertyValueText' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationPropertyValueText' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationPropertyValueText', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationPropertyValueText';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationPropertyValueText',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangPutAsync
     *
     * Update property value text by language
     *
     * @param  int $item_id (required)
     * @param  int $variation_id (required)
     * @param  int $property_id (required)
     * @param  int $lang (required)
     * @param  \ck\Model\RestItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsPostRequest|null $_rest_items_item_id_variations_variation_id_variation_properties_property_id_texts_lang (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangPutAsync(
        int $item_id,
        int $variation_id,
        int $property_id,
        int $lang,
        ?\ck\Model\RestItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsPostRequest $_rest_items_item_id_variations_variation_id_variation_properties_property_id_texts_lang = null,
        string $contentType = self::contentTypes['restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangPut'][0]
    ): PromiseInterface
    {
        return $this->restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangPutAsyncWithHttpInfo($item_id, $variation_id, $property_id, $lang, $_rest_items_item_id_variations_variation_id_variation_properties_property_id_texts_lang, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangPutAsyncWithHttpInfo
     *
     * Update property value text by language
     *
     * @param  int $item_id (required)
     * @param  int $variation_id (required)
     * @param  int $property_id (required)
     * @param  int $lang (required)
     * @param  \ck\Model\RestItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsPostRequest|null $_rest_items_item_id_variations_variation_id_variation_properties_property_id_texts_lang (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangPutAsyncWithHttpInfo(
        $item_id,
        $variation_id,
        $property_id,
        $lang,
        $_rest_items_item_id_variations_variation_id_variation_properties_property_id_texts_lang = null,
        string $contentType = self::contentTypes['restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationPropertyValueText';
        $request = $this->restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangPutRequest($item_id, $variation_id, $property_id, $lang, $_rest_items_item_id_variations_variation_id_variation_properties_property_id_texts_lang, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangPut'
     *
     * @param  int $item_id (required)
     * @param  int $variation_id (required)
     * @param  int $property_id (required)
     * @param  int $lang (required)
     * @param  \ck\Model\RestItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsPostRequest|null $_rest_items_item_id_variations_variation_id_variation_properties_property_id_texts_lang (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangPutRequest(
        $item_id,
        $variation_id,
        $property_id,
        $lang,
        $_rest_items_item_id_variations_variation_id_variation_properties_property_id_texts_lang = null,
        string $contentType = self::contentTypes['restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangPut'][0]
    ): Request
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $item_id when calling restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangPut'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangPut'
            );
        }

        // verify the required parameter 'property_id' is set
        if ($property_id === null || (is_array($property_id) && count($property_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $property_id when calling restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangPut'
            );
        }

        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $lang when calling restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsLangPut'
            );
        }



        $resourcePath = '/rest/items/{itemId}/variations/{variationId}/variation_properties/{propertyId}/texts/{lang}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }
        // path params
        if ($property_id !== null) {
            $resourcePath = str_replace(
                '{' . 'propertyId' . '}',
                ObjectSerializer::toPathValue($property_id),
                $resourcePath
            );
        }
        // path params
        if ($lang !== null) {
            $resourcePath = str_replace(
                '{' . 'lang' . '}',
                ObjectSerializer::toPathValue($lang),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_item_id_variations_variation_id_variation_properties_property_id_texts_lang)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_item_id_variations_variation_id_variation_properties_property_id_texts_lang));
            } else {
                $httpBody = $_rest_items_item_id_variations_variation_id_variation_properties_property_id_texts_lang;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsPost
     *
     * Create property value text by language
     *
     * @param  int $item_id item_id (required)
     * @param  int $variation_id variation_id (required)
     * @param  int $property_id property_id (required)
     * @param  \ck\Model\RestItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsPostRequest|null $_rest_items_item_id_variations_variation_id_variation_properties_property_id_texts _rest_items_item_id_variations_variation_id_variation_properties_property_id_texts (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\VariationPropertyValueText
     */
    public function restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsPost(
        int $item_id,
        int $variation_id,
        int $property_id,
        ?\ck\Model\RestItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsPostRequest $_rest_items_item_id_variations_variation_id_variation_properties_property_id_texts = null,
        string $contentType = self::contentTypes['restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsPost'][0]
    ): \ck\Model\VariationPropertyValueText
    {
        list($response) = $this->restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsPostWithHttpInfo($item_id, $variation_id, $property_id, $_rest_items_item_id_variations_variation_id_variation_properties_property_id_texts, $contentType);
        return $response;
    }

    /**
     * Operation restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsPostWithHttpInfo
     *
     * Create property value text by language
     *
     * @param  int $item_id (required)
     * @param  int $variation_id (required)
     * @param  int $property_id (required)
     * @param  \ck\Model\RestItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsPostRequest|null $_rest_items_item_id_variations_variation_id_variation_properties_property_id_texts (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\VariationPropertyValueText, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsPostWithHttpInfo(
        int $item_id,
        int $variation_id,
        int $property_id,
        ?\ck\Model\RestItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsPostRequest $_rest_items_item_id_variations_variation_id_variation_properties_property_id_texts = null,
        string $contentType = self::contentTypes['restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsPost'][0]
    ): array
    {
        $request = $this->restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsPostRequest($item_id, $variation_id, $property_id, $_rest_items_item_id_variations_variation_id_variation_properties_property_id_texts, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\VariationPropertyValueText' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\VariationPropertyValueText' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\VariationPropertyValueText', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\VariationPropertyValueText';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\VariationPropertyValueText',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsPostAsync
     *
     * Create property value text by language
     *
     * @param  int $item_id (required)
     * @param  int $variation_id (required)
     * @param  int $property_id (required)
     * @param  \ck\Model\RestItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsPostRequest|null $_rest_items_item_id_variations_variation_id_variation_properties_property_id_texts (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsPostAsync(
        int $item_id,
        int $variation_id,
        int $property_id,
        ?\ck\Model\RestItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsPostRequest $_rest_items_item_id_variations_variation_id_variation_properties_property_id_texts = null,
        string $contentType = self::contentTypes['restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsPostAsyncWithHttpInfo($item_id, $variation_id, $property_id, $_rest_items_item_id_variations_variation_id_variation_properties_property_id_texts, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsPostAsyncWithHttpInfo
     *
     * Create property value text by language
     *
     * @param  int $item_id (required)
     * @param  int $variation_id (required)
     * @param  int $property_id (required)
     * @param  \ck\Model\RestItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsPostRequest|null $_rest_items_item_id_variations_variation_id_variation_properties_property_id_texts (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsPostAsyncWithHttpInfo(
        $item_id,
        $variation_id,
        $property_id,
        $_rest_items_item_id_variations_variation_id_variation_properties_property_id_texts = null,
        string $contentType = self::contentTypes['restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\VariationPropertyValueText';
        $request = $this->restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsPostRequest($item_id, $variation_id, $property_id, $_rest_items_item_id_variations_variation_id_variation_properties_property_id_texts, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsPost'
     *
     * @param  int $item_id (required)
     * @param  int $variation_id (required)
     * @param  int $property_id (required)
     * @param  \ck\Model\RestItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsPostRequest|null $_rest_items_item_id_variations_variation_id_variation_properties_property_id_texts (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsPostRequest(
        $item_id,
        $variation_id,
        $property_id,
        $_rest_items_item_id_variations_variation_id_variation_properties_property_id_texts = null,
        string $contentType = self::contentTypes['restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsPost'][0]
    ): Request
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $item_id when calling restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsPost'
            );
        }

        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsPost'
            );
        }

        // verify the required parameter 'property_id' is set
        if ($property_id === null || (is_array($property_id) && count($property_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $property_id when calling restItemsItemIdVariationsVariationIdVariationPropertiesPropertyIdTextsPost'
            );
        }



        $resourcePath = '/rest/items/{itemId}/variations/{variationId}/variation_properties/{propertyId}/texts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }
        // path params
        if ($property_id !== null) {
            $resourcePath = str_replace(
                '{' . 'propertyId' . '}',
                ObjectSerializer::toPathValue($property_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_item_id_variations_variation_id_variation_properties_property_id_texts)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_item_id_variations_variation_id_variation_properties_property_id_texts));
            } else {
                $httpBody = $_rest_items_item_id_variations_variation_id_variation_properties_property_id_texts;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsItemShippingProfilesGet
     *
     * List all shipping profiles of all items
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemShippingProfilesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response
     */
    public function restItemsItemShippingProfilesGet(
        string $contentType = self::contentTypes['restItemsItemShippingProfilesGet'][0]
    ): \ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response
    {
        list($response) = $this->restItemsItemShippingProfilesGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restItemsItemShippingProfilesGetWithHttpInfo
     *
     * List all shipping profiles of all items
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemShippingProfilesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsItemShippingProfilesGetWithHttpInfo(
        string $contentType = self::contentTypes['restItemsItemShippingProfilesGet'][0]
    ): array
    {
        $request = $this->restItemsItemShippingProfilesGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsItemShippingProfilesGetAsync
     *
     * List all shipping profiles of all items
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemShippingProfilesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsItemShippingProfilesGetAsync(
        string $contentType = self::contentTypes['restItemsItemShippingProfilesGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsItemShippingProfilesGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsItemShippingProfilesGetAsyncWithHttpInfo
     *
     * List all shipping profiles of all items
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemShippingProfilesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsItemShippingProfilesGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restItemsItemShippingProfilesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response';
        $request = $this->restItemsItemShippingProfilesGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsItemShippingProfilesGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemShippingProfilesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsItemShippingProfilesGetRequest(
        string $contentType = self::contentTypes['restItemsItemShippingProfilesGet'][0]
    ): Request
    {


        $resourcePath = '/rest/items/item_shipping_profiles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsItemShippingProfilesPost
     *
     * Bulk activate shipping profiles
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemShippingProfilesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsItemShippingProfilesPost(
        string $contentType = self::contentTypes['restItemsItemShippingProfilesPost'][0]
    ): object
    {
        list($response) = $this->restItemsItemShippingProfilesPostWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restItemsItemShippingProfilesPostWithHttpInfo
     *
     * Bulk activate shipping profiles
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemShippingProfilesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsItemShippingProfilesPostWithHttpInfo(
        string $contentType = self::contentTypes['restItemsItemShippingProfilesPost'][0]
    ): array
    {
        $request = $this->restItemsItemShippingProfilesPostRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsItemShippingProfilesPostAsync
     *
     * Bulk activate shipping profiles
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemShippingProfilesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsItemShippingProfilesPostAsync(
        string $contentType = self::contentTypes['restItemsItemShippingProfilesPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsItemShippingProfilesPostAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsItemShippingProfilesPostAsyncWithHttpInfo
     *
     * Bulk activate shipping profiles
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemShippingProfilesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsItemShippingProfilesPostAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restItemsItemShippingProfilesPost'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsItemShippingProfilesPostRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsItemShippingProfilesPost'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsItemShippingProfilesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsItemShippingProfilesPostRequest(
        string $contentType = self::contentTypes['restItemsItemShippingProfilesPost'][0]
    ): Request
    {


        $resourcePath = '/rest/items/item_shipping_profiles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsLabelsGet
     *
     * List item label templates
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsLabelsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object[]
     */
    public function restItemsLabelsGet(
        string $contentType = self::contentTypes['restItemsLabelsGet'][0]
    ): array
    {
        list($response) = $this->restItemsLabelsGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restItemsLabelsGetWithHttpInfo
     *
     * List item label templates
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsLabelsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsLabelsGetWithHttpInfo(
        string $contentType = self::contentTypes['restItemsLabelsGet'][0]
    ): array
    {
        $request = $this->restItemsLabelsGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsLabelsGetAsync
     *
     * List item label templates
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsLabelsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsLabelsGetAsync(
        string $contentType = self::contentTypes['restItemsLabelsGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsLabelsGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsLabelsGetAsyncWithHttpInfo
     *
     * List item label templates
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsLabelsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsLabelsGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restItemsLabelsGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object[]';
        $request = $this->restItemsLabelsGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsLabelsGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsLabelsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsLabelsGetRequest(
        string $contentType = self::contentTypes['restItemsLabelsGet'][0]
    ): Request
    {


        $resourcePath = '/rest/items/labels';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsManufacturersGet
     *
     * List manufacturers
     *
     * @param  string|null $with Includes the specified manufacturer information in the results. The following parameters are available: commissions, externals (optional)
     * @param  string|null $updated_at Filter restricts the list of results to records updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     * @param  string|null $name Filter restricts the list of results to records with specified name. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsManufacturersGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestItemsManufacturersGet200Response
     */
    public function restItemsManufacturersGet(
        ?string $with = null,
        ?string $updated_at = null,
        ?string $name = null,
        string $contentType = self::contentTypes['restItemsManufacturersGet'][0]
    ): \ck\Model\RestItemsManufacturersGet200Response
    {
        list($response) = $this->restItemsManufacturersGetWithHttpInfo($with, $updated_at, $name, $contentType);
        return $response;
    }

    /**
     * Operation restItemsManufacturersGetWithHttpInfo
     *
     * List manufacturers
     *
     * @param  string|null $with Includes the specified manufacturer information in the results. The following parameters are available: commissions, externals (optional)
     * @param  string|null $updated_at Filter restricts the list of results to records updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     * @param  string|null $name Filter restricts the list of results to records with specified name. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsManufacturersGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestItemsManufacturersGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsManufacturersGetWithHttpInfo(
        ?string $with = null,
        ?string $updated_at = null,
        ?string $name = null,
        string $contentType = self::contentTypes['restItemsManufacturersGet'][0]
    ): array
    {
        $request = $this->restItemsManufacturersGetRequest($with, $updated_at, $name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestItemsManufacturersGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestItemsManufacturersGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestItemsManufacturersGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestItemsManufacturersGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestItemsManufacturersGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsManufacturersGetAsync
     *
     * List manufacturers
     *
     * @param  string|null $with Includes the specified manufacturer information in the results. The following parameters are available: commissions, externals (optional)
     * @param  string|null $updated_at Filter restricts the list of results to records updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     * @param  string|null $name Filter restricts the list of results to records with specified name. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsManufacturersGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsManufacturersGetAsync(
        ?string $with = null,
        ?string $updated_at = null,
        ?string $name = null,
        string $contentType = self::contentTypes['restItemsManufacturersGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsManufacturersGetAsyncWithHttpInfo($with, $updated_at, $name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsManufacturersGetAsyncWithHttpInfo
     *
     * List manufacturers
     *
     * @param  string|null $with Includes the specified manufacturer information in the results. The following parameters are available: commissions, externals (optional)
     * @param  string|null $updated_at Filter restricts the list of results to records updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     * @param  string|null $name Filter restricts the list of results to records with specified name. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsManufacturersGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsManufacturersGetAsyncWithHttpInfo(
        $with = null,
        $updated_at = null,
        $name = null,
        string $contentType = self::contentTypes['restItemsManufacturersGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestItemsManufacturersGet200Response';
        $request = $this->restItemsManufacturersGetRequest($with, $updated_at, $name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsManufacturersGet'
     *
     * @param  string|null $with Includes the specified manufacturer information in the results. The following parameters are available: commissions, externals (optional)
     * @param  string|null $updated_at Filter restricts the list of results to records updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     * @param  string|null $name Filter restricts the list of results to records with specified name. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsManufacturersGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsManufacturersGetRequest(
        $with = null,
        $updated_at = null,
        $name = null,
        string $contentType = self::contentTypes['restItemsManufacturersGet'][0]
    ): Request
    {





        $resourcePath = '/rest/items/manufacturers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_at,
            'updatedAt', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsManufacturersIdCommissionsGet
     *
     * List commissions
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsManufacturersIdCommissionsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ManufacturerCommission[]
     */
    public function restItemsManufacturersIdCommissionsGet(
        int $id,
        string $contentType = self::contentTypes['restItemsManufacturersIdCommissionsGet'][0]
    ): array
    {
        list($response) = $this->restItemsManufacturersIdCommissionsGetWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsManufacturersIdCommissionsGetWithHttpInfo
     *
     * List commissions
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsManufacturersIdCommissionsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ManufacturerCommission[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsManufacturersIdCommissionsGetWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restItemsManufacturersIdCommissionsGet'][0]
    ): array
    {
        $request = $this->restItemsManufacturersIdCommissionsGetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ManufacturerCommission[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ManufacturerCommission[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ManufacturerCommission[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ManufacturerCommission[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ManufacturerCommission[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsManufacturersIdCommissionsGetAsync
     *
     * List commissions
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsManufacturersIdCommissionsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsManufacturersIdCommissionsGetAsync(
        int $id,
        string $contentType = self::contentTypes['restItemsManufacturersIdCommissionsGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsManufacturersIdCommissionsGetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsManufacturersIdCommissionsGetAsyncWithHttpInfo
     *
     * List commissions
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsManufacturersIdCommissionsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsManufacturersIdCommissionsGetAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restItemsManufacturersIdCommissionsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ManufacturerCommission[]';
        $request = $this->restItemsManufacturersIdCommissionsGetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsManufacturersIdCommissionsGet'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsManufacturersIdCommissionsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsManufacturersIdCommissionsGetRequest(
        $id,
        string $contentType = self::contentTypes['restItemsManufacturersIdCommissionsGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsManufacturersIdCommissionsGet'
            );
        }


        $resourcePath = '/rest/items/manufacturers/{id}/commissions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsManufacturersIdCommissionsManufacturerIdDelete
     *
     * Delete a commission
     *
     * @param  int $id id (required)
     * @param  int $manufacturer_id manufacturer_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsManufacturersIdCommissionsManufacturerIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsManufacturersIdCommissionsManufacturerIdDelete(
        int $id,
        int $manufacturer_id,
        string $contentType = self::contentTypes['restItemsManufacturersIdCommissionsManufacturerIdDelete'][0]
    ): object
    {
        list($response) = $this->restItemsManufacturersIdCommissionsManufacturerIdDeleteWithHttpInfo($id, $manufacturer_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsManufacturersIdCommissionsManufacturerIdDeleteWithHttpInfo
     *
     * Delete a commission
     *
     * @param  int $id (required)
     * @param  int $manufacturer_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsManufacturersIdCommissionsManufacturerIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsManufacturersIdCommissionsManufacturerIdDeleteWithHttpInfo(
        int $id,
        int $manufacturer_id,
        string $contentType = self::contentTypes['restItemsManufacturersIdCommissionsManufacturerIdDelete'][0]
    ): array
    {
        $request = $this->restItemsManufacturersIdCommissionsManufacturerIdDeleteRequest($id, $manufacturer_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsManufacturersIdCommissionsManufacturerIdDeleteAsync
     *
     * Delete a commission
     *
     * @param  int $id (required)
     * @param  int $manufacturer_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsManufacturersIdCommissionsManufacturerIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsManufacturersIdCommissionsManufacturerIdDeleteAsync(
        int $id,
        int $manufacturer_id,
        string $contentType = self::contentTypes['restItemsManufacturersIdCommissionsManufacturerIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemsManufacturersIdCommissionsManufacturerIdDeleteAsyncWithHttpInfo($id, $manufacturer_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsManufacturersIdCommissionsManufacturerIdDeleteAsyncWithHttpInfo
     *
     * Delete a commission
     *
     * @param  int $id (required)
     * @param  int $manufacturer_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsManufacturersIdCommissionsManufacturerIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsManufacturersIdCommissionsManufacturerIdDeleteAsyncWithHttpInfo(
        $id,
        $manufacturer_id,
        string $contentType = self::contentTypes['restItemsManufacturersIdCommissionsManufacturerIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsManufacturersIdCommissionsManufacturerIdDeleteRequest($id, $manufacturer_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsManufacturersIdCommissionsManufacturerIdDelete'
     *
     * @param  int $id (required)
     * @param  int $manufacturer_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsManufacturersIdCommissionsManufacturerIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsManufacturersIdCommissionsManufacturerIdDeleteRequest(
        $id,
        $manufacturer_id,
        string $contentType = self::contentTypes['restItemsManufacturersIdCommissionsManufacturerIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsManufacturersIdCommissionsManufacturerIdDelete'
            );
        }

        // verify the required parameter 'manufacturer_id' is set
        if ($manufacturer_id === null || (is_array($manufacturer_id) && count($manufacturer_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $manufacturer_id when calling restItemsManufacturersIdCommissionsManufacturerIdDelete'
            );
        }


        $resourcePath = '/rest/items/manufacturers/{id}/commissions/{manufacturerId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($manufacturer_id !== null) {
            $resourcePath = str_replace(
                '{' . 'manufacturerId' . '}',
                ObjectSerializer::toPathValue($manufacturer_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsManufacturersIdCommissionsManufacturerIdGet
     *
     * Get a commission
     *
     * @param  int $id id (required)
     * @param  int $manufacturer_id manufacturer_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsManufacturersIdCommissionsManufacturerIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ManufacturerCommission
     */
    public function restItemsManufacturersIdCommissionsManufacturerIdGet(
        int $id,
        int $manufacturer_id,
        string $contentType = self::contentTypes['restItemsManufacturersIdCommissionsManufacturerIdGet'][0]
    ): \ck\Model\ManufacturerCommission
    {
        list($response) = $this->restItemsManufacturersIdCommissionsManufacturerIdGetWithHttpInfo($id, $manufacturer_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsManufacturersIdCommissionsManufacturerIdGetWithHttpInfo
     *
     * Get a commission
     *
     * @param  int $id (required)
     * @param  int $manufacturer_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsManufacturersIdCommissionsManufacturerIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ManufacturerCommission, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsManufacturersIdCommissionsManufacturerIdGetWithHttpInfo(
        int $id,
        int $manufacturer_id,
        string $contentType = self::contentTypes['restItemsManufacturersIdCommissionsManufacturerIdGet'][0]
    ): array
    {
        $request = $this->restItemsManufacturersIdCommissionsManufacturerIdGetRequest($id, $manufacturer_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ManufacturerCommission' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ManufacturerCommission' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ManufacturerCommission', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ManufacturerCommission';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ManufacturerCommission',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsManufacturersIdCommissionsManufacturerIdGetAsync
     *
     * Get a commission
     *
     * @param  int $id (required)
     * @param  int $manufacturer_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsManufacturersIdCommissionsManufacturerIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsManufacturersIdCommissionsManufacturerIdGetAsync(
        int $id,
        int $manufacturer_id,
        string $contentType = self::contentTypes['restItemsManufacturersIdCommissionsManufacturerIdGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsManufacturersIdCommissionsManufacturerIdGetAsyncWithHttpInfo($id, $manufacturer_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsManufacturersIdCommissionsManufacturerIdGetAsyncWithHttpInfo
     *
     * Get a commission
     *
     * @param  int $id (required)
     * @param  int $manufacturer_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsManufacturersIdCommissionsManufacturerIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsManufacturersIdCommissionsManufacturerIdGetAsyncWithHttpInfo(
        $id,
        $manufacturer_id,
        string $contentType = self::contentTypes['restItemsManufacturersIdCommissionsManufacturerIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ManufacturerCommission';
        $request = $this->restItemsManufacturersIdCommissionsManufacturerIdGetRequest($id, $manufacturer_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsManufacturersIdCommissionsManufacturerIdGet'
     *
     * @param  int $id (required)
     * @param  int $manufacturer_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsManufacturersIdCommissionsManufacturerIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsManufacturersIdCommissionsManufacturerIdGetRequest(
        $id,
        $manufacturer_id,
        string $contentType = self::contentTypes['restItemsManufacturersIdCommissionsManufacturerIdGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsManufacturersIdCommissionsManufacturerIdGet'
            );
        }

        // verify the required parameter 'manufacturer_id' is set
        if ($manufacturer_id === null || (is_array($manufacturer_id) && count($manufacturer_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $manufacturer_id when calling restItemsManufacturersIdCommissionsManufacturerIdGet'
            );
        }


        $resourcePath = '/rest/items/manufacturers/{id}/commissions/{manufacturerId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($manufacturer_id !== null) {
            $resourcePath = str_replace(
                '{' . 'manufacturerId' . '}',
                ObjectSerializer::toPathValue($manufacturer_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsManufacturersIdCommissionsManufacturerIdPut
     *
     * Update a commission
     *
     * @param  int $id id (required)
     * @param  int $manufacturer_id manufacturer_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsManufacturersIdCommissionsManufacturerIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ManufacturerCommission
     */
    public function restItemsManufacturersIdCommissionsManufacturerIdPut(
        int $id,
        int $manufacturer_id,
        string $contentType = self::contentTypes['restItemsManufacturersIdCommissionsManufacturerIdPut'][0]
    ): \ck\Model\ManufacturerCommission
    {
        list($response) = $this->restItemsManufacturersIdCommissionsManufacturerIdPutWithHttpInfo($id, $manufacturer_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsManufacturersIdCommissionsManufacturerIdPutWithHttpInfo
     *
     * Update a commission
     *
     * @param  int $id (required)
     * @param  int $manufacturer_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsManufacturersIdCommissionsManufacturerIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ManufacturerCommission, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsManufacturersIdCommissionsManufacturerIdPutWithHttpInfo(
        int $id,
        int $manufacturer_id,
        string $contentType = self::contentTypes['restItemsManufacturersIdCommissionsManufacturerIdPut'][0]
    ): array
    {
        $request = $this->restItemsManufacturersIdCommissionsManufacturerIdPutRequest($id, $manufacturer_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ManufacturerCommission' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ManufacturerCommission' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ManufacturerCommission', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ManufacturerCommission';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ManufacturerCommission',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsManufacturersIdCommissionsManufacturerIdPutAsync
     *
     * Update a commission
     *
     * @param  int $id (required)
     * @param  int $manufacturer_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsManufacturersIdCommissionsManufacturerIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsManufacturersIdCommissionsManufacturerIdPutAsync(
        int $id,
        int $manufacturer_id,
        string $contentType = self::contentTypes['restItemsManufacturersIdCommissionsManufacturerIdPut'][0]
    ): PromiseInterface
    {
        return $this->restItemsManufacturersIdCommissionsManufacturerIdPutAsyncWithHttpInfo($id, $manufacturer_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsManufacturersIdCommissionsManufacturerIdPutAsyncWithHttpInfo
     *
     * Update a commission
     *
     * @param  int $id (required)
     * @param  int $manufacturer_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsManufacturersIdCommissionsManufacturerIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsManufacturersIdCommissionsManufacturerIdPutAsyncWithHttpInfo(
        $id,
        $manufacturer_id,
        string $contentType = self::contentTypes['restItemsManufacturersIdCommissionsManufacturerIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ManufacturerCommission';
        $request = $this->restItemsManufacturersIdCommissionsManufacturerIdPutRequest($id, $manufacturer_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsManufacturersIdCommissionsManufacturerIdPut'
     *
     * @param  int $id (required)
     * @param  int $manufacturer_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsManufacturersIdCommissionsManufacturerIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsManufacturersIdCommissionsManufacturerIdPutRequest(
        $id,
        $manufacturer_id,
        string $contentType = self::contentTypes['restItemsManufacturersIdCommissionsManufacturerIdPut'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsManufacturersIdCommissionsManufacturerIdPut'
            );
        }

        // verify the required parameter 'manufacturer_id' is set
        if ($manufacturer_id === null || (is_array($manufacturer_id) && count($manufacturer_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $manufacturer_id when calling restItemsManufacturersIdCommissionsManufacturerIdPut'
            );
        }


        $resourcePath = '/rest/items/manufacturers/{id}/commissions/{manufacturerId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($manufacturer_id !== null) {
            $resourcePath = str_replace(
                '{' . 'manufacturerId' . '}',
                ObjectSerializer::toPathValue($manufacturer_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsManufacturersIdCommissionsPost
     *
     * Create a commission
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsManufacturersIdCommissionsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ManufacturerCommission
     */
    public function restItemsManufacturersIdCommissionsPost(
        int $id,
        string $contentType = self::contentTypes['restItemsManufacturersIdCommissionsPost'][0]
    ): \ck\Model\ManufacturerCommission
    {
        list($response) = $this->restItemsManufacturersIdCommissionsPostWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsManufacturersIdCommissionsPostWithHttpInfo
     *
     * Create a commission
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsManufacturersIdCommissionsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ManufacturerCommission, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsManufacturersIdCommissionsPostWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restItemsManufacturersIdCommissionsPost'][0]
    ): array
    {
        $request = $this->restItemsManufacturersIdCommissionsPostRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ManufacturerCommission' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ManufacturerCommission' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ManufacturerCommission', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ManufacturerCommission';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ManufacturerCommission',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsManufacturersIdCommissionsPostAsync
     *
     * Create a commission
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsManufacturersIdCommissionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsManufacturersIdCommissionsPostAsync(
        int $id,
        string $contentType = self::contentTypes['restItemsManufacturersIdCommissionsPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsManufacturersIdCommissionsPostAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsManufacturersIdCommissionsPostAsyncWithHttpInfo
     *
     * Create a commission
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsManufacturersIdCommissionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsManufacturersIdCommissionsPostAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restItemsManufacturersIdCommissionsPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ManufacturerCommission';
        $request = $this->restItemsManufacturersIdCommissionsPostRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsManufacturersIdCommissionsPost'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsManufacturersIdCommissionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsManufacturersIdCommissionsPostRequest(
        $id,
        string $contentType = self::contentTypes['restItemsManufacturersIdCommissionsPost'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsManufacturersIdCommissionsPost'
            );
        }


        $resourcePath = '/rest/items/manufacturers/{id}/commissions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsManufacturersIdDelete
     *
     * Delete a manufacturer
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsManufacturersIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsManufacturersIdDelete(
        int $id,
        string $contentType = self::contentTypes['restItemsManufacturersIdDelete'][0]
    ): object
    {
        list($response) = $this->restItemsManufacturersIdDeleteWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsManufacturersIdDeleteWithHttpInfo
     *
     * Delete a manufacturer
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsManufacturersIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsManufacturersIdDeleteWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restItemsManufacturersIdDelete'][0]
    ): array
    {
        $request = $this->restItemsManufacturersIdDeleteRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsManufacturersIdDeleteAsync
     *
     * Delete a manufacturer
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsManufacturersIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsManufacturersIdDeleteAsync(
        int $id,
        string $contentType = self::contentTypes['restItemsManufacturersIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemsManufacturersIdDeleteAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsManufacturersIdDeleteAsyncWithHttpInfo
     *
     * Delete a manufacturer
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsManufacturersIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsManufacturersIdDeleteAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restItemsManufacturersIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsManufacturersIdDeleteRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsManufacturersIdDelete'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsManufacturersIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsManufacturersIdDeleteRequest(
        $id,
        string $contentType = self::contentTypes['restItemsManufacturersIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsManufacturersIdDelete'
            );
        }


        $resourcePath = '/rest/items/manufacturers/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsManufacturersIdGet
     *
     * Get a manufacturer
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsManufacturersIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Manufacturer
     */
    public function restItemsManufacturersIdGet(
        int $id,
        string $contentType = self::contentTypes['restItemsManufacturersIdGet'][0]
    ): \ck\Model\Manufacturer
    {
        list($response) = $this->restItemsManufacturersIdGetWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsManufacturersIdGetWithHttpInfo
     *
     * Get a manufacturer
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsManufacturersIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Manufacturer, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsManufacturersIdGetWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restItemsManufacturersIdGet'][0]
    ): array
    {
        $request = $this->restItemsManufacturersIdGetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Manufacturer' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Manufacturer' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Manufacturer', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Manufacturer';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Manufacturer',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsManufacturersIdGetAsync
     *
     * Get a manufacturer
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsManufacturersIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsManufacturersIdGetAsync(
        int $id,
        string $contentType = self::contentTypes['restItemsManufacturersIdGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsManufacturersIdGetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsManufacturersIdGetAsyncWithHttpInfo
     *
     * Get a manufacturer
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsManufacturersIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsManufacturersIdGetAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restItemsManufacturersIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Manufacturer';
        $request = $this->restItemsManufacturersIdGetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsManufacturersIdGet'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsManufacturersIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsManufacturersIdGetRequest(
        $id,
        string $contentType = self::contentTypes['restItemsManufacturersIdGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsManufacturersIdGet'
            );
        }


        $resourcePath = '/rest/items/manufacturers/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsManufacturersIdPut
     *
     * Update a manufacturer
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsManufacturersIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Manufacturer
     */
    public function restItemsManufacturersIdPut(
        int $id,
        string $contentType = self::contentTypes['restItemsManufacturersIdPut'][0]
    ): \ck\Model\Manufacturer
    {
        list($response) = $this->restItemsManufacturersIdPutWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsManufacturersIdPutWithHttpInfo
     *
     * Update a manufacturer
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsManufacturersIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Manufacturer, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsManufacturersIdPutWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restItemsManufacturersIdPut'][0]
    ): array
    {
        $request = $this->restItemsManufacturersIdPutRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Manufacturer' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Manufacturer' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Manufacturer', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Manufacturer';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Manufacturer',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsManufacturersIdPutAsync
     *
     * Update a manufacturer
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsManufacturersIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsManufacturersIdPutAsync(
        int $id,
        string $contentType = self::contentTypes['restItemsManufacturersIdPut'][0]
    ): PromiseInterface
    {
        return $this->restItemsManufacturersIdPutAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsManufacturersIdPutAsyncWithHttpInfo
     *
     * Update a manufacturer
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsManufacturersIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsManufacturersIdPutAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restItemsManufacturersIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Manufacturer';
        $request = $this->restItemsManufacturersIdPutRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsManufacturersIdPut'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsManufacturersIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsManufacturersIdPutRequest(
        $id,
        string $contentType = self::contentTypes['restItemsManufacturersIdPut'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsManufacturersIdPut'
            );
        }


        $resourcePath = '/rest/items/manufacturers/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsManufacturersPost
     *
     * Create a manufacturer
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsManufacturersPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Manufacturer
     */
    public function restItemsManufacturersPost(
        string $contentType = self::contentTypes['restItemsManufacturersPost'][0]
    ): \ck\Model\Manufacturer
    {
        list($response) = $this->restItemsManufacturersPostWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restItemsManufacturersPostWithHttpInfo
     *
     * Create a manufacturer
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsManufacturersPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Manufacturer, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsManufacturersPostWithHttpInfo(
        string $contentType = self::contentTypes['restItemsManufacturersPost'][0]
    ): array
    {
        $request = $this->restItemsManufacturersPostRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Manufacturer' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Manufacturer' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Manufacturer', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Manufacturer';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Manufacturer',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsManufacturersPostAsync
     *
     * Create a manufacturer
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsManufacturersPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsManufacturersPostAsync(
        string $contentType = self::contentTypes['restItemsManufacturersPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsManufacturersPostAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsManufacturersPostAsyncWithHttpInfo
     *
     * Create a manufacturer
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsManufacturersPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsManufacturersPostAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restItemsManufacturersPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Manufacturer';
        $request = $this->restItemsManufacturersPostRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsManufacturersPost'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsManufacturersPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsManufacturersPostRequest(
        string $contentType = self::contentTypes['restItemsManufacturersPost'][0]
    ): Request
    {


        $resourcePath = '/rest/items/manufacturers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsPackingUnitsGet
     *
     * Get the item variation packing units
     *
     * @param  string|null $language The language to return the unit name for. If no language is provided, all the languages will be returned (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPackingUnitsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\PackingUnit[]
     */
    public function restItemsPackingUnitsGet(
        ?string $language = null,
        string $contentType = self::contentTypes['restItemsPackingUnitsGet'][0]
    ): array
    {
        list($response) = $this->restItemsPackingUnitsGetWithHttpInfo($language, $contentType);
        return $response;
    }

    /**
     * Operation restItemsPackingUnitsGetWithHttpInfo
     *
     * Get the item variation packing units
     *
     * @param  string|null $language The language to return the unit name for. If no language is provided, all the languages will be returned (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPackingUnitsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\PackingUnit[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsPackingUnitsGetWithHttpInfo(
        ?string $language = null,
        string $contentType = self::contentTypes['restItemsPackingUnitsGet'][0]
    ): array
    {
        $request = $this->restItemsPackingUnitsGetRequest($language, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\PackingUnit[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\PackingUnit[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\PackingUnit[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\PackingUnit[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\PackingUnit[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsPackingUnitsGetAsync
     *
     * Get the item variation packing units
     *
     * @param  string|null $language The language to return the unit name for. If no language is provided, all the languages will be returned (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPackingUnitsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPackingUnitsGetAsync(
        ?string $language = null,
        string $contentType = self::contentTypes['restItemsPackingUnitsGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsPackingUnitsGetAsyncWithHttpInfo($language, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsPackingUnitsGetAsyncWithHttpInfo
     *
     * Get the item variation packing units
     *
     * @param  string|null $language The language to return the unit name for. If no language is provided, all the languages will be returned (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPackingUnitsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPackingUnitsGetAsyncWithHttpInfo(
        $language = null,
        string $contentType = self::contentTypes['restItemsPackingUnitsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\PackingUnit[]';
        $request = $this->restItemsPackingUnitsGetRequest($language, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsPackingUnitsGet'
     *
     * @param  string|null $language The language to return the unit name for. If no language is provided, all the languages will be returned (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPackingUnitsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsPackingUnitsGetRequest(
        $language = null,
        string $contentType = self::contentTypes['restItemsPackingUnitsGet'][0]
    ): Request
    {



        $resourcePath = '/rest/items/packing_units';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $language,
            'language', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsPackingUnitsIdGet
     *
     * Get the item variation packing unit for a specific given id
     *
     * @param  int $id The ID of the packing unit (required)
     * @param  string|null $language The language to return the unit name for. If no language is provided, all the languages will be returned (optional)
     * @param  bool|null $is_unit_id A flag to say if the ID provided is the unit ID or not. If true, the unit ID will be taken into account to get the result (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPackingUnitsIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\PackingUnit
     */
    public function restItemsPackingUnitsIdGet(
        int $id,
        ?string $language = null,
        ?bool $is_unit_id = null,
        string $contentType = self::contentTypes['restItemsPackingUnitsIdGet'][0]
    ): \ck\Model\PackingUnit
    {
        list($response) = $this->restItemsPackingUnitsIdGetWithHttpInfo($id, $language, $is_unit_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsPackingUnitsIdGetWithHttpInfo
     *
     * Get the item variation packing unit for a specific given id
     *
     * @param  int $id The ID of the packing unit (required)
     * @param  string|null $language The language to return the unit name for. If no language is provided, all the languages will be returned (optional)
     * @param  bool|null $is_unit_id A flag to say if the ID provided is the unit ID or not. If true, the unit ID will be taken into account to get the result (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPackingUnitsIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\PackingUnit, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsPackingUnitsIdGetWithHttpInfo(
        int $id,
        ?string $language = null,
        ?bool $is_unit_id = null,
        string $contentType = self::contentTypes['restItemsPackingUnitsIdGet'][0]
    ): array
    {
        $request = $this->restItemsPackingUnitsIdGetRequest($id, $language, $is_unit_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\PackingUnit' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\PackingUnit' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\PackingUnit', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\PackingUnit';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\PackingUnit',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsPackingUnitsIdGetAsync
     *
     * Get the item variation packing unit for a specific given id
     *
     * @param  int $id The ID of the packing unit (required)
     * @param  string|null $language The language to return the unit name for. If no language is provided, all the languages will be returned (optional)
     * @param  bool|null $is_unit_id A flag to say if the ID provided is the unit ID or not. If true, the unit ID will be taken into account to get the result (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPackingUnitsIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPackingUnitsIdGetAsync(
        int $id,
        ?string $language = null,
        ?bool $is_unit_id = null,
        string $contentType = self::contentTypes['restItemsPackingUnitsIdGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsPackingUnitsIdGetAsyncWithHttpInfo($id, $language, $is_unit_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsPackingUnitsIdGetAsyncWithHttpInfo
     *
     * Get the item variation packing unit for a specific given id
     *
     * @param  int $id The ID of the packing unit (required)
     * @param  string|null $language The language to return the unit name for. If no language is provided, all the languages will be returned (optional)
     * @param  bool|null $is_unit_id A flag to say if the ID provided is the unit ID or not. If true, the unit ID will be taken into account to get the result (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPackingUnitsIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPackingUnitsIdGetAsyncWithHttpInfo(
        $id,
        $language = null,
        $is_unit_id = null,
        string $contentType = self::contentTypes['restItemsPackingUnitsIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\PackingUnit';
        $request = $this->restItemsPackingUnitsIdGetRequest($id, $language, $is_unit_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsPackingUnitsIdGet'
     *
     * @param  int $id The ID of the packing unit (required)
     * @param  string|null $language The language to return the unit name for. If no language is provided, all the languages will be returned (optional)
     * @param  bool|null $is_unit_id A flag to say if the ID provided is the unit ID or not. If true, the unit ID will be taken into account to get the result (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPackingUnitsIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsPackingUnitsIdGetRequest(
        $id,
        $language = null,
        $is_unit_id = null,
        string $contentType = self::contentTypes['restItemsPackingUnitsIdGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsPackingUnitsIdGet'
            );
        }




        $resourcePath = '/rest/items/packing_units/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $language,
            'language', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_unit_id,
            'isUnitId', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsPost
     *
     * Create new items
     *
     * @param  \ck\Model\RestItemsPostRequest|null $_rest_items _rest_items (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Item
     */
    public function restItemsPost(
        ?\ck\Model\RestItemsPostRequest $_rest_items = null,
        string $contentType = self::contentTypes['restItemsPost'][0]
    ): \ck\Model\Item
    {
        list($response) = $this->restItemsPostWithHttpInfo($_rest_items, $contentType);
        return $response;
    }

    /**
     * Operation restItemsPostWithHttpInfo
     *
     * Create new items
     *
     * @param  \ck\Model\RestItemsPostRequest|null $_rest_items (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Item, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsPostWithHttpInfo(
        ?\ck\Model\RestItemsPostRequest $_rest_items = null,
        string $contentType = self::contentTypes['restItemsPost'][0]
    ): array
    {
        $request = $this->restItemsPostRequest($_rest_items, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Item' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Item' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Item', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Item';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Item',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsPostAsync
     *
     * Create new items
     *
     * @param  \ck\Model\RestItemsPostRequest|null $_rest_items (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPostAsync(
        ?\ck\Model\RestItemsPostRequest $_rest_items = null,
        string $contentType = self::contentTypes['restItemsPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsPostAsyncWithHttpInfo($_rest_items, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsPostAsyncWithHttpInfo
     *
     * Create new items
     *
     * @param  \ck\Model\RestItemsPostRequest|null $_rest_items (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPostAsyncWithHttpInfo(
        $_rest_items = null,
        string $contentType = self::contentTypes['restItemsPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Item';
        $request = $this->restItemsPostRequest($_rest_items, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsPost'
     *
     * @param  \ck\Model\RestItemsPostRequest|null $_rest_items (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsPostRequest(
        $_rest_items = null,
        string $contentType = self::contentTypes['restItemsPost'][0]
    ): Request
    {



        $resourcePath = '/rest/items';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items));
            } else {
                $httpBody = $_rest_items;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsPropertiesGet
     *
     * List properties
     *
     * @param  string|null $with Includes the specified property information in the results. The following parameters are available: &lt;ul&gt;&lt;li&gt;names&lt;/b&gt; &#x3D; The names of the property&lt;/li&gt;&lt;li&gt;group&lt;/b&gt; &#x3D; The property group assigned to the property&lt;/li&gt;&lt;li&gt;marketComponents&lt;/b&gt; &#x3D; Lists the markets where the property is available &lt;/li&gt;&lt;li&gt;selections&lt;/b&gt; &#x3D; Lists the selections of the property&lt;/li&gt;&lt;/ul&gt; More than one parameter should be separated by commas. (optional)
     * @param  string|null $updated_at Filter restricts the list of results to items updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     * @param  string|null $group_id Filter restricts the list of results to items linked to a specified property group (optional)
     * @param  int|null $page Limits the results to a specific page. The page number must be specified. (optional)
     * @param  int|null $items_per_page Limits the number of results listed per page to a specific number. The number of properties to be listed per page must be specified. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestItemsPropertiesGet200Response
     */
    public function restItemsPropertiesGet(
        ?string $with = null,
        ?string $updated_at = null,
        ?string $group_id = null,
        ?int $page = null,
        ?int $items_per_page = null,
        string $contentType = self::contentTypes['restItemsPropertiesGet'][0]
    ): \ck\Model\RestItemsPropertiesGet200Response
    {
        list($response) = $this->restItemsPropertiesGetWithHttpInfo($with, $updated_at, $group_id, $page, $items_per_page, $contentType);
        return $response;
    }

    /**
     * Operation restItemsPropertiesGetWithHttpInfo
     *
     * List properties
     *
     * @param  string|null $with Includes the specified property information in the results. The following parameters are available: &lt;ul&gt;&lt;li&gt;names&lt;/b&gt; &#x3D; The names of the property&lt;/li&gt;&lt;li&gt;group&lt;/b&gt; &#x3D; The property group assigned to the property&lt;/li&gt;&lt;li&gt;marketComponents&lt;/b&gt; &#x3D; Lists the markets where the property is available &lt;/li&gt;&lt;li&gt;selections&lt;/b&gt; &#x3D; Lists the selections of the property&lt;/li&gt;&lt;/ul&gt; More than one parameter should be separated by commas. (optional)
     * @param  string|null $updated_at Filter restricts the list of results to items updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     * @param  string|null $group_id Filter restricts the list of results to items linked to a specified property group (optional)
     * @param  int|null $page Limits the results to a specific page. The page number must be specified. (optional)
     * @param  int|null $items_per_page Limits the number of results listed per page to a specific number. The number of properties to be listed per page must be specified. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestItemsPropertiesGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsPropertiesGetWithHttpInfo(
        ?string $with = null,
        ?string $updated_at = null,
        ?string $group_id = null,
        ?int $page = null,
        ?int $items_per_page = null,
        string $contentType = self::contentTypes['restItemsPropertiesGet'][0]
    ): array
    {
        $request = $this->restItemsPropertiesGetRequest($with, $updated_at, $group_id, $page, $items_per_page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestItemsPropertiesGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestItemsPropertiesGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestItemsPropertiesGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestItemsPropertiesGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestItemsPropertiesGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsPropertiesGetAsync
     *
     * List properties
     *
     * @param  string|null $with Includes the specified property information in the results. The following parameters are available: &lt;ul&gt;&lt;li&gt;names&lt;/b&gt; &#x3D; The names of the property&lt;/li&gt;&lt;li&gt;group&lt;/b&gt; &#x3D; The property group assigned to the property&lt;/li&gt;&lt;li&gt;marketComponents&lt;/b&gt; &#x3D; Lists the markets where the property is available &lt;/li&gt;&lt;li&gt;selections&lt;/b&gt; &#x3D; Lists the selections of the property&lt;/li&gt;&lt;/ul&gt; More than one parameter should be separated by commas. (optional)
     * @param  string|null $updated_at Filter restricts the list of results to items updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     * @param  string|null $group_id Filter restricts the list of results to items linked to a specified property group (optional)
     * @param  int|null $page Limits the results to a specific page. The page number must be specified. (optional)
     * @param  int|null $items_per_page Limits the number of results listed per page to a specific number. The number of properties to be listed per page must be specified. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertiesGetAsync(
        ?string $with = null,
        ?string $updated_at = null,
        ?string $group_id = null,
        ?int $page = null,
        ?int $items_per_page = null,
        string $contentType = self::contentTypes['restItemsPropertiesGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsPropertiesGetAsyncWithHttpInfo($with, $updated_at, $group_id, $page, $items_per_page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsPropertiesGetAsyncWithHttpInfo
     *
     * List properties
     *
     * @param  string|null $with Includes the specified property information in the results. The following parameters are available: &lt;ul&gt;&lt;li&gt;names&lt;/b&gt; &#x3D; The names of the property&lt;/li&gt;&lt;li&gt;group&lt;/b&gt; &#x3D; The property group assigned to the property&lt;/li&gt;&lt;li&gt;marketComponents&lt;/b&gt; &#x3D; Lists the markets where the property is available &lt;/li&gt;&lt;li&gt;selections&lt;/b&gt; &#x3D; Lists the selections of the property&lt;/li&gt;&lt;/ul&gt; More than one parameter should be separated by commas. (optional)
     * @param  string|null $updated_at Filter restricts the list of results to items updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     * @param  string|null $group_id Filter restricts the list of results to items linked to a specified property group (optional)
     * @param  int|null $page Limits the results to a specific page. The page number must be specified. (optional)
     * @param  int|null $items_per_page Limits the number of results listed per page to a specific number. The number of properties to be listed per page must be specified. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertiesGetAsyncWithHttpInfo(
        $with = null,
        $updated_at = null,
        $group_id = null,
        $page = null,
        $items_per_page = null,
        string $contentType = self::contentTypes['restItemsPropertiesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestItemsPropertiesGet200Response';
        $request = $this->restItemsPropertiesGetRequest($with, $updated_at, $group_id, $page, $items_per_page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsPropertiesGet'
     *
     * @param  string|null $with Includes the specified property information in the results. The following parameters are available: &lt;ul&gt;&lt;li&gt;names&lt;/b&gt; &#x3D; The names of the property&lt;/li&gt;&lt;li&gt;group&lt;/b&gt; &#x3D; The property group assigned to the property&lt;/li&gt;&lt;li&gt;marketComponents&lt;/b&gt; &#x3D; Lists the markets where the property is available &lt;/li&gt;&lt;li&gt;selections&lt;/b&gt; &#x3D; Lists the selections of the property&lt;/li&gt;&lt;/ul&gt; More than one parameter should be separated by commas. (optional)
     * @param  string|null $updated_at Filter restricts the list of results to items updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     * @param  string|null $group_id Filter restricts the list of results to items linked to a specified property group (optional)
     * @param  int|null $page Limits the results to a specific page. The page number must be specified. (optional)
     * @param  int|null $items_per_page Limits the number of results listed per page to a specific number. The number of properties to be listed per page must be specified. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsPropertiesGetRequest(
        $with = null,
        $updated_at = null,
        $group_id = null,
        $page = null,
        $items_per_page = null,
        string $contentType = self::contentTypes['restItemsPropertiesGet'][0]
    ): Request
    {







        $resourcePath = '/rest/items/properties';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_at,
            'updatedAt', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group_id,
            'groupId', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $items_per_page,
            'itemsPerPage', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsPropertiesIdDelete
     *
     * Delete a property
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restItemsPropertiesIdDelete(
        int $id,
        string $contentType = self::contentTypes['restItemsPropertiesIdDelete'][0]
    ): void
    {
        $this->restItemsPropertiesIdDeleteWithHttpInfo($id, $contentType);
    }

    /**
     * Operation restItemsPropertiesIdDeleteWithHttpInfo
     *
     * Delete a property
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsPropertiesIdDeleteWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restItemsPropertiesIdDelete'][0]
    ): array
    {
        $request = $this->restItemsPropertiesIdDeleteRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsPropertiesIdDeleteAsync
     *
     * Delete a property
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertiesIdDeleteAsync(
        int $id,
        string $contentType = self::contentTypes['restItemsPropertiesIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemsPropertiesIdDeleteAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsPropertiesIdDeleteAsyncWithHttpInfo
     *
     * Delete a property
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertiesIdDeleteAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restItemsPropertiesIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restItemsPropertiesIdDeleteRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsPropertiesIdDelete'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsPropertiesIdDeleteRequest(
        $id,
        string $contentType = self::contentTypes['restItemsPropertiesIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsPropertiesIdDelete'
            );
        }


        $resourcePath = '/rest/items/properties/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsPropertiesIdGet
     *
     * Get a property
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Property
     */
    public function restItemsPropertiesIdGet(
        int $id,
        string $contentType = self::contentTypes['restItemsPropertiesIdGet'][0]
    ): \ck\Model\Property
    {
        list($response) = $this->restItemsPropertiesIdGetWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsPropertiesIdGetWithHttpInfo
     *
     * Get a property
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Property, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsPropertiesIdGetWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restItemsPropertiesIdGet'][0]
    ): array
    {
        $request = $this->restItemsPropertiesIdGetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Property' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Property' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Property', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Property';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Property',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsPropertiesIdGetAsync
     *
     * Get a property
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertiesIdGetAsync(
        int $id,
        string $contentType = self::contentTypes['restItemsPropertiesIdGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsPropertiesIdGetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsPropertiesIdGetAsyncWithHttpInfo
     *
     * Get a property
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertiesIdGetAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restItemsPropertiesIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Property';
        $request = $this->restItemsPropertiesIdGetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsPropertiesIdGet'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsPropertiesIdGetRequest(
        $id,
        string $contentType = self::contentTypes['restItemsPropertiesIdGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsPropertiesIdGet'
            );
        }


        $resourcePath = '/rest/items/properties/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsPropertiesIdMarketReferencesGet
     *
     * List property market references
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdMarketReferencesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\PropertyMarketReference[]
     */
    public function restItemsPropertiesIdMarketReferencesGet(
        int $id,
        string $contentType = self::contentTypes['restItemsPropertiesIdMarketReferencesGet'][0]
    ): array
    {
        list($response) = $this->restItemsPropertiesIdMarketReferencesGetWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsPropertiesIdMarketReferencesGetWithHttpInfo
     *
     * List property market references
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdMarketReferencesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\PropertyMarketReference[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsPropertiesIdMarketReferencesGetWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restItemsPropertiesIdMarketReferencesGet'][0]
    ): array
    {
        $request = $this->restItemsPropertiesIdMarketReferencesGetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\PropertyMarketReference[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\PropertyMarketReference[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\PropertyMarketReference[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\PropertyMarketReference[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\PropertyMarketReference[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsPropertiesIdMarketReferencesGetAsync
     *
     * List property market references
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdMarketReferencesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertiesIdMarketReferencesGetAsync(
        int $id,
        string $contentType = self::contentTypes['restItemsPropertiesIdMarketReferencesGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsPropertiesIdMarketReferencesGetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsPropertiesIdMarketReferencesGetAsyncWithHttpInfo
     *
     * List property market references
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdMarketReferencesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertiesIdMarketReferencesGetAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restItemsPropertiesIdMarketReferencesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\PropertyMarketReference[]';
        $request = $this->restItemsPropertiesIdMarketReferencesGetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsPropertiesIdMarketReferencesGet'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdMarketReferencesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsPropertiesIdMarketReferencesGetRequest(
        $id,
        string $contentType = self::contentTypes['restItemsPropertiesIdMarketReferencesGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsPropertiesIdMarketReferencesGet'
            );
        }


        $resourcePath = '/rest/items/properties/{id}/market_references';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsPropertiesIdMarketReferencesMarketIdDelete
     *
     * Delete a property market reference
     *
     * @param  int $id id (required)
     * @param  int $market_id market_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdMarketReferencesMarketIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsPropertiesIdMarketReferencesMarketIdDelete(
        int $id,
        int $market_id,
        string $contentType = self::contentTypes['restItemsPropertiesIdMarketReferencesMarketIdDelete'][0]
    ): object
    {
        list($response) = $this->restItemsPropertiesIdMarketReferencesMarketIdDeleteWithHttpInfo($id, $market_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsPropertiesIdMarketReferencesMarketIdDeleteWithHttpInfo
     *
     * Delete a property market reference
     *
     * @param  int $id (required)
     * @param  int $market_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdMarketReferencesMarketIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsPropertiesIdMarketReferencesMarketIdDeleteWithHttpInfo(
        int $id,
        int $market_id,
        string $contentType = self::contentTypes['restItemsPropertiesIdMarketReferencesMarketIdDelete'][0]
    ): array
    {
        $request = $this->restItemsPropertiesIdMarketReferencesMarketIdDeleteRequest($id, $market_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsPropertiesIdMarketReferencesMarketIdDeleteAsync
     *
     * Delete a property market reference
     *
     * @param  int $id (required)
     * @param  int $market_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdMarketReferencesMarketIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertiesIdMarketReferencesMarketIdDeleteAsync(
        int $id,
        int $market_id,
        string $contentType = self::contentTypes['restItemsPropertiesIdMarketReferencesMarketIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemsPropertiesIdMarketReferencesMarketIdDeleteAsyncWithHttpInfo($id, $market_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsPropertiesIdMarketReferencesMarketIdDeleteAsyncWithHttpInfo
     *
     * Delete a property market reference
     *
     * @param  int $id (required)
     * @param  int $market_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdMarketReferencesMarketIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertiesIdMarketReferencesMarketIdDeleteAsyncWithHttpInfo(
        $id,
        $market_id,
        string $contentType = self::contentTypes['restItemsPropertiesIdMarketReferencesMarketIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsPropertiesIdMarketReferencesMarketIdDeleteRequest($id, $market_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsPropertiesIdMarketReferencesMarketIdDelete'
     *
     * @param  int $id (required)
     * @param  int $market_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdMarketReferencesMarketIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsPropertiesIdMarketReferencesMarketIdDeleteRequest(
        $id,
        $market_id,
        string $contentType = self::contentTypes['restItemsPropertiesIdMarketReferencesMarketIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsPropertiesIdMarketReferencesMarketIdDelete'
            );
        }

        // verify the required parameter 'market_id' is set
        if ($market_id === null || (is_array($market_id) && count($market_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $market_id when calling restItemsPropertiesIdMarketReferencesMarketIdDelete'
            );
        }


        $resourcePath = '/rest/items/properties/{id}/market_references/{marketId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($market_id !== null) {
            $resourcePath = str_replace(
                '{' . 'marketId' . '}',
                ObjectSerializer::toPathValue($market_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsPropertiesIdMarketReferencesMarketIdGet
     *
     * Get a property market reference
     *
     * @param  int $id id (required)
     * @param  int $market_id market_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdMarketReferencesMarketIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\PropertyMarketReference
     */
    public function restItemsPropertiesIdMarketReferencesMarketIdGet(
        int $id,
        int $market_id,
        string $contentType = self::contentTypes['restItemsPropertiesIdMarketReferencesMarketIdGet'][0]
    ): \ck\Model\PropertyMarketReference
    {
        list($response) = $this->restItemsPropertiesIdMarketReferencesMarketIdGetWithHttpInfo($id, $market_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsPropertiesIdMarketReferencesMarketIdGetWithHttpInfo
     *
     * Get a property market reference
     *
     * @param  int $id (required)
     * @param  int $market_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdMarketReferencesMarketIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\PropertyMarketReference, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsPropertiesIdMarketReferencesMarketIdGetWithHttpInfo(
        int $id,
        int $market_id,
        string $contentType = self::contentTypes['restItemsPropertiesIdMarketReferencesMarketIdGet'][0]
    ): array
    {
        $request = $this->restItemsPropertiesIdMarketReferencesMarketIdGetRequest($id, $market_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\PropertyMarketReference' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\PropertyMarketReference' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\PropertyMarketReference', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\PropertyMarketReference';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\PropertyMarketReference',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsPropertiesIdMarketReferencesMarketIdGetAsync
     *
     * Get a property market reference
     *
     * @param  int $id (required)
     * @param  int $market_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdMarketReferencesMarketIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertiesIdMarketReferencesMarketIdGetAsync(
        int $id,
        int $market_id,
        string $contentType = self::contentTypes['restItemsPropertiesIdMarketReferencesMarketIdGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsPropertiesIdMarketReferencesMarketIdGetAsyncWithHttpInfo($id, $market_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsPropertiesIdMarketReferencesMarketIdGetAsyncWithHttpInfo
     *
     * Get a property market reference
     *
     * @param  int $id (required)
     * @param  int $market_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdMarketReferencesMarketIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertiesIdMarketReferencesMarketIdGetAsyncWithHttpInfo(
        $id,
        $market_id,
        string $contentType = self::contentTypes['restItemsPropertiesIdMarketReferencesMarketIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\PropertyMarketReference';
        $request = $this->restItemsPropertiesIdMarketReferencesMarketIdGetRequest($id, $market_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsPropertiesIdMarketReferencesMarketIdGet'
     *
     * @param  int $id (required)
     * @param  int $market_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdMarketReferencesMarketIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsPropertiesIdMarketReferencesMarketIdGetRequest(
        $id,
        $market_id,
        string $contentType = self::contentTypes['restItemsPropertiesIdMarketReferencesMarketIdGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsPropertiesIdMarketReferencesMarketIdGet'
            );
        }

        // verify the required parameter 'market_id' is set
        if ($market_id === null || (is_array($market_id) && count($market_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $market_id when calling restItemsPropertiesIdMarketReferencesMarketIdGet'
            );
        }


        $resourcePath = '/rest/items/properties/{id}/market_references/{marketId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($market_id !== null) {
            $resourcePath = str_replace(
                '{' . 'marketId' . '}',
                ObjectSerializer::toPathValue($market_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsPropertiesIdMarketReferencesMarketIdPut
     *
     * Update a property market reference
     *
     * @param  int $id id (required)
     * @param  int $market_id market_id (required)
     * @param  \ck\Model\RestItemsPropertiesIdMarketReferencesPostRequest|null $_rest_items_properties_id_market_references_market_id _rest_items_properties_id_market_references_market_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdMarketReferencesMarketIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\PropertyMarketReference
     */
    public function restItemsPropertiesIdMarketReferencesMarketIdPut(
        int $id,
        int $market_id,
        ?\ck\Model\RestItemsPropertiesIdMarketReferencesPostRequest $_rest_items_properties_id_market_references_market_id = null,
        string $contentType = self::contentTypes['restItemsPropertiesIdMarketReferencesMarketIdPut'][0]
    ): \ck\Model\PropertyMarketReference
    {
        list($response) = $this->restItemsPropertiesIdMarketReferencesMarketIdPutWithHttpInfo($id, $market_id, $_rest_items_properties_id_market_references_market_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsPropertiesIdMarketReferencesMarketIdPutWithHttpInfo
     *
     * Update a property market reference
     *
     * @param  int $id (required)
     * @param  int $market_id (required)
     * @param  \ck\Model\RestItemsPropertiesIdMarketReferencesPostRequest|null $_rest_items_properties_id_market_references_market_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdMarketReferencesMarketIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\PropertyMarketReference, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsPropertiesIdMarketReferencesMarketIdPutWithHttpInfo(
        int $id,
        int $market_id,
        ?\ck\Model\RestItemsPropertiesIdMarketReferencesPostRequest $_rest_items_properties_id_market_references_market_id = null,
        string $contentType = self::contentTypes['restItemsPropertiesIdMarketReferencesMarketIdPut'][0]
    ): array
    {
        $request = $this->restItemsPropertiesIdMarketReferencesMarketIdPutRequest($id, $market_id, $_rest_items_properties_id_market_references_market_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\PropertyMarketReference' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\PropertyMarketReference' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\PropertyMarketReference', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\PropertyMarketReference';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\PropertyMarketReference',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsPropertiesIdMarketReferencesMarketIdPutAsync
     *
     * Update a property market reference
     *
     * @param  int $id (required)
     * @param  int $market_id (required)
     * @param  \ck\Model\RestItemsPropertiesIdMarketReferencesPostRequest|null $_rest_items_properties_id_market_references_market_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdMarketReferencesMarketIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertiesIdMarketReferencesMarketIdPutAsync(
        int $id,
        int $market_id,
        ?\ck\Model\RestItemsPropertiesIdMarketReferencesPostRequest $_rest_items_properties_id_market_references_market_id = null,
        string $contentType = self::contentTypes['restItemsPropertiesIdMarketReferencesMarketIdPut'][0]
    ): PromiseInterface
    {
        return $this->restItemsPropertiesIdMarketReferencesMarketIdPutAsyncWithHttpInfo($id, $market_id, $_rest_items_properties_id_market_references_market_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsPropertiesIdMarketReferencesMarketIdPutAsyncWithHttpInfo
     *
     * Update a property market reference
     *
     * @param  int $id (required)
     * @param  int $market_id (required)
     * @param  \ck\Model\RestItemsPropertiesIdMarketReferencesPostRequest|null $_rest_items_properties_id_market_references_market_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdMarketReferencesMarketIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertiesIdMarketReferencesMarketIdPutAsyncWithHttpInfo(
        $id,
        $market_id,
        $_rest_items_properties_id_market_references_market_id = null,
        string $contentType = self::contentTypes['restItemsPropertiesIdMarketReferencesMarketIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\PropertyMarketReference';
        $request = $this->restItemsPropertiesIdMarketReferencesMarketIdPutRequest($id, $market_id, $_rest_items_properties_id_market_references_market_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsPropertiesIdMarketReferencesMarketIdPut'
     *
     * @param  int $id (required)
     * @param  int $market_id (required)
     * @param  \ck\Model\RestItemsPropertiesIdMarketReferencesPostRequest|null $_rest_items_properties_id_market_references_market_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdMarketReferencesMarketIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsPropertiesIdMarketReferencesMarketIdPutRequest(
        $id,
        $market_id,
        $_rest_items_properties_id_market_references_market_id = null,
        string $contentType = self::contentTypes['restItemsPropertiesIdMarketReferencesMarketIdPut'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsPropertiesIdMarketReferencesMarketIdPut'
            );
        }

        // verify the required parameter 'market_id' is set
        if ($market_id === null || (is_array($market_id) && count($market_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $market_id when calling restItemsPropertiesIdMarketReferencesMarketIdPut'
            );
        }



        $resourcePath = '/rest/items/properties/{id}/market_references/{marketId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($market_id !== null) {
            $resourcePath = str_replace(
                '{' . 'marketId' . '}',
                ObjectSerializer::toPathValue($market_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_properties_id_market_references_market_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_properties_id_market_references_market_id));
            } else {
                $httpBody = $_rest_items_properties_id_market_references_market_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsPropertiesIdMarketReferencesPost
     *
     * Create a property market reference
     *
     * @param  int $id id (required)
     * @param  \ck\Model\RestItemsPropertiesIdMarketReferencesPostRequest|null $_rest_items_properties_id_market_references _rest_items_properties_id_market_references (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdMarketReferencesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\PropertyMarketReference
     */
    public function restItemsPropertiesIdMarketReferencesPost(
        int $id,
        ?\ck\Model\RestItemsPropertiesIdMarketReferencesPostRequest $_rest_items_properties_id_market_references = null,
        string $contentType = self::contentTypes['restItemsPropertiesIdMarketReferencesPost'][0]
    ): \ck\Model\PropertyMarketReference
    {
        list($response) = $this->restItemsPropertiesIdMarketReferencesPostWithHttpInfo($id, $_rest_items_properties_id_market_references, $contentType);
        return $response;
    }

    /**
     * Operation restItemsPropertiesIdMarketReferencesPostWithHttpInfo
     *
     * Create a property market reference
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsPropertiesIdMarketReferencesPostRequest|null $_rest_items_properties_id_market_references (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdMarketReferencesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\PropertyMarketReference, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsPropertiesIdMarketReferencesPostWithHttpInfo(
        int $id,
        ?\ck\Model\RestItemsPropertiesIdMarketReferencesPostRequest $_rest_items_properties_id_market_references = null,
        string $contentType = self::contentTypes['restItemsPropertiesIdMarketReferencesPost'][0]
    ): array
    {
        $request = $this->restItemsPropertiesIdMarketReferencesPostRequest($id, $_rest_items_properties_id_market_references, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\PropertyMarketReference' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\PropertyMarketReference' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\PropertyMarketReference', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\PropertyMarketReference';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\PropertyMarketReference',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsPropertiesIdMarketReferencesPostAsync
     *
     * Create a property market reference
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsPropertiesIdMarketReferencesPostRequest|null $_rest_items_properties_id_market_references (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdMarketReferencesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertiesIdMarketReferencesPostAsync(
        int $id,
        ?\ck\Model\RestItemsPropertiesIdMarketReferencesPostRequest $_rest_items_properties_id_market_references = null,
        string $contentType = self::contentTypes['restItemsPropertiesIdMarketReferencesPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsPropertiesIdMarketReferencesPostAsyncWithHttpInfo($id, $_rest_items_properties_id_market_references, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsPropertiesIdMarketReferencesPostAsyncWithHttpInfo
     *
     * Create a property market reference
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsPropertiesIdMarketReferencesPostRequest|null $_rest_items_properties_id_market_references (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdMarketReferencesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertiesIdMarketReferencesPostAsyncWithHttpInfo(
        $id,
        $_rest_items_properties_id_market_references = null,
        string $contentType = self::contentTypes['restItemsPropertiesIdMarketReferencesPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\PropertyMarketReference';
        $request = $this->restItemsPropertiesIdMarketReferencesPostRequest($id, $_rest_items_properties_id_market_references, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsPropertiesIdMarketReferencesPost'
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsPropertiesIdMarketReferencesPostRequest|null $_rest_items_properties_id_market_references (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdMarketReferencesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsPropertiesIdMarketReferencesPostRequest(
        $id,
        $_rest_items_properties_id_market_references = null,
        string $contentType = self::contentTypes['restItemsPropertiesIdMarketReferencesPost'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsPropertiesIdMarketReferencesPost'
            );
        }



        $resourcePath = '/rest/items/properties/{id}/market_references';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_properties_id_market_references)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_properties_id_market_references));
            } else {
                $httpBody = $_rest_items_properties_id_market_references;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsPropertiesIdNamesGet
     *
     * List the property names
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdNamesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\PropertyName[]
     */
    public function restItemsPropertiesIdNamesGet(
        int $id,
        string $contentType = self::contentTypes['restItemsPropertiesIdNamesGet'][0]
    ): array
    {
        list($response) = $this->restItemsPropertiesIdNamesGetWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsPropertiesIdNamesGetWithHttpInfo
     *
     * List the property names
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdNamesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\PropertyName[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsPropertiesIdNamesGetWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restItemsPropertiesIdNamesGet'][0]
    ): array
    {
        $request = $this->restItemsPropertiesIdNamesGetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\PropertyName[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\PropertyName[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\PropertyName[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\PropertyName[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\PropertyName[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsPropertiesIdNamesGetAsync
     *
     * List the property names
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdNamesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertiesIdNamesGetAsync(
        int $id,
        string $contentType = self::contentTypes['restItemsPropertiesIdNamesGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsPropertiesIdNamesGetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsPropertiesIdNamesGetAsyncWithHttpInfo
     *
     * List the property names
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdNamesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertiesIdNamesGetAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restItemsPropertiesIdNamesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\PropertyName[]';
        $request = $this->restItemsPropertiesIdNamesGetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsPropertiesIdNamesGet'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdNamesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsPropertiesIdNamesGetRequest(
        $id,
        string $contentType = self::contentTypes['restItemsPropertiesIdNamesGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsPropertiesIdNamesGet'
            );
        }


        $resourcePath = '/rest/items/properties/{id}/names';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsPropertiesIdNamesLangDelete
     *
     * Delete a property name
     *
     * @param  int $id id (required)
     * @param  int $lang lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdNamesLangDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restItemsPropertiesIdNamesLangDelete(
        int $id,
        int $lang,
        string $contentType = self::contentTypes['restItemsPropertiesIdNamesLangDelete'][0]
    ): void
    {
        $this->restItemsPropertiesIdNamesLangDeleteWithHttpInfo($id, $lang, $contentType);
    }

    /**
     * Operation restItemsPropertiesIdNamesLangDeleteWithHttpInfo
     *
     * Delete a property name
     *
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdNamesLangDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsPropertiesIdNamesLangDeleteWithHttpInfo(
        int $id,
        int $lang,
        string $contentType = self::contentTypes['restItemsPropertiesIdNamesLangDelete'][0]
    ): array
    {
        $request = $this->restItemsPropertiesIdNamesLangDeleteRequest($id, $lang, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsPropertiesIdNamesLangDeleteAsync
     *
     * Delete a property name
     *
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdNamesLangDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertiesIdNamesLangDeleteAsync(
        int $id,
        int $lang,
        string $contentType = self::contentTypes['restItemsPropertiesIdNamesLangDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemsPropertiesIdNamesLangDeleteAsyncWithHttpInfo($id, $lang, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsPropertiesIdNamesLangDeleteAsyncWithHttpInfo
     *
     * Delete a property name
     *
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdNamesLangDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertiesIdNamesLangDeleteAsyncWithHttpInfo(
        $id,
        $lang,
        string $contentType = self::contentTypes['restItemsPropertiesIdNamesLangDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restItemsPropertiesIdNamesLangDeleteRequest($id, $lang, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsPropertiesIdNamesLangDelete'
     *
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdNamesLangDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsPropertiesIdNamesLangDeleteRequest(
        $id,
        $lang,
        string $contentType = self::contentTypes['restItemsPropertiesIdNamesLangDelete'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsPropertiesIdNamesLangDelete'
            );
        }

        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $lang when calling restItemsPropertiesIdNamesLangDelete'
            );
        }


        $resourcePath = '/rest/items/properties/{id}/names/{lang}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($lang !== null) {
            $resourcePath = str_replace(
                '{' . 'lang' . '}',
                ObjectSerializer::toPathValue($lang),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsPropertiesIdNamesLangGet
     *
     * Get a property name
     *
     * @param  int $id id (required)
     * @param  int $lang lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdNamesLangGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\PropertyName
     */
    public function restItemsPropertiesIdNamesLangGet(
        int $id,
        int $lang,
        string $contentType = self::contentTypes['restItemsPropertiesIdNamesLangGet'][0]
    ): \ck\Model\PropertyName
    {
        list($response) = $this->restItemsPropertiesIdNamesLangGetWithHttpInfo($id, $lang, $contentType);
        return $response;
    }

    /**
     * Operation restItemsPropertiesIdNamesLangGetWithHttpInfo
     *
     * Get a property name
     *
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdNamesLangGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\PropertyName, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsPropertiesIdNamesLangGetWithHttpInfo(
        int $id,
        int $lang,
        string $contentType = self::contentTypes['restItemsPropertiesIdNamesLangGet'][0]
    ): array
    {
        $request = $this->restItemsPropertiesIdNamesLangGetRequest($id, $lang, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\PropertyName' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\PropertyName' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\PropertyName', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\PropertyName';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\PropertyName',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsPropertiesIdNamesLangGetAsync
     *
     * Get a property name
     *
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdNamesLangGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertiesIdNamesLangGetAsync(
        int $id,
        int $lang,
        string $contentType = self::contentTypes['restItemsPropertiesIdNamesLangGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsPropertiesIdNamesLangGetAsyncWithHttpInfo($id, $lang, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsPropertiesIdNamesLangGetAsyncWithHttpInfo
     *
     * Get a property name
     *
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdNamesLangGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertiesIdNamesLangGetAsyncWithHttpInfo(
        $id,
        $lang,
        string $contentType = self::contentTypes['restItemsPropertiesIdNamesLangGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\PropertyName';
        $request = $this->restItemsPropertiesIdNamesLangGetRequest($id, $lang, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsPropertiesIdNamesLangGet'
     *
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdNamesLangGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsPropertiesIdNamesLangGetRequest(
        $id,
        $lang,
        string $contentType = self::contentTypes['restItemsPropertiesIdNamesLangGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsPropertiesIdNamesLangGet'
            );
        }

        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $lang when calling restItemsPropertiesIdNamesLangGet'
            );
        }


        $resourcePath = '/rest/items/properties/{id}/names/{lang}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($lang !== null) {
            $resourcePath = str_replace(
                '{' . 'lang' . '}',
                ObjectSerializer::toPathValue($lang),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsPropertiesIdNamesLangPut
     *
     * Update a property name
     *
     * @param  int $id id (required)
     * @param  int $lang lang (required)
     * @param  \ck\Model\RestItemsPropertiesIdNamesPostRequest|null $_rest_items_properties_id_names_lang _rest_items_properties_id_names_lang (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdNamesLangPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\PropertyName
     */
    public function restItemsPropertiesIdNamesLangPut(
        int $id,
        int $lang,
        ?\ck\Model\RestItemsPropertiesIdNamesPostRequest $_rest_items_properties_id_names_lang = null,
        string $contentType = self::contentTypes['restItemsPropertiesIdNamesLangPut'][0]
    ): \ck\Model\PropertyName
    {
        list($response) = $this->restItemsPropertiesIdNamesLangPutWithHttpInfo($id, $lang, $_rest_items_properties_id_names_lang, $contentType);
        return $response;
    }

    /**
     * Operation restItemsPropertiesIdNamesLangPutWithHttpInfo
     *
     * Update a property name
     *
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  \ck\Model\RestItemsPropertiesIdNamesPostRequest|null $_rest_items_properties_id_names_lang (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdNamesLangPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\PropertyName, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsPropertiesIdNamesLangPutWithHttpInfo(
        int $id,
        int $lang,
        ?\ck\Model\RestItemsPropertiesIdNamesPostRequest $_rest_items_properties_id_names_lang = null,
        string $contentType = self::contentTypes['restItemsPropertiesIdNamesLangPut'][0]
    ): array
    {
        $request = $this->restItemsPropertiesIdNamesLangPutRequest($id, $lang, $_rest_items_properties_id_names_lang, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\PropertyName' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\PropertyName' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\PropertyName', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\PropertyName';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\PropertyName',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsPropertiesIdNamesLangPutAsync
     *
     * Update a property name
     *
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  \ck\Model\RestItemsPropertiesIdNamesPostRequest|null $_rest_items_properties_id_names_lang (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdNamesLangPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertiesIdNamesLangPutAsync(
        int $id,
        int $lang,
        ?\ck\Model\RestItemsPropertiesIdNamesPostRequest $_rest_items_properties_id_names_lang = null,
        string $contentType = self::contentTypes['restItemsPropertiesIdNamesLangPut'][0]
    ): PromiseInterface
    {
        return $this->restItemsPropertiesIdNamesLangPutAsyncWithHttpInfo($id, $lang, $_rest_items_properties_id_names_lang, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsPropertiesIdNamesLangPutAsyncWithHttpInfo
     *
     * Update a property name
     *
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  \ck\Model\RestItemsPropertiesIdNamesPostRequest|null $_rest_items_properties_id_names_lang (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdNamesLangPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertiesIdNamesLangPutAsyncWithHttpInfo(
        $id,
        $lang,
        $_rest_items_properties_id_names_lang = null,
        string $contentType = self::contentTypes['restItemsPropertiesIdNamesLangPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\PropertyName';
        $request = $this->restItemsPropertiesIdNamesLangPutRequest($id, $lang, $_rest_items_properties_id_names_lang, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsPropertiesIdNamesLangPut'
     *
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  \ck\Model\RestItemsPropertiesIdNamesPostRequest|null $_rest_items_properties_id_names_lang (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdNamesLangPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsPropertiesIdNamesLangPutRequest(
        $id,
        $lang,
        $_rest_items_properties_id_names_lang = null,
        string $contentType = self::contentTypes['restItemsPropertiesIdNamesLangPut'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsPropertiesIdNamesLangPut'
            );
        }

        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $lang when calling restItemsPropertiesIdNamesLangPut'
            );
        }



        $resourcePath = '/rest/items/properties/{id}/names/{lang}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($lang !== null) {
            $resourcePath = str_replace(
                '{' . 'lang' . '}',
                ObjectSerializer::toPathValue($lang),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_properties_id_names_lang)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_properties_id_names_lang));
            } else {
                $httpBody = $_rest_items_properties_id_names_lang;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsPropertiesIdNamesPost
     *
     * Create a property name
     *
     * @param  int $id id (required)
     * @param  \ck\Model\RestItemsPropertiesIdNamesPostRequest|null $_rest_items_properties_id_names _rest_items_properties_id_names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdNamesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\PropertyName
     */
    public function restItemsPropertiesIdNamesPost(
        int $id,
        ?\ck\Model\RestItemsPropertiesIdNamesPostRequest $_rest_items_properties_id_names = null,
        string $contentType = self::contentTypes['restItemsPropertiesIdNamesPost'][0]
    ): \ck\Model\PropertyName
    {
        list($response) = $this->restItemsPropertiesIdNamesPostWithHttpInfo($id, $_rest_items_properties_id_names, $contentType);
        return $response;
    }

    /**
     * Operation restItemsPropertiesIdNamesPostWithHttpInfo
     *
     * Create a property name
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsPropertiesIdNamesPostRequest|null $_rest_items_properties_id_names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdNamesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\PropertyName, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsPropertiesIdNamesPostWithHttpInfo(
        int $id,
        ?\ck\Model\RestItemsPropertiesIdNamesPostRequest $_rest_items_properties_id_names = null,
        string $contentType = self::contentTypes['restItemsPropertiesIdNamesPost'][0]
    ): array
    {
        $request = $this->restItemsPropertiesIdNamesPostRequest($id, $_rest_items_properties_id_names, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\PropertyName' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\PropertyName' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\PropertyName', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\PropertyName';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\PropertyName',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsPropertiesIdNamesPostAsync
     *
     * Create a property name
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsPropertiesIdNamesPostRequest|null $_rest_items_properties_id_names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdNamesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertiesIdNamesPostAsync(
        int $id,
        ?\ck\Model\RestItemsPropertiesIdNamesPostRequest $_rest_items_properties_id_names = null,
        string $contentType = self::contentTypes['restItemsPropertiesIdNamesPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsPropertiesIdNamesPostAsyncWithHttpInfo($id, $_rest_items_properties_id_names, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsPropertiesIdNamesPostAsyncWithHttpInfo
     *
     * Create a property name
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsPropertiesIdNamesPostRequest|null $_rest_items_properties_id_names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdNamesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertiesIdNamesPostAsyncWithHttpInfo(
        $id,
        $_rest_items_properties_id_names = null,
        string $contentType = self::contentTypes['restItemsPropertiesIdNamesPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\PropertyName';
        $request = $this->restItemsPropertiesIdNamesPostRequest($id, $_rest_items_properties_id_names, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsPropertiesIdNamesPost'
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsPropertiesIdNamesPostRequest|null $_rest_items_properties_id_names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdNamesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsPropertiesIdNamesPostRequest(
        $id,
        $_rest_items_properties_id_names = null,
        string $contentType = self::contentTypes['restItemsPropertiesIdNamesPost'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsPropertiesIdNamesPost'
            );
        }



        $resourcePath = '/rest/items/properties/{id}/names';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_properties_id_names)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_properties_id_names));
            } else {
                $httpBody = $_rest_items_properties_id_names;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsPropertiesIdPut
     *
     * Update a property
     *
     * @param  int $id id (required)
     * @param  \ck\Model\RestItemsPropertiesPostRequest|null $_rest_items_properties_id _rest_items_properties_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Property
     */
    public function restItemsPropertiesIdPut(
        int $id,
        ?\ck\Model\RestItemsPropertiesPostRequest $_rest_items_properties_id = null,
        string $contentType = self::contentTypes['restItemsPropertiesIdPut'][0]
    ): \ck\Model\Property
    {
        list($response) = $this->restItemsPropertiesIdPutWithHttpInfo($id, $_rest_items_properties_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsPropertiesIdPutWithHttpInfo
     *
     * Update a property
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsPropertiesPostRequest|null $_rest_items_properties_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Property, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsPropertiesIdPutWithHttpInfo(
        int $id,
        ?\ck\Model\RestItemsPropertiesPostRequest $_rest_items_properties_id = null,
        string $contentType = self::contentTypes['restItemsPropertiesIdPut'][0]
    ): array
    {
        $request = $this->restItemsPropertiesIdPutRequest($id, $_rest_items_properties_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Property' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Property' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Property', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Property';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Property',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsPropertiesIdPutAsync
     *
     * Update a property
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsPropertiesPostRequest|null $_rest_items_properties_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertiesIdPutAsync(
        int $id,
        ?\ck\Model\RestItemsPropertiesPostRequest $_rest_items_properties_id = null,
        string $contentType = self::contentTypes['restItemsPropertiesIdPut'][0]
    ): PromiseInterface
    {
        return $this->restItemsPropertiesIdPutAsyncWithHttpInfo($id, $_rest_items_properties_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsPropertiesIdPutAsyncWithHttpInfo
     *
     * Update a property
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsPropertiesPostRequest|null $_rest_items_properties_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertiesIdPutAsyncWithHttpInfo(
        $id,
        $_rest_items_properties_id = null,
        string $contentType = self::contentTypes['restItemsPropertiesIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Property';
        $request = $this->restItemsPropertiesIdPutRequest($id, $_rest_items_properties_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsPropertiesIdPut'
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsPropertiesPostRequest|null $_rest_items_properties_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsPropertiesIdPutRequest(
        $id,
        $_rest_items_properties_id = null,
        string $contentType = self::contentTypes['restItemsPropertiesIdPut'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsPropertiesIdPut'
            );
        }



        $resourcePath = '/rest/items/properties/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_properties_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_properties_id));
            } else {
                $httpBody = $_rest_items_properties_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsPropertiesPost
     *
     * Create a property
     *
     * @param  \ck\Model\RestItemsPropertiesPostRequest|null $_rest_items_properties _rest_items_properties (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Property
     */
    public function restItemsPropertiesPost(
        ?\ck\Model\RestItemsPropertiesPostRequest $_rest_items_properties = null,
        string $contentType = self::contentTypes['restItemsPropertiesPost'][0]
    ): \ck\Model\Property
    {
        list($response) = $this->restItemsPropertiesPostWithHttpInfo($_rest_items_properties, $contentType);
        return $response;
    }

    /**
     * Operation restItemsPropertiesPostWithHttpInfo
     *
     * Create a property
     *
     * @param  \ck\Model\RestItemsPropertiesPostRequest|null $_rest_items_properties (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Property, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsPropertiesPostWithHttpInfo(
        ?\ck\Model\RestItemsPropertiesPostRequest $_rest_items_properties = null,
        string $contentType = self::contentTypes['restItemsPropertiesPost'][0]
    ): array
    {
        $request = $this->restItemsPropertiesPostRequest($_rest_items_properties, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Property' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Property' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Property', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Property';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Property',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsPropertiesPostAsync
     *
     * Create a property
     *
     * @param  \ck\Model\RestItemsPropertiesPostRequest|null $_rest_items_properties (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertiesPostAsync(
        ?\ck\Model\RestItemsPropertiesPostRequest $_rest_items_properties = null,
        string $contentType = self::contentTypes['restItemsPropertiesPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsPropertiesPostAsyncWithHttpInfo($_rest_items_properties, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsPropertiesPostAsyncWithHttpInfo
     *
     * Create a property
     *
     * @param  \ck\Model\RestItemsPropertiesPostRequest|null $_rest_items_properties (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertiesPostAsyncWithHttpInfo(
        $_rest_items_properties = null,
        string $contentType = self::contentTypes['restItemsPropertiesPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Property';
        $request = $this->restItemsPropertiesPostRequest($_rest_items_properties, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsPropertiesPost'
     *
     * @param  \ck\Model\RestItemsPropertiesPostRequest|null $_rest_items_properties (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsPropertiesPostRequest(
        $_rest_items_properties = null,
        string $contentType = self::contentTypes['restItemsPropertiesPost'][0]
    ): Request
    {



        $resourcePath = '/rest/items/properties';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_properties)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_properties));
            } else {
                $httpBody = $_rest_items_properties;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsPropertiesPropertyIdSelectionsGet
     *
     * List property selections
     *
     * @param  int $property_id property_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesPropertyIdSelectionsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\PropertySelection[]
     */
    public function restItemsPropertiesPropertyIdSelectionsGet(
        int $property_id,
        string $contentType = self::contentTypes['restItemsPropertiesPropertyIdSelectionsGet'][0]
    ): array
    {
        list($response) = $this->restItemsPropertiesPropertyIdSelectionsGetWithHttpInfo($property_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsPropertiesPropertyIdSelectionsGetWithHttpInfo
     *
     * List property selections
     *
     * @param  int $property_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesPropertyIdSelectionsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\PropertySelection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsPropertiesPropertyIdSelectionsGetWithHttpInfo(
        int $property_id,
        string $contentType = self::contentTypes['restItemsPropertiesPropertyIdSelectionsGet'][0]
    ): array
    {
        $request = $this->restItemsPropertiesPropertyIdSelectionsGetRequest($property_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\PropertySelection[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\PropertySelection[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\PropertySelection[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\PropertySelection[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\PropertySelection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsPropertiesPropertyIdSelectionsGetAsync
     *
     * List property selections
     *
     * @param  int $property_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesPropertyIdSelectionsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertiesPropertyIdSelectionsGetAsync(
        int $property_id,
        string $contentType = self::contentTypes['restItemsPropertiesPropertyIdSelectionsGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsPropertiesPropertyIdSelectionsGetAsyncWithHttpInfo($property_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsPropertiesPropertyIdSelectionsGetAsyncWithHttpInfo
     *
     * List property selections
     *
     * @param  int $property_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesPropertyIdSelectionsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertiesPropertyIdSelectionsGetAsyncWithHttpInfo(
        $property_id,
        string $contentType = self::contentTypes['restItemsPropertiesPropertyIdSelectionsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\PropertySelection[]';
        $request = $this->restItemsPropertiesPropertyIdSelectionsGetRequest($property_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsPropertiesPropertyIdSelectionsGet'
     *
     * @param  int $property_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesPropertyIdSelectionsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsPropertiesPropertyIdSelectionsGetRequest(
        $property_id,
        string $contentType = self::contentTypes['restItemsPropertiesPropertyIdSelectionsGet'][0]
    ): Request
    {

        // verify the required parameter 'property_id' is set
        if ($property_id === null || (is_array($property_id) && count($property_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $property_id when calling restItemsPropertiesPropertyIdSelectionsGet'
            );
        }


        $resourcePath = '/rest/items/properties/{propertyId}/selections';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($property_id !== null) {
            $resourcePath = str_replace(
                '{' . 'propertyId' . '}',
                ObjectSerializer::toPathValue($property_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsPropertiesPropertyIdSelectionsIdDelete
     *
     * Delete a property selection
     *
     * @param  int $property_id property_id (required)
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsPropertiesPropertyIdSelectionsIdDelete(
        int $property_id,
        int $id,
        string $contentType = self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdDelete'][0]
    ): object
    {
        list($response) = $this->restItemsPropertiesPropertyIdSelectionsIdDeleteWithHttpInfo($property_id, $id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsPropertiesPropertyIdSelectionsIdDeleteWithHttpInfo
     *
     * Delete a property selection
     *
     * @param  int $property_id (required)
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsPropertiesPropertyIdSelectionsIdDeleteWithHttpInfo(
        int $property_id,
        int $id,
        string $contentType = self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdDelete'][0]
    ): array
    {
        $request = $this->restItemsPropertiesPropertyIdSelectionsIdDeleteRequest($property_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsPropertiesPropertyIdSelectionsIdDeleteAsync
     *
     * Delete a property selection
     *
     * @param  int $property_id (required)
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertiesPropertyIdSelectionsIdDeleteAsync(
        int $property_id,
        int $id,
        string $contentType = self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemsPropertiesPropertyIdSelectionsIdDeleteAsyncWithHttpInfo($property_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsPropertiesPropertyIdSelectionsIdDeleteAsyncWithHttpInfo
     *
     * Delete a property selection
     *
     * @param  int $property_id (required)
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertiesPropertyIdSelectionsIdDeleteAsyncWithHttpInfo(
        $property_id,
        $id,
        string $contentType = self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsPropertiesPropertyIdSelectionsIdDeleteRequest($property_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsPropertiesPropertyIdSelectionsIdDelete'
     *
     * @param  int $property_id (required)
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsPropertiesPropertyIdSelectionsIdDeleteRequest(
        $property_id,
        $id,
        string $contentType = self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'property_id' is set
        if ($property_id === null || (is_array($property_id) && count($property_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $property_id when calling restItemsPropertiesPropertyIdSelectionsIdDelete'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsPropertiesPropertyIdSelectionsIdDelete'
            );
        }


        $resourcePath = '/rest/items/properties/{propertyId}/selections/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($property_id !== null) {
            $resourcePath = str_replace(
                '{' . 'propertyId' . '}',
                ObjectSerializer::toPathValue($property_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsPropertiesPropertyIdSelectionsIdGet
     *
     * Get a property selection
     *
     * @param  int $property_id property_id (required)
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\PropertySelection[]
     */
    public function restItemsPropertiesPropertyIdSelectionsIdGet(
        int $property_id,
        int $id,
        string $contentType = self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdGet'][0]
    ): array
    {
        list($response) = $this->restItemsPropertiesPropertyIdSelectionsIdGetWithHttpInfo($property_id, $id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsPropertiesPropertyIdSelectionsIdGetWithHttpInfo
     *
     * Get a property selection
     *
     * @param  int $property_id (required)
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\PropertySelection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsPropertiesPropertyIdSelectionsIdGetWithHttpInfo(
        int $property_id,
        int $id,
        string $contentType = self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdGet'][0]
    ): array
    {
        $request = $this->restItemsPropertiesPropertyIdSelectionsIdGetRequest($property_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\PropertySelection[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\PropertySelection[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\PropertySelection[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\PropertySelection[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\PropertySelection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsPropertiesPropertyIdSelectionsIdGetAsync
     *
     * Get a property selection
     *
     * @param  int $property_id (required)
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertiesPropertyIdSelectionsIdGetAsync(
        int $property_id,
        int $id,
        string $contentType = self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsPropertiesPropertyIdSelectionsIdGetAsyncWithHttpInfo($property_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsPropertiesPropertyIdSelectionsIdGetAsyncWithHttpInfo
     *
     * Get a property selection
     *
     * @param  int $property_id (required)
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertiesPropertyIdSelectionsIdGetAsyncWithHttpInfo(
        $property_id,
        $id,
        string $contentType = self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\PropertySelection[]';
        $request = $this->restItemsPropertiesPropertyIdSelectionsIdGetRequest($property_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsPropertiesPropertyIdSelectionsIdGet'
     *
     * @param  int $property_id (required)
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsPropertiesPropertyIdSelectionsIdGetRequest(
        $property_id,
        $id,
        string $contentType = self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdGet'][0]
    ): Request
    {

        // verify the required parameter 'property_id' is set
        if ($property_id === null || (is_array($property_id) && count($property_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $property_id when calling restItemsPropertiesPropertyIdSelectionsIdGet'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsPropertiesPropertyIdSelectionsIdGet'
            );
        }


        $resourcePath = '/rest/items/properties/{propertyId}/selections/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($property_id !== null) {
            $resourcePath = str_replace(
                '{' . 'propertyId' . '}',
                ObjectSerializer::toPathValue($property_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsPropertiesPropertyIdSelectionsIdLangDelete
     *
     * Delete a property selection language
     *
     * @param  int $property_id property_id (required)
     * @param  int $id id (required)
     * @param  int $lang lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdLangDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsPropertiesPropertyIdSelectionsIdLangDelete(
        int $property_id,
        int $id,
        int $lang,
        string $contentType = self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdLangDelete'][0]
    ): object
    {
        list($response) = $this->restItemsPropertiesPropertyIdSelectionsIdLangDeleteWithHttpInfo($property_id, $id, $lang, $contentType);
        return $response;
    }

    /**
     * Operation restItemsPropertiesPropertyIdSelectionsIdLangDeleteWithHttpInfo
     *
     * Delete a property selection language
     *
     * @param  int $property_id (required)
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdLangDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsPropertiesPropertyIdSelectionsIdLangDeleteWithHttpInfo(
        int $property_id,
        int $id,
        int $lang,
        string $contentType = self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdLangDelete'][0]
    ): array
    {
        $request = $this->restItemsPropertiesPropertyIdSelectionsIdLangDeleteRequest($property_id, $id, $lang, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsPropertiesPropertyIdSelectionsIdLangDeleteAsync
     *
     * Delete a property selection language
     *
     * @param  int $property_id (required)
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdLangDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertiesPropertyIdSelectionsIdLangDeleteAsync(
        int $property_id,
        int $id,
        int $lang,
        string $contentType = self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdLangDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemsPropertiesPropertyIdSelectionsIdLangDeleteAsyncWithHttpInfo($property_id, $id, $lang, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsPropertiesPropertyIdSelectionsIdLangDeleteAsyncWithHttpInfo
     *
     * Delete a property selection language
     *
     * @param  int $property_id (required)
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdLangDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertiesPropertyIdSelectionsIdLangDeleteAsyncWithHttpInfo(
        $property_id,
        $id,
        $lang,
        string $contentType = self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdLangDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsPropertiesPropertyIdSelectionsIdLangDeleteRequest($property_id, $id, $lang, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsPropertiesPropertyIdSelectionsIdLangDelete'
     *
     * @param  int $property_id (required)
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdLangDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsPropertiesPropertyIdSelectionsIdLangDeleteRequest(
        $property_id,
        $id,
        $lang,
        string $contentType = self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdLangDelete'][0]
    ): Request
    {

        // verify the required parameter 'property_id' is set
        if ($property_id === null || (is_array($property_id) && count($property_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $property_id when calling restItemsPropertiesPropertyIdSelectionsIdLangDelete'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsPropertiesPropertyIdSelectionsIdLangDelete'
            );
        }

        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $lang when calling restItemsPropertiesPropertyIdSelectionsIdLangDelete'
            );
        }


        $resourcePath = '/rest/items/properties/{propertyId}/selections/{id}/{lang}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($property_id !== null) {
            $resourcePath = str_replace(
                '{' . 'propertyId' . '}',
                ObjectSerializer::toPathValue($property_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($lang !== null) {
            $resourcePath = str_replace(
                '{' . 'lang' . '}',
                ObjectSerializer::toPathValue($lang),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsPropertiesPropertyIdSelectionsIdLangGet
     *
     * List property selections by language
     *
     * @param  int $property_id property_id (required)
     * @param  int $id id (required)
     * @param  int $lang lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdLangGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\PropertySelection
     */
    public function restItemsPropertiesPropertyIdSelectionsIdLangGet(
        int $property_id,
        int $id,
        int $lang,
        string $contentType = self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdLangGet'][0]
    ): \ck\Model\PropertySelection
    {
        list($response) = $this->restItemsPropertiesPropertyIdSelectionsIdLangGetWithHttpInfo($property_id, $id, $lang, $contentType);
        return $response;
    }

    /**
     * Operation restItemsPropertiesPropertyIdSelectionsIdLangGetWithHttpInfo
     *
     * List property selections by language
     *
     * @param  int $property_id (required)
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdLangGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\PropertySelection, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsPropertiesPropertyIdSelectionsIdLangGetWithHttpInfo(
        int $property_id,
        int $id,
        int $lang,
        string $contentType = self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdLangGet'][0]
    ): array
    {
        $request = $this->restItemsPropertiesPropertyIdSelectionsIdLangGetRequest($property_id, $id, $lang, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\PropertySelection' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\PropertySelection' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\PropertySelection', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\PropertySelection';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\PropertySelection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsPropertiesPropertyIdSelectionsIdLangGetAsync
     *
     * List property selections by language
     *
     * @param  int $property_id (required)
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdLangGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertiesPropertyIdSelectionsIdLangGetAsync(
        int $property_id,
        int $id,
        int $lang,
        string $contentType = self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdLangGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsPropertiesPropertyIdSelectionsIdLangGetAsyncWithHttpInfo($property_id, $id, $lang, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsPropertiesPropertyIdSelectionsIdLangGetAsyncWithHttpInfo
     *
     * List property selections by language
     *
     * @param  int $property_id (required)
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdLangGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertiesPropertyIdSelectionsIdLangGetAsyncWithHttpInfo(
        $property_id,
        $id,
        $lang,
        string $contentType = self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdLangGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\PropertySelection';
        $request = $this->restItemsPropertiesPropertyIdSelectionsIdLangGetRequest($property_id, $id, $lang, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsPropertiesPropertyIdSelectionsIdLangGet'
     *
     * @param  int $property_id (required)
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdLangGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsPropertiesPropertyIdSelectionsIdLangGetRequest(
        $property_id,
        $id,
        $lang,
        string $contentType = self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdLangGet'][0]
    ): Request
    {

        // verify the required parameter 'property_id' is set
        if ($property_id === null || (is_array($property_id) && count($property_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $property_id when calling restItemsPropertiesPropertyIdSelectionsIdLangGet'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsPropertiesPropertyIdSelectionsIdLangGet'
            );
        }

        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $lang when calling restItemsPropertiesPropertyIdSelectionsIdLangGet'
            );
        }


        $resourcePath = '/rest/items/properties/{propertyId}/selections/{id}/{lang}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($property_id !== null) {
            $resourcePath = str_replace(
                '{' . 'propertyId' . '}',
                ObjectSerializer::toPathValue($property_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($lang !== null) {
            $resourcePath = str_replace(
                '{' . 'lang' . '}',
                ObjectSerializer::toPathValue($lang),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsPropertiesPropertyIdSelectionsIdLangPut
     *
     * Update a property selection
     *
     * @param  int $property_id property_id (required)
     * @param  int $id id (required)
     * @param  int $lang lang (required)
     * @param  \ck\Model\RestItemsPropertiesPropertyIdSelectionsPostRequest|null $_rest_items_properties_property_id_selections_id_lang _rest_items_properties_property_id_selections_id_lang (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdLangPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\PropertySelection
     */
    public function restItemsPropertiesPropertyIdSelectionsIdLangPut(
        int $property_id,
        int $id,
        int $lang,
        ?\ck\Model\RestItemsPropertiesPropertyIdSelectionsPostRequest $_rest_items_properties_property_id_selections_id_lang = null,
        string $contentType = self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdLangPut'][0]
    ): \ck\Model\PropertySelection
    {
        list($response) = $this->restItemsPropertiesPropertyIdSelectionsIdLangPutWithHttpInfo($property_id, $id, $lang, $_rest_items_properties_property_id_selections_id_lang, $contentType);
        return $response;
    }

    /**
     * Operation restItemsPropertiesPropertyIdSelectionsIdLangPutWithHttpInfo
     *
     * Update a property selection
     *
     * @param  int $property_id (required)
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  \ck\Model\RestItemsPropertiesPropertyIdSelectionsPostRequest|null $_rest_items_properties_property_id_selections_id_lang (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdLangPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\PropertySelection, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsPropertiesPropertyIdSelectionsIdLangPutWithHttpInfo(
        int $property_id,
        int $id,
        int $lang,
        ?\ck\Model\RestItemsPropertiesPropertyIdSelectionsPostRequest $_rest_items_properties_property_id_selections_id_lang = null,
        string $contentType = self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdLangPut'][0]
    ): array
    {
        $request = $this->restItemsPropertiesPropertyIdSelectionsIdLangPutRequest($property_id, $id, $lang, $_rest_items_properties_property_id_selections_id_lang, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\PropertySelection' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\PropertySelection' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\PropertySelection', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\PropertySelection';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\PropertySelection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsPropertiesPropertyIdSelectionsIdLangPutAsync
     *
     * Update a property selection
     *
     * @param  int $property_id (required)
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  \ck\Model\RestItemsPropertiesPropertyIdSelectionsPostRequest|null $_rest_items_properties_property_id_selections_id_lang (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdLangPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertiesPropertyIdSelectionsIdLangPutAsync(
        int $property_id,
        int $id,
        int $lang,
        ?\ck\Model\RestItemsPropertiesPropertyIdSelectionsPostRequest $_rest_items_properties_property_id_selections_id_lang = null,
        string $contentType = self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdLangPut'][0]
    ): PromiseInterface
    {
        return $this->restItemsPropertiesPropertyIdSelectionsIdLangPutAsyncWithHttpInfo($property_id, $id, $lang, $_rest_items_properties_property_id_selections_id_lang, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsPropertiesPropertyIdSelectionsIdLangPutAsyncWithHttpInfo
     *
     * Update a property selection
     *
     * @param  int $property_id (required)
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  \ck\Model\RestItemsPropertiesPropertyIdSelectionsPostRequest|null $_rest_items_properties_property_id_selections_id_lang (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdLangPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertiesPropertyIdSelectionsIdLangPutAsyncWithHttpInfo(
        $property_id,
        $id,
        $lang,
        $_rest_items_properties_property_id_selections_id_lang = null,
        string $contentType = self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdLangPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\PropertySelection';
        $request = $this->restItemsPropertiesPropertyIdSelectionsIdLangPutRequest($property_id, $id, $lang, $_rest_items_properties_property_id_selections_id_lang, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsPropertiesPropertyIdSelectionsIdLangPut'
     *
     * @param  int $property_id (required)
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  \ck\Model\RestItemsPropertiesPropertyIdSelectionsPostRequest|null $_rest_items_properties_property_id_selections_id_lang (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdLangPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsPropertiesPropertyIdSelectionsIdLangPutRequest(
        $property_id,
        $id,
        $lang,
        $_rest_items_properties_property_id_selections_id_lang = null,
        string $contentType = self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdLangPut'][0]
    ): Request
    {

        // verify the required parameter 'property_id' is set
        if ($property_id === null || (is_array($property_id) && count($property_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $property_id when calling restItemsPropertiesPropertyIdSelectionsIdLangPut'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsPropertiesPropertyIdSelectionsIdLangPut'
            );
        }

        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $lang when calling restItemsPropertiesPropertyIdSelectionsIdLangPut'
            );
        }



        $resourcePath = '/rest/items/properties/{propertyId}/selections/{id}/{lang}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($property_id !== null) {
            $resourcePath = str_replace(
                '{' . 'propertyId' . '}',
                ObjectSerializer::toPathValue($property_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($lang !== null) {
            $resourcePath = str_replace(
                '{' . 'lang' . '}',
                ObjectSerializer::toPathValue($lang),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_properties_property_id_selections_id_lang)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_properties_property_id_selections_id_lang));
            } else {
                $httpBody = $_rest_items_properties_property_id_selections_id_lang;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsPropertiesPropertyIdSelectionsIdPost
     *
     * Creates a property selection lang
     *
     * @param  int $property_id property_id (required)
     * @param  int $id id (required)
     * @param  \ck\Model\RestItemsPropertiesPropertyIdSelectionsPostRequest|null $_rest_items_properties_property_id_selections_id _rest_items_properties_property_id_selections_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\PropertySelection
     */
    public function restItemsPropertiesPropertyIdSelectionsIdPost(
        int $property_id,
        int $id,
        ?\ck\Model\RestItemsPropertiesPropertyIdSelectionsPostRequest $_rest_items_properties_property_id_selections_id = null,
        string $contentType = self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdPost'][0]
    ): \ck\Model\PropertySelection
    {
        list($response) = $this->restItemsPropertiesPropertyIdSelectionsIdPostWithHttpInfo($property_id, $id, $_rest_items_properties_property_id_selections_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsPropertiesPropertyIdSelectionsIdPostWithHttpInfo
     *
     * Creates a property selection lang
     *
     * @param  int $property_id (required)
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsPropertiesPropertyIdSelectionsPostRequest|null $_rest_items_properties_property_id_selections_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\PropertySelection, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsPropertiesPropertyIdSelectionsIdPostWithHttpInfo(
        int $property_id,
        int $id,
        ?\ck\Model\RestItemsPropertiesPropertyIdSelectionsPostRequest $_rest_items_properties_property_id_selections_id = null,
        string $contentType = self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdPost'][0]
    ): array
    {
        $request = $this->restItemsPropertiesPropertyIdSelectionsIdPostRequest($property_id, $id, $_rest_items_properties_property_id_selections_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\PropertySelection' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\PropertySelection' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\PropertySelection', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\PropertySelection';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\PropertySelection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsPropertiesPropertyIdSelectionsIdPostAsync
     *
     * Creates a property selection lang
     *
     * @param  int $property_id (required)
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsPropertiesPropertyIdSelectionsPostRequest|null $_rest_items_properties_property_id_selections_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertiesPropertyIdSelectionsIdPostAsync(
        int $property_id,
        int $id,
        ?\ck\Model\RestItemsPropertiesPropertyIdSelectionsPostRequest $_rest_items_properties_property_id_selections_id = null,
        string $contentType = self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsPropertiesPropertyIdSelectionsIdPostAsyncWithHttpInfo($property_id, $id, $_rest_items_properties_property_id_selections_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsPropertiesPropertyIdSelectionsIdPostAsyncWithHttpInfo
     *
     * Creates a property selection lang
     *
     * @param  int $property_id (required)
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsPropertiesPropertyIdSelectionsPostRequest|null $_rest_items_properties_property_id_selections_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertiesPropertyIdSelectionsIdPostAsyncWithHttpInfo(
        $property_id,
        $id,
        $_rest_items_properties_property_id_selections_id = null,
        string $contentType = self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\PropertySelection';
        $request = $this->restItemsPropertiesPropertyIdSelectionsIdPostRequest($property_id, $id, $_rest_items_properties_property_id_selections_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsPropertiesPropertyIdSelectionsIdPost'
     *
     * @param  int $property_id (required)
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsPropertiesPropertyIdSelectionsPostRequest|null $_rest_items_properties_property_id_selections_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsPropertiesPropertyIdSelectionsIdPostRequest(
        $property_id,
        $id,
        $_rest_items_properties_property_id_selections_id = null,
        string $contentType = self::contentTypes['restItemsPropertiesPropertyIdSelectionsIdPost'][0]
    ): Request
    {

        // verify the required parameter 'property_id' is set
        if ($property_id === null || (is_array($property_id) && count($property_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $property_id when calling restItemsPropertiesPropertyIdSelectionsIdPost'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsPropertiesPropertyIdSelectionsIdPost'
            );
        }



        $resourcePath = '/rest/items/properties/{propertyId}/selections/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($property_id !== null) {
            $resourcePath = str_replace(
                '{' . 'propertyId' . '}',
                ObjectSerializer::toPathValue($property_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_properties_property_id_selections_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_properties_property_id_selections_id));
            } else {
                $httpBody = $_rest_items_properties_property_id_selections_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsPropertiesPropertyIdSelectionsLangGet
     *
     * List property selections
     *
     * @param  int $property_id property_id (required)
     * @param  int $lang lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesPropertyIdSelectionsLangGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\PropertySelection[]
     */
    public function restItemsPropertiesPropertyIdSelectionsLangGet(
        int $property_id,
        int $lang,
        string $contentType = self::contentTypes['restItemsPropertiesPropertyIdSelectionsLangGet'][0]
    ): array
    {
        list($response) = $this->restItemsPropertiesPropertyIdSelectionsLangGetWithHttpInfo($property_id, $lang, $contentType);
        return $response;
    }

    /**
     * Operation restItemsPropertiesPropertyIdSelectionsLangGetWithHttpInfo
     *
     * List property selections
     *
     * @param  int $property_id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesPropertyIdSelectionsLangGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\PropertySelection[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsPropertiesPropertyIdSelectionsLangGetWithHttpInfo(
        int $property_id,
        int $lang,
        string $contentType = self::contentTypes['restItemsPropertiesPropertyIdSelectionsLangGet'][0]
    ): array
    {
        $request = $this->restItemsPropertiesPropertyIdSelectionsLangGetRequest($property_id, $lang, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\PropertySelection[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\PropertySelection[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\PropertySelection[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\PropertySelection[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\PropertySelection[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsPropertiesPropertyIdSelectionsLangGetAsync
     *
     * List property selections
     *
     * @param  int $property_id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesPropertyIdSelectionsLangGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertiesPropertyIdSelectionsLangGetAsync(
        int $property_id,
        int $lang,
        string $contentType = self::contentTypes['restItemsPropertiesPropertyIdSelectionsLangGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsPropertiesPropertyIdSelectionsLangGetAsyncWithHttpInfo($property_id, $lang, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsPropertiesPropertyIdSelectionsLangGetAsyncWithHttpInfo
     *
     * List property selections
     *
     * @param  int $property_id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesPropertyIdSelectionsLangGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertiesPropertyIdSelectionsLangGetAsyncWithHttpInfo(
        $property_id,
        $lang,
        string $contentType = self::contentTypes['restItemsPropertiesPropertyIdSelectionsLangGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\PropertySelection[]';
        $request = $this->restItemsPropertiesPropertyIdSelectionsLangGetRequest($property_id, $lang, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsPropertiesPropertyIdSelectionsLangGet'
     *
     * @param  int $property_id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesPropertyIdSelectionsLangGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsPropertiesPropertyIdSelectionsLangGetRequest(
        $property_id,
        $lang,
        string $contentType = self::contentTypes['restItemsPropertiesPropertyIdSelectionsLangGet'][0]
    ): Request
    {

        // verify the required parameter 'property_id' is set
        if ($property_id === null || (is_array($property_id) && count($property_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $property_id when calling restItemsPropertiesPropertyIdSelectionsLangGet'
            );
        }

        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $lang when calling restItemsPropertiesPropertyIdSelectionsLangGet'
            );
        }


        $resourcePath = '/rest/items/properties/{propertyId}/selections/{lang}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($property_id !== null) {
            $resourcePath = str_replace(
                '{' . 'propertyId' . '}',
                ObjectSerializer::toPathValue($property_id),
                $resourcePath
            );
        }
        // path params
        if ($lang !== null) {
            $resourcePath = str_replace(
                '{' . 'lang' . '}',
                ObjectSerializer::toPathValue($lang),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsPropertiesPropertyIdSelectionsPost
     *
     * Create a property selection
     *
     * @param  int $property_id property_id (required)
     * @param  \ck\Model\RestItemsPropertiesPropertyIdSelectionsPostRequest|null $_rest_items_properties_property_id_selections _rest_items_properties_property_id_selections (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesPropertyIdSelectionsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\PropertySelection
     */
    public function restItemsPropertiesPropertyIdSelectionsPost(
        int $property_id,
        ?\ck\Model\RestItemsPropertiesPropertyIdSelectionsPostRequest $_rest_items_properties_property_id_selections = null,
        string $contentType = self::contentTypes['restItemsPropertiesPropertyIdSelectionsPost'][0]
    ): \ck\Model\PropertySelection
    {
        list($response) = $this->restItemsPropertiesPropertyIdSelectionsPostWithHttpInfo($property_id, $_rest_items_properties_property_id_selections, $contentType);
        return $response;
    }

    /**
     * Operation restItemsPropertiesPropertyIdSelectionsPostWithHttpInfo
     *
     * Create a property selection
     *
     * @param  int $property_id (required)
     * @param  \ck\Model\RestItemsPropertiesPropertyIdSelectionsPostRequest|null $_rest_items_properties_property_id_selections (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesPropertyIdSelectionsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\PropertySelection, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsPropertiesPropertyIdSelectionsPostWithHttpInfo(
        int $property_id,
        ?\ck\Model\RestItemsPropertiesPropertyIdSelectionsPostRequest $_rest_items_properties_property_id_selections = null,
        string $contentType = self::contentTypes['restItemsPropertiesPropertyIdSelectionsPost'][0]
    ): array
    {
        $request = $this->restItemsPropertiesPropertyIdSelectionsPostRequest($property_id, $_rest_items_properties_property_id_selections, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\PropertySelection' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\PropertySelection' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\PropertySelection', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\PropertySelection';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\PropertySelection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsPropertiesPropertyIdSelectionsPostAsync
     *
     * Create a property selection
     *
     * @param  int $property_id (required)
     * @param  \ck\Model\RestItemsPropertiesPropertyIdSelectionsPostRequest|null $_rest_items_properties_property_id_selections (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesPropertyIdSelectionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertiesPropertyIdSelectionsPostAsync(
        int $property_id,
        ?\ck\Model\RestItemsPropertiesPropertyIdSelectionsPostRequest $_rest_items_properties_property_id_selections = null,
        string $contentType = self::contentTypes['restItemsPropertiesPropertyIdSelectionsPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsPropertiesPropertyIdSelectionsPostAsyncWithHttpInfo($property_id, $_rest_items_properties_property_id_selections, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsPropertiesPropertyIdSelectionsPostAsyncWithHttpInfo
     *
     * Create a property selection
     *
     * @param  int $property_id (required)
     * @param  \ck\Model\RestItemsPropertiesPropertyIdSelectionsPostRequest|null $_rest_items_properties_property_id_selections (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesPropertyIdSelectionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertiesPropertyIdSelectionsPostAsyncWithHttpInfo(
        $property_id,
        $_rest_items_properties_property_id_selections = null,
        string $contentType = self::contentTypes['restItemsPropertiesPropertyIdSelectionsPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\PropertySelection';
        $request = $this->restItemsPropertiesPropertyIdSelectionsPostRequest($property_id, $_rest_items_properties_property_id_selections, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsPropertiesPropertyIdSelectionsPost'
     *
     * @param  int $property_id (required)
     * @param  \ck\Model\RestItemsPropertiesPropertyIdSelectionsPostRequest|null $_rest_items_properties_property_id_selections (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertiesPropertyIdSelectionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsPropertiesPropertyIdSelectionsPostRequest(
        $property_id,
        $_rest_items_properties_property_id_selections = null,
        string $contentType = self::contentTypes['restItemsPropertiesPropertyIdSelectionsPost'][0]
    ): Request
    {

        // verify the required parameter 'property_id' is set
        if ($property_id === null || (is_array($property_id) && count($property_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $property_id when calling restItemsPropertiesPropertyIdSelectionsPost'
            );
        }



        $resourcePath = '/rest/items/properties/{propertyId}/selections';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($property_id !== null) {
            $resourcePath = str_replace(
                '{' . 'propertyId' . '}',
                ObjectSerializer::toPathValue($property_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_properties_property_id_selections)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_properties_property_id_selections));
            } else {
                $httpBody = $_rest_items_properties_property_id_selections;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsPropertyGroupsGet
     *
     * List property groups
     *
     * @param  string|null $with Includes the specified property group information in the results. The following parameters are available: &lt;ul&gt;&lt;li&gt;names&lt;/b&gt; &#x3D; The names of the property group&lt;/li&gt;&lt;li&gt;properties&lt;/b&gt; &#x3D; The properties that are assigned to the property group&lt;/li&gt;&lt;/ul&gt; More than one parameter should be separated by commas. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertyGroupsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestItemsPropertyGroupsGet200Response
     */
    public function restItemsPropertyGroupsGet(
        ?string $with = null,
        string $contentType = self::contentTypes['restItemsPropertyGroupsGet'][0]
    ): \ck\Model\RestItemsPropertyGroupsGet200Response
    {
        list($response) = $this->restItemsPropertyGroupsGetWithHttpInfo($with, $contentType);
        return $response;
    }

    /**
     * Operation restItemsPropertyGroupsGetWithHttpInfo
     *
     * List property groups
     *
     * @param  string|null $with Includes the specified property group information in the results. The following parameters are available: &lt;ul&gt;&lt;li&gt;names&lt;/b&gt; &#x3D; The names of the property group&lt;/li&gt;&lt;li&gt;properties&lt;/b&gt; &#x3D; The properties that are assigned to the property group&lt;/li&gt;&lt;/ul&gt; More than one parameter should be separated by commas. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertyGroupsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestItemsPropertyGroupsGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsPropertyGroupsGetWithHttpInfo(
        ?string $with = null,
        string $contentType = self::contentTypes['restItemsPropertyGroupsGet'][0]
    ): array
    {
        $request = $this->restItemsPropertyGroupsGetRequest($with, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestItemsPropertyGroupsGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestItemsPropertyGroupsGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestItemsPropertyGroupsGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestItemsPropertyGroupsGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestItemsPropertyGroupsGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsPropertyGroupsGetAsync
     *
     * List property groups
     *
     * @param  string|null $with Includes the specified property group information in the results. The following parameters are available: &lt;ul&gt;&lt;li&gt;names&lt;/b&gt; &#x3D; The names of the property group&lt;/li&gt;&lt;li&gt;properties&lt;/b&gt; &#x3D; The properties that are assigned to the property group&lt;/li&gt;&lt;/ul&gt; More than one parameter should be separated by commas. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertyGroupsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertyGroupsGetAsync(
        ?string $with = null,
        string $contentType = self::contentTypes['restItemsPropertyGroupsGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsPropertyGroupsGetAsyncWithHttpInfo($with, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsPropertyGroupsGetAsyncWithHttpInfo
     *
     * List property groups
     *
     * @param  string|null $with Includes the specified property group information in the results. The following parameters are available: &lt;ul&gt;&lt;li&gt;names&lt;/b&gt; &#x3D; The names of the property group&lt;/li&gt;&lt;li&gt;properties&lt;/b&gt; &#x3D; The properties that are assigned to the property group&lt;/li&gt;&lt;/ul&gt; More than one parameter should be separated by commas. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertyGroupsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertyGroupsGetAsyncWithHttpInfo(
        $with = null,
        string $contentType = self::contentTypes['restItemsPropertyGroupsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestItemsPropertyGroupsGet200Response';
        $request = $this->restItemsPropertyGroupsGetRequest($with, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsPropertyGroupsGet'
     *
     * @param  string|null $with Includes the specified property group information in the results. The following parameters are available: &lt;ul&gt;&lt;li&gt;names&lt;/b&gt; &#x3D; The names of the property group&lt;/li&gt;&lt;li&gt;properties&lt;/b&gt; &#x3D; The properties that are assigned to the property group&lt;/li&gt;&lt;/ul&gt; More than one parameter should be separated by commas. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertyGroupsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsPropertyGroupsGetRequest(
        $with = null,
        string $contentType = self::contentTypes['restItemsPropertyGroupsGet'][0]
    ): Request
    {



        $resourcePath = '/rest/items/property_groups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsPropertyGroupsIdDelete
     *
     * Delete a property group
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertyGroupsIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsPropertyGroupsIdDelete(
        int $id,
        string $contentType = self::contentTypes['restItemsPropertyGroupsIdDelete'][0]
    ): object
    {
        list($response) = $this->restItemsPropertyGroupsIdDeleteWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsPropertyGroupsIdDeleteWithHttpInfo
     *
     * Delete a property group
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertyGroupsIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsPropertyGroupsIdDeleteWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restItemsPropertyGroupsIdDelete'][0]
    ): array
    {
        $request = $this->restItemsPropertyGroupsIdDeleteRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsPropertyGroupsIdDeleteAsync
     *
     * Delete a property group
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertyGroupsIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertyGroupsIdDeleteAsync(
        int $id,
        string $contentType = self::contentTypes['restItemsPropertyGroupsIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemsPropertyGroupsIdDeleteAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsPropertyGroupsIdDeleteAsyncWithHttpInfo
     *
     * Delete a property group
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertyGroupsIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertyGroupsIdDeleteAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restItemsPropertyGroupsIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsPropertyGroupsIdDeleteRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsPropertyGroupsIdDelete'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertyGroupsIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsPropertyGroupsIdDeleteRequest(
        $id,
        string $contentType = self::contentTypes['restItemsPropertyGroupsIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsPropertyGroupsIdDelete'
            );
        }


        $resourcePath = '/rest/items/property_groups/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsPropertyGroupsIdGet
     *
     * Get a property group
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertyGroupsIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\PropertyGroup
     */
    public function restItemsPropertyGroupsIdGet(
        int $id,
        string $contentType = self::contentTypes['restItemsPropertyGroupsIdGet'][0]
    ): \ck\Model\PropertyGroup
    {
        list($response) = $this->restItemsPropertyGroupsIdGetWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsPropertyGroupsIdGetWithHttpInfo
     *
     * Get a property group
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertyGroupsIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\PropertyGroup, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsPropertyGroupsIdGetWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restItemsPropertyGroupsIdGet'][0]
    ): array
    {
        $request = $this->restItemsPropertyGroupsIdGetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\PropertyGroup' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\PropertyGroup' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\PropertyGroup', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\PropertyGroup';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\PropertyGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsPropertyGroupsIdGetAsync
     *
     * Get a property group
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertyGroupsIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertyGroupsIdGetAsync(
        int $id,
        string $contentType = self::contentTypes['restItemsPropertyGroupsIdGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsPropertyGroupsIdGetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsPropertyGroupsIdGetAsyncWithHttpInfo
     *
     * Get a property group
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertyGroupsIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertyGroupsIdGetAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restItemsPropertyGroupsIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\PropertyGroup';
        $request = $this->restItemsPropertyGroupsIdGetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsPropertyGroupsIdGet'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertyGroupsIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsPropertyGroupsIdGetRequest(
        $id,
        string $contentType = self::contentTypes['restItemsPropertyGroupsIdGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsPropertyGroupsIdGet'
            );
        }


        $resourcePath = '/rest/items/property_groups/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsPropertyGroupsIdNamesGet
     *
     * List the property group names of a property group
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertyGroupsIdNamesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\PropertyGroupName[]
     */
    public function restItemsPropertyGroupsIdNamesGet(
        int $id,
        string $contentType = self::contentTypes['restItemsPropertyGroupsIdNamesGet'][0]
    ): array
    {
        list($response) = $this->restItemsPropertyGroupsIdNamesGetWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsPropertyGroupsIdNamesGetWithHttpInfo
     *
     * List the property group names of a property group
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertyGroupsIdNamesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\PropertyGroupName[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsPropertyGroupsIdNamesGetWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restItemsPropertyGroupsIdNamesGet'][0]
    ): array
    {
        $request = $this->restItemsPropertyGroupsIdNamesGetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\PropertyGroupName[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\PropertyGroupName[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\PropertyGroupName[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\PropertyGroupName[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\PropertyGroupName[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsPropertyGroupsIdNamesGetAsync
     *
     * List the property group names of a property group
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertyGroupsIdNamesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertyGroupsIdNamesGetAsync(
        int $id,
        string $contentType = self::contentTypes['restItemsPropertyGroupsIdNamesGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsPropertyGroupsIdNamesGetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsPropertyGroupsIdNamesGetAsyncWithHttpInfo
     *
     * List the property group names of a property group
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertyGroupsIdNamesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertyGroupsIdNamesGetAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restItemsPropertyGroupsIdNamesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\PropertyGroupName[]';
        $request = $this->restItemsPropertyGroupsIdNamesGetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsPropertyGroupsIdNamesGet'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertyGroupsIdNamesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsPropertyGroupsIdNamesGetRequest(
        $id,
        string $contentType = self::contentTypes['restItemsPropertyGroupsIdNamesGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsPropertyGroupsIdNamesGet'
            );
        }


        $resourcePath = '/rest/items/property_groups/{id}/names';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsPropertyGroupsIdNamesLangDelete
     *
     * Delete a property group name
     *
     * @param  int $id id (required)
     * @param  int $lang lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertyGroupsIdNamesLangDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsPropertyGroupsIdNamesLangDelete(
        int $id,
        int $lang,
        string $contentType = self::contentTypes['restItemsPropertyGroupsIdNamesLangDelete'][0]
    ): object
    {
        list($response) = $this->restItemsPropertyGroupsIdNamesLangDeleteWithHttpInfo($id, $lang, $contentType);
        return $response;
    }

    /**
     * Operation restItemsPropertyGroupsIdNamesLangDeleteWithHttpInfo
     *
     * Delete a property group name
     *
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertyGroupsIdNamesLangDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsPropertyGroupsIdNamesLangDeleteWithHttpInfo(
        int $id,
        int $lang,
        string $contentType = self::contentTypes['restItemsPropertyGroupsIdNamesLangDelete'][0]
    ): array
    {
        $request = $this->restItemsPropertyGroupsIdNamesLangDeleteRequest($id, $lang, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsPropertyGroupsIdNamesLangDeleteAsync
     *
     * Delete a property group name
     *
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertyGroupsIdNamesLangDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertyGroupsIdNamesLangDeleteAsync(
        int $id,
        int $lang,
        string $contentType = self::contentTypes['restItemsPropertyGroupsIdNamesLangDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemsPropertyGroupsIdNamesLangDeleteAsyncWithHttpInfo($id, $lang, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsPropertyGroupsIdNamesLangDeleteAsyncWithHttpInfo
     *
     * Delete a property group name
     *
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertyGroupsIdNamesLangDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertyGroupsIdNamesLangDeleteAsyncWithHttpInfo(
        $id,
        $lang,
        string $contentType = self::contentTypes['restItemsPropertyGroupsIdNamesLangDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsPropertyGroupsIdNamesLangDeleteRequest($id, $lang, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsPropertyGroupsIdNamesLangDelete'
     *
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertyGroupsIdNamesLangDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsPropertyGroupsIdNamesLangDeleteRequest(
        $id,
        $lang,
        string $contentType = self::contentTypes['restItemsPropertyGroupsIdNamesLangDelete'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsPropertyGroupsIdNamesLangDelete'
            );
        }

        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $lang when calling restItemsPropertyGroupsIdNamesLangDelete'
            );
        }


        $resourcePath = '/rest/items/property_groups/{id}/names/{lang}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($lang !== null) {
            $resourcePath = str_replace(
                '{' . 'lang' . '}',
                ObjectSerializer::toPathValue($lang),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsPropertyGroupsIdNamesLangGet
     *
     * Get a property group name in a language
     *
     * @param  int $id id (required)
     * @param  int $lang lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertyGroupsIdNamesLangGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\PropertyGroupName
     */
    public function restItemsPropertyGroupsIdNamesLangGet(
        int $id,
        int $lang,
        string $contentType = self::contentTypes['restItemsPropertyGroupsIdNamesLangGet'][0]
    ): \ck\Model\PropertyGroupName
    {
        list($response) = $this->restItemsPropertyGroupsIdNamesLangGetWithHttpInfo($id, $lang, $contentType);
        return $response;
    }

    /**
     * Operation restItemsPropertyGroupsIdNamesLangGetWithHttpInfo
     *
     * Get a property group name in a language
     *
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertyGroupsIdNamesLangGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\PropertyGroupName, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsPropertyGroupsIdNamesLangGetWithHttpInfo(
        int $id,
        int $lang,
        string $contentType = self::contentTypes['restItemsPropertyGroupsIdNamesLangGet'][0]
    ): array
    {
        $request = $this->restItemsPropertyGroupsIdNamesLangGetRequest($id, $lang, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\PropertyGroupName' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\PropertyGroupName' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\PropertyGroupName', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\PropertyGroupName';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\PropertyGroupName',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsPropertyGroupsIdNamesLangGetAsync
     *
     * Get a property group name in a language
     *
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertyGroupsIdNamesLangGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertyGroupsIdNamesLangGetAsync(
        int $id,
        int $lang,
        string $contentType = self::contentTypes['restItemsPropertyGroupsIdNamesLangGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsPropertyGroupsIdNamesLangGetAsyncWithHttpInfo($id, $lang, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsPropertyGroupsIdNamesLangGetAsyncWithHttpInfo
     *
     * Get a property group name in a language
     *
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertyGroupsIdNamesLangGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertyGroupsIdNamesLangGetAsyncWithHttpInfo(
        $id,
        $lang,
        string $contentType = self::contentTypes['restItemsPropertyGroupsIdNamesLangGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\PropertyGroupName';
        $request = $this->restItemsPropertyGroupsIdNamesLangGetRequest($id, $lang, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsPropertyGroupsIdNamesLangGet'
     *
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertyGroupsIdNamesLangGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsPropertyGroupsIdNamesLangGetRequest(
        $id,
        $lang,
        string $contentType = self::contentTypes['restItemsPropertyGroupsIdNamesLangGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsPropertyGroupsIdNamesLangGet'
            );
        }

        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $lang when calling restItemsPropertyGroupsIdNamesLangGet'
            );
        }


        $resourcePath = '/rest/items/property_groups/{id}/names/{lang}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($lang !== null) {
            $resourcePath = str_replace(
                '{' . 'lang' . '}',
                ObjectSerializer::toPathValue($lang),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsPropertyGroupsIdNamesLangPut
     *
     * Update a property group name
     *
     * @param  int $id id (required)
     * @param  int $lang lang (required)
     * @param  \ck\Model\RestItemsPropertyGroupsIdNamesPostRequest|null $_rest_items_property_groups_id_names_lang _rest_items_property_groups_id_names_lang (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertyGroupsIdNamesLangPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\PropertyGroupName
     */
    public function restItemsPropertyGroupsIdNamesLangPut(
        int $id,
        int $lang,
        ?\ck\Model\RestItemsPropertyGroupsIdNamesPostRequest $_rest_items_property_groups_id_names_lang = null,
        string $contentType = self::contentTypes['restItemsPropertyGroupsIdNamesLangPut'][0]
    ): \ck\Model\PropertyGroupName
    {
        list($response) = $this->restItemsPropertyGroupsIdNamesLangPutWithHttpInfo($id, $lang, $_rest_items_property_groups_id_names_lang, $contentType);
        return $response;
    }

    /**
     * Operation restItemsPropertyGroupsIdNamesLangPutWithHttpInfo
     *
     * Update a property group name
     *
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  \ck\Model\RestItemsPropertyGroupsIdNamesPostRequest|null $_rest_items_property_groups_id_names_lang (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertyGroupsIdNamesLangPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\PropertyGroupName, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsPropertyGroupsIdNamesLangPutWithHttpInfo(
        int $id,
        int $lang,
        ?\ck\Model\RestItemsPropertyGroupsIdNamesPostRequest $_rest_items_property_groups_id_names_lang = null,
        string $contentType = self::contentTypes['restItemsPropertyGroupsIdNamesLangPut'][0]
    ): array
    {
        $request = $this->restItemsPropertyGroupsIdNamesLangPutRequest($id, $lang, $_rest_items_property_groups_id_names_lang, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\PropertyGroupName' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\PropertyGroupName' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\PropertyGroupName', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\PropertyGroupName';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\PropertyGroupName',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsPropertyGroupsIdNamesLangPutAsync
     *
     * Update a property group name
     *
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  \ck\Model\RestItemsPropertyGroupsIdNamesPostRequest|null $_rest_items_property_groups_id_names_lang (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertyGroupsIdNamesLangPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertyGroupsIdNamesLangPutAsync(
        int $id,
        int $lang,
        ?\ck\Model\RestItemsPropertyGroupsIdNamesPostRequest $_rest_items_property_groups_id_names_lang = null,
        string $contentType = self::contentTypes['restItemsPropertyGroupsIdNamesLangPut'][0]
    ): PromiseInterface
    {
        return $this->restItemsPropertyGroupsIdNamesLangPutAsyncWithHttpInfo($id, $lang, $_rest_items_property_groups_id_names_lang, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsPropertyGroupsIdNamesLangPutAsyncWithHttpInfo
     *
     * Update a property group name
     *
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  \ck\Model\RestItemsPropertyGroupsIdNamesPostRequest|null $_rest_items_property_groups_id_names_lang (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertyGroupsIdNamesLangPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertyGroupsIdNamesLangPutAsyncWithHttpInfo(
        $id,
        $lang,
        $_rest_items_property_groups_id_names_lang = null,
        string $contentType = self::contentTypes['restItemsPropertyGroupsIdNamesLangPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\PropertyGroupName';
        $request = $this->restItemsPropertyGroupsIdNamesLangPutRequest($id, $lang, $_rest_items_property_groups_id_names_lang, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsPropertyGroupsIdNamesLangPut'
     *
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  \ck\Model\RestItemsPropertyGroupsIdNamesPostRequest|null $_rest_items_property_groups_id_names_lang (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertyGroupsIdNamesLangPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsPropertyGroupsIdNamesLangPutRequest(
        $id,
        $lang,
        $_rest_items_property_groups_id_names_lang = null,
        string $contentType = self::contentTypes['restItemsPropertyGroupsIdNamesLangPut'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsPropertyGroupsIdNamesLangPut'
            );
        }

        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $lang when calling restItemsPropertyGroupsIdNamesLangPut'
            );
        }



        $resourcePath = '/rest/items/property_groups/{id}/names/{lang}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($lang !== null) {
            $resourcePath = str_replace(
                '{' . 'lang' . '}',
                ObjectSerializer::toPathValue($lang),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_property_groups_id_names_lang)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_property_groups_id_names_lang));
            } else {
                $httpBody = $_rest_items_property_groups_id_names_lang;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsPropertyGroupsIdNamesPost
     *
     * Create a property group name
     *
     * @param  int $id id (required)
     * @param  \ck\Model\RestItemsPropertyGroupsIdNamesPostRequest|null $_rest_items_property_groups_id_names _rest_items_property_groups_id_names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertyGroupsIdNamesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\PropertyGroupName
     */
    public function restItemsPropertyGroupsIdNamesPost(
        int $id,
        ?\ck\Model\RestItemsPropertyGroupsIdNamesPostRequest $_rest_items_property_groups_id_names = null,
        string $contentType = self::contentTypes['restItemsPropertyGroupsIdNamesPost'][0]
    ): \ck\Model\PropertyGroupName
    {
        list($response) = $this->restItemsPropertyGroupsIdNamesPostWithHttpInfo($id, $_rest_items_property_groups_id_names, $contentType);
        return $response;
    }

    /**
     * Operation restItemsPropertyGroupsIdNamesPostWithHttpInfo
     *
     * Create a property group name
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsPropertyGroupsIdNamesPostRequest|null $_rest_items_property_groups_id_names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertyGroupsIdNamesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\PropertyGroupName, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsPropertyGroupsIdNamesPostWithHttpInfo(
        int $id,
        ?\ck\Model\RestItemsPropertyGroupsIdNamesPostRequest $_rest_items_property_groups_id_names = null,
        string $contentType = self::contentTypes['restItemsPropertyGroupsIdNamesPost'][0]
    ): array
    {
        $request = $this->restItemsPropertyGroupsIdNamesPostRequest($id, $_rest_items_property_groups_id_names, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\PropertyGroupName' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\PropertyGroupName' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\PropertyGroupName', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\PropertyGroupName';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\PropertyGroupName',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsPropertyGroupsIdNamesPostAsync
     *
     * Create a property group name
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsPropertyGroupsIdNamesPostRequest|null $_rest_items_property_groups_id_names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertyGroupsIdNamesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertyGroupsIdNamesPostAsync(
        int $id,
        ?\ck\Model\RestItemsPropertyGroupsIdNamesPostRequest $_rest_items_property_groups_id_names = null,
        string $contentType = self::contentTypes['restItemsPropertyGroupsIdNamesPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsPropertyGroupsIdNamesPostAsyncWithHttpInfo($id, $_rest_items_property_groups_id_names, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsPropertyGroupsIdNamesPostAsyncWithHttpInfo
     *
     * Create a property group name
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsPropertyGroupsIdNamesPostRequest|null $_rest_items_property_groups_id_names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertyGroupsIdNamesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertyGroupsIdNamesPostAsyncWithHttpInfo(
        $id,
        $_rest_items_property_groups_id_names = null,
        string $contentType = self::contentTypes['restItemsPropertyGroupsIdNamesPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\PropertyGroupName';
        $request = $this->restItemsPropertyGroupsIdNamesPostRequest($id, $_rest_items_property_groups_id_names, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsPropertyGroupsIdNamesPost'
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsPropertyGroupsIdNamesPostRequest|null $_rest_items_property_groups_id_names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertyGroupsIdNamesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsPropertyGroupsIdNamesPostRequest(
        $id,
        $_rest_items_property_groups_id_names = null,
        string $contentType = self::contentTypes['restItemsPropertyGroupsIdNamesPost'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsPropertyGroupsIdNamesPost'
            );
        }



        $resourcePath = '/rest/items/property_groups/{id}/names';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_property_groups_id_names)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_property_groups_id_names));
            } else {
                $httpBody = $_rest_items_property_groups_id_names;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsPropertyGroupsIdPut
     *
     * Update a property group
     *
     * @param  int $id id (required)
     * @param  \ck\Model\RestItemsPropertyGroupsPostRequest|null $_rest_items_property_groups_id _rest_items_property_groups_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertyGroupsIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\PropertyGroup
     */
    public function restItemsPropertyGroupsIdPut(
        int $id,
        ?\ck\Model\RestItemsPropertyGroupsPostRequest $_rest_items_property_groups_id = null,
        string $contentType = self::contentTypes['restItemsPropertyGroupsIdPut'][0]
    ): \ck\Model\PropertyGroup
    {
        list($response) = $this->restItemsPropertyGroupsIdPutWithHttpInfo($id, $_rest_items_property_groups_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsPropertyGroupsIdPutWithHttpInfo
     *
     * Update a property group
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsPropertyGroupsPostRequest|null $_rest_items_property_groups_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertyGroupsIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\PropertyGroup, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsPropertyGroupsIdPutWithHttpInfo(
        int $id,
        ?\ck\Model\RestItemsPropertyGroupsPostRequest $_rest_items_property_groups_id = null,
        string $contentType = self::contentTypes['restItemsPropertyGroupsIdPut'][0]
    ): array
    {
        $request = $this->restItemsPropertyGroupsIdPutRequest($id, $_rest_items_property_groups_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\PropertyGroup' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\PropertyGroup' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\PropertyGroup', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\PropertyGroup';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\PropertyGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsPropertyGroupsIdPutAsync
     *
     * Update a property group
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsPropertyGroupsPostRequest|null $_rest_items_property_groups_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertyGroupsIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertyGroupsIdPutAsync(
        int $id,
        ?\ck\Model\RestItemsPropertyGroupsPostRequest $_rest_items_property_groups_id = null,
        string $contentType = self::contentTypes['restItemsPropertyGroupsIdPut'][0]
    ): PromiseInterface
    {
        return $this->restItemsPropertyGroupsIdPutAsyncWithHttpInfo($id, $_rest_items_property_groups_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsPropertyGroupsIdPutAsyncWithHttpInfo
     *
     * Update a property group
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsPropertyGroupsPostRequest|null $_rest_items_property_groups_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertyGroupsIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertyGroupsIdPutAsyncWithHttpInfo(
        $id,
        $_rest_items_property_groups_id = null,
        string $contentType = self::contentTypes['restItemsPropertyGroupsIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\PropertyGroup';
        $request = $this->restItemsPropertyGroupsIdPutRequest($id, $_rest_items_property_groups_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsPropertyGroupsIdPut'
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsPropertyGroupsPostRequest|null $_rest_items_property_groups_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertyGroupsIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsPropertyGroupsIdPutRequest(
        $id,
        $_rest_items_property_groups_id = null,
        string $contentType = self::contentTypes['restItemsPropertyGroupsIdPut'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsPropertyGroupsIdPut'
            );
        }



        $resourcePath = '/rest/items/property_groups/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_property_groups_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_property_groups_id));
            } else {
                $httpBody = $_rest_items_property_groups_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsPropertyGroupsPost
     *
     * Create a property group
     *
     * @param  \ck\Model\RestItemsPropertyGroupsPostRequest|null $_rest_items_property_groups _rest_items_property_groups (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertyGroupsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\PropertyGroup
     */
    public function restItemsPropertyGroupsPost(
        ?\ck\Model\RestItemsPropertyGroupsPostRequest $_rest_items_property_groups = null,
        string $contentType = self::contentTypes['restItemsPropertyGroupsPost'][0]
    ): \ck\Model\PropertyGroup
    {
        list($response) = $this->restItemsPropertyGroupsPostWithHttpInfo($_rest_items_property_groups, $contentType);
        return $response;
    }

    /**
     * Operation restItemsPropertyGroupsPostWithHttpInfo
     *
     * Create a property group
     *
     * @param  \ck\Model\RestItemsPropertyGroupsPostRequest|null $_rest_items_property_groups (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertyGroupsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\PropertyGroup, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsPropertyGroupsPostWithHttpInfo(
        ?\ck\Model\RestItemsPropertyGroupsPostRequest $_rest_items_property_groups = null,
        string $contentType = self::contentTypes['restItemsPropertyGroupsPost'][0]
    ): array
    {
        $request = $this->restItemsPropertyGroupsPostRequest($_rest_items_property_groups, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\PropertyGroup' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\PropertyGroup' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\PropertyGroup', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\PropertyGroup';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\PropertyGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsPropertyGroupsPostAsync
     *
     * Create a property group
     *
     * @param  \ck\Model\RestItemsPropertyGroupsPostRequest|null $_rest_items_property_groups (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertyGroupsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertyGroupsPostAsync(
        ?\ck\Model\RestItemsPropertyGroupsPostRequest $_rest_items_property_groups = null,
        string $contentType = self::contentTypes['restItemsPropertyGroupsPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsPropertyGroupsPostAsyncWithHttpInfo($_rest_items_property_groups, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsPropertyGroupsPostAsyncWithHttpInfo
     *
     * Create a property group
     *
     * @param  \ck\Model\RestItemsPropertyGroupsPostRequest|null $_rest_items_property_groups (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertyGroupsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPropertyGroupsPostAsyncWithHttpInfo(
        $_rest_items_property_groups = null,
        string $contentType = self::contentTypes['restItemsPropertyGroupsPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\PropertyGroup';
        $request = $this->restItemsPropertyGroupsPostRequest($_rest_items_property_groups, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsPropertyGroupsPost'
     *
     * @param  \ck\Model\RestItemsPropertyGroupsPostRequest|null $_rest_items_property_groups (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPropertyGroupsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsPropertyGroupsPostRequest(
        $_rest_items_property_groups = null,
        string $contentType = self::contentTypes['restItemsPropertyGroupsPost'][0]
    ): Request
    {



        $resourcePath = '/rest/items/property_groups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_property_groups)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_property_groups));
            } else {
                $httpBody = $_rest_items_property_groups;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsPut
     *
     * Bulk update items
     *
     * @param  \ck\Model\RestItemsPutRequest|null $_rest_items _rest_items (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsPut(
        ?\ck\Model\RestItemsPutRequest $_rest_items = null,
        string $contentType = self::contentTypes['restItemsPut'][0]
    ): object
    {
        list($response) = $this->restItemsPutWithHttpInfo($_rest_items, $contentType);
        return $response;
    }

    /**
     * Operation restItemsPutWithHttpInfo
     *
     * Bulk update items
     *
     * @param  \ck\Model\RestItemsPutRequest|null $_rest_items (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsPutWithHttpInfo(
        ?\ck\Model\RestItemsPutRequest $_rest_items = null,
        string $contentType = self::contentTypes['restItemsPut'][0]
    ): array
    {
        $request = $this->restItemsPutRequest($_rest_items, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsPutAsync
     *
     * Bulk update items
     *
     * @param  \ck\Model\RestItemsPutRequest|null $_rest_items (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPutAsync(
        ?\ck\Model\RestItemsPutRequest $_rest_items = null,
        string $contentType = self::contentTypes['restItemsPut'][0]
    ): PromiseInterface
    {
        return $this->restItemsPutAsyncWithHttpInfo($_rest_items, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsPutAsyncWithHttpInfo
     *
     * Bulk update items
     *
     * @param  \ck\Model\RestItemsPutRequest|null $_rest_items (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsPutAsyncWithHttpInfo(
        $_rest_items = null,
        string $contentType = self::contentTypes['restItemsPut'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsPutRequest($_rest_items, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsPut'
     *
     * @param  \ck\Model\RestItemsPutRequest|null $_rest_items (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsPutRequest(
        $_rest_items = null,
        string $contentType = self::contentTypes['restItemsPut'][0]
    ): Request
    {



        $resourcePath = '/rest/items';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items));
            } else {
                $httpBody = $_rest_items;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsSalesPricesGet
     *
     * List sales prices
     *
     * @param  string|null $updated_at Filter restricts the list of results to items updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestItemsSalesPricesGet200Response
     */
    public function restItemsSalesPricesGet(
        ?string $updated_at = null,
        string $contentType = self::contentTypes['restItemsSalesPricesGet'][0]
    ): \ck\Model\RestItemsSalesPricesGet200Response
    {
        list($response) = $this->restItemsSalesPricesGetWithHttpInfo($updated_at, $contentType);
        return $response;
    }

    /**
     * Operation restItemsSalesPricesGetWithHttpInfo
     *
     * List sales prices
     *
     * @param  string|null $updated_at Filter restricts the list of results to items updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestItemsSalesPricesGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsSalesPricesGetWithHttpInfo(
        ?string $updated_at = null,
        string $contentType = self::contentTypes['restItemsSalesPricesGet'][0]
    ): array
    {
        $request = $this->restItemsSalesPricesGetRequest($updated_at, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestItemsSalesPricesGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestItemsSalesPricesGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestItemsSalesPricesGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestItemsSalesPricesGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestItemsSalesPricesGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsSalesPricesGetAsync
     *
     * List sales prices
     *
     * @param  string|null $updated_at Filter restricts the list of results to items updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsSalesPricesGetAsync(
        ?string $updated_at = null,
        string $contentType = self::contentTypes['restItemsSalesPricesGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsSalesPricesGetAsyncWithHttpInfo($updated_at, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsSalesPricesGetAsyncWithHttpInfo
     *
     * List sales prices
     *
     * @param  string|null $updated_at Filter restricts the list of results to items updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsSalesPricesGetAsyncWithHttpInfo(
        $updated_at = null,
        string $contentType = self::contentTypes['restItemsSalesPricesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestItemsSalesPricesGet200Response';
        $request = $this->restItemsSalesPricesGetRequest($updated_at, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsSalesPricesGet'
     *
     * @param  string|null $updated_at Filter restricts the list of results to items updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsSalesPricesGetRequest(
        $updated_at = null,
        string $contentType = self::contentTypes['restItemsSalesPricesGet'][0]
    ): Request
    {



        $resourcePath = '/rest/items/sales_prices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_at,
            'updatedAt', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsSalesPricesIdAccountsAccountTypeAccountIdDelete
     *
     * Deactivate a referrer account
     *
     * @param  int $id id (required)
     * @param  int $account_type account_type (required)
     * @param  int $account_id account_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdAccountsAccountTypeAccountIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsSalesPricesIdAccountsAccountTypeAccountIdDelete(
        int $id,
        int $account_type,
        int $account_id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdAccountsAccountTypeAccountIdDelete'][0]
    ): object
    {
        list($response) = $this->restItemsSalesPricesIdAccountsAccountTypeAccountIdDeleteWithHttpInfo($id, $account_type, $account_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsSalesPricesIdAccountsAccountTypeAccountIdDeleteWithHttpInfo
     *
     * Deactivate a referrer account
     *
     * @param  int $id (required)
     * @param  int $account_type (required)
     * @param  int $account_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdAccountsAccountTypeAccountIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsSalesPricesIdAccountsAccountTypeAccountIdDeleteWithHttpInfo(
        int $id,
        int $account_type,
        int $account_id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdAccountsAccountTypeAccountIdDelete'][0]
    ): array
    {
        $request = $this->restItemsSalesPricesIdAccountsAccountTypeAccountIdDeleteRequest($id, $account_type, $account_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsSalesPricesIdAccountsAccountTypeAccountIdDeleteAsync
     *
     * Deactivate a referrer account
     *
     * @param  int $id (required)
     * @param  int $account_type (required)
     * @param  int $account_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdAccountsAccountTypeAccountIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsSalesPricesIdAccountsAccountTypeAccountIdDeleteAsync(
        int $id,
        int $account_type,
        int $account_id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdAccountsAccountTypeAccountIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemsSalesPricesIdAccountsAccountTypeAccountIdDeleteAsyncWithHttpInfo($id, $account_type, $account_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsSalesPricesIdAccountsAccountTypeAccountIdDeleteAsyncWithHttpInfo
     *
     * Deactivate a referrer account
     *
     * @param  int $id (required)
     * @param  int $account_type (required)
     * @param  int $account_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdAccountsAccountTypeAccountIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsSalesPricesIdAccountsAccountTypeAccountIdDeleteAsyncWithHttpInfo(
        $id,
        $account_type,
        $account_id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdAccountsAccountTypeAccountIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsSalesPricesIdAccountsAccountTypeAccountIdDeleteRequest($id, $account_type, $account_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsSalesPricesIdAccountsAccountTypeAccountIdDelete'
     *
     * @param  int $id (required)
     * @param  int $account_type (required)
     * @param  int $account_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdAccountsAccountTypeAccountIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsSalesPricesIdAccountsAccountTypeAccountIdDeleteRequest(
        $id,
        $account_type,
        $account_id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdAccountsAccountTypeAccountIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsSalesPricesIdAccountsAccountTypeAccountIdDelete'
            );
        }

        // verify the required parameter 'account_type' is set
        if ($account_type === null || (is_array($account_type) && count($account_type) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $account_type when calling restItemsSalesPricesIdAccountsAccountTypeAccountIdDelete'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $account_id when calling restItemsSalesPricesIdAccountsAccountTypeAccountIdDelete'
            );
        }


        $resourcePath = '/rest/items/sales_prices/{id}/accounts/{accountType}/{accountId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($account_type !== null) {
            $resourcePath = str_replace(
                '{' . 'accountType' . '}',
                ObjectSerializer::toPathValue($account_type),
                $resourcePath
            );
        }
        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsSalesPricesIdAccountsGet
     *
     * List referrer accounts
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdAccountsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\SalesPriceAccount[]
     */
    public function restItemsSalesPricesIdAccountsGet(
        int $id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdAccountsGet'][0]
    ): array
    {
        list($response) = $this->restItemsSalesPricesIdAccountsGetWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsSalesPricesIdAccountsGetWithHttpInfo
     *
     * List referrer accounts
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdAccountsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\SalesPriceAccount[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsSalesPricesIdAccountsGetWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdAccountsGet'][0]
    ): array
    {
        $request = $this->restItemsSalesPricesIdAccountsGetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\SalesPriceAccount[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\SalesPriceAccount[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\SalesPriceAccount[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\SalesPriceAccount[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\SalesPriceAccount[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsSalesPricesIdAccountsGetAsync
     *
     * List referrer accounts
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdAccountsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsSalesPricesIdAccountsGetAsync(
        int $id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdAccountsGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsSalesPricesIdAccountsGetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsSalesPricesIdAccountsGetAsyncWithHttpInfo
     *
     * List referrer accounts
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdAccountsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsSalesPricesIdAccountsGetAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdAccountsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\SalesPriceAccount[]';
        $request = $this->restItemsSalesPricesIdAccountsGetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsSalesPricesIdAccountsGet'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdAccountsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsSalesPricesIdAccountsGetRequest(
        $id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdAccountsGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsSalesPricesIdAccountsGet'
            );
        }


        $resourcePath = '/rest/items/sales_prices/{id}/accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsSalesPricesIdAccountsPost
     *
     * Activate a referrer account
     *
     * @param  int $id id (required)
     * @param  \ck\Model\RestItemsSalesPricesIdAccountsPostRequest|null $_rest_items_sales_prices_id_accounts _rest_items_sales_prices_id_accounts (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdAccountsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\SalesPriceAccount
     */
    public function restItemsSalesPricesIdAccountsPost(
        int $id,
        ?\ck\Model\RestItemsSalesPricesIdAccountsPostRequest $_rest_items_sales_prices_id_accounts = null,
        string $contentType = self::contentTypes['restItemsSalesPricesIdAccountsPost'][0]
    ): \ck\Model\SalesPriceAccount
    {
        list($response) = $this->restItemsSalesPricesIdAccountsPostWithHttpInfo($id, $_rest_items_sales_prices_id_accounts, $contentType);
        return $response;
    }

    /**
     * Operation restItemsSalesPricesIdAccountsPostWithHttpInfo
     *
     * Activate a referrer account
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsSalesPricesIdAccountsPostRequest|null $_rest_items_sales_prices_id_accounts (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdAccountsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\SalesPriceAccount, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsSalesPricesIdAccountsPostWithHttpInfo(
        int $id,
        ?\ck\Model\RestItemsSalesPricesIdAccountsPostRequest $_rest_items_sales_prices_id_accounts = null,
        string $contentType = self::contentTypes['restItemsSalesPricesIdAccountsPost'][0]
    ): array
    {
        $request = $this->restItemsSalesPricesIdAccountsPostRequest($id, $_rest_items_sales_prices_id_accounts, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\SalesPriceAccount' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\SalesPriceAccount' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\SalesPriceAccount', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\SalesPriceAccount';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\SalesPriceAccount',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsSalesPricesIdAccountsPostAsync
     *
     * Activate a referrer account
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsSalesPricesIdAccountsPostRequest|null $_rest_items_sales_prices_id_accounts (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdAccountsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsSalesPricesIdAccountsPostAsync(
        int $id,
        ?\ck\Model\RestItemsSalesPricesIdAccountsPostRequest $_rest_items_sales_prices_id_accounts = null,
        string $contentType = self::contentTypes['restItemsSalesPricesIdAccountsPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsSalesPricesIdAccountsPostAsyncWithHttpInfo($id, $_rest_items_sales_prices_id_accounts, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsSalesPricesIdAccountsPostAsyncWithHttpInfo
     *
     * Activate a referrer account
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsSalesPricesIdAccountsPostRequest|null $_rest_items_sales_prices_id_accounts (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdAccountsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsSalesPricesIdAccountsPostAsyncWithHttpInfo(
        $id,
        $_rest_items_sales_prices_id_accounts = null,
        string $contentType = self::contentTypes['restItemsSalesPricesIdAccountsPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\SalesPriceAccount';
        $request = $this->restItemsSalesPricesIdAccountsPostRequest($id, $_rest_items_sales_prices_id_accounts, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsSalesPricesIdAccountsPost'
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsSalesPricesIdAccountsPostRequest|null $_rest_items_sales_prices_id_accounts (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdAccountsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsSalesPricesIdAccountsPostRequest(
        $id,
        $_rest_items_sales_prices_id_accounts = null,
        string $contentType = self::contentTypes['restItemsSalesPricesIdAccountsPost'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsSalesPricesIdAccountsPost'
            );
        }



        $resourcePath = '/rest/items/sales_prices/{id}/accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_sales_prices_id_accounts)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_sales_prices_id_accounts));
            } else {
                $httpBody = $_rest_items_sales_prices_id_accounts;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsSalesPricesIdCountriesCountryIdDelete
     *
     * Deactivate a country
     *
     * @param  int $id id (required)
     * @param  int $country_id country_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdCountriesCountryIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsSalesPricesIdCountriesCountryIdDelete(
        int $id,
        int $country_id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdCountriesCountryIdDelete'][0]
    ): object
    {
        list($response) = $this->restItemsSalesPricesIdCountriesCountryIdDeleteWithHttpInfo($id, $country_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsSalesPricesIdCountriesCountryIdDeleteWithHttpInfo
     *
     * Deactivate a country
     *
     * @param  int $id (required)
     * @param  int $country_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdCountriesCountryIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsSalesPricesIdCountriesCountryIdDeleteWithHttpInfo(
        int $id,
        int $country_id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdCountriesCountryIdDelete'][0]
    ): array
    {
        $request = $this->restItemsSalesPricesIdCountriesCountryIdDeleteRequest($id, $country_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsSalesPricesIdCountriesCountryIdDeleteAsync
     *
     * Deactivate a country
     *
     * @param  int $id (required)
     * @param  int $country_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdCountriesCountryIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsSalesPricesIdCountriesCountryIdDeleteAsync(
        int $id,
        int $country_id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdCountriesCountryIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemsSalesPricesIdCountriesCountryIdDeleteAsyncWithHttpInfo($id, $country_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsSalesPricesIdCountriesCountryIdDeleteAsyncWithHttpInfo
     *
     * Deactivate a country
     *
     * @param  int $id (required)
     * @param  int $country_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdCountriesCountryIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsSalesPricesIdCountriesCountryIdDeleteAsyncWithHttpInfo(
        $id,
        $country_id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdCountriesCountryIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsSalesPricesIdCountriesCountryIdDeleteRequest($id, $country_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsSalesPricesIdCountriesCountryIdDelete'
     *
     * @param  int $id (required)
     * @param  int $country_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdCountriesCountryIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsSalesPricesIdCountriesCountryIdDeleteRequest(
        $id,
        $country_id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdCountriesCountryIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsSalesPricesIdCountriesCountryIdDelete'
            );
        }

        // verify the required parameter 'country_id' is set
        if ($country_id === null || (is_array($country_id) && count($country_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $country_id when calling restItemsSalesPricesIdCountriesCountryIdDelete'
            );
        }


        $resourcePath = '/rest/items/sales_prices/{id}/countries/{countryId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($country_id !== null) {
            $resourcePath = str_replace(
                '{' . 'countryId' . '}',
                ObjectSerializer::toPathValue($country_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsSalesPricesIdCountriesGet
     *
     * List countries by sales price
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdCountriesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\SalesPriceCountry[]
     */
    public function restItemsSalesPricesIdCountriesGet(
        int $id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdCountriesGet'][0]
    ): array
    {
        list($response) = $this->restItemsSalesPricesIdCountriesGetWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsSalesPricesIdCountriesGetWithHttpInfo
     *
     * List countries by sales price
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdCountriesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\SalesPriceCountry[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsSalesPricesIdCountriesGetWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdCountriesGet'][0]
    ): array
    {
        $request = $this->restItemsSalesPricesIdCountriesGetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\SalesPriceCountry[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\SalesPriceCountry[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\SalesPriceCountry[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\SalesPriceCountry[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\SalesPriceCountry[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsSalesPricesIdCountriesGetAsync
     *
     * List countries by sales price
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdCountriesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsSalesPricesIdCountriesGetAsync(
        int $id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdCountriesGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsSalesPricesIdCountriesGetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsSalesPricesIdCountriesGetAsyncWithHttpInfo
     *
     * List countries by sales price
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdCountriesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsSalesPricesIdCountriesGetAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdCountriesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\SalesPriceCountry[]';
        $request = $this->restItemsSalesPricesIdCountriesGetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsSalesPricesIdCountriesGet'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdCountriesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsSalesPricesIdCountriesGetRequest(
        $id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdCountriesGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsSalesPricesIdCountriesGet'
            );
        }


        $resourcePath = '/rest/items/sales_prices/{id}/countries';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsSalesPricesIdCountriesPost
     *
     * Activate a country
     *
     * @param  int $id id (required)
     * @param  \ck\Model\RestItemsSalesPricesIdCountriesPostRequest|null $_rest_items_sales_prices_id_countries _rest_items_sales_prices_id_countries (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdCountriesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\SalesPriceCountry
     */
    public function restItemsSalesPricesIdCountriesPost(
        int $id,
        ?\ck\Model\RestItemsSalesPricesIdCountriesPostRequest $_rest_items_sales_prices_id_countries = null,
        string $contentType = self::contentTypes['restItemsSalesPricesIdCountriesPost'][0]
    ): \ck\Model\SalesPriceCountry
    {
        list($response) = $this->restItemsSalesPricesIdCountriesPostWithHttpInfo($id, $_rest_items_sales_prices_id_countries, $contentType);
        return $response;
    }

    /**
     * Operation restItemsSalesPricesIdCountriesPostWithHttpInfo
     *
     * Activate a country
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsSalesPricesIdCountriesPostRequest|null $_rest_items_sales_prices_id_countries (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdCountriesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\SalesPriceCountry, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsSalesPricesIdCountriesPostWithHttpInfo(
        int $id,
        ?\ck\Model\RestItemsSalesPricesIdCountriesPostRequest $_rest_items_sales_prices_id_countries = null,
        string $contentType = self::contentTypes['restItemsSalesPricesIdCountriesPost'][0]
    ): array
    {
        $request = $this->restItemsSalesPricesIdCountriesPostRequest($id, $_rest_items_sales_prices_id_countries, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\SalesPriceCountry' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\SalesPriceCountry' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\SalesPriceCountry', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\SalesPriceCountry';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\SalesPriceCountry',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsSalesPricesIdCountriesPostAsync
     *
     * Activate a country
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsSalesPricesIdCountriesPostRequest|null $_rest_items_sales_prices_id_countries (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdCountriesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsSalesPricesIdCountriesPostAsync(
        int $id,
        ?\ck\Model\RestItemsSalesPricesIdCountriesPostRequest $_rest_items_sales_prices_id_countries = null,
        string $contentType = self::contentTypes['restItemsSalesPricesIdCountriesPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsSalesPricesIdCountriesPostAsyncWithHttpInfo($id, $_rest_items_sales_prices_id_countries, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsSalesPricesIdCountriesPostAsyncWithHttpInfo
     *
     * Activate a country
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsSalesPricesIdCountriesPostRequest|null $_rest_items_sales_prices_id_countries (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdCountriesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsSalesPricesIdCountriesPostAsyncWithHttpInfo(
        $id,
        $_rest_items_sales_prices_id_countries = null,
        string $contentType = self::contentTypes['restItemsSalesPricesIdCountriesPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\SalesPriceCountry';
        $request = $this->restItemsSalesPricesIdCountriesPostRequest($id, $_rest_items_sales_prices_id_countries, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsSalesPricesIdCountriesPost'
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsSalesPricesIdCountriesPostRequest|null $_rest_items_sales_prices_id_countries (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdCountriesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsSalesPricesIdCountriesPostRequest(
        $id,
        $_rest_items_sales_prices_id_countries = null,
        string $contentType = self::contentTypes['restItemsSalesPricesIdCountriesPost'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsSalesPricesIdCountriesPost'
            );
        }



        $resourcePath = '/rest/items/sales_prices/{id}/countries';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_sales_prices_id_countries)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_sales_prices_id_countries));
            } else {
                $httpBody = $_rest_items_sales_prices_id_countries;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsSalesPricesIdCurrenciesCurrencyDelete
     *
     * Deactivate a currency
     *
     * @param  int $id id (required)
     * @param  int $currency currency (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdCurrenciesCurrencyDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsSalesPricesIdCurrenciesCurrencyDelete(
        int $id,
        int $currency,
        string $contentType = self::contentTypes['restItemsSalesPricesIdCurrenciesCurrencyDelete'][0]
    ): object
    {
        list($response) = $this->restItemsSalesPricesIdCurrenciesCurrencyDeleteWithHttpInfo($id, $currency, $contentType);
        return $response;
    }

    /**
     * Operation restItemsSalesPricesIdCurrenciesCurrencyDeleteWithHttpInfo
     *
     * Deactivate a currency
     *
     * @param  int $id (required)
     * @param  int $currency (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdCurrenciesCurrencyDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsSalesPricesIdCurrenciesCurrencyDeleteWithHttpInfo(
        int $id,
        int $currency,
        string $contentType = self::contentTypes['restItemsSalesPricesIdCurrenciesCurrencyDelete'][0]
    ): array
    {
        $request = $this->restItemsSalesPricesIdCurrenciesCurrencyDeleteRequest($id, $currency, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsSalesPricesIdCurrenciesCurrencyDeleteAsync
     *
     * Deactivate a currency
     *
     * @param  int $id (required)
     * @param  int $currency (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdCurrenciesCurrencyDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsSalesPricesIdCurrenciesCurrencyDeleteAsync(
        int $id,
        int $currency,
        string $contentType = self::contentTypes['restItemsSalesPricesIdCurrenciesCurrencyDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemsSalesPricesIdCurrenciesCurrencyDeleteAsyncWithHttpInfo($id, $currency, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsSalesPricesIdCurrenciesCurrencyDeleteAsyncWithHttpInfo
     *
     * Deactivate a currency
     *
     * @param  int $id (required)
     * @param  int $currency (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdCurrenciesCurrencyDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsSalesPricesIdCurrenciesCurrencyDeleteAsyncWithHttpInfo(
        $id,
        $currency,
        string $contentType = self::contentTypes['restItemsSalesPricesIdCurrenciesCurrencyDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsSalesPricesIdCurrenciesCurrencyDeleteRequest($id, $currency, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsSalesPricesIdCurrenciesCurrencyDelete'
     *
     * @param  int $id (required)
     * @param  int $currency (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdCurrenciesCurrencyDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsSalesPricesIdCurrenciesCurrencyDeleteRequest(
        $id,
        $currency,
        string $contentType = self::contentTypes['restItemsSalesPricesIdCurrenciesCurrencyDelete'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsSalesPricesIdCurrenciesCurrencyDelete'
            );
        }

        // verify the required parameter 'currency' is set
        if ($currency === null || (is_array($currency) && count($currency) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $currency when calling restItemsSalesPricesIdCurrenciesCurrencyDelete'
            );
        }


        $resourcePath = '/rest/items/sales_prices/{id}/currencies/{currency}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($currency !== null) {
            $resourcePath = str_replace(
                '{' . 'currency' . '}',
                ObjectSerializer::toPathValue($currency),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsSalesPricesIdCurrenciesGet
     *
     * List activated currencies
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdCurrenciesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\SalesPriceCurrency[]
     */
    public function restItemsSalesPricesIdCurrenciesGet(
        int $id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdCurrenciesGet'][0]
    ): array
    {
        list($response) = $this->restItemsSalesPricesIdCurrenciesGetWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsSalesPricesIdCurrenciesGetWithHttpInfo
     *
     * List activated currencies
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdCurrenciesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\SalesPriceCurrency[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsSalesPricesIdCurrenciesGetWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdCurrenciesGet'][0]
    ): array
    {
        $request = $this->restItemsSalesPricesIdCurrenciesGetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\SalesPriceCurrency[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\SalesPriceCurrency[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\SalesPriceCurrency[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\SalesPriceCurrency[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\SalesPriceCurrency[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsSalesPricesIdCurrenciesGetAsync
     *
     * List activated currencies
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdCurrenciesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsSalesPricesIdCurrenciesGetAsync(
        int $id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdCurrenciesGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsSalesPricesIdCurrenciesGetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsSalesPricesIdCurrenciesGetAsyncWithHttpInfo
     *
     * List activated currencies
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdCurrenciesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsSalesPricesIdCurrenciesGetAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdCurrenciesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\SalesPriceCurrency[]';
        $request = $this->restItemsSalesPricesIdCurrenciesGetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsSalesPricesIdCurrenciesGet'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdCurrenciesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsSalesPricesIdCurrenciesGetRequest(
        $id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdCurrenciesGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsSalesPricesIdCurrenciesGet'
            );
        }


        $resourcePath = '/rest/items/sales_prices/{id}/currencies';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsSalesPricesIdCurrenciesPost
     *
     * Activate a currency
     *
     * @param  int $id id (required)
     * @param  \ck\Model\RestItemsSalesPricesIdCurrenciesPostRequest|null $_rest_items_sales_prices_id_currencies _rest_items_sales_prices_id_currencies (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdCurrenciesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\SalesPriceCurrency
     */
    public function restItemsSalesPricesIdCurrenciesPost(
        int $id,
        ?\ck\Model\RestItemsSalesPricesIdCurrenciesPostRequest $_rest_items_sales_prices_id_currencies = null,
        string $contentType = self::contentTypes['restItemsSalesPricesIdCurrenciesPost'][0]
    ): \ck\Model\SalesPriceCurrency
    {
        list($response) = $this->restItemsSalesPricesIdCurrenciesPostWithHttpInfo($id, $_rest_items_sales_prices_id_currencies, $contentType);
        return $response;
    }

    /**
     * Operation restItemsSalesPricesIdCurrenciesPostWithHttpInfo
     *
     * Activate a currency
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsSalesPricesIdCurrenciesPostRequest|null $_rest_items_sales_prices_id_currencies (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdCurrenciesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\SalesPriceCurrency, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsSalesPricesIdCurrenciesPostWithHttpInfo(
        int $id,
        ?\ck\Model\RestItemsSalesPricesIdCurrenciesPostRequest $_rest_items_sales_prices_id_currencies = null,
        string $contentType = self::contentTypes['restItemsSalesPricesIdCurrenciesPost'][0]
    ): array
    {
        $request = $this->restItemsSalesPricesIdCurrenciesPostRequest($id, $_rest_items_sales_prices_id_currencies, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\SalesPriceCurrency' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\SalesPriceCurrency' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\SalesPriceCurrency', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\SalesPriceCurrency';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\SalesPriceCurrency',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsSalesPricesIdCurrenciesPostAsync
     *
     * Activate a currency
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsSalesPricesIdCurrenciesPostRequest|null $_rest_items_sales_prices_id_currencies (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdCurrenciesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsSalesPricesIdCurrenciesPostAsync(
        int $id,
        ?\ck\Model\RestItemsSalesPricesIdCurrenciesPostRequest $_rest_items_sales_prices_id_currencies = null,
        string $contentType = self::contentTypes['restItemsSalesPricesIdCurrenciesPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsSalesPricesIdCurrenciesPostAsyncWithHttpInfo($id, $_rest_items_sales_prices_id_currencies, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsSalesPricesIdCurrenciesPostAsyncWithHttpInfo
     *
     * Activate a currency
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsSalesPricesIdCurrenciesPostRequest|null $_rest_items_sales_prices_id_currencies (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdCurrenciesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsSalesPricesIdCurrenciesPostAsyncWithHttpInfo(
        $id,
        $_rest_items_sales_prices_id_currencies = null,
        string $contentType = self::contentTypes['restItemsSalesPricesIdCurrenciesPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\SalesPriceCurrency';
        $request = $this->restItemsSalesPricesIdCurrenciesPostRequest($id, $_rest_items_sales_prices_id_currencies, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsSalesPricesIdCurrenciesPost'
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsSalesPricesIdCurrenciesPostRequest|null $_rest_items_sales_prices_id_currencies (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdCurrenciesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsSalesPricesIdCurrenciesPostRequest(
        $id,
        $_rest_items_sales_prices_id_currencies = null,
        string $contentType = self::contentTypes['restItemsSalesPricesIdCurrenciesPost'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsSalesPricesIdCurrenciesPost'
            );
        }



        $resourcePath = '/rest/items/sales_prices/{id}/currencies';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_sales_prices_id_currencies)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_sales_prices_id_currencies));
            } else {
                $httpBody = $_rest_items_sales_prices_id_currencies;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsSalesPricesIdCustomerClassesCustomerClassIdDelete
     *
     * Activate a customer class
     *
     * @param  int $id id (required)
     * @param  int $customer_class_id customer_class_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdCustomerClassesCustomerClassIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsSalesPricesIdCustomerClassesCustomerClassIdDelete(
        int $id,
        int $customer_class_id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdCustomerClassesCustomerClassIdDelete'][0]
    ): object
    {
        list($response) = $this->restItemsSalesPricesIdCustomerClassesCustomerClassIdDeleteWithHttpInfo($id, $customer_class_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsSalesPricesIdCustomerClassesCustomerClassIdDeleteWithHttpInfo
     *
     * Activate a customer class
     *
     * @param  int $id (required)
     * @param  int $customer_class_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdCustomerClassesCustomerClassIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsSalesPricesIdCustomerClassesCustomerClassIdDeleteWithHttpInfo(
        int $id,
        int $customer_class_id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdCustomerClassesCustomerClassIdDelete'][0]
    ): array
    {
        $request = $this->restItemsSalesPricesIdCustomerClassesCustomerClassIdDeleteRequest($id, $customer_class_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsSalesPricesIdCustomerClassesCustomerClassIdDeleteAsync
     *
     * Activate a customer class
     *
     * @param  int $id (required)
     * @param  int $customer_class_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdCustomerClassesCustomerClassIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsSalesPricesIdCustomerClassesCustomerClassIdDeleteAsync(
        int $id,
        int $customer_class_id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdCustomerClassesCustomerClassIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemsSalesPricesIdCustomerClassesCustomerClassIdDeleteAsyncWithHttpInfo($id, $customer_class_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsSalesPricesIdCustomerClassesCustomerClassIdDeleteAsyncWithHttpInfo
     *
     * Activate a customer class
     *
     * @param  int $id (required)
     * @param  int $customer_class_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdCustomerClassesCustomerClassIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsSalesPricesIdCustomerClassesCustomerClassIdDeleteAsyncWithHttpInfo(
        $id,
        $customer_class_id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdCustomerClassesCustomerClassIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsSalesPricesIdCustomerClassesCustomerClassIdDeleteRequest($id, $customer_class_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsSalesPricesIdCustomerClassesCustomerClassIdDelete'
     *
     * @param  int $id (required)
     * @param  int $customer_class_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdCustomerClassesCustomerClassIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsSalesPricesIdCustomerClassesCustomerClassIdDeleteRequest(
        $id,
        $customer_class_id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdCustomerClassesCustomerClassIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsSalesPricesIdCustomerClassesCustomerClassIdDelete'
            );
        }

        // verify the required parameter 'customer_class_id' is set
        if ($customer_class_id === null || (is_array($customer_class_id) && count($customer_class_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $customer_class_id when calling restItemsSalesPricesIdCustomerClassesCustomerClassIdDelete'
            );
        }


        $resourcePath = '/rest/items/sales_prices/{id}/customer_classes/{customerClassId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($customer_class_id !== null) {
            $resourcePath = str_replace(
                '{' . 'customerClassId' . '}',
                ObjectSerializer::toPathValue($customer_class_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsSalesPricesIdCustomerClassesGet
     *
     * List activated customer classes
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdCustomerClassesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\SalesPriceCustomerClass[]
     */
    public function restItemsSalesPricesIdCustomerClassesGet(
        int $id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdCustomerClassesGet'][0]
    ): array
    {
        list($response) = $this->restItemsSalesPricesIdCustomerClassesGetWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsSalesPricesIdCustomerClassesGetWithHttpInfo
     *
     * List activated customer classes
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdCustomerClassesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\SalesPriceCustomerClass[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsSalesPricesIdCustomerClassesGetWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdCustomerClassesGet'][0]
    ): array
    {
        $request = $this->restItemsSalesPricesIdCustomerClassesGetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\SalesPriceCustomerClass[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\SalesPriceCustomerClass[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\SalesPriceCustomerClass[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\SalesPriceCustomerClass[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\SalesPriceCustomerClass[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsSalesPricesIdCustomerClassesGetAsync
     *
     * List activated customer classes
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdCustomerClassesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsSalesPricesIdCustomerClassesGetAsync(
        int $id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdCustomerClassesGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsSalesPricesIdCustomerClassesGetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsSalesPricesIdCustomerClassesGetAsyncWithHttpInfo
     *
     * List activated customer classes
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdCustomerClassesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsSalesPricesIdCustomerClassesGetAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdCustomerClassesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\SalesPriceCustomerClass[]';
        $request = $this->restItemsSalesPricesIdCustomerClassesGetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsSalesPricesIdCustomerClassesGet'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdCustomerClassesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsSalesPricesIdCustomerClassesGetRequest(
        $id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdCustomerClassesGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsSalesPricesIdCustomerClassesGet'
            );
        }


        $resourcePath = '/rest/items/sales_prices/{id}/customer_classes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsSalesPricesIdCustomerClassesPost
     *
     * Activate a customer class
     *
     * @param  int $id id (required)
     * @param  \ck\Model\RestItemsSalesPricesIdCustomerClassesPostRequest|null $_rest_items_sales_prices_id_customer_classes _rest_items_sales_prices_id_customer_classes (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdCustomerClassesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\SalesPriceCustomerClass
     */
    public function restItemsSalesPricesIdCustomerClassesPost(
        int $id,
        ?\ck\Model\RestItemsSalesPricesIdCustomerClassesPostRequest $_rest_items_sales_prices_id_customer_classes = null,
        string $contentType = self::contentTypes['restItemsSalesPricesIdCustomerClassesPost'][0]
    ): \ck\Model\SalesPriceCustomerClass
    {
        list($response) = $this->restItemsSalesPricesIdCustomerClassesPostWithHttpInfo($id, $_rest_items_sales_prices_id_customer_classes, $contentType);
        return $response;
    }

    /**
     * Operation restItemsSalesPricesIdCustomerClassesPostWithHttpInfo
     *
     * Activate a customer class
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsSalesPricesIdCustomerClassesPostRequest|null $_rest_items_sales_prices_id_customer_classes (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdCustomerClassesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\SalesPriceCustomerClass, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsSalesPricesIdCustomerClassesPostWithHttpInfo(
        int $id,
        ?\ck\Model\RestItemsSalesPricesIdCustomerClassesPostRequest $_rest_items_sales_prices_id_customer_classes = null,
        string $contentType = self::contentTypes['restItemsSalesPricesIdCustomerClassesPost'][0]
    ): array
    {
        $request = $this->restItemsSalesPricesIdCustomerClassesPostRequest($id, $_rest_items_sales_prices_id_customer_classes, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\SalesPriceCustomerClass' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\SalesPriceCustomerClass' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\SalesPriceCustomerClass', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\SalesPriceCustomerClass';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\SalesPriceCustomerClass',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsSalesPricesIdCustomerClassesPostAsync
     *
     * Activate a customer class
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsSalesPricesIdCustomerClassesPostRequest|null $_rest_items_sales_prices_id_customer_classes (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdCustomerClassesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsSalesPricesIdCustomerClassesPostAsync(
        int $id,
        ?\ck\Model\RestItemsSalesPricesIdCustomerClassesPostRequest $_rest_items_sales_prices_id_customer_classes = null,
        string $contentType = self::contentTypes['restItemsSalesPricesIdCustomerClassesPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsSalesPricesIdCustomerClassesPostAsyncWithHttpInfo($id, $_rest_items_sales_prices_id_customer_classes, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsSalesPricesIdCustomerClassesPostAsyncWithHttpInfo
     *
     * Activate a customer class
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsSalesPricesIdCustomerClassesPostRequest|null $_rest_items_sales_prices_id_customer_classes (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdCustomerClassesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsSalesPricesIdCustomerClassesPostAsyncWithHttpInfo(
        $id,
        $_rest_items_sales_prices_id_customer_classes = null,
        string $contentType = self::contentTypes['restItemsSalesPricesIdCustomerClassesPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\SalesPriceCustomerClass';
        $request = $this->restItemsSalesPricesIdCustomerClassesPostRequest($id, $_rest_items_sales_prices_id_customer_classes, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsSalesPricesIdCustomerClassesPost'
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsSalesPricesIdCustomerClassesPostRequest|null $_rest_items_sales_prices_id_customer_classes (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdCustomerClassesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsSalesPricesIdCustomerClassesPostRequest(
        $id,
        $_rest_items_sales_prices_id_customer_classes = null,
        string $contentType = self::contentTypes['restItemsSalesPricesIdCustomerClassesPost'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsSalesPricesIdCustomerClassesPost'
            );
        }



        $resourcePath = '/rest/items/sales_prices/{id}/customer_classes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_sales_prices_id_customer_classes)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_sales_prices_id_customer_classes));
            } else {
                $httpBody = $_rest_items_sales_prices_id_customer_classes;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsSalesPricesIdDelete
     *
     * Delete a sales price
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsSalesPricesIdDelete(
        int $id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdDelete'][0]
    ): object
    {
        list($response) = $this->restItemsSalesPricesIdDeleteWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsSalesPricesIdDeleteWithHttpInfo
     *
     * Delete a sales price
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsSalesPricesIdDeleteWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdDelete'][0]
    ): array
    {
        $request = $this->restItemsSalesPricesIdDeleteRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsSalesPricesIdDeleteAsync
     *
     * Delete a sales price
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsSalesPricesIdDeleteAsync(
        int $id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemsSalesPricesIdDeleteAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsSalesPricesIdDeleteAsyncWithHttpInfo
     *
     * Delete a sales price
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsSalesPricesIdDeleteAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsSalesPricesIdDeleteRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsSalesPricesIdDelete'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsSalesPricesIdDeleteRequest(
        $id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsSalesPricesIdDelete'
            );
        }


        $resourcePath = '/rest/items/sales_prices/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsSalesPricesIdGet
     *
     * Get a sales price
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\SalesPrice
     */
    public function restItemsSalesPricesIdGet(
        int $id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdGet'][0]
    ): \ck\Model\SalesPrice
    {
        list($response) = $this->restItemsSalesPricesIdGetWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsSalesPricesIdGetWithHttpInfo
     *
     * Get a sales price
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\SalesPrice, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsSalesPricesIdGetWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdGet'][0]
    ): array
    {
        $request = $this->restItemsSalesPricesIdGetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\SalesPrice' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\SalesPrice' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\SalesPrice', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\SalesPrice';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\SalesPrice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsSalesPricesIdGetAsync
     *
     * Get a sales price
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsSalesPricesIdGetAsync(
        int $id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsSalesPricesIdGetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsSalesPricesIdGetAsyncWithHttpInfo
     *
     * Get a sales price
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsSalesPricesIdGetAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\SalesPrice';
        $request = $this->restItemsSalesPricesIdGetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsSalesPricesIdGet'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsSalesPricesIdGetRequest(
        $id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsSalesPricesIdGet'
            );
        }


        $resourcePath = '/rest/items/sales_prices/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsSalesPricesIdNamesGet
     *
     * List names of a sales price
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdNamesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\SalesPriceName[]
     */
    public function restItemsSalesPricesIdNamesGet(
        int $id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdNamesGet'][0]
    ): array
    {
        list($response) = $this->restItemsSalesPricesIdNamesGetWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsSalesPricesIdNamesGetWithHttpInfo
     *
     * List names of a sales price
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdNamesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\SalesPriceName[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsSalesPricesIdNamesGetWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdNamesGet'][0]
    ): array
    {
        $request = $this->restItemsSalesPricesIdNamesGetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\SalesPriceName[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\SalesPriceName[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\SalesPriceName[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\SalesPriceName[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\SalesPriceName[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsSalesPricesIdNamesGetAsync
     *
     * List names of a sales price
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdNamesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsSalesPricesIdNamesGetAsync(
        int $id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdNamesGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsSalesPricesIdNamesGetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsSalesPricesIdNamesGetAsyncWithHttpInfo
     *
     * List names of a sales price
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdNamesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsSalesPricesIdNamesGetAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdNamesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\SalesPriceName[]';
        $request = $this->restItemsSalesPricesIdNamesGetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsSalesPricesIdNamesGet'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdNamesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsSalesPricesIdNamesGetRequest(
        $id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdNamesGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsSalesPricesIdNamesGet'
            );
        }


        $resourcePath = '/rest/items/sales_prices/{id}/names';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsSalesPricesIdNamesLangDelete
     *
     * Delete a sales price name
     *
     * @param  int $id id (required)
     * @param  int $lang lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdNamesLangDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsSalesPricesIdNamesLangDelete(
        int $id,
        int $lang,
        string $contentType = self::contentTypes['restItemsSalesPricesIdNamesLangDelete'][0]
    ): object
    {
        list($response) = $this->restItemsSalesPricesIdNamesLangDeleteWithHttpInfo($id, $lang, $contentType);
        return $response;
    }

    /**
     * Operation restItemsSalesPricesIdNamesLangDeleteWithHttpInfo
     *
     * Delete a sales price name
     *
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdNamesLangDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsSalesPricesIdNamesLangDeleteWithHttpInfo(
        int $id,
        int $lang,
        string $contentType = self::contentTypes['restItemsSalesPricesIdNamesLangDelete'][0]
    ): array
    {
        $request = $this->restItemsSalesPricesIdNamesLangDeleteRequest($id, $lang, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsSalesPricesIdNamesLangDeleteAsync
     *
     * Delete a sales price name
     *
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdNamesLangDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsSalesPricesIdNamesLangDeleteAsync(
        int $id,
        int $lang,
        string $contentType = self::contentTypes['restItemsSalesPricesIdNamesLangDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemsSalesPricesIdNamesLangDeleteAsyncWithHttpInfo($id, $lang, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsSalesPricesIdNamesLangDeleteAsyncWithHttpInfo
     *
     * Delete a sales price name
     *
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdNamesLangDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsSalesPricesIdNamesLangDeleteAsyncWithHttpInfo(
        $id,
        $lang,
        string $contentType = self::contentTypes['restItemsSalesPricesIdNamesLangDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsSalesPricesIdNamesLangDeleteRequest($id, $lang, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsSalesPricesIdNamesLangDelete'
     *
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdNamesLangDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsSalesPricesIdNamesLangDeleteRequest(
        $id,
        $lang,
        string $contentType = self::contentTypes['restItemsSalesPricesIdNamesLangDelete'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsSalesPricesIdNamesLangDelete'
            );
        }

        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $lang when calling restItemsSalesPricesIdNamesLangDelete'
            );
        }


        $resourcePath = '/rest/items/sales_prices/{id}/names/{lang}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($lang !== null) {
            $resourcePath = str_replace(
                '{' . 'lang' . '}',
                ObjectSerializer::toPathValue($lang),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsSalesPricesIdNamesLangGet
     *
     * Gets a sales price name
     *
     * @param  int $id id (required)
     * @param  int $lang lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdNamesLangGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\SalesPriceName
     */
    public function restItemsSalesPricesIdNamesLangGet(
        int $id,
        int $lang,
        string $contentType = self::contentTypes['restItemsSalesPricesIdNamesLangGet'][0]
    ): \ck\Model\SalesPriceName
    {
        list($response) = $this->restItemsSalesPricesIdNamesLangGetWithHttpInfo($id, $lang, $contentType);
        return $response;
    }

    /**
     * Operation restItemsSalesPricesIdNamesLangGetWithHttpInfo
     *
     * Gets a sales price name
     *
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdNamesLangGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\SalesPriceName, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsSalesPricesIdNamesLangGetWithHttpInfo(
        int $id,
        int $lang,
        string $contentType = self::contentTypes['restItemsSalesPricesIdNamesLangGet'][0]
    ): array
    {
        $request = $this->restItemsSalesPricesIdNamesLangGetRequest($id, $lang, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\SalesPriceName' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\SalesPriceName' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\SalesPriceName', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\SalesPriceName';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\SalesPriceName',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsSalesPricesIdNamesLangGetAsync
     *
     * Gets a sales price name
     *
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdNamesLangGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsSalesPricesIdNamesLangGetAsync(
        int $id,
        int $lang,
        string $contentType = self::contentTypes['restItemsSalesPricesIdNamesLangGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsSalesPricesIdNamesLangGetAsyncWithHttpInfo($id, $lang, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsSalesPricesIdNamesLangGetAsyncWithHttpInfo
     *
     * Gets a sales price name
     *
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdNamesLangGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsSalesPricesIdNamesLangGetAsyncWithHttpInfo(
        $id,
        $lang,
        string $contentType = self::contentTypes['restItemsSalesPricesIdNamesLangGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\SalesPriceName';
        $request = $this->restItemsSalesPricesIdNamesLangGetRequest($id, $lang, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsSalesPricesIdNamesLangGet'
     *
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdNamesLangGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsSalesPricesIdNamesLangGetRequest(
        $id,
        $lang,
        string $contentType = self::contentTypes['restItemsSalesPricesIdNamesLangGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsSalesPricesIdNamesLangGet'
            );
        }

        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $lang when calling restItemsSalesPricesIdNamesLangGet'
            );
        }


        $resourcePath = '/rest/items/sales_prices/{id}/names/{lang}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($lang !== null) {
            $resourcePath = str_replace(
                '{' . 'lang' . '}',
                ObjectSerializer::toPathValue($lang),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsSalesPricesIdNamesLangPut
     *
     * Update a sales price name
     *
     * @param  int $id id (required)
     * @param  int $lang lang (required)
     * @param  \ck\Model\RestItemsSalesPricesIdNamesPostRequest|null $_rest_items_sales_prices_id_names_lang _rest_items_sales_prices_id_names_lang (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdNamesLangPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\SalesPriceName
     */
    public function restItemsSalesPricesIdNamesLangPut(
        int $id,
        int $lang,
        ?\ck\Model\RestItemsSalesPricesIdNamesPostRequest $_rest_items_sales_prices_id_names_lang = null,
        string $contentType = self::contentTypes['restItemsSalesPricesIdNamesLangPut'][0]
    ): \ck\Model\SalesPriceName
    {
        list($response) = $this->restItemsSalesPricesIdNamesLangPutWithHttpInfo($id, $lang, $_rest_items_sales_prices_id_names_lang, $contentType);
        return $response;
    }

    /**
     * Operation restItemsSalesPricesIdNamesLangPutWithHttpInfo
     *
     * Update a sales price name
     *
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  \ck\Model\RestItemsSalesPricesIdNamesPostRequest|null $_rest_items_sales_prices_id_names_lang (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdNamesLangPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\SalesPriceName, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsSalesPricesIdNamesLangPutWithHttpInfo(
        int $id,
        int $lang,
        ?\ck\Model\RestItemsSalesPricesIdNamesPostRequest $_rest_items_sales_prices_id_names_lang = null,
        string $contentType = self::contentTypes['restItemsSalesPricesIdNamesLangPut'][0]
    ): array
    {
        $request = $this->restItemsSalesPricesIdNamesLangPutRequest($id, $lang, $_rest_items_sales_prices_id_names_lang, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\SalesPriceName' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\SalesPriceName' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\SalesPriceName', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\SalesPriceName';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\SalesPriceName',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsSalesPricesIdNamesLangPutAsync
     *
     * Update a sales price name
     *
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  \ck\Model\RestItemsSalesPricesIdNamesPostRequest|null $_rest_items_sales_prices_id_names_lang (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdNamesLangPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsSalesPricesIdNamesLangPutAsync(
        int $id,
        int $lang,
        ?\ck\Model\RestItemsSalesPricesIdNamesPostRequest $_rest_items_sales_prices_id_names_lang = null,
        string $contentType = self::contentTypes['restItemsSalesPricesIdNamesLangPut'][0]
    ): PromiseInterface
    {
        return $this->restItemsSalesPricesIdNamesLangPutAsyncWithHttpInfo($id, $lang, $_rest_items_sales_prices_id_names_lang, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsSalesPricesIdNamesLangPutAsyncWithHttpInfo
     *
     * Update a sales price name
     *
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  \ck\Model\RestItemsSalesPricesIdNamesPostRequest|null $_rest_items_sales_prices_id_names_lang (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdNamesLangPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsSalesPricesIdNamesLangPutAsyncWithHttpInfo(
        $id,
        $lang,
        $_rest_items_sales_prices_id_names_lang = null,
        string $contentType = self::contentTypes['restItemsSalesPricesIdNamesLangPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\SalesPriceName';
        $request = $this->restItemsSalesPricesIdNamesLangPutRequest($id, $lang, $_rest_items_sales_prices_id_names_lang, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsSalesPricesIdNamesLangPut'
     *
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  \ck\Model\RestItemsSalesPricesIdNamesPostRequest|null $_rest_items_sales_prices_id_names_lang (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdNamesLangPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsSalesPricesIdNamesLangPutRequest(
        $id,
        $lang,
        $_rest_items_sales_prices_id_names_lang = null,
        string $contentType = self::contentTypes['restItemsSalesPricesIdNamesLangPut'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsSalesPricesIdNamesLangPut'
            );
        }

        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $lang when calling restItemsSalesPricesIdNamesLangPut'
            );
        }



        $resourcePath = '/rest/items/sales_prices/{id}/names/{lang}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($lang !== null) {
            $resourcePath = str_replace(
                '{' . 'lang' . '}',
                ObjectSerializer::toPathValue($lang),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_sales_prices_id_names_lang)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_sales_prices_id_names_lang));
            } else {
                $httpBody = $_rest_items_sales_prices_id_names_lang;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsSalesPricesIdNamesPost
     *
     * Create a sales price name
     *
     * @param  int $id id (required)
     * @param  \ck\Model\RestItemsSalesPricesIdNamesPostRequest|null $_rest_items_sales_prices_id_names _rest_items_sales_prices_id_names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdNamesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\SalesPriceName
     */
    public function restItemsSalesPricesIdNamesPost(
        int $id,
        ?\ck\Model\RestItemsSalesPricesIdNamesPostRequest $_rest_items_sales_prices_id_names = null,
        string $contentType = self::contentTypes['restItemsSalesPricesIdNamesPost'][0]
    ): \ck\Model\SalesPriceName
    {
        list($response) = $this->restItemsSalesPricesIdNamesPostWithHttpInfo($id, $_rest_items_sales_prices_id_names, $contentType);
        return $response;
    }

    /**
     * Operation restItemsSalesPricesIdNamesPostWithHttpInfo
     *
     * Create a sales price name
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsSalesPricesIdNamesPostRequest|null $_rest_items_sales_prices_id_names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdNamesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\SalesPriceName, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsSalesPricesIdNamesPostWithHttpInfo(
        int $id,
        ?\ck\Model\RestItemsSalesPricesIdNamesPostRequest $_rest_items_sales_prices_id_names = null,
        string $contentType = self::contentTypes['restItemsSalesPricesIdNamesPost'][0]
    ): array
    {
        $request = $this->restItemsSalesPricesIdNamesPostRequest($id, $_rest_items_sales_prices_id_names, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\SalesPriceName' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\SalesPriceName' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\SalesPriceName', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\SalesPriceName';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\SalesPriceName',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsSalesPricesIdNamesPostAsync
     *
     * Create a sales price name
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsSalesPricesIdNamesPostRequest|null $_rest_items_sales_prices_id_names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdNamesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsSalesPricesIdNamesPostAsync(
        int $id,
        ?\ck\Model\RestItemsSalesPricesIdNamesPostRequest $_rest_items_sales_prices_id_names = null,
        string $contentType = self::contentTypes['restItemsSalesPricesIdNamesPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsSalesPricesIdNamesPostAsyncWithHttpInfo($id, $_rest_items_sales_prices_id_names, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsSalesPricesIdNamesPostAsyncWithHttpInfo
     *
     * Create a sales price name
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsSalesPricesIdNamesPostRequest|null $_rest_items_sales_prices_id_names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdNamesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsSalesPricesIdNamesPostAsyncWithHttpInfo(
        $id,
        $_rest_items_sales_prices_id_names = null,
        string $contentType = self::contentTypes['restItemsSalesPricesIdNamesPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\SalesPriceName';
        $request = $this->restItemsSalesPricesIdNamesPostRequest($id, $_rest_items_sales_prices_id_names, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsSalesPricesIdNamesPost'
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsSalesPricesIdNamesPostRequest|null $_rest_items_sales_prices_id_names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdNamesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsSalesPricesIdNamesPostRequest(
        $id,
        $_rest_items_sales_prices_id_names = null,
        string $contentType = self::contentTypes['restItemsSalesPricesIdNamesPost'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsSalesPricesIdNamesPost'
            );
        }



        $resourcePath = '/rest/items/sales_prices/{id}/names';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_sales_prices_id_names)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_sales_prices_id_names));
            } else {
                $httpBody = $_rest_items_sales_prices_id_names;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsSalesPricesIdOnlineStoresGet
     *
     * List activated clients (stores)
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdOnlineStoresGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\SalesPriceOnlineStore[]
     */
    public function restItemsSalesPricesIdOnlineStoresGet(
        int $id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdOnlineStoresGet'][0]
    ): array
    {
        list($response) = $this->restItemsSalesPricesIdOnlineStoresGetWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsSalesPricesIdOnlineStoresGetWithHttpInfo
     *
     * List activated clients (stores)
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdOnlineStoresGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\SalesPriceOnlineStore[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsSalesPricesIdOnlineStoresGetWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdOnlineStoresGet'][0]
    ): array
    {
        $request = $this->restItemsSalesPricesIdOnlineStoresGetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\SalesPriceOnlineStore[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\SalesPriceOnlineStore[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\SalesPriceOnlineStore[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\SalesPriceOnlineStore[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\SalesPriceOnlineStore[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsSalesPricesIdOnlineStoresGetAsync
     *
     * List activated clients (stores)
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdOnlineStoresGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsSalesPricesIdOnlineStoresGetAsync(
        int $id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdOnlineStoresGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsSalesPricesIdOnlineStoresGetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsSalesPricesIdOnlineStoresGetAsyncWithHttpInfo
     *
     * List activated clients (stores)
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdOnlineStoresGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsSalesPricesIdOnlineStoresGetAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdOnlineStoresGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\SalesPriceOnlineStore[]';
        $request = $this->restItemsSalesPricesIdOnlineStoresGetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsSalesPricesIdOnlineStoresGet'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdOnlineStoresGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsSalesPricesIdOnlineStoresGetRequest(
        $id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdOnlineStoresGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsSalesPricesIdOnlineStoresGet'
            );
        }


        $resourcePath = '/rest/items/sales_prices/{id}/online_stores';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsSalesPricesIdOnlineStoresPost
     *
     * Activate a client (store)
     *
     * @param  int $id id (required)
     * @param  \ck\Model\RestItemsSalesPricesIdOnlineStoresPostRequest|null $_rest_items_sales_prices_id_online_stores _rest_items_sales_prices_id_online_stores (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdOnlineStoresPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\SalesPriceOnlineStore
     */
    public function restItemsSalesPricesIdOnlineStoresPost(
        int $id,
        ?\ck\Model\RestItemsSalesPricesIdOnlineStoresPostRequest $_rest_items_sales_prices_id_online_stores = null,
        string $contentType = self::contentTypes['restItemsSalesPricesIdOnlineStoresPost'][0]
    ): \ck\Model\SalesPriceOnlineStore
    {
        list($response) = $this->restItemsSalesPricesIdOnlineStoresPostWithHttpInfo($id, $_rest_items_sales_prices_id_online_stores, $contentType);
        return $response;
    }

    /**
     * Operation restItemsSalesPricesIdOnlineStoresPostWithHttpInfo
     *
     * Activate a client (store)
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsSalesPricesIdOnlineStoresPostRequest|null $_rest_items_sales_prices_id_online_stores (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdOnlineStoresPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\SalesPriceOnlineStore, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsSalesPricesIdOnlineStoresPostWithHttpInfo(
        int $id,
        ?\ck\Model\RestItemsSalesPricesIdOnlineStoresPostRequest $_rest_items_sales_prices_id_online_stores = null,
        string $contentType = self::contentTypes['restItemsSalesPricesIdOnlineStoresPost'][0]
    ): array
    {
        $request = $this->restItemsSalesPricesIdOnlineStoresPostRequest($id, $_rest_items_sales_prices_id_online_stores, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\SalesPriceOnlineStore' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\SalesPriceOnlineStore' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\SalesPriceOnlineStore', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\SalesPriceOnlineStore';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\SalesPriceOnlineStore',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsSalesPricesIdOnlineStoresPostAsync
     *
     * Activate a client (store)
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsSalesPricesIdOnlineStoresPostRequest|null $_rest_items_sales_prices_id_online_stores (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdOnlineStoresPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsSalesPricesIdOnlineStoresPostAsync(
        int $id,
        ?\ck\Model\RestItemsSalesPricesIdOnlineStoresPostRequest $_rest_items_sales_prices_id_online_stores = null,
        string $contentType = self::contentTypes['restItemsSalesPricesIdOnlineStoresPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsSalesPricesIdOnlineStoresPostAsyncWithHttpInfo($id, $_rest_items_sales_prices_id_online_stores, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsSalesPricesIdOnlineStoresPostAsyncWithHttpInfo
     *
     * Activate a client (store)
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsSalesPricesIdOnlineStoresPostRequest|null $_rest_items_sales_prices_id_online_stores (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdOnlineStoresPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsSalesPricesIdOnlineStoresPostAsyncWithHttpInfo(
        $id,
        $_rest_items_sales_prices_id_online_stores = null,
        string $contentType = self::contentTypes['restItemsSalesPricesIdOnlineStoresPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\SalesPriceOnlineStore';
        $request = $this->restItemsSalesPricesIdOnlineStoresPostRequest($id, $_rest_items_sales_prices_id_online_stores, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsSalesPricesIdOnlineStoresPost'
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsSalesPricesIdOnlineStoresPostRequest|null $_rest_items_sales_prices_id_online_stores (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdOnlineStoresPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsSalesPricesIdOnlineStoresPostRequest(
        $id,
        $_rest_items_sales_prices_id_online_stores = null,
        string $contentType = self::contentTypes['restItemsSalesPricesIdOnlineStoresPost'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsSalesPricesIdOnlineStoresPost'
            );
        }



        $resourcePath = '/rest/items/sales_prices/{id}/online_stores';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_sales_prices_id_online_stores)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_sales_prices_id_online_stores));
            } else {
                $httpBody = $_rest_items_sales_prices_id_online_stores;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsSalesPricesIdOnlineStoresWebstoreIdDelete
     *
     * Deactivate a client (store)
     *
     * @param  int $id id (required)
     * @param  int $webstore_id webstore_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdOnlineStoresWebstoreIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsSalesPricesIdOnlineStoresWebstoreIdDelete(
        int $id,
        int $webstore_id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdOnlineStoresWebstoreIdDelete'][0]
    ): object
    {
        list($response) = $this->restItemsSalesPricesIdOnlineStoresWebstoreIdDeleteWithHttpInfo($id, $webstore_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsSalesPricesIdOnlineStoresWebstoreIdDeleteWithHttpInfo
     *
     * Deactivate a client (store)
     *
     * @param  int $id (required)
     * @param  int $webstore_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdOnlineStoresWebstoreIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsSalesPricesIdOnlineStoresWebstoreIdDeleteWithHttpInfo(
        int $id,
        int $webstore_id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdOnlineStoresWebstoreIdDelete'][0]
    ): array
    {
        $request = $this->restItemsSalesPricesIdOnlineStoresWebstoreIdDeleteRequest($id, $webstore_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsSalesPricesIdOnlineStoresWebstoreIdDeleteAsync
     *
     * Deactivate a client (store)
     *
     * @param  int $id (required)
     * @param  int $webstore_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdOnlineStoresWebstoreIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsSalesPricesIdOnlineStoresWebstoreIdDeleteAsync(
        int $id,
        int $webstore_id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdOnlineStoresWebstoreIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemsSalesPricesIdOnlineStoresWebstoreIdDeleteAsyncWithHttpInfo($id, $webstore_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsSalesPricesIdOnlineStoresWebstoreIdDeleteAsyncWithHttpInfo
     *
     * Deactivate a client (store)
     *
     * @param  int $id (required)
     * @param  int $webstore_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdOnlineStoresWebstoreIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsSalesPricesIdOnlineStoresWebstoreIdDeleteAsyncWithHttpInfo(
        $id,
        $webstore_id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdOnlineStoresWebstoreIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsSalesPricesIdOnlineStoresWebstoreIdDeleteRequest($id, $webstore_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsSalesPricesIdOnlineStoresWebstoreIdDelete'
     *
     * @param  int $id (required)
     * @param  int $webstore_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdOnlineStoresWebstoreIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsSalesPricesIdOnlineStoresWebstoreIdDeleteRequest(
        $id,
        $webstore_id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdOnlineStoresWebstoreIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsSalesPricesIdOnlineStoresWebstoreIdDelete'
            );
        }

        // verify the required parameter 'webstore_id' is set
        if ($webstore_id === null || (is_array($webstore_id) && count($webstore_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $webstore_id when calling restItemsSalesPricesIdOnlineStoresWebstoreIdDelete'
            );
        }


        $resourcePath = '/rest/items/sales_prices/{id}/online_stores/{webstoreId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($webstore_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webstoreId' . '}',
                ObjectSerializer::toPathValue($webstore_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsSalesPricesIdPut
     *
     * Update a sales price
     *
     * @param  int $id id (required)
     * @param  \ck\Model\RestItemsSalesPricesPostRequest|null $_rest_items_sales_prices_id _rest_items_sales_prices_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\SalesPrice
     */
    public function restItemsSalesPricesIdPut(
        int $id,
        ?\ck\Model\RestItemsSalesPricesPostRequest $_rest_items_sales_prices_id = null,
        string $contentType = self::contentTypes['restItemsSalesPricesIdPut'][0]
    ): \ck\Model\SalesPrice
    {
        list($response) = $this->restItemsSalesPricesIdPutWithHttpInfo($id, $_rest_items_sales_prices_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsSalesPricesIdPutWithHttpInfo
     *
     * Update a sales price
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsSalesPricesPostRequest|null $_rest_items_sales_prices_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\SalesPrice, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsSalesPricesIdPutWithHttpInfo(
        int $id,
        ?\ck\Model\RestItemsSalesPricesPostRequest $_rest_items_sales_prices_id = null,
        string $contentType = self::contentTypes['restItemsSalesPricesIdPut'][0]
    ): array
    {
        $request = $this->restItemsSalesPricesIdPutRequest($id, $_rest_items_sales_prices_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\SalesPrice' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\SalesPrice' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\SalesPrice', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\SalesPrice';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\SalesPrice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsSalesPricesIdPutAsync
     *
     * Update a sales price
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsSalesPricesPostRequest|null $_rest_items_sales_prices_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsSalesPricesIdPutAsync(
        int $id,
        ?\ck\Model\RestItemsSalesPricesPostRequest $_rest_items_sales_prices_id = null,
        string $contentType = self::contentTypes['restItemsSalesPricesIdPut'][0]
    ): PromiseInterface
    {
        return $this->restItemsSalesPricesIdPutAsyncWithHttpInfo($id, $_rest_items_sales_prices_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsSalesPricesIdPutAsyncWithHttpInfo
     *
     * Update a sales price
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsSalesPricesPostRequest|null $_rest_items_sales_prices_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsSalesPricesIdPutAsyncWithHttpInfo(
        $id,
        $_rest_items_sales_prices_id = null,
        string $contentType = self::contentTypes['restItemsSalesPricesIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\SalesPrice';
        $request = $this->restItemsSalesPricesIdPutRequest($id, $_rest_items_sales_prices_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsSalesPricesIdPut'
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsSalesPricesPostRequest|null $_rest_items_sales_prices_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsSalesPricesIdPutRequest(
        $id,
        $_rest_items_sales_prices_id = null,
        string $contentType = self::contentTypes['restItemsSalesPricesIdPut'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsSalesPricesIdPut'
            );
        }



        $resourcePath = '/rest/items/sales_prices/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_sales_prices_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_sales_prices_id));
            } else {
                $httpBody = $_rest_items_sales_prices_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsSalesPricesIdReferrersGet
     *
     * List activated referrers
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdReferrersGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\SalesPriceReferrer[]
     */
    public function restItemsSalesPricesIdReferrersGet(
        int $id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdReferrersGet'][0]
    ): array
    {
        list($response) = $this->restItemsSalesPricesIdReferrersGetWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsSalesPricesIdReferrersGetWithHttpInfo
     *
     * List activated referrers
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdReferrersGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\SalesPriceReferrer[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsSalesPricesIdReferrersGetWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdReferrersGet'][0]
    ): array
    {
        $request = $this->restItemsSalesPricesIdReferrersGetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\SalesPriceReferrer[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\SalesPriceReferrer[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\SalesPriceReferrer[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\SalesPriceReferrer[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\SalesPriceReferrer[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsSalesPricesIdReferrersGetAsync
     *
     * List activated referrers
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdReferrersGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsSalesPricesIdReferrersGetAsync(
        int $id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdReferrersGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsSalesPricesIdReferrersGetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsSalesPricesIdReferrersGetAsyncWithHttpInfo
     *
     * List activated referrers
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdReferrersGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsSalesPricesIdReferrersGetAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdReferrersGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\SalesPriceReferrer[]';
        $request = $this->restItemsSalesPricesIdReferrersGetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsSalesPricesIdReferrersGet'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdReferrersGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsSalesPricesIdReferrersGetRequest(
        $id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdReferrersGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsSalesPricesIdReferrersGet'
            );
        }


        $resourcePath = '/rest/items/sales_prices/{id}/referrers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsSalesPricesIdReferrersPost
     *
     * Activate a referrer
     *
     * @param  int $id id (required)
     * @param  \ck\Model\RestItemsSalesPricesIdReferrersPostRequest|null $_rest_items_sales_prices_id_referrers _rest_items_sales_prices_id_referrers (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdReferrersPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\SalesPriceReferrer
     */
    public function restItemsSalesPricesIdReferrersPost(
        int $id,
        ?\ck\Model\RestItemsSalesPricesIdReferrersPostRequest $_rest_items_sales_prices_id_referrers = null,
        string $contentType = self::contentTypes['restItemsSalesPricesIdReferrersPost'][0]
    ): \ck\Model\SalesPriceReferrer
    {
        list($response) = $this->restItemsSalesPricesIdReferrersPostWithHttpInfo($id, $_rest_items_sales_prices_id_referrers, $contentType);
        return $response;
    }

    /**
     * Operation restItemsSalesPricesIdReferrersPostWithHttpInfo
     *
     * Activate a referrer
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsSalesPricesIdReferrersPostRequest|null $_rest_items_sales_prices_id_referrers (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdReferrersPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\SalesPriceReferrer, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsSalesPricesIdReferrersPostWithHttpInfo(
        int $id,
        ?\ck\Model\RestItemsSalesPricesIdReferrersPostRequest $_rest_items_sales_prices_id_referrers = null,
        string $contentType = self::contentTypes['restItemsSalesPricesIdReferrersPost'][0]
    ): array
    {
        $request = $this->restItemsSalesPricesIdReferrersPostRequest($id, $_rest_items_sales_prices_id_referrers, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\SalesPriceReferrer' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\SalesPriceReferrer' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\SalesPriceReferrer', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\SalesPriceReferrer';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\SalesPriceReferrer',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsSalesPricesIdReferrersPostAsync
     *
     * Activate a referrer
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsSalesPricesIdReferrersPostRequest|null $_rest_items_sales_prices_id_referrers (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdReferrersPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsSalesPricesIdReferrersPostAsync(
        int $id,
        ?\ck\Model\RestItemsSalesPricesIdReferrersPostRequest $_rest_items_sales_prices_id_referrers = null,
        string $contentType = self::contentTypes['restItemsSalesPricesIdReferrersPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsSalesPricesIdReferrersPostAsyncWithHttpInfo($id, $_rest_items_sales_prices_id_referrers, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsSalesPricesIdReferrersPostAsyncWithHttpInfo
     *
     * Activate a referrer
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsSalesPricesIdReferrersPostRequest|null $_rest_items_sales_prices_id_referrers (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdReferrersPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsSalesPricesIdReferrersPostAsyncWithHttpInfo(
        $id,
        $_rest_items_sales_prices_id_referrers = null,
        string $contentType = self::contentTypes['restItemsSalesPricesIdReferrersPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\SalesPriceReferrer';
        $request = $this->restItemsSalesPricesIdReferrersPostRequest($id, $_rest_items_sales_prices_id_referrers, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsSalesPricesIdReferrersPost'
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsSalesPricesIdReferrersPostRequest|null $_rest_items_sales_prices_id_referrers (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdReferrersPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsSalesPricesIdReferrersPostRequest(
        $id,
        $_rest_items_sales_prices_id_referrers = null,
        string $contentType = self::contentTypes['restItemsSalesPricesIdReferrersPost'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsSalesPricesIdReferrersPost'
            );
        }



        $resourcePath = '/rest/items/sales_prices/{id}/referrers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_sales_prices_id_referrers)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_sales_prices_id_referrers));
            } else {
                $httpBody = $_rest_items_sales_prices_id_referrers;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsSalesPricesIdReferrersReferrerIdDelete
     *
     * Deactivates a referrer
     *
     * @param  int $id id (required)
     * @param  int $referrer_id referrer_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdReferrersReferrerIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsSalesPricesIdReferrersReferrerIdDelete(
        int $id,
        int $referrer_id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdReferrersReferrerIdDelete'][0]
    ): object
    {
        list($response) = $this->restItemsSalesPricesIdReferrersReferrerIdDeleteWithHttpInfo($id, $referrer_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsSalesPricesIdReferrersReferrerIdDeleteWithHttpInfo
     *
     * Deactivates a referrer
     *
     * @param  int $id (required)
     * @param  int $referrer_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdReferrersReferrerIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsSalesPricesIdReferrersReferrerIdDeleteWithHttpInfo(
        int $id,
        int $referrer_id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdReferrersReferrerIdDelete'][0]
    ): array
    {
        $request = $this->restItemsSalesPricesIdReferrersReferrerIdDeleteRequest($id, $referrer_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsSalesPricesIdReferrersReferrerIdDeleteAsync
     *
     * Deactivates a referrer
     *
     * @param  int $id (required)
     * @param  int $referrer_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdReferrersReferrerIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsSalesPricesIdReferrersReferrerIdDeleteAsync(
        int $id,
        int $referrer_id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdReferrersReferrerIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemsSalesPricesIdReferrersReferrerIdDeleteAsyncWithHttpInfo($id, $referrer_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsSalesPricesIdReferrersReferrerIdDeleteAsyncWithHttpInfo
     *
     * Deactivates a referrer
     *
     * @param  int $id (required)
     * @param  int $referrer_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdReferrersReferrerIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsSalesPricesIdReferrersReferrerIdDeleteAsyncWithHttpInfo(
        $id,
        $referrer_id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdReferrersReferrerIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsSalesPricesIdReferrersReferrerIdDeleteRequest($id, $referrer_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsSalesPricesIdReferrersReferrerIdDelete'
     *
     * @param  int $id (required)
     * @param  int $referrer_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesIdReferrersReferrerIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsSalesPricesIdReferrersReferrerIdDeleteRequest(
        $id,
        $referrer_id,
        string $contentType = self::contentTypes['restItemsSalesPricesIdReferrersReferrerIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsSalesPricesIdReferrersReferrerIdDelete'
            );
        }

        // verify the required parameter 'referrer_id' is set
        if ($referrer_id === null || (is_array($referrer_id) && count($referrer_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $referrer_id when calling restItemsSalesPricesIdReferrersReferrerIdDelete'
            );
        }


        $resourcePath = '/rest/items/sales_prices/{id}/referrers/{referrerId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($referrer_id !== null) {
            $resourcePath = str_replace(
                '{' . 'referrerId' . '}',
                ObjectSerializer::toPathValue($referrer_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsSalesPricesPost
     *
     * Create a sales price
     *
     * @param  \ck\Model\RestItemsSalesPricesPostRequest|null $_rest_items_sales_prices _rest_items_sales_prices (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\SalesPrice
     */
    public function restItemsSalesPricesPost(
        ?\ck\Model\RestItemsSalesPricesPostRequest $_rest_items_sales_prices = null,
        string $contentType = self::contentTypes['restItemsSalesPricesPost'][0]
    ): \ck\Model\SalesPrice
    {
        list($response) = $this->restItemsSalesPricesPostWithHttpInfo($_rest_items_sales_prices, $contentType);
        return $response;
    }

    /**
     * Operation restItemsSalesPricesPostWithHttpInfo
     *
     * Create a sales price
     *
     * @param  \ck\Model\RestItemsSalesPricesPostRequest|null $_rest_items_sales_prices (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\SalesPrice, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsSalesPricesPostWithHttpInfo(
        ?\ck\Model\RestItemsSalesPricesPostRequest $_rest_items_sales_prices = null,
        string $contentType = self::contentTypes['restItemsSalesPricesPost'][0]
    ): array
    {
        $request = $this->restItemsSalesPricesPostRequest($_rest_items_sales_prices, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\SalesPrice' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\SalesPrice' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\SalesPrice', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\SalesPrice';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\SalesPrice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsSalesPricesPostAsync
     *
     * Create a sales price
     *
     * @param  \ck\Model\RestItemsSalesPricesPostRequest|null $_rest_items_sales_prices (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsSalesPricesPostAsync(
        ?\ck\Model\RestItemsSalesPricesPostRequest $_rest_items_sales_prices = null,
        string $contentType = self::contentTypes['restItemsSalesPricesPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsSalesPricesPostAsyncWithHttpInfo($_rest_items_sales_prices, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsSalesPricesPostAsyncWithHttpInfo
     *
     * Create a sales price
     *
     * @param  \ck\Model\RestItemsSalesPricesPostRequest|null $_rest_items_sales_prices (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsSalesPricesPostAsyncWithHttpInfo(
        $_rest_items_sales_prices = null,
        string $contentType = self::contentTypes['restItemsSalesPricesPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\SalesPrice';
        $request = $this->restItemsSalesPricesPostRequest($_rest_items_sales_prices, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsSalesPricesPost'
     *
     * @param  \ck\Model\RestItemsSalesPricesPostRequest|null $_rest_items_sales_prices (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsSalesPricesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsSalesPricesPostRequest(
        $_rest_items_sales_prices = null,
        string $contentType = self::contentTypes['restItemsSalesPricesPost'][0]
    ): Request
    {



        $resourcePath = '/rest/items/sales_prices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_sales_prices)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_sales_prices));
            } else {
                $httpBody = $_rest_items_sales_prices;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsUnitsGet
     *
     * List units
     *
     * @param  string|null $updated_at Filter restricts the list of results to items updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsUnitsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestItemsUnitsGet200Response
     */
    public function restItemsUnitsGet(
        ?string $updated_at = null,
        string $contentType = self::contentTypes['restItemsUnitsGet'][0]
    ): \ck\Model\RestItemsUnitsGet200Response
    {
        list($response) = $this->restItemsUnitsGetWithHttpInfo($updated_at, $contentType);
        return $response;
    }

    /**
     * Operation restItemsUnitsGetWithHttpInfo
     *
     * List units
     *
     * @param  string|null $updated_at Filter restricts the list of results to items updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsUnitsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestItemsUnitsGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsUnitsGetWithHttpInfo(
        ?string $updated_at = null,
        string $contentType = self::contentTypes['restItemsUnitsGet'][0]
    ): array
    {
        $request = $this->restItemsUnitsGetRequest($updated_at, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestItemsUnitsGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestItemsUnitsGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestItemsUnitsGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestItemsUnitsGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestItemsUnitsGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsUnitsGetAsync
     *
     * List units
     *
     * @param  string|null $updated_at Filter restricts the list of results to items updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsUnitsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsUnitsGetAsync(
        ?string $updated_at = null,
        string $contentType = self::contentTypes['restItemsUnitsGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsUnitsGetAsyncWithHttpInfo($updated_at, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsUnitsGetAsyncWithHttpInfo
     *
     * List units
     *
     * @param  string|null $updated_at Filter restricts the list of results to items updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsUnitsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsUnitsGetAsyncWithHttpInfo(
        $updated_at = null,
        string $contentType = self::contentTypes['restItemsUnitsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestItemsUnitsGet200Response';
        $request = $this->restItemsUnitsGetRequest($updated_at, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsUnitsGet'
     *
     * @param  string|null $updated_at Filter restricts the list of results to items updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsUnitsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsUnitsGetRequest(
        $updated_at = null,
        string $contentType = self::contentTypes['restItemsUnitsGet'][0]
    ): Request
    {



        $resourcePath = '/rest/items/units';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_at,
            'updatedAt', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsUnitsIdDelete
     *
     * Delete a unit
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsUnitsIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsUnitsIdDelete(
        int $id,
        string $contentType = self::contentTypes['restItemsUnitsIdDelete'][0]
    ): object
    {
        list($response) = $this->restItemsUnitsIdDeleteWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsUnitsIdDeleteWithHttpInfo
     *
     * Delete a unit
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsUnitsIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsUnitsIdDeleteWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restItemsUnitsIdDelete'][0]
    ): array
    {
        $request = $this->restItemsUnitsIdDeleteRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsUnitsIdDeleteAsync
     *
     * Delete a unit
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsUnitsIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsUnitsIdDeleteAsync(
        int $id,
        string $contentType = self::contentTypes['restItemsUnitsIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemsUnitsIdDeleteAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsUnitsIdDeleteAsyncWithHttpInfo
     *
     * Delete a unit
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsUnitsIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsUnitsIdDeleteAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restItemsUnitsIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsUnitsIdDeleteRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsUnitsIdDelete'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsUnitsIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsUnitsIdDeleteRequest(
        $id,
        string $contentType = self::contentTypes['restItemsUnitsIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsUnitsIdDelete'
            );
        }


        $resourcePath = '/rest/items/units/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsUnitsIdGet
     *
     * Get a unit
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsUnitsIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Unit
     */
    public function restItemsUnitsIdGet(
        int $id,
        string $contentType = self::contentTypes['restItemsUnitsIdGet'][0]
    ): \ck\Model\Unit
    {
        list($response) = $this->restItemsUnitsIdGetWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsUnitsIdGetWithHttpInfo
     *
     * Get a unit
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsUnitsIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Unit, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsUnitsIdGetWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restItemsUnitsIdGet'][0]
    ): array
    {
        $request = $this->restItemsUnitsIdGetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Unit' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Unit' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Unit', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Unit';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Unit',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsUnitsIdGetAsync
     *
     * Get a unit
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsUnitsIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsUnitsIdGetAsync(
        int $id,
        string $contentType = self::contentTypes['restItemsUnitsIdGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsUnitsIdGetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsUnitsIdGetAsyncWithHttpInfo
     *
     * Get a unit
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsUnitsIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsUnitsIdGetAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restItemsUnitsIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Unit';
        $request = $this->restItemsUnitsIdGetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsUnitsIdGet'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsUnitsIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsUnitsIdGetRequest(
        $id,
        string $contentType = self::contentTypes['restItemsUnitsIdGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsUnitsIdGet'
            );
        }


        $resourcePath = '/rest/items/units/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsUnitsIdNamesGet
     *
     * List unit names
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsUnitsIdNamesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\UnitName[]
     */
    public function restItemsUnitsIdNamesGet(
        int $id,
        string $contentType = self::contentTypes['restItemsUnitsIdNamesGet'][0]
    ): array
    {
        list($response) = $this->restItemsUnitsIdNamesGetWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsUnitsIdNamesGetWithHttpInfo
     *
     * List unit names
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsUnitsIdNamesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\UnitName[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsUnitsIdNamesGetWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restItemsUnitsIdNamesGet'][0]
    ): array
    {
        $request = $this->restItemsUnitsIdNamesGetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\UnitName[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\UnitName[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\UnitName[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\UnitName[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\UnitName[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsUnitsIdNamesGetAsync
     *
     * List unit names
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsUnitsIdNamesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsUnitsIdNamesGetAsync(
        int $id,
        string $contentType = self::contentTypes['restItemsUnitsIdNamesGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsUnitsIdNamesGetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsUnitsIdNamesGetAsyncWithHttpInfo
     *
     * List unit names
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsUnitsIdNamesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsUnitsIdNamesGetAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restItemsUnitsIdNamesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\UnitName[]';
        $request = $this->restItemsUnitsIdNamesGetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsUnitsIdNamesGet'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsUnitsIdNamesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsUnitsIdNamesGetRequest(
        $id,
        string $contentType = self::contentTypes['restItemsUnitsIdNamesGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsUnitsIdNamesGet'
            );
        }


        $resourcePath = '/rest/items/units/{id}/names';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsUnitsIdNamesLangDelete
     *
     * Delete a unit name
     *
     * @param  int $id id (required)
     * @param  int $lang lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsUnitsIdNamesLangDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsUnitsIdNamesLangDelete(
        int $id,
        int $lang,
        string $contentType = self::contentTypes['restItemsUnitsIdNamesLangDelete'][0]
    ): object
    {
        list($response) = $this->restItemsUnitsIdNamesLangDeleteWithHttpInfo($id, $lang, $contentType);
        return $response;
    }

    /**
     * Operation restItemsUnitsIdNamesLangDeleteWithHttpInfo
     *
     * Delete a unit name
     *
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsUnitsIdNamesLangDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsUnitsIdNamesLangDeleteWithHttpInfo(
        int $id,
        int $lang,
        string $contentType = self::contentTypes['restItemsUnitsIdNamesLangDelete'][0]
    ): array
    {
        $request = $this->restItemsUnitsIdNamesLangDeleteRequest($id, $lang, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsUnitsIdNamesLangDeleteAsync
     *
     * Delete a unit name
     *
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsUnitsIdNamesLangDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsUnitsIdNamesLangDeleteAsync(
        int $id,
        int $lang,
        string $contentType = self::contentTypes['restItemsUnitsIdNamesLangDelete'][0]
    ): PromiseInterface
    {
        return $this->restItemsUnitsIdNamesLangDeleteAsyncWithHttpInfo($id, $lang, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsUnitsIdNamesLangDeleteAsyncWithHttpInfo
     *
     * Delete a unit name
     *
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsUnitsIdNamesLangDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsUnitsIdNamesLangDeleteAsyncWithHttpInfo(
        $id,
        $lang,
        string $contentType = self::contentTypes['restItemsUnitsIdNamesLangDelete'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsUnitsIdNamesLangDeleteRequest($id, $lang, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsUnitsIdNamesLangDelete'
     *
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsUnitsIdNamesLangDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsUnitsIdNamesLangDeleteRequest(
        $id,
        $lang,
        string $contentType = self::contentTypes['restItemsUnitsIdNamesLangDelete'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsUnitsIdNamesLangDelete'
            );
        }

        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $lang when calling restItemsUnitsIdNamesLangDelete'
            );
        }


        $resourcePath = '/rest/items/units/{id}/names/{lang}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($lang !== null) {
            $resourcePath = str_replace(
                '{' . 'lang' . '}',
                ObjectSerializer::toPathValue($lang),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsUnitsIdNamesLangGet
     *
     * Get a unit name
     *
     * @param  int $id id (required)
     * @param  int $lang lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsUnitsIdNamesLangGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\UnitName
     */
    public function restItemsUnitsIdNamesLangGet(
        int $id,
        int $lang,
        string $contentType = self::contentTypes['restItemsUnitsIdNamesLangGet'][0]
    ): \ck\Model\UnitName
    {
        list($response) = $this->restItemsUnitsIdNamesLangGetWithHttpInfo($id, $lang, $contentType);
        return $response;
    }

    /**
     * Operation restItemsUnitsIdNamesLangGetWithHttpInfo
     *
     * Get a unit name
     *
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsUnitsIdNamesLangGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\UnitName, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsUnitsIdNamesLangGetWithHttpInfo(
        int $id,
        int $lang,
        string $contentType = self::contentTypes['restItemsUnitsIdNamesLangGet'][0]
    ): array
    {
        $request = $this->restItemsUnitsIdNamesLangGetRequest($id, $lang, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\UnitName' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\UnitName' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\UnitName', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\UnitName';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\UnitName',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsUnitsIdNamesLangGetAsync
     *
     * Get a unit name
     *
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsUnitsIdNamesLangGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsUnitsIdNamesLangGetAsync(
        int $id,
        int $lang,
        string $contentType = self::contentTypes['restItemsUnitsIdNamesLangGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsUnitsIdNamesLangGetAsyncWithHttpInfo($id, $lang, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsUnitsIdNamesLangGetAsyncWithHttpInfo
     *
     * Get a unit name
     *
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsUnitsIdNamesLangGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsUnitsIdNamesLangGetAsyncWithHttpInfo(
        $id,
        $lang,
        string $contentType = self::contentTypes['restItemsUnitsIdNamesLangGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\UnitName';
        $request = $this->restItemsUnitsIdNamesLangGetRequest($id, $lang, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsUnitsIdNamesLangGet'
     *
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsUnitsIdNamesLangGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsUnitsIdNamesLangGetRequest(
        $id,
        $lang,
        string $contentType = self::contentTypes['restItemsUnitsIdNamesLangGet'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsUnitsIdNamesLangGet'
            );
        }

        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $lang when calling restItemsUnitsIdNamesLangGet'
            );
        }


        $resourcePath = '/rest/items/units/{id}/names/{lang}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($lang !== null) {
            $resourcePath = str_replace(
                '{' . 'lang' . '}',
                ObjectSerializer::toPathValue($lang),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsUnitsIdNamesLangPut
     *
     * Update a unit name
     *
     * @param  int $id id (required)
     * @param  int $lang lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsUnitsIdNamesLangPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\UnitName
     */
    public function restItemsUnitsIdNamesLangPut(
        int $id,
        int $lang,
        string $contentType = self::contentTypes['restItemsUnitsIdNamesLangPut'][0]
    ): \ck\Model\UnitName
    {
        list($response) = $this->restItemsUnitsIdNamesLangPutWithHttpInfo($id, $lang, $contentType);
        return $response;
    }

    /**
     * Operation restItemsUnitsIdNamesLangPutWithHttpInfo
     *
     * Update a unit name
     *
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsUnitsIdNamesLangPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\UnitName, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsUnitsIdNamesLangPutWithHttpInfo(
        int $id,
        int $lang,
        string $contentType = self::contentTypes['restItemsUnitsIdNamesLangPut'][0]
    ): array
    {
        $request = $this->restItemsUnitsIdNamesLangPutRequest($id, $lang, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\UnitName' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\UnitName' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\UnitName', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\UnitName';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\UnitName',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsUnitsIdNamesLangPutAsync
     *
     * Update a unit name
     *
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsUnitsIdNamesLangPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsUnitsIdNamesLangPutAsync(
        int $id,
        int $lang,
        string $contentType = self::contentTypes['restItemsUnitsIdNamesLangPut'][0]
    ): PromiseInterface
    {
        return $this->restItemsUnitsIdNamesLangPutAsyncWithHttpInfo($id, $lang, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsUnitsIdNamesLangPutAsyncWithHttpInfo
     *
     * Update a unit name
     *
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsUnitsIdNamesLangPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsUnitsIdNamesLangPutAsyncWithHttpInfo(
        $id,
        $lang,
        string $contentType = self::contentTypes['restItemsUnitsIdNamesLangPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\UnitName';
        $request = $this->restItemsUnitsIdNamesLangPutRequest($id, $lang, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsUnitsIdNamesLangPut'
     *
     * @param  int $id (required)
     * @param  int $lang (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsUnitsIdNamesLangPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsUnitsIdNamesLangPutRequest(
        $id,
        $lang,
        string $contentType = self::contentTypes['restItemsUnitsIdNamesLangPut'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsUnitsIdNamesLangPut'
            );
        }

        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $lang when calling restItemsUnitsIdNamesLangPut'
            );
        }


        $resourcePath = '/rest/items/units/{id}/names/{lang}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($lang !== null) {
            $resourcePath = str_replace(
                '{' . 'lang' . '}',
                ObjectSerializer::toPathValue($lang),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsUnitsIdNamesPost
     *
     * Create a unit name
     *
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsUnitsIdNamesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\UnitName
     */
    public function restItemsUnitsIdNamesPost(
        int $id,
        string $contentType = self::contentTypes['restItemsUnitsIdNamesPost'][0]
    ): \ck\Model\UnitName
    {
        list($response) = $this->restItemsUnitsIdNamesPostWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsUnitsIdNamesPostWithHttpInfo
     *
     * Create a unit name
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsUnitsIdNamesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\UnitName, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsUnitsIdNamesPostWithHttpInfo(
        int $id,
        string $contentType = self::contentTypes['restItemsUnitsIdNamesPost'][0]
    ): array
    {
        $request = $this->restItemsUnitsIdNamesPostRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\UnitName' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\UnitName' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\UnitName', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\UnitName';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\UnitName',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsUnitsIdNamesPostAsync
     *
     * Create a unit name
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsUnitsIdNamesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsUnitsIdNamesPostAsync(
        int $id,
        string $contentType = self::contentTypes['restItemsUnitsIdNamesPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsUnitsIdNamesPostAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsUnitsIdNamesPostAsyncWithHttpInfo
     *
     * Create a unit name
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsUnitsIdNamesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsUnitsIdNamesPostAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes['restItemsUnitsIdNamesPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\UnitName';
        $request = $this->restItemsUnitsIdNamesPostRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsUnitsIdNamesPost'
     *
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsUnitsIdNamesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsUnitsIdNamesPostRequest(
        $id,
        string $contentType = self::contentTypes['restItemsUnitsIdNamesPost'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsUnitsIdNamesPost'
            );
        }


        $resourcePath = '/rest/items/units/{id}/names';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsUnitsIdPut
     *
     * Update a unit
     *
     * @param  int $id id (required)
     * @param  \ck\Model\RestItemsUnitsPostRequest|null $_rest_items_units_id _rest_items_units_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsUnitsIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Unit
     */
    public function restItemsUnitsIdPut(
        int $id,
        ?\ck\Model\RestItemsUnitsPostRequest $_rest_items_units_id = null,
        string $contentType = self::contentTypes['restItemsUnitsIdPut'][0]
    ): \ck\Model\Unit
    {
        list($response) = $this->restItemsUnitsIdPutWithHttpInfo($id, $_rest_items_units_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsUnitsIdPutWithHttpInfo
     *
     * Update a unit
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsUnitsPostRequest|null $_rest_items_units_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsUnitsIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Unit, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsUnitsIdPutWithHttpInfo(
        int $id,
        ?\ck\Model\RestItemsUnitsPostRequest $_rest_items_units_id = null,
        string $contentType = self::contentTypes['restItemsUnitsIdPut'][0]
    ): array
    {
        $request = $this->restItemsUnitsIdPutRequest($id, $_rest_items_units_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Unit' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Unit' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Unit', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Unit';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Unit',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsUnitsIdPutAsync
     *
     * Update a unit
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsUnitsPostRequest|null $_rest_items_units_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsUnitsIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsUnitsIdPutAsync(
        int $id,
        ?\ck\Model\RestItemsUnitsPostRequest $_rest_items_units_id = null,
        string $contentType = self::contentTypes['restItemsUnitsIdPut'][0]
    ): PromiseInterface
    {
        return $this->restItemsUnitsIdPutAsyncWithHttpInfo($id, $_rest_items_units_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsUnitsIdPutAsyncWithHttpInfo
     *
     * Update a unit
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsUnitsPostRequest|null $_rest_items_units_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsUnitsIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsUnitsIdPutAsyncWithHttpInfo(
        $id,
        $_rest_items_units_id = null,
        string $contentType = self::contentTypes['restItemsUnitsIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Unit';
        $request = $this->restItemsUnitsIdPutRequest($id, $_rest_items_units_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsUnitsIdPut'
     *
     * @param  int $id (required)
     * @param  \ck\Model\RestItemsUnitsPostRequest|null $_rest_items_units_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsUnitsIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsUnitsIdPutRequest(
        $id,
        $_rest_items_units_id = null,
        string $contentType = self::contentTypes['restItemsUnitsIdPut'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsUnitsIdPut'
            );
        }



        $resourcePath = '/rest/items/units/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_units_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_units_id));
            } else {
                $httpBody = $_rest_items_units_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsUnitsPost
     *
     * Create a unit
     *
     * @param  \ck\Model\RestItemsUnitsPostRequest|null $_rest_items_units _rest_items_units (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsUnitsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Unit
     */
    public function restItemsUnitsPost(
        ?\ck\Model\RestItemsUnitsPostRequest $_rest_items_units = null,
        string $contentType = self::contentTypes['restItemsUnitsPost'][0]
    ): \ck\Model\Unit
    {
        list($response) = $this->restItemsUnitsPostWithHttpInfo($_rest_items_units, $contentType);
        return $response;
    }

    /**
     * Operation restItemsUnitsPostWithHttpInfo
     *
     * Create a unit
     *
     * @param  \ck\Model\RestItemsUnitsPostRequest|null $_rest_items_units (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsUnitsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Unit, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsUnitsPostWithHttpInfo(
        ?\ck\Model\RestItemsUnitsPostRequest $_rest_items_units = null,
        string $contentType = self::contentTypes['restItemsUnitsPost'][0]
    ): array
    {
        $request = $this->restItemsUnitsPostRequest($_rest_items_units, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Unit' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Unit' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Unit', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Unit';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Unit',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsUnitsPostAsync
     *
     * Create a unit
     *
     * @param  \ck\Model\RestItemsUnitsPostRequest|null $_rest_items_units (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsUnitsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsUnitsPostAsync(
        ?\ck\Model\RestItemsUnitsPostRequest $_rest_items_units = null,
        string $contentType = self::contentTypes['restItemsUnitsPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsUnitsPostAsyncWithHttpInfo($_rest_items_units, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsUnitsPostAsyncWithHttpInfo
     *
     * Create a unit
     *
     * @param  \ck\Model\RestItemsUnitsPostRequest|null $_rest_items_units (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsUnitsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsUnitsPostAsyncWithHttpInfo(
        $_rest_items_units = null,
        string $contentType = self::contentTypes['restItemsUnitsPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Unit';
        $request = $this->restItemsUnitsPostRequest($_rest_items_units, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsUnitsPost'
     *
     * @param  \ck\Model\RestItemsUnitsPostRequest|null $_rest_items_units (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsUnitsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsUnitsPostRequest(
        $_rest_items_units = null,
        string $contentType = self::contentTypes['restItemsUnitsPost'][0]
    ): Request
    {



        $resourcePath = '/rest/items/units';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_units)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_units));
            } else {
                $httpBody = $_rest_items_units;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsVariationsGet
     *
     * Search variations
     *
     * @param  string|null $with Includes the specified variation information in the results. The following parameters are available: &lt;ul&gt;&lt;li&gt;properties&lt;/b&gt; &#x3D; The properties linked to the variation&lt;/li&gt;&lt;li&gt;variationProperties&lt;/b&gt; &#x3D; The properties linked to the variation&lt;/li&gt;&lt;li&gt;variationBarcodes&lt;/b&gt; &#x3D; The barcode linked to the variation and the saved code&lt;/li&gt;&lt;li&gt;variationBundleComponents&lt;/b&gt; &#x3D; The bundle components of the variation and their quantities&lt;/li&gt;&lt;li&gt;variationComponentBundles&lt;/b&gt; &#x3D; The bundles that this variation is a component of&lt;/li&gt;&lt;li&gt;variationSalesPrices&lt;/b&gt; &#x3D; The sales prices linked to the variation and the saved price&lt;/li&gt;&lt;li&gt;marketItemNumbers&lt;/b&gt; &#x3D; The market ident number of the variation&lt;/li&gt;&lt;li&gt;variationCategories&lt;/b&gt; &#x3D; The categories linked to the variation&lt;/li&gt;&lt;li&gt;variationClients&lt;/b&gt; &#x3D; The clients (stores) for which the variation is activated&lt;/li&gt;&lt;li&gt;variationMarkets&lt;/b&gt; &#x3D; The markets for which the variation is activated &lt;/li&gt;&lt;li&gt;variationDefaultCategory&lt;/b&gt; &#x3D; The default category of the variation&lt;/li&gt;&lt;li&gt;variationSuppliers&lt;/b&gt; &#x3D; The supplier data associated with the variation&lt;/li&gt;&lt;li&gt;variationWarehouses&lt;/b&gt; &#x3D; The warehouse data associated with the variation&lt;/li&gt;&lt;li&gt;images&lt;/b&gt; &#x3D; The images linked to the variation&lt;/li&gt;&lt;li&gt;itemImages&lt;/b&gt; &#x3D; The images linked to the item&lt;/li&gt;&lt;li&gt;variationAttributeValues&lt;/b&gt; &#x3D; The attribute values of the variation&lt;/li&gt;&lt;li&gt;variationSkus&lt;/b&gt; &#x3D; The SKU data associated with the variation&lt;/li&gt;&lt;li&gt;variationAdditionalSkus&lt;/b&gt; &#x3D; The additional SKU data associated with the variation&lt;/li&gt;&lt;li&gt;unit&lt;/b&gt; &#x3D; The unit assigned to the variation&lt;/li&gt;&lt;li&gt;parent&lt;/b&gt; &#x3D; The main variation of the variation. Value is null if this variation is the item&#39;s main variation.&lt;/li&gt;&lt;li&gt;item&lt;/b&gt; &#x3D; The item of the variation&lt;/li&gt;&lt;li&gt;stock&lt;/b&gt; &#x3D; The stock data of the variation&lt;/li&gt;&lt;/ul&gt; For example, specifying the parameters variationCategories and variationDefaultCategory will include the default category and all other categories the variations are linked to. More than one parameter should be separated by commas. (optional)
     * @param  string|null $lang The &lt;a href&#x3D;&#39;https://developers.plentymarkets.com/rest-doc/introduction#countries&#39; target&#x3D;&#39;_blank&#39;&gt;language&lt;/a&gt; of the variation information. (optional)
     * @param  int|null $page Limits the results to a specific page. The page number must be specified. (optional)
     * @param  int|null $items_per_page Limits the number of results listed per page to a specific number. The number of variations to be listed per page must be specified. (optional)
     * @param  int|null $id Filter restricts the list of results to variations with the specified variation ID. An variation ID must be specified. More than one ID should be separated by commas. (optional)
     * @param  int|null $item_id Filter restricts the list of results to variations with the specified item ID. An item ID must be specified. More than one ID should be separated by commas. (optional)
     * @param  int|null $variation_tag_id Filter restricts the list of results to variations with the specified tag ID. An tag ID must be specified. More than one ID should be separated by commas. (optional)
     * @param  string|null $item_name Filter restricts the list of results to variations with the specified item name. An item name must be specified. (optional)
     * @param  string|null $flag_one Filter restricts the list of results to variations of items with the flag one. The flag one must be specified. (optional)
     * @param  string|null $flag_two Filter restricts the list of results to variations of items with the flag two. The flag two must be specified. (optional)
     * @param  int|null $store_special Filter restricts the list of results to variations of items with the specified store special. The following values are allowed: 0 (None), 1 (Special offer), 2 (New item), 3(Top item). (optional)
     * @param  int|null $category_id Filter restricts the list of results to variations with the specified category id (optional)
     * @param  bool|null $is_main Filter restricts the list of results to variations that are main variations. (optional)
     * @param  bool|null $is_active Filter restricts the list of results to variations that are active. (optional)
     * @param  string|null $barcode Filter restricts the list of results to variations with the specified barcode. A barcode must be specified. (optional)
     * @param  string|null $number_exact Filter restricts the list of results to the variation with the variation number specified. (optional)
     * @param  string|null $number_fuzzy Filter restricts the list of results to variations with numbers that contain the variation number specified (SQL LIKE operator). For example, if variations with variation numbers 1 to 400 exist in the system, filtering by 12 will list variation numbers 12, 112, 120-129, 212 and 312. (optional)
     * @param  bool|null $is_bundle Filter restricts the list of results to variations to which variations were added to create a bundle. (optional)
     * @param  int|null $plenty_id Filter restricts the list of results to variations that are visible in specified clients. Separate more than one client by commas. (optional)
     * @param  int|null $referrer_id Filter restricts the list of results to variations that are visible in specified markets. Separate more than one referrer by commas. (optional)
     * @param  string|null $supplier_number Filter restricts the list of results to variations with the specified supplier number. A supplier number must be specified. (optional)
     * @param  string|null $sku Filter restricts the list of results to variations with the specified SKU. In additional, results can also be restricted to a specific referrer by specifying the referrer ID after a colon. Example: L0R3MIP5UM:104.1 (optional)
     * @param  int|null $manufacturer_id Filter restricts the list of results to variations with the specified manufacturer ID. (optional)
     * @param  string|null $updated_between Filter restricts the list of results to variations updated during the specified period. The end date (to) is optional. If no end date is specified, variations updated between the start date (from) and the present will be listed. The dates can be specified as unix timestamps or in the ISO 8601 date format. Start date and optional end date are separated by a comma. For example, .../variations?updatedBetween&#x3D;1451606400,1456790400 will list variations updated between 2016-01-01 and 2016-03-01. .../variations?updatedBetween&#x3D;1451606400 will list variations updated since 2016-01-01. The PHP function strtotime is also supported. (optional)
     * @param  string|null $created_between Filter restricts the list of results to variations created during the specified period. The end date (to) is optional. If no end date is specified, variations created between the start date (from) and the present will be listed. The dates can be specified as unix timestamps or in the ISO 8601 date format. Start date and optional end date are separated by a comma. For example, .../variations?createdBetween&#x3D;1451606400,1456790400 will list variations created between 2016-01-01 and 2016-03-01. .../variations?createdBetween&#x3D;1451606400 will list variations created since 2016-01-01. The PHP function strtotime is also supported. (optional)
     * @param  string|null $related_updated_between Filter restricts the list of results to those variations for which related information was updated during the specified period. Related information is defined as information linked to the variation, i.e. barcodes, categories, images, markets, clients (stores), prices, suppliers, warehouses and the default category. See variationUpdatedBetween for supported formats. (optional)
     * @param  string|null $item_description Filter restricts the list of results to variations with descriptions that contain the specified string. (optional)
     * @param  string|null $stock_warehouse_id Filter restricts the list of results to variations which have physical stock on the given warehouse. (optional)
     * @param  int|null $supplier_id Filter restricts the list of results to variations with the specified supplier ID. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsVariationsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestItemsVariationsGet200Response
     */
    public function restItemsVariationsGet(
        ?string $with = null,
        ?string $lang = null,
        ?int $page = null,
        ?int $items_per_page = null,
        ?int $id = null,
        ?int $item_id = null,
        ?int $variation_tag_id = null,
        ?string $item_name = null,
        ?string $flag_one = null,
        ?string $flag_two = null,
        ?int $store_special = null,
        ?int $category_id = null,
        ?bool $is_main = null,
        ?bool $is_active = null,
        ?string $barcode = null,
        ?string $number_exact = null,
        ?string $number_fuzzy = null,
        ?bool $is_bundle = null,
        ?int $plenty_id = null,
        ?int $referrer_id = null,
        ?string $supplier_number = null,
        ?string $sku = null,
        ?int $manufacturer_id = null,
        ?string $updated_between = null,
        ?string $created_between = null,
        ?string $related_updated_between = null,
        ?string $item_description = null,
        ?string $stock_warehouse_id = null,
        ?int $supplier_id = null,
        string $contentType = self::contentTypes['restItemsVariationsGet'][0]
    ): \ck\Model\RestItemsVariationsGet200Response
    {
        list($response) = $this->restItemsVariationsGetWithHttpInfo($with, $lang, $page, $items_per_page, $id, $item_id, $variation_tag_id, $item_name, $flag_one, $flag_two, $store_special, $category_id, $is_main, $is_active, $barcode, $number_exact, $number_fuzzy, $is_bundle, $plenty_id, $referrer_id, $supplier_number, $sku, $manufacturer_id, $updated_between, $created_between, $related_updated_between, $item_description, $stock_warehouse_id, $supplier_id, $contentType);
        return $response;
    }

    /**
     * Operation restItemsVariationsGetWithHttpInfo
     *
     * Search variations
     *
     * @param  string|null $with Includes the specified variation information in the results. The following parameters are available: &lt;ul&gt;&lt;li&gt;properties&lt;/b&gt; &#x3D; The properties linked to the variation&lt;/li&gt;&lt;li&gt;variationProperties&lt;/b&gt; &#x3D; The properties linked to the variation&lt;/li&gt;&lt;li&gt;variationBarcodes&lt;/b&gt; &#x3D; The barcode linked to the variation and the saved code&lt;/li&gt;&lt;li&gt;variationBundleComponents&lt;/b&gt; &#x3D; The bundle components of the variation and their quantities&lt;/li&gt;&lt;li&gt;variationComponentBundles&lt;/b&gt; &#x3D; The bundles that this variation is a component of&lt;/li&gt;&lt;li&gt;variationSalesPrices&lt;/b&gt; &#x3D; The sales prices linked to the variation and the saved price&lt;/li&gt;&lt;li&gt;marketItemNumbers&lt;/b&gt; &#x3D; The market ident number of the variation&lt;/li&gt;&lt;li&gt;variationCategories&lt;/b&gt; &#x3D; The categories linked to the variation&lt;/li&gt;&lt;li&gt;variationClients&lt;/b&gt; &#x3D; The clients (stores) for which the variation is activated&lt;/li&gt;&lt;li&gt;variationMarkets&lt;/b&gt; &#x3D; The markets for which the variation is activated &lt;/li&gt;&lt;li&gt;variationDefaultCategory&lt;/b&gt; &#x3D; The default category of the variation&lt;/li&gt;&lt;li&gt;variationSuppliers&lt;/b&gt; &#x3D; The supplier data associated with the variation&lt;/li&gt;&lt;li&gt;variationWarehouses&lt;/b&gt; &#x3D; The warehouse data associated with the variation&lt;/li&gt;&lt;li&gt;images&lt;/b&gt; &#x3D; The images linked to the variation&lt;/li&gt;&lt;li&gt;itemImages&lt;/b&gt; &#x3D; The images linked to the item&lt;/li&gt;&lt;li&gt;variationAttributeValues&lt;/b&gt; &#x3D; The attribute values of the variation&lt;/li&gt;&lt;li&gt;variationSkus&lt;/b&gt; &#x3D; The SKU data associated with the variation&lt;/li&gt;&lt;li&gt;variationAdditionalSkus&lt;/b&gt; &#x3D; The additional SKU data associated with the variation&lt;/li&gt;&lt;li&gt;unit&lt;/b&gt; &#x3D; The unit assigned to the variation&lt;/li&gt;&lt;li&gt;parent&lt;/b&gt; &#x3D; The main variation of the variation. Value is null if this variation is the item&#39;s main variation.&lt;/li&gt;&lt;li&gt;item&lt;/b&gt; &#x3D; The item of the variation&lt;/li&gt;&lt;li&gt;stock&lt;/b&gt; &#x3D; The stock data of the variation&lt;/li&gt;&lt;/ul&gt; For example, specifying the parameters variationCategories and variationDefaultCategory will include the default category and all other categories the variations are linked to. More than one parameter should be separated by commas. (optional)
     * @param  string|null $lang The &lt;a href&#x3D;&#39;https://developers.plentymarkets.com/rest-doc/introduction#countries&#39; target&#x3D;&#39;_blank&#39;&gt;language&lt;/a&gt; of the variation information. (optional)
     * @param  int|null $page Limits the results to a specific page. The page number must be specified. (optional)
     * @param  int|null $items_per_page Limits the number of results listed per page to a specific number. The number of variations to be listed per page must be specified. (optional)
     * @param  int|null $id Filter restricts the list of results to variations with the specified variation ID. An variation ID must be specified. More than one ID should be separated by commas. (optional)
     * @param  int|null $item_id Filter restricts the list of results to variations with the specified item ID. An item ID must be specified. More than one ID should be separated by commas. (optional)
     * @param  int|null $variation_tag_id Filter restricts the list of results to variations with the specified tag ID. An tag ID must be specified. More than one ID should be separated by commas. (optional)
     * @param  string|null $item_name Filter restricts the list of results to variations with the specified item name. An item name must be specified. (optional)
     * @param  string|null $flag_one Filter restricts the list of results to variations of items with the flag one. The flag one must be specified. (optional)
     * @param  string|null $flag_two Filter restricts the list of results to variations of items with the flag two. The flag two must be specified. (optional)
     * @param  int|null $store_special Filter restricts the list of results to variations of items with the specified store special. The following values are allowed: 0 (None), 1 (Special offer), 2 (New item), 3(Top item). (optional)
     * @param  int|null $category_id Filter restricts the list of results to variations with the specified category id (optional)
     * @param  bool|null $is_main Filter restricts the list of results to variations that are main variations. (optional)
     * @param  bool|null $is_active Filter restricts the list of results to variations that are active. (optional)
     * @param  string|null $barcode Filter restricts the list of results to variations with the specified barcode. A barcode must be specified. (optional)
     * @param  string|null $number_exact Filter restricts the list of results to the variation with the variation number specified. (optional)
     * @param  string|null $number_fuzzy Filter restricts the list of results to variations with numbers that contain the variation number specified (SQL LIKE operator). For example, if variations with variation numbers 1 to 400 exist in the system, filtering by 12 will list variation numbers 12, 112, 120-129, 212 and 312. (optional)
     * @param  bool|null $is_bundle Filter restricts the list of results to variations to which variations were added to create a bundle. (optional)
     * @param  int|null $plenty_id Filter restricts the list of results to variations that are visible in specified clients. Separate more than one client by commas. (optional)
     * @param  int|null $referrer_id Filter restricts the list of results to variations that are visible in specified markets. Separate more than one referrer by commas. (optional)
     * @param  string|null $supplier_number Filter restricts the list of results to variations with the specified supplier number. A supplier number must be specified. (optional)
     * @param  string|null $sku Filter restricts the list of results to variations with the specified SKU. In additional, results can also be restricted to a specific referrer by specifying the referrer ID after a colon. Example: L0R3MIP5UM:104.1 (optional)
     * @param  int|null $manufacturer_id Filter restricts the list of results to variations with the specified manufacturer ID. (optional)
     * @param  string|null $updated_between Filter restricts the list of results to variations updated during the specified period. The end date (to) is optional. If no end date is specified, variations updated between the start date (from) and the present will be listed. The dates can be specified as unix timestamps or in the ISO 8601 date format. Start date and optional end date are separated by a comma. For example, .../variations?updatedBetween&#x3D;1451606400,1456790400 will list variations updated between 2016-01-01 and 2016-03-01. .../variations?updatedBetween&#x3D;1451606400 will list variations updated since 2016-01-01. The PHP function strtotime is also supported. (optional)
     * @param  string|null $created_between Filter restricts the list of results to variations created during the specified period. The end date (to) is optional. If no end date is specified, variations created between the start date (from) and the present will be listed. The dates can be specified as unix timestamps or in the ISO 8601 date format. Start date and optional end date are separated by a comma. For example, .../variations?createdBetween&#x3D;1451606400,1456790400 will list variations created between 2016-01-01 and 2016-03-01. .../variations?createdBetween&#x3D;1451606400 will list variations created since 2016-01-01. The PHP function strtotime is also supported. (optional)
     * @param  string|null $related_updated_between Filter restricts the list of results to those variations for which related information was updated during the specified period. Related information is defined as information linked to the variation, i.e. barcodes, categories, images, markets, clients (stores), prices, suppliers, warehouses and the default category. See variationUpdatedBetween for supported formats. (optional)
     * @param  string|null $item_description Filter restricts the list of results to variations with descriptions that contain the specified string. (optional)
     * @param  string|null $stock_warehouse_id Filter restricts the list of results to variations which have physical stock on the given warehouse. (optional)
     * @param  int|null $supplier_id Filter restricts the list of results to variations with the specified supplier ID. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsVariationsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestItemsVariationsGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsVariationsGetWithHttpInfo(
        ?string $with = null,
        ?string $lang = null,
        ?int $page = null,
        ?int $items_per_page = null,
        ?int $id = null,
        ?int $item_id = null,
        ?int $variation_tag_id = null,
        ?string $item_name = null,
        ?string $flag_one = null,
        ?string $flag_two = null,
        ?int $store_special = null,
        ?int $category_id = null,
        ?bool $is_main = null,
        ?bool $is_active = null,
        ?string $barcode = null,
        ?string $number_exact = null,
        ?string $number_fuzzy = null,
        ?bool $is_bundle = null,
        ?int $plenty_id = null,
        ?int $referrer_id = null,
        ?string $supplier_number = null,
        ?string $sku = null,
        ?int $manufacturer_id = null,
        ?string $updated_between = null,
        ?string $created_between = null,
        ?string $related_updated_between = null,
        ?string $item_description = null,
        ?string $stock_warehouse_id = null,
        ?int $supplier_id = null,
        string $contentType = self::contentTypes['restItemsVariationsGet'][0]
    ): array
    {
        $request = $this->restItemsVariationsGetRequest($with, $lang, $page, $items_per_page, $id, $item_id, $variation_tag_id, $item_name, $flag_one, $flag_two, $store_special, $category_id, $is_main, $is_active, $barcode, $number_exact, $number_fuzzy, $is_bundle, $plenty_id, $referrer_id, $supplier_number, $sku, $manufacturer_id, $updated_between, $created_between, $related_updated_between, $item_description, $stock_warehouse_id, $supplier_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestItemsVariationsGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestItemsVariationsGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestItemsVariationsGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestItemsVariationsGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestItemsVariationsGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsVariationsGetAsync
     *
     * Search variations
     *
     * @param  string|null $with Includes the specified variation information in the results. The following parameters are available: &lt;ul&gt;&lt;li&gt;properties&lt;/b&gt; &#x3D; The properties linked to the variation&lt;/li&gt;&lt;li&gt;variationProperties&lt;/b&gt; &#x3D; The properties linked to the variation&lt;/li&gt;&lt;li&gt;variationBarcodes&lt;/b&gt; &#x3D; The barcode linked to the variation and the saved code&lt;/li&gt;&lt;li&gt;variationBundleComponents&lt;/b&gt; &#x3D; The bundle components of the variation and their quantities&lt;/li&gt;&lt;li&gt;variationComponentBundles&lt;/b&gt; &#x3D; The bundles that this variation is a component of&lt;/li&gt;&lt;li&gt;variationSalesPrices&lt;/b&gt; &#x3D; The sales prices linked to the variation and the saved price&lt;/li&gt;&lt;li&gt;marketItemNumbers&lt;/b&gt; &#x3D; The market ident number of the variation&lt;/li&gt;&lt;li&gt;variationCategories&lt;/b&gt; &#x3D; The categories linked to the variation&lt;/li&gt;&lt;li&gt;variationClients&lt;/b&gt; &#x3D; The clients (stores) for which the variation is activated&lt;/li&gt;&lt;li&gt;variationMarkets&lt;/b&gt; &#x3D; The markets for which the variation is activated &lt;/li&gt;&lt;li&gt;variationDefaultCategory&lt;/b&gt; &#x3D; The default category of the variation&lt;/li&gt;&lt;li&gt;variationSuppliers&lt;/b&gt; &#x3D; The supplier data associated with the variation&lt;/li&gt;&lt;li&gt;variationWarehouses&lt;/b&gt; &#x3D; The warehouse data associated with the variation&lt;/li&gt;&lt;li&gt;images&lt;/b&gt; &#x3D; The images linked to the variation&lt;/li&gt;&lt;li&gt;itemImages&lt;/b&gt; &#x3D; The images linked to the item&lt;/li&gt;&lt;li&gt;variationAttributeValues&lt;/b&gt; &#x3D; The attribute values of the variation&lt;/li&gt;&lt;li&gt;variationSkus&lt;/b&gt; &#x3D; The SKU data associated with the variation&lt;/li&gt;&lt;li&gt;variationAdditionalSkus&lt;/b&gt; &#x3D; The additional SKU data associated with the variation&lt;/li&gt;&lt;li&gt;unit&lt;/b&gt; &#x3D; The unit assigned to the variation&lt;/li&gt;&lt;li&gt;parent&lt;/b&gt; &#x3D; The main variation of the variation. Value is null if this variation is the item&#39;s main variation.&lt;/li&gt;&lt;li&gt;item&lt;/b&gt; &#x3D; The item of the variation&lt;/li&gt;&lt;li&gt;stock&lt;/b&gt; &#x3D; The stock data of the variation&lt;/li&gt;&lt;/ul&gt; For example, specifying the parameters variationCategories and variationDefaultCategory will include the default category and all other categories the variations are linked to. More than one parameter should be separated by commas. (optional)
     * @param  string|null $lang The &lt;a href&#x3D;&#39;https://developers.plentymarkets.com/rest-doc/introduction#countries&#39; target&#x3D;&#39;_blank&#39;&gt;language&lt;/a&gt; of the variation information. (optional)
     * @param  int|null $page Limits the results to a specific page. The page number must be specified. (optional)
     * @param  int|null $items_per_page Limits the number of results listed per page to a specific number. The number of variations to be listed per page must be specified. (optional)
     * @param  int|null $id Filter restricts the list of results to variations with the specified variation ID. An variation ID must be specified. More than one ID should be separated by commas. (optional)
     * @param  int|null $item_id Filter restricts the list of results to variations with the specified item ID. An item ID must be specified. More than one ID should be separated by commas. (optional)
     * @param  int|null $variation_tag_id Filter restricts the list of results to variations with the specified tag ID. An tag ID must be specified. More than one ID should be separated by commas. (optional)
     * @param  string|null $item_name Filter restricts the list of results to variations with the specified item name. An item name must be specified. (optional)
     * @param  string|null $flag_one Filter restricts the list of results to variations of items with the flag one. The flag one must be specified. (optional)
     * @param  string|null $flag_two Filter restricts the list of results to variations of items with the flag two. The flag two must be specified. (optional)
     * @param  int|null $store_special Filter restricts the list of results to variations of items with the specified store special. The following values are allowed: 0 (None), 1 (Special offer), 2 (New item), 3(Top item). (optional)
     * @param  int|null $category_id Filter restricts the list of results to variations with the specified category id (optional)
     * @param  bool|null $is_main Filter restricts the list of results to variations that are main variations. (optional)
     * @param  bool|null $is_active Filter restricts the list of results to variations that are active. (optional)
     * @param  string|null $barcode Filter restricts the list of results to variations with the specified barcode. A barcode must be specified. (optional)
     * @param  string|null $number_exact Filter restricts the list of results to the variation with the variation number specified. (optional)
     * @param  string|null $number_fuzzy Filter restricts the list of results to variations with numbers that contain the variation number specified (SQL LIKE operator). For example, if variations with variation numbers 1 to 400 exist in the system, filtering by 12 will list variation numbers 12, 112, 120-129, 212 and 312. (optional)
     * @param  bool|null $is_bundle Filter restricts the list of results to variations to which variations were added to create a bundle. (optional)
     * @param  int|null $plenty_id Filter restricts the list of results to variations that are visible in specified clients. Separate more than one client by commas. (optional)
     * @param  int|null $referrer_id Filter restricts the list of results to variations that are visible in specified markets. Separate more than one referrer by commas. (optional)
     * @param  string|null $supplier_number Filter restricts the list of results to variations with the specified supplier number. A supplier number must be specified. (optional)
     * @param  string|null $sku Filter restricts the list of results to variations with the specified SKU. In additional, results can also be restricted to a specific referrer by specifying the referrer ID after a colon. Example: L0R3MIP5UM:104.1 (optional)
     * @param  int|null $manufacturer_id Filter restricts the list of results to variations with the specified manufacturer ID. (optional)
     * @param  string|null $updated_between Filter restricts the list of results to variations updated during the specified period. The end date (to) is optional. If no end date is specified, variations updated between the start date (from) and the present will be listed. The dates can be specified as unix timestamps or in the ISO 8601 date format. Start date and optional end date are separated by a comma. For example, .../variations?updatedBetween&#x3D;1451606400,1456790400 will list variations updated between 2016-01-01 and 2016-03-01. .../variations?updatedBetween&#x3D;1451606400 will list variations updated since 2016-01-01. The PHP function strtotime is also supported. (optional)
     * @param  string|null $created_between Filter restricts the list of results to variations created during the specified period. The end date (to) is optional. If no end date is specified, variations created between the start date (from) and the present will be listed. The dates can be specified as unix timestamps or in the ISO 8601 date format. Start date and optional end date are separated by a comma. For example, .../variations?createdBetween&#x3D;1451606400,1456790400 will list variations created between 2016-01-01 and 2016-03-01. .../variations?createdBetween&#x3D;1451606400 will list variations created since 2016-01-01. The PHP function strtotime is also supported. (optional)
     * @param  string|null $related_updated_between Filter restricts the list of results to those variations for which related information was updated during the specified period. Related information is defined as information linked to the variation, i.e. barcodes, categories, images, markets, clients (stores), prices, suppliers, warehouses and the default category. See variationUpdatedBetween for supported formats. (optional)
     * @param  string|null $item_description Filter restricts the list of results to variations with descriptions that contain the specified string. (optional)
     * @param  string|null $stock_warehouse_id Filter restricts the list of results to variations which have physical stock on the given warehouse. (optional)
     * @param  int|null $supplier_id Filter restricts the list of results to variations with the specified supplier ID. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsVariationsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsVariationsGetAsync(
        ?string $with = null,
        ?string $lang = null,
        ?int $page = null,
        ?int $items_per_page = null,
        ?int $id = null,
        ?int $item_id = null,
        ?int $variation_tag_id = null,
        ?string $item_name = null,
        ?string $flag_one = null,
        ?string $flag_two = null,
        ?int $store_special = null,
        ?int $category_id = null,
        ?bool $is_main = null,
        ?bool $is_active = null,
        ?string $barcode = null,
        ?string $number_exact = null,
        ?string $number_fuzzy = null,
        ?bool $is_bundle = null,
        ?int $plenty_id = null,
        ?int $referrer_id = null,
        ?string $supplier_number = null,
        ?string $sku = null,
        ?int $manufacturer_id = null,
        ?string $updated_between = null,
        ?string $created_between = null,
        ?string $related_updated_between = null,
        ?string $item_description = null,
        ?string $stock_warehouse_id = null,
        ?int $supplier_id = null,
        string $contentType = self::contentTypes['restItemsVariationsGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsVariationsGetAsyncWithHttpInfo($with, $lang, $page, $items_per_page, $id, $item_id, $variation_tag_id, $item_name, $flag_one, $flag_two, $store_special, $category_id, $is_main, $is_active, $barcode, $number_exact, $number_fuzzy, $is_bundle, $plenty_id, $referrer_id, $supplier_number, $sku, $manufacturer_id, $updated_between, $created_between, $related_updated_between, $item_description, $stock_warehouse_id, $supplier_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsVariationsGetAsyncWithHttpInfo
     *
     * Search variations
     *
     * @param  string|null $with Includes the specified variation information in the results. The following parameters are available: &lt;ul&gt;&lt;li&gt;properties&lt;/b&gt; &#x3D; The properties linked to the variation&lt;/li&gt;&lt;li&gt;variationProperties&lt;/b&gt; &#x3D; The properties linked to the variation&lt;/li&gt;&lt;li&gt;variationBarcodes&lt;/b&gt; &#x3D; The barcode linked to the variation and the saved code&lt;/li&gt;&lt;li&gt;variationBundleComponents&lt;/b&gt; &#x3D; The bundle components of the variation and their quantities&lt;/li&gt;&lt;li&gt;variationComponentBundles&lt;/b&gt; &#x3D; The bundles that this variation is a component of&lt;/li&gt;&lt;li&gt;variationSalesPrices&lt;/b&gt; &#x3D; The sales prices linked to the variation and the saved price&lt;/li&gt;&lt;li&gt;marketItemNumbers&lt;/b&gt; &#x3D; The market ident number of the variation&lt;/li&gt;&lt;li&gt;variationCategories&lt;/b&gt; &#x3D; The categories linked to the variation&lt;/li&gt;&lt;li&gt;variationClients&lt;/b&gt; &#x3D; The clients (stores) for which the variation is activated&lt;/li&gt;&lt;li&gt;variationMarkets&lt;/b&gt; &#x3D; The markets for which the variation is activated &lt;/li&gt;&lt;li&gt;variationDefaultCategory&lt;/b&gt; &#x3D; The default category of the variation&lt;/li&gt;&lt;li&gt;variationSuppliers&lt;/b&gt; &#x3D; The supplier data associated with the variation&lt;/li&gt;&lt;li&gt;variationWarehouses&lt;/b&gt; &#x3D; The warehouse data associated with the variation&lt;/li&gt;&lt;li&gt;images&lt;/b&gt; &#x3D; The images linked to the variation&lt;/li&gt;&lt;li&gt;itemImages&lt;/b&gt; &#x3D; The images linked to the item&lt;/li&gt;&lt;li&gt;variationAttributeValues&lt;/b&gt; &#x3D; The attribute values of the variation&lt;/li&gt;&lt;li&gt;variationSkus&lt;/b&gt; &#x3D; The SKU data associated with the variation&lt;/li&gt;&lt;li&gt;variationAdditionalSkus&lt;/b&gt; &#x3D; The additional SKU data associated with the variation&lt;/li&gt;&lt;li&gt;unit&lt;/b&gt; &#x3D; The unit assigned to the variation&lt;/li&gt;&lt;li&gt;parent&lt;/b&gt; &#x3D; The main variation of the variation. Value is null if this variation is the item&#39;s main variation.&lt;/li&gt;&lt;li&gt;item&lt;/b&gt; &#x3D; The item of the variation&lt;/li&gt;&lt;li&gt;stock&lt;/b&gt; &#x3D; The stock data of the variation&lt;/li&gt;&lt;/ul&gt; For example, specifying the parameters variationCategories and variationDefaultCategory will include the default category and all other categories the variations are linked to. More than one parameter should be separated by commas. (optional)
     * @param  string|null $lang The &lt;a href&#x3D;&#39;https://developers.plentymarkets.com/rest-doc/introduction#countries&#39; target&#x3D;&#39;_blank&#39;&gt;language&lt;/a&gt; of the variation information. (optional)
     * @param  int|null $page Limits the results to a specific page. The page number must be specified. (optional)
     * @param  int|null $items_per_page Limits the number of results listed per page to a specific number. The number of variations to be listed per page must be specified. (optional)
     * @param  int|null $id Filter restricts the list of results to variations with the specified variation ID. An variation ID must be specified. More than one ID should be separated by commas. (optional)
     * @param  int|null $item_id Filter restricts the list of results to variations with the specified item ID. An item ID must be specified. More than one ID should be separated by commas. (optional)
     * @param  int|null $variation_tag_id Filter restricts the list of results to variations with the specified tag ID. An tag ID must be specified. More than one ID should be separated by commas. (optional)
     * @param  string|null $item_name Filter restricts the list of results to variations with the specified item name. An item name must be specified. (optional)
     * @param  string|null $flag_one Filter restricts the list of results to variations of items with the flag one. The flag one must be specified. (optional)
     * @param  string|null $flag_two Filter restricts the list of results to variations of items with the flag two. The flag two must be specified. (optional)
     * @param  int|null $store_special Filter restricts the list of results to variations of items with the specified store special. The following values are allowed: 0 (None), 1 (Special offer), 2 (New item), 3(Top item). (optional)
     * @param  int|null $category_id Filter restricts the list of results to variations with the specified category id (optional)
     * @param  bool|null $is_main Filter restricts the list of results to variations that are main variations. (optional)
     * @param  bool|null $is_active Filter restricts the list of results to variations that are active. (optional)
     * @param  string|null $barcode Filter restricts the list of results to variations with the specified barcode. A barcode must be specified. (optional)
     * @param  string|null $number_exact Filter restricts the list of results to the variation with the variation number specified. (optional)
     * @param  string|null $number_fuzzy Filter restricts the list of results to variations with numbers that contain the variation number specified (SQL LIKE operator). For example, if variations with variation numbers 1 to 400 exist in the system, filtering by 12 will list variation numbers 12, 112, 120-129, 212 and 312. (optional)
     * @param  bool|null $is_bundle Filter restricts the list of results to variations to which variations were added to create a bundle. (optional)
     * @param  int|null $plenty_id Filter restricts the list of results to variations that are visible in specified clients. Separate more than one client by commas. (optional)
     * @param  int|null $referrer_id Filter restricts the list of results to variations that are visible in specified markets. Separate more than one referrer by commas. (optional)
     * @param  string|null $supplier_number Filter restricts the list of results to variations with the specified supplier number. A supplier number must be specified. (optional)
     * @param  string|null $sku Filter restricts the list of results to variations with the specified SKU. In additional, results can also be restricted to a specific referrer by specifying the referrer ID after a colon. Example: L0R3MIP5UM:104.1 (optional)
     * @param  int|null $manufacturer_id Filter restricts the list of results to variations with the specified manufacturer ID. (optional)
     * @param  string|null $updated_between Filter restricts the list of results to variations updated during the specified period. The end date (to) is optional. If no end date is specified, variations updated between the start date (from) and the present will be listed. The dates can be specified as unix timestamps or in the ISO 8601 date format. Start date and optional end date are separated by a comma. For example, .../variations?updatedBetween&#x3D;1451606400,1456790400 will list variations updated between 2016-01-01 and 2016-03-01. .../variations?updatedBetween&#x3D;1451606400 will list variations updated since 2016-01-01. The PHP function strtotime is also supported. (optional)
     * @param  string|null $created_between Filter restricts the list of results to variations created during the specified period. The end date (to) is optional. If no end date is specified, variations created between the start date (from) and the present will be listed. The dates can be specified as unix timestamps or in the ISO 8601 date format. Start date and optional end date are separated by a comma. For example, .../variations?createdBetween&#x3D;1451606400,1456790400 will list variations created between 2016-01-01 and 2016-03-01. .../variations?createdBetween&#x3D;1451606400 will list variations created since 2016-01-01. The PHP function strtotime is also supported. (optional)
     * @param  string|null $related_updated_between Filter restricts the list of results to those variations for which related information was updated during the specified period. Related information is defined as information linked to the variation, i.e. barcodes, categories, images, markets, clients (stores), prices, suppliers, warehouses and the default category. See variationUpdatedBetween for supported formats. (optional)
     * @param  string|null $item_description Filter restricts the list of results to variations with descriptions that contain the specified string. (optional)
     * @param  string|null $stock_warehouse_id Filter restricts the list of results to variations which have physical stock on the given warehouse. (optional)
     * @param  int|null $supplier_id Filter restricts the list of results to variations with the specified supplier ID. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsVariationsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsVariationsGetAsyncWithHttpInfo(
        $with = null,
        $lang = null,
        $page = null,
        $items_per_page = null,
        $id = null,
        $item_id = null,
        $variation_tag_id = null,
        $item_name = null,
        $flag_one = null,
        $flag_two = null,
        $store_special = null,
        $category_id = null,
        $is_main = null,
        $is_active = null,
        $barcode = null,
        $number_exact = null,
        $number_fuzzy = null,
        $is_bundle = null,
        $plenty_id = null,
        $referrer_id = null,
        $supplier_number = null,
        $sku = null,
        $manufacturer_id = null,
        $updated_between = null,
        $created_between = null,
        $related_updated_between = null,
        $item_description = null,
        $stock_warehouse_id = null,
        $supplier_id = null,
        string $contentType = self::contentTypes['restItemsVariationsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestItemsVariationsGet200Response';
        $request = $this->restItemsVariationsGetRequest($with, $lang, $page, $items_per_page, $id, $item_id, $variation_tag_id, $item_name, $flag_one, $flag_two, $store_special, $category_id, $is_main, $is_active, $barcode, $number_exact, $number_fuzzy, $is_bundle, $plenty_id, $referrer_id, $supplier_number, $sku, $manufacturer_id, $updated_between, $created_between, $related_updated_between, $item_description, $stock_warehouse_id, $supplier_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsVariationsGet'
     *
     * @param  string|null $with Includes the specified variation information in the results. The following parameters are available: &lt;ul&gt;&lt;li&gt;properties&lt;/b&gt; &#x3D; The properties linked to the variation&lt;/li&gt;&lt;li&gt;variationProperties&lt;/b&gt; &#x3D; The properties linked to the variation&lt;/li&gt;&lt;li&gt;variationBarcodes&lt;/b&gt; &#x3D; The barcode linked to the variation and the saved code&lt;/li&gt;&lt;li&gt;variationBundleComponents&lt;/b&gt; &#x3D; The bundle components of the variation and their quantities&lt;/li&gt;&lt;li&gt;variationComponentBundles&lt;/b&gt; &#x3D; The bundles that this variation is a component of&lt;/li&gt;&lt;li&gt;variationSalesPrices&lt;/b&gt; &#x3D; The sales prices linked to the variation and the saved price&lt;/li&gt;&lt;li&gt;marketItemNumbers&lt;/b&gt; &#x3D; The market ident number of the variation&lt;/li&gt;&lt;li&gt;variationCategories&lt;/b&gt; &#x3D; The categories linked to the variation&lt;/li&gt;&lt;li&gt;variationClients&lt;/b&gt; &#x3D; The clients (stores) for which the variation is activated&lt;/li&gt;&lt;li&gt;variationMarkets&lt;/b&gt; &#x3D; The markets for which the variation is activated &lt;/li&gt;&lt;li&gt;variationDefaultCategory&lt;/b&gt; &#x3D; The default category of the variation&lt;/li&gt;&lt;li&gt;variationSuppliers&lt;/b&gt; &#x3D; The supplier data associated with the variation&lt;/li&gt;&lt;li&gt;variationWarehouses&lt;/b&gt; &#x3D; The warehouse data associated with the variation&lt;/li&gt;&lt;li&gt;images&lt;/b&gt; &#x3D; The images linked to the variation&lt;/li&gt;&lt;li&gt;itemImages&lt;/b&gt; &#x3D; The images linked to the item&lt;/li&gt;&lt;li&gt;variationAttributeValues&lt;/b&gt; &#x3D; The attribute values of the variation&lt;/li&gt;&lt;li&gt;variationSkus&lt;/b&gt; &#x3D; The SKU data associated with the variation&lt;/li&gt;&lt;li&gt;variationAdditionalSkus&lt;/b&gt; &#x3D; The additional SKU data associated with the variation&lt;/li&gt;&lt;li&gt;unit&lt;/b&gt; &#x3D; The unit assigned to the variation&lt;/li&gt;&lt;li&gt;parent&lt;/b&gt; &#x3D; The main variation of the variation. Value is null if this variation is the item&#39;s main variation.&lt;/li&gt;&lt;li&gt;item&lt;/b&gt; &#x3D; The item of the variation&lt;/li&gt;&lt;li&gt;stock&lt;/b&gt; &#x3D; The stock data of the variation&lt;/li&gt;&lt;/ul&gt; For example, specifying the parameters variationCategories and variationDefaultCategory will include the default category and all other categories the variations are linked to. More than one parameter should be separated by commas. (optional)
     * @param  string|null $lang The &lt;a href&#x3D;&#39;https://developers.plentymarkets.com/rest-doc/introduction#countries&#39; target&#x3D;&#39;_blank&#39;&gt;language&lt;/a&gt; of the variation information. (optional)
     * @param  int|null $page Limits the results to a specific page. The page number must be specified. (optional)
     * @param  int|null $items_per_page Limits the number of results listed per page to a specific number. The number of variations to be listed per page must be specified. (optional)
     * @param  int|null $id Filter restricts the list of results to variations with the specified variation ID. An variation ID must be specified. More than one ID should be separated by commas. (optional)
     * @param  int|null $item_id Filter restricts the list of results to variations with the specified item ID. An item ID must be specified. More than one ID should be separated by commas. (optional)
     * @param  int|null $variation_tag_id Filter restricts the list of results to variations with the specified tag ID. An tag ID must be specified. More than one ID should be separated by commas. (optional)
     * @param  string|null $item_name Filter restricts the list of results to variations with the specified item name. An item name must be specified. (optional)
     * @param  string|null $flag_one Filter restricts the list of results to variations of items with the flag one. The flag one must be specified. (optional)
     * @param  string|null $flag_two Filter restricts the list of results to variations of items with the flag two. The flag two must be specified. (optional)
     * @param  int|null $store_special Filter restricts the list of results to variations of items with the specified store special. The following values are allowed: 0 (None), 1 (Special offer), 2 (New item), 3(Top item). (optional)
     * @param  int|null $category_id Filter restricts the list of results to variations with the specified category id (optional)
     * @param  bool|null $is_main Filter restricts the list of results to variations that are main variations. (optional)
     * @param  bool|null $is_active Filter restricts the list of results to variations that are active. (optional)
     * @param  string|null $barcode Filter restricts the list of results to variations with the specified barcode. A barcode must be specified. (optional)
     * @param  string|null $number_exact Filter restricts the list of results to the variation with the variation number specified. (optional)
     * @param  string|null $number_fuzzy Filter restricts the list of results to variations with numbers that contain the variation number specified (SQL LIKE operator). For example, if variations with variation numbers 1 to 400 exist in the system, filtering by 12 will list variation numbers 12, 112, 120-129, 212 and 312. (optional)
     * @param  bool|null $is_bundle Filter restricts the list of results to variations to which variations were added to create a bundle. (optional)
     * @param  int|null $plenty_id Filter restricts the list of results to variations that are visible in specified clients. Separate more than one client by commas. (optional)
     * @param  int|null $referrer_id Filter restricts the list of results to variations that are visible in specified markets. Separate more than one referrer by commas. (optional)
     * @param  string|null $supplier_number Filter restricts the list of results to variations with the specified supplier number. A supplier number must be specified. (optional)
     * @param  string|null $sku Filter restricts the list of results to variations with the specified SKU. In additional, results can also be restricted to a specific referrer by specifying the referrer ID after a colon. Example: L0R3MIP5UM:104.1 (optional)
     * @param  int|null $manufacturer_id Filter restricts the list of results to variations with the specified manufacturer ID. (optional)
     * @param  string|null $updated_between Filter restricts the list of results to variations updated during the specified period. The end date (to) is optional. If no end date is specified, variations updated between the start date (from) and the present will be listed. The dates can be specified as unix timestamps or in the ISO 8601 date format. Start date and optional end date are separated by a comma. For example, .../variations?updatedBetween&#x3D;1451606400,1456790400 will list variations updated between 2016-01-01 and 2016-03-01. .../variations?updatedBetween&#x3D;1451606400 will list variations updated since 2016-01-01. The PHP function strtotime is also supported. (optional)
     * @param  string|null $created_between Filter restricts the list of results to variations created during the specified period. The end date (to) is optional. If no end date is specified, variations created between the start date (from) and the present will be listed. The dates can be specified as unix timestamps or in the ISO 8601 date format. Start date and optional end date are separated by a comma. For example, .../variations?createdBetween&#x3D;1451606400,1456790400 will list variations created between 2016-01-01 and 2016-03-01. .../variations?createdBetween&#x3D;1451606400 will list variations created since 2016-01-01. The PHP function strtotime is also supported. (optional)
     * @param  string|null $related_updated_between Filter restricts the list of results to those variations for which related information was updated during the specified period. Related information is defined as information linked to the variation, i.e. barcodes, categories, images, markets, clients (stores), prices, suppliers, warehouses and the default category. See variationUpdatedBetween for supported formats. (optional)
     * @param  string|null $item_description Filter restricts the list of results to variations with descriptions that contain the specified string. (optional)
     * @param  string|null $stock_warehouse_id Filter restricts the list of results to variations which have physical stock on the given warehouse. (optional)
     * @param  int|null $supplier_id Filter restricts the list of results to variations with the specified supplier ID. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsVariationsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsVariationsGetRequest(
        $with = null,
        $lang = null,
        $page = null,
        $items_per_page = null,
        $id = null,
        $item_id = null,
        $variation_tag_id = null,
        $item_name = null,
        $flag_one = null,
        $flag_two = null,
        $store_special = null,
        $category_id = null,
        $is_main = null,
        $is_active = null,
        $barcode = null,
        $number_exact = null,
        $number_fuzzy = null,
        $is_bundle = null,
        $plenty_id = null,
        $referrer_id = null,
        $supplier_number = null,
        $sku = null,
        $manufacturer_id = null,
        $updated_between = null,
        $created_between = null,
        $related_updated_between = null,
        $item_description = null,
        $stock_warehouse_id = null,
        $supplier_id = null,
        string $contentType = self::contentTypes['restItemsVariationsGet'][0]
    ): Request
    {































        $resourcePath = '/rest/items/variations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $lang,
            'lang', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $items_per_page,
            'itemsPerPage', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $item_id,
            'itemId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $variation_tag_id,
            'variationTagId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $item_name,
            'itemName', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $flag_one,
            'flagOne', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $flag_two,
            'flagTwo', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $store_special,
            'storeSpecial', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $category_id,
            'categoryId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_main,
            'isMain', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_active,
            'isActive', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $barcode,
            'barcode', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $number_exact,
            'numberExact', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $number_fuzzy,
            'numberFuzzy', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_bundle,
            'isBundle', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $plenty_id,
            'plentyId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $referrer_id,
            'referrerId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $supplier_number,
            'supplierNumber', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sku,
            'sku', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $manufacturer_id,
            'manufacturerId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_between,
            'updatedBetween', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_between,
            'createdBetween', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $related_updated_between,
            'relatedUpdatedBetween', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $item_description,
            'itemDescription', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $stock_warehouse_id,
            'stockWarehouseId', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $supplier_id,
            'supplierId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsVariationsPut
     *
     * Update up to 50 variations
     *
     * @param  \ck\Model\RestItemsVariationsPutRequest|null $_rest_items_variations _rest_items_variations (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsVariationsPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsVariationsPut(
        ?\ck\Model\RestItemsVariationsPutRequest $_rest_items_variations = null,
        string $contentType = self::contentTypes['restItemsVariationsPut'][0]
    ): object
    {
        list($response) = $this->restItemsVariationsPutWithHttpInfo($_rest_items_variations, $contentType);
        return $response;
    }

    /**
     * Operation restItemsVariationsPutWithHttpInfo
     *
     * Update up to 50 variations
     *
     * @param  \ck\Model\RestItemsVariationsPutRequest|null $_rest_items_variations (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsVariationsPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsVariationsPutWithHttpInfo(
        ?\ck\Model\RestItemsVariationsPutRequest $_rest_items_variations = null,
        string $contentType = self::contentTypes['restItemsVariationsPut'][0]
    ): array
    {
        $request = $this->restItemsVariationsPutRequest($_rest_items_variations, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsVariationsPutAsync
     *
     * Update up to 50 variations
     *
     * @param  \ck\Model\RestItemsVariationsPutRequest|null $_rest_items_variations (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsVariationsPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsVariationsPutAsync(
        ?\ck\Model\RestItemsVariationsPutRequest $_rest_items_variations = null,
        string $contentType = self::contentTypes['restItemsVariationsPut'][0]
    ): PromiseInterface
    {
        return $this->restItemsVariationsPutAsyncWithHttpInfo($_rest_items_variations, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsVariationsPutAsyncWithHttpInfo
     *
     * Update up to 50 variations
     *
     * @param  \ck\Model\RestItemsVariationsPutRequest|null $_rest_items_variations (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsVariationsPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsVariationsPutAsyncWithHttpInfo(
        $_rest_items_variations = null,
        string $contentType = self::contentTypes['restItemsVariationsPut'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsVariationsPutRequest($_rest_items_variations, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsVariationsPut'
     *
     * @param  \ck\Model\RestItemsVariationsPutRequest|null $_rest_items_variations (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsVariationsPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsVariationsPutRequest(
        $_rest_items_variations = null,
        string $contentType = self::contentTypes['restItemsVariationsPut'][0]
    ): Request
    {



        $resourcePath = '/rest/items/variations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_variations)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_variations));
            } else {
                $httpBody = $_rest_items_variations;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsVariationsVariationCategoriesPost
     *
     * Bulk create category links
     *
     * @param  \ck\Model\RestItemsVariationsVariationCategoriesPutRequest|null $_rest_items_variations_variation_categories _rest_items_variations_variation_categories (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsVariationsVariationCategoriesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsVariationsVariationCategoriesPost(
        ?\ck\Model\RestItemsVariationsVariationCategoriesPutRequest $_rest_items_variations_variation_categories = null,
        string $contentType = self::contentTypes['restItemsVariationsVariationCategoriesPost'][0]
    ): object
    {
        list($response) = $this->restItemsVariationsVariationCategoriesPostWithHttpInfo($_rest_items_variations_variation_categories, $contentType);
        return $response;
    }

    /**
     * Operation restItemsVariationsVariationCategoriesPostWithHttpInfo
     *
     * Bulk create category links
     *
     * @param  \ck\Model\RestItemsVariationsVariationCategoriesPutRequest|null $_rest_items_variations_variation_categories (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsVariationsVariationCategoriesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsVariationsVariationCategoriesPostWithHttpInfo(
        ?\ck\Model\RestItemsVariationsVariationCategoriesPutRequest $_rest_items_variations_variation_categories = null,
        string $contentType = self::contentTypes['restItemsVariationsVariationCategoriesPost'][0]
    ): array
    {
        $request = $this->restItemsVariationsVariationCategoriesPostRequest($_rest_items_variations_variation_categories, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsVariationsVariationCategoriesPostAsync
     *
     * Bulk create category links
     *
     * @param  \ck\Model\RestItemsVariationsVariationCategoriesPutRequest|null $_rest_items_variations_variation_categories (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsVariationsVariationCategoriesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsVariationsVariationCategoriesPostAsync(
        ?\ck\Model\RestItemsVariationsVariationCategoriesPutRequest $_rest_items_variations_variation_categories = null,
        string $contentType = self::contentTypes['restItemsVariationsVariationCategoriesPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsVariationsVariationCategoriesPostAsyncWithHttpInfo($_rest_items_variations_variation_categories, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsVariationsVariationCategoriesPostAsyncWithHttpInfo
     *
     * Bulk create category links
     *
     * @param  \ck\Model\RestItemsVariationsVariationCategoriesPutRequest|null $_rest_items_variations_variation_categories (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsVariationsVariationCategoriesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsVariationsVariationCategoriesPostAsyncWithHttpInfo(
        $_rest_items_variations_variation_categories = null,
        string $contentType = self::contentTypes['restItemsVariationsVariationCategoriesPost'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsVariationsVariationCategoriesPostRequest($_rest_items_variations_variation_categories, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsVariationsVariationCategoriesPost'
     *
     * @param  \ck\Model\RestItemsVariationsVariationCategoriesPutRequest|null $_rest_items_variations_variation_categories (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsVariationsVariationCategoriesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsVariationsVariationCategoriesPostRequest(
        $_rest_items_variations_variation_categories = null,
        string $contentType = self::contentTypes['restItemsVariationsVariationCategoriesPost'][0]
    ): Request
    {



        $resourcePath = '/rest/items/variations/variation_categories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_variations_variation_categories)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_variations_variation_categories));
            } else {
                $httpBody = $_rest_items_variations_variation_categories;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsVariationsVariationCategoriesPut
     *
     * Bulk update category links
     *
     * @param  \ck\Model\RestItemsVariationsVariationCategoriesPutRequest|null $_rest_items_variations_variation_categories _rest_items_variations_variation_categories (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsVariationsVariationCategoriesPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsVariationsVariationCategoriesPut(
        ?\ck\Model\RestItemsVariationsVariationCategoriesPutRequest $_rest_items_variations_variation_categories = null,
        string $contentType = self::contentTypes['restItemsVariationsVariationCategoriesPut'][0]
    ): object
    {
        list($response) = $this->restItemsVariationsVariationCategoriesPutWithHttpInfo($_rest_items_variations_variation_categories, $contentType);
        return $response;
    }

    /**
     * Operation restItemsVariationsVariationCategoriesPutWithHttpInfo
     *
     * Bulk update category links
     *
     * @param  \ck\Model\RestItemsVariationsVariationCategoriesPutRequest|null $_rest_items_variations_variation_categories (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsVariationsVariationCategoriesPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsVariationsVariationCategoriesPutWithHttpInfo(
        ?\ck\Model\RestItemsVariationsVariationCategoriesPutRequest $_rest_items_variations_variation_categories = null,
        string $contentType = self::contentTypes['restItemsVariationsVariationCategoriesPut'][0]
    ): array
    {
        $request = $this->restItemsVariationsVariationCategoriesPutRequest($_rest_items_variations_variation_categories, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsVariationsVariationCategoriesPutAsync
     *
     * Bulk update category links
     *
     * @param  \ck\Model\RestItemsVariationsVariationCategoriesPutRequest|null $_rest_items_variations_variation_categories (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsVariationsVariationCategoriesPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsVariationsVariationCategoriesPutAsync(
        ?\ck\Model\RestItemsVariationsVariationCategoriesPutRequest $_rest_items_variations_variation_categories = null,
        string $contentType = self::contentTypes['restItemsVariationsVariationCategoriesPut'][0]
    ): PromiseInterface
    {
        return $this->restItemsVariationsVariationCategoriesPutAsyncWithHttpInfo($_rest_items_variations_variation_categories, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsVariationsVariationCategoriesPutAsyncWithHttpInfo
     *
     * Bulk update category links
     *
     * @param  \ck\Model\RestItemsVariationsVariationCategoriesPutRequest|null $_rest_items_variations_variation_categories (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsVariationsVariationCategoriesPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsVariationsVariationCategoriesPutAsyncWithHttpInfo(
        $_rest_items_variations_variation_categories = null,
        string $contentType = self::contentTypes['restItemsVariationsVariationCategoriesPut'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsVariationsVariationCategoriesPutRequest($_rest_items_variations_variation_categories, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsVariationsVariationCategoriesPut'
     *
     * @param  \ck\Model\RestItemsVariationsVariationCategoriesPutRequest|null $_rest_items_variations_variation_categories (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsVariationsVariationCategoriesPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsVariationsVariationCategoriesPutRequest(
        $_rest_items_variations_variation_categories = null,
        string $contentType = self::contentTypes['restItemsVariationsVariationCategoriesPut'][0]
    ): Request
    {



        $resourcePath = '/rest/items/variations/variation_categories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_variations_variation_categories)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_variations_variation_categories));
            } else {
                $httpBody = $_rest_items_variations_variation_categories;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsVariationsVariationMarketsGet
     *
     * List all links between variations and markets
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsVariationsVariationMarketsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestItemsVariationsVariationMarketsGet200Response
     */
    public function restItemsVariationsVariationMarketsGet(
        string $contentType = self::contentTypes['restItemsVariationsVariationMarketsGet'][0]
    ): \ck\Model\RestItemsVariationsVariationMarketsGet200Response
    {
        list($response) = $this->restItemsVariationsVariationMarketsGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restItemsVariationsVariationMarketsGetWithHttpInfo
     *
     * List all links between variations and markets
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsVariationsVariationMarketsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestItemsVariationsVariationMarketsGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsVariationsVariationMarketsGetWithHttpInfo(
        string $contentType = self::contentTypes['restItemsVariationsVariationMarketsGet'][0]
    ): array
    {
        $request = $this->restItemsVariationsVariationMarketsGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestItemsVariationsVariationMarketsGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestItemsVariationsVariationMarketsGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestItemsVariationsVariationMarketsGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestItemsVariationsVariationMarketsGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestItemsVariationsVariationMarketsGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsVariationsVariationMarketsGetAsync
     *
     * List all links between variations and markets
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsVariationsVariationMarketsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsVariationsVariationMarketsGetAsync(
        string $contentType = self::contentTypes['restItemsVariationsVariationMarketsGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsVariationsVariationMarketsGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsVariationsVariationMarketsGetAsyncWithHttpInfo
     *
     * List all links between variations and markets
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsVariationsVariationMarketsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsVariationsVariationMarketsGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restItemsVariationsVariationMarketsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestItemsVariationsVariationMarketsGet200Response';
        $request = $this->restItemsVariationsVariationMarketsGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsVariationsVariationMarketsGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsVariationsVariationMarketsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsVariationsVariationMarketsGetRequest(
        string $contentType = self::contentTypes['restItemsVariationsVariationMarketsGet'][0]
    ): Request
    {


        $resourcePath = '/rest/items/variations/variation_markets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsVariationsVariationMarketsPost
     *
     * Create up to 50 links between variations and markets
     *
     * @param  \ck\Model\RestItemsVariationsVariationMarketsPostRequest|null $_rest_items_variations_variation_markets _rest_items_variations_variation_markets (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsVariationsVariationMarketsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsVariationsVariationMarketsPost(
        ?\ck\Model\RestItemsVariationsVariationMarketsPostRequest $_rest_items_variations_variation_markets = null,
        string $contentType = self::contentTypes['restItemsVariationsVariationMarketsPost'][0]
    ): object
    {
        list($response) = $this->restItemsVariationsVariationMarketsPostWithHttpInfo($_rest_items_variations_variation_markets, $contentType);
        return $response;
    }

    /**
     * Operation restItemsVariationsVariationMarketsPostWithHttpInfo
     *
     * Create up to 50 links between variations and markets
     *
     * @param  \ck\Model\RestItemsVariationsVariationMarketsPostRequest|null $_rest_items_variations_variation_markets (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsVariationsVariationMarketsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsVariationsVariationMarketsPostWithHttpInfo(
        ?\ck\Model\RestItemsVariationsVariationMarketsPostRequest $_rest_items_variations_variation_markets = null,
        string $contentType = self::contentTypes['restItemsVariationsVariationMarketsPost'][0]
    ): array
    {
        $request = $this->restItemsVariationsVariationMarketsPostRequest($_rest_items_variations_variation_markets, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsVariationsVariationMarketsPostAsync
     *
     * Create up to 50 links between variations and markets
     *
     * @param  \ck\Model\RestItemsVariationsVariationMarketsPostRequest|null $_rest_items_variations_variation_markets (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsVariationsVariationMarketsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsVariationsVariationMarketsPostAsync(
        ?\ck\Model\RestItemsVariationsVariationMarketsPostRequest $_rest_items_variations_variation_markets = null,
        string $contentType = self::contentTypes['restItemsVariationsVariationMarketsPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsVariationsVariationMarketsPostAsyncWithHttpInfo($_rest_items_variations_variation_markets, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsVariationsVariationMarketsPostAsyncWithHttpInfo
     *
     * Create up to 50 links between variations and markets
     *
     * @param  \ck\Model\RestItemsVariationsVariationMarketsPostRequest|null $_rest_items_variations_variation_markets (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsVariationsVariationMarketsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsVariationsVariationMarketsPostAsyncWithHttpInfo(
        $_rest_items_variations_variation_markets = null,
        string $contentType = self::contentTypes['restItemsVariationsVariationMarketsPost'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsVariationsVariationMarketsPostRequest($_rest_items_variations_variation_markets, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsVariationsVariationMarketsPost'
     *
     * @param  \ck\Model\RestItemsVariationsVariationMarketsPostRequest|null $_rest_items_variations_variation_markets (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsVariationsVariationMarketsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsVariationsVariationMarketsPostRequest(
        $_rest_items_variations_variation_markets = null,
        string $contentType = self::contentTypes['restItemsVariationsVariationMarketsPost'][0]
    ): Request
    {



        $resourcePath = '/rest/items/variations/variation_markets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_variations_variation_markets)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_variations_variation_markets));
            } else {
                $httpBody = $_rest_items_variations_variation_markets;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsVariationsVariationPropertiesPost
     *
     * Bulk update properties
     *
     * @param  \ck\Model\RestItemsVariationsVariationPropertiesPutRequest|null $_rest_items_variations_variation_properties _rest_items_variations_variation_properties (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsVariationsVariationPropertiesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsVariationsVariationPropertiesPost(
        ?\ck\Model\RestItemsVariationsVariationPropertiesPutRequest $_rest_items_variations_variation_properties = null,
        string $contentType = self::contentTypes['restItemsVariationsVariationPropertiesPost'][0]
    ): object
    {
        list($response) = $this->restItemsVariationsVariationPropertiesPostWithHttpInfo($_rest_items_variations_variation_properties, $contentType);
        return $response;
    }

    /**
     * Operation restItemsVariationsVariationPropertiesPostWithHttpInfo
     *
     * Bulk update properties
     *
     * @param  \ck\Model\RestItemsVariationsVariationPropertiesPutRequest|null $_rest_items_variations_variation_properties (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsVariationsVariationPropertiesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsVariationsVariationPropertiesPostWithHttpInfo(
        ?\ck\Model\RestItemsVariationsVariationPropertiesPutRequest $_rest_items_variations_variation_properties = null,
        string $contentType = self::contentTypes['restItemsVariationsVariationPropertiesPost'][0]
    ): array
    {
        $request = $this->restItemsVariationsVariationPropertiesPostRequest($_rest_items_variations_variation_properties, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsVariationsVariationPropertiesPostAsync
     *
     * Bulk update properties
     *
     * @param  \ck\Model\RestItemsVariationsVariationPropertiesPutRequest|null $_rest_items_variations_variation_properties (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsVariationsVariationPropertiesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsVariationsVariationPropertiesPostAsync(
        ?\ck\Model\RestItemsVariationsVariationPropertiesPutRequest $_rest_items_variations_variation_properties = null,
        string $contentType = self::contentTypes['restItemsVariationsVariationPropertiesPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsVariationsVariationPropertiesPostAsyncWithHttpInfo($_rest_items_variations_variation_properties, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsVariationsVariationPropertiesPostAsyncWithHttpInfo
     *
     * Bulk update properties
     *
     * @param  \ck\Model\RestItemsVariationsVariationPropertiesPutRequest|null $_rest_items_variations_variation_properties (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsVariationsVariationPropertiesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsVariationsVariationPropertiesPostAsyncWithHttpInfo(
        $_rest_items_variations_variation_properties = null,
        string $contentType = self::contentTypes['restItemsVariationsVariationPropertiesPost'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsVariationsVariationPropertiesPostRequest($_rest_items_variations_variation_properties, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsVariationsVariationPropertiesPost'
     *
     * @param  \ck\Model\RestItemsVariationsVariationPropertiesPutRequest|null $_rest_items_variations_variation_properties (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsVariationsVariationPropertiesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsVariationsVariationPropertiesPostRequest(
        $_rest_items_variations_variation_properties = null,
        string $contentType = self::contentTypes['restItemsVariationsVariationPropertiesPost'][0]
    ): Request
    {



        $resourcePath = '/rest/items/variations/variation_properties';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_variations_variation_properties)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_variations_variation_properties));
            } else {
                $httpBody = $_rest_items_variations_variation_properties;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsVariationsVariationPropertiesPut
     *
     * Bulk update properties
     *
     * @param  \ck\Model\RestItemsVariationsVariationPropertiesPutRequest|null $_rest_items_variations_variation_properties _rest_items_variations_variation_properties (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsVariationsVariationPropertiesPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsVariationsVariationPropertiesPut(
        ?\ck\Model\RestItemsVariationsVariationPropertiesPutRequest $_rest_items_variations_variation_properties = null,
        string $contentType = self::contentTypes['restItemsVariationsVariationPropertiesPut'][0]
    ): object
    {
        list($response) = $this->restItemsVariationsVariationPropertiesPutWithHttpInfo($_rest_items_variations_variation_properties, $contentType);
        return $response;
    }

    /**
     * Operation restItemsVariationsVariationPropertiesPutWithHttpInfo
     *
     * Bulk update properties
     *
     * @param  \ck\Model\RestItemsVariationsVariationPropertiesPutRequest|null $_rest_items_variations_variation_properties (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsVariationsVariationPropertiesPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsVariationsVariationPropertiesPutWithHttpInfo(
        ?\ck\Model\RestItemsVariationsVariationPropertiesPutRequest $_rest_items_variations_variation_properties = null,
        string $contentType = self::contentTypes['restItemsVariationsVariationPropertiesPut'][0]
    ): array
    {
        $request = $this->restItemsVariationsVariationPropertiesPutRequest($_rest_items_variations_variation_properties, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsVariationsVariationPropertiesPutAsync
     *
     * Bulk update properties
     *
     * @param  \ck\Model\RestItemsVariationsVariationPropertiesPutRequest|null $_rest_items_variations_variation_properties (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsVariationsVariationPropertiesPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsVariationsVariationPropertiesPutAsync(
        ?\ck\Model\RestItemsVariationsVariationPropertiesPutRequest $_rest_items_variations_variation_properties = null,
        string $contentType = self::contentTypes['restItemsVariationsVariationPropertiesPut'][0]
    ): PromiseInterface
    {
        return $this->restItemsVariationsVariationPropertiesPutAsyncWithHttpInfo($_rest_items_variations_variation_properties, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsVariationsVariationPropertiesPutAsyncWithHttpInfo
     *
     * Bulk update properties
     *
     * @param  \ck\Model\RestItemsVariationsVariationPropertiesPutRequest|null $_rest_items_variations_variation_properties (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsVariationsVariationPropertiesPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsVariationsVariationPropertiesPutAsyncWithHttpInfo(
        $_rest_items_variations_variation_properties = null,
        string $contentType = self::contentTypes['restItemsVariationsVariationPropertiesPut'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsVariationsVariationPropertiesPutRequest($_rest_items_variations_variation_properties, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsVariationsVariationPropertiesPut'
     *
     * @param  \ck\Model\RestItemsVariationsVariationPropertiesPutRequest|null $_rest_items_variations_variation_properties (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsVariationsVariationPropertiesPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsVariationsVariationPropertiesPutRequest(
        $_rest_items_variations_variation_properties = null,
        string $contentType = self::contentTypes['restItemsVariationsVariationPropertiesPut'][0]
    ): Request
    {



        $resourcePath = '/rest/items/variations/variation_properties';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_variations_variation_properties)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_variations_variation_properties));
            } else {
                $httpBody = $_rest_items_variations_variation_properties;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsVariationsVariationSalesPricesGet
     *
     * Get all sales price relations
     *
     * @param  int|null $variation_id Filter that restricts the search result to the sales price data of a specific variation. (optional)
     * @param  int|null $sales_price_id Filter that restricts the search result to the sales price data of variations linked to a specific sales price. (optional)
     * @param  string|null $updated_at Filter that restricts the search result to links between variations and sales prices updated after a specific point in time. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsVariationsVariationSalesPricesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response
     */
    public function restItemsVariationsVariationSalesPricesGet(
        ?int $variation_id = null,
        ?int $sales_price_id = null,
        ?string $updated_at = null,
        string $contentType = self::contentTypes['restItemsVariationsVariationSalesPricesGet'][0]
    ): \ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response
    {
        list($response) = $this->restItemsVariationsVariationSalesPricesGetWithHttpInfo($variation_id, $sales_price_id, $updated_at, $contentType);
        return $response;
    }

    /**
     * Operation restItemsVariationsVariationSalesPricesGetWithHttpInfo
     *
     * Get all sales price relations
     *
     * @param  int|null $variation_id Filter that restricts the search result to the sales price data of a specific variation. (optional)
     * @param  int|null $sales_price_id Filter that restricts the search result to the sales price data of variations linked to a specific sales price. (optional)
     * @param  string|null $updated_at Filter that restricts the search result to links between variations and sales prices updated after a specific point in time. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsVariationsVariationSalesPricesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsVariationsVariationSalesPricesGetWithHttpInfo(
        ?int $variation_id = null,
        ?int $sales_price_id = null,
        ?string $updated_at = null,
        string $contentType = self::contentTypes['restItemsVariationsVariationSalesPricesGet'][0]
    ): array
    {
        $request = $this->restItemsVariationsVariationSalesPricesGetRequest($variation_id, $sales_price_id, $updated_at, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsVariationsVariationSalesPricesGetAsync
     *
     * Get all sales price relations
     *
     * @param  int|null $variation_id Filter that restricts the search result to the sales price data of a specific variation. (optional)
     * @param  int|null $sales_price_id Filter that restricts the search result to the sales price data of variations linked to a specific sales price. (optional)
     * @param  string|null $updated_at Filter that restricts the search result to links between variations and sales prices updated after a specific point in time. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsVariationsVariationSalesPricesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsVariationsVariationSalesPricesGetAsync(
        ?int $variation_id = null,
        ?int $sales_price_id = null,
        ?string $updated_at = null,
        string $contentType = self::contentTypes['restItemsVariationsVariationSalesPricesGet'][0]
    ): PromiseInterface
    {
        return $this->restItemsVariationsVariationSalesPricesGetAsyncWithHttpInfo($variation_id, $sales_price_id, $updated_at, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsVariationsVariationSalesPricesGetAsyncWithHttpInfo
     *
     * Get all sales price relations
     *
     * @param  int|null $variation_id Filter that restricts the search result to the sales price data of a specific variation. (optional)
     * @param  int|null $sales_price_id Filter that restricts the search result to the sales price data of variations linked to a specific sales price. (optional)
     * @param  string|null $updated_at Filter that restricts the search result to links between variations and sales prices updated after a specific point in time. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsVariationsVariationSalesPricesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsVariationsVariationSalesPricesGetAsyncWithHttpInfo(
        $variation_id = null,
        $sales_price_id = null,
        $updated_at = null,
        string $contentType = self::contentTypes['restItemsVariationsVariationSalesPricesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestAccountsContactsSalesRepresentativeRegionsGet200Response';
        $request = $this->restItemsVariationsVariationSalesPricesGetRequest($variation_id, $sales_price_id, $updated_at, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsVariationsVariationSalesPricesGet'
     *
     * @param  int|null $variation_id Filter that restricts the search result to the sales price data of a specific variation. (optional)
     * @param  int|null $sales_price_id Filter that restricts the search result to the sales price data of variations linked to a specific sales price. (optional)
     * @param  string|null $updated_at Filter that restricts the search result to links between variations and sales prices updated after a specific point in time. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsVariationsVariationSalesPricesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsVariationsVariationSalesPricesGetRequest(
        $variation_id = null,
        $sales_price_id = null,
        $updated_at = null,
        string $contentType = self::contentTypes['restItemsVariationsVariationSalesPricesGet'][0]
    ): Request
    {





        $resourcePath = '/rest/items/variations/variation_sales_prices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $variation_id,
            'variationId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sales_price_id,
            'salesPriceId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_at,
            'updatedAt', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsVariationsVariationSalesPricesPost
     *
     * Bulk create prices
     *
     * @param  \ck\Model\RestItemsVariationsVariationSalesPricesPutRequest|null $_rest_items_variations_variation_sales_prices _rest_items_variations_variation_sales_prices (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsVariationsVariationSalesPricesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsVariationsVariationSalesPricesPost(
        ?\ck\Model\RestItemsVariationsVariationSalesPricesPutRequest $_rest_items_variations_variation_sales_prices = null,
        string $contentType = self::contentTypes['restItemsVariationsVariationSalesPricesPost'][0]
    ): object
    {
        list($response) = $this->restItemsVariationsVariationSalesPricesPostWithHttpInfo($_rest_items_variations_variation_sales_prices, $contentType);
        return $response;
    }

    /**
     * Operation restItemsVariationsVariationSalesPricesPostWithHttpInfo
     *
     * Bulk create prices
     *
     * @param  \ck\Model\RestItemsVariationsVariationSalesPricesPutRequest|null $_rest_items_variations_variation_sales_prices (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsVariationsVariationSalesPricesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsVariationsVariationSalesPricesPostWithHttpInfo(
        ?\ck\Model\RestItemsVariationsVariationSalesPricesPutRequest $_rest_items_variations_variation_sales_prices = null,
        string $contentType = self::contentTypes['restItemsVariationsVariationSalesPricesPost'][0]
    ): array
    {
        $request = $this->restItemsVariationsVariationSalesPricesPostRequest($_rest_items_variations_variation_sales_prices, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsVariationsVariationSalesPricesPostAsync
     *
     * Bulk create prices
     *
     * @param  \ck\Model\RestItemsVariationsVariationSalesPricesPutRequest|null $_rest_items_variations_variation_sales_prices (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsVariationsVariationSalesPricesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsVariationsVariationSalesPricesPostAsync(
        ?\ck\Model\RestItemsVariationsVariationSalesPricesPutRequest $_rest_items_variations_variation_sales_prices = null,
        string $contentType = self::contentTypes['restItemsVariationsVariationSalesPricesPost'][0]
    ): PromiseInterface
    {
        return $this->restItemsVariationsVariationSalesPricesPostAsyncWithHttpInfo($_rest_items_variations_variation_sales_prices, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsVariationsVariationSalesPricesPostAsyncWithHttpInfo
     *
     * Bulk create prices
     *
     * @param  \ck\Model\RestItemsVariationsVariationSalesPricesPutRequest|null $_rest_items_variations_variation_sales_prices (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsVariationsVariationSalesPricesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsVariationsVariationSalesPricesPostAsyncWithHttpInfo(
        $_rest_items_variations_variation_sales_prices = null,
        string $contentType = self::contentTypes['restItemsVariationsVariationSalesPricesPost'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsVariationsVariationSalesPricesPostRequest($_rest_items_variations_variation_sales_prices, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsVariationsVariationSalesPricesPost'
     *
     * @param  \ck\Model\RestItemsVariationsVariationSalesPricesPutRequest|null $_rest_items_variations_variation_sales_prices (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsVariationsVariationSalesPricesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsVariationsVariationSalesPricesPostRequest(
        $_rest_items_variations_variation_sales_prices = null,
        string $contentType = self::contentTypes['restItemsVariationsVariationSalesPricesPost'][0]
    ): Request
    {



        $resourcePath = '/rest/items/variations/variation_sales_prices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_variations_variation_sales_prices)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_variations_variation_sales_prices));
            } else {
                $httpBody = $_rest_items_variations_variation_sales_prices;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restItemsVariationsVariationSalesPricesPut
     *
     * Bulk update prices
     *
     * @param  \ck\Model\RestItemsVariationsVariationSalesPricesPutRequest|null $_rest_items_variations_variation_sales_prices _rest_items_variations_variation_sales_prices (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsVariationsVariationSalesPricesPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restItemsVariationsVariationSalesPricesPut(
        ?\ck\Model\RestItemsVariationsVariationSalesPricesPutRequest $_rest_items_variations_variation_sales_prices = null,
        string $contentType = self::contentTypes['restItemsVariationsVariationSalesPricesPut'][0]
    ): object
    {
        list($response) = $this->restItemsVariationsVariationSalesPricesPutWithHttpInfo($_rest_items_variations_variation_sales_prices, $contentType);
        return $response;
    }

    /**
     * Operation restItemsVariationsVariationSalesPricesPutWithHttpInfo
     *
     * Bulk update prices
     *
     * @param  \ck\Model\RestItemsVariationsVariationSalesPricesPutRequest|null $_rest_items_variations_variation_sales_prices (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsVariationsVariationSalesPricesPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restItemsVariationsVariationSalesPricesPutWithHttpInfo(
        ?\ck\Model\RestItemsVariationsVariationSalesPricesPutRequest $_rest_items_variations_variation_sales_prices = null,
        string $contentType = self::contentTypes['restItemsVariationsVariationSalesPricesPut'][0]
    ): array
    {
        $request = $this->restItemsVariationsVariationSalesPricesPutRequest($_rest_items_variations_variation_sales_prices, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsVariationsVariationSalesPricesPutAsync
     *
     * Bulk update prices
     *
     * @param  \ck\Model\RestItemsVariationsVariationSalesPricesPutRequest|null $_rest_items_variations_variation_sales_prices (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsVariationsVariationSalesPricesPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsVariationsVariationSalesPricesPutAsync(
        ?\ck\Model\RestItemsVariationsVariationSalesPricesPutRequest $_rest_items_variations_variation_sales_prices = null,
        string $contentType = self::contentTypes['restItemsVariationsVariationSalesPricesPut'][0]
    ): PromiseInterface
    {
        return $this->restItemsVariationsVariationSalesPricesPutAsyncWithHttpInfo($_rest_items_variations_variation_sales_prices, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsVariationsVariationSalesPricesPutAsyncWithHttpInfo
     *
     * Bulk update prices
     *
     * @param  \ck\Model\RestItemsVariationsVariationSalesPricesPutRequest|null $_rest_items_variations_variation_sales_prices (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsVariationsVariationSalesPricesPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restItemsVariationsVariationSalesPricesPutAsyncWithHttpInfo(
        $_rest_items_variations_variation_sales_prices = null,
        string $contentType = self::contentTypes['restItemsVariationsVariationSalesPricesPut'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restItemsVariationsVariationSalesPricesPutRequest($_rest_items_variations_variation_sales_prices, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsVariationsVariationSalesPricesPut'
     *
     * @param  \ck\Model\RestItemsVariationsVariationSalesPricesPutRequest|null $_rest_items_variations_variation_sales_prices (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restItemsVariationsVariationSalesPricesPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restItemsVariationsVariationSalesPricesPutRequest(
        $_rest_items_variations_variation_sales_prices = null,
        string $contentType = self::contentTypes['restItemsVariationsVariationSalesPricesPut'][0]
    ): Request
    {



        $resourcePath = '/rest/items/variations/variation_sales_prices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_items_variations_variation_sales_prices)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_items_variations_variation_sales_prices));
            } else {
                $httpBody = $_rest_items_variations_variation_sales_prices;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption(): array
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
