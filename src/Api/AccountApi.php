<?php
/**
 * AccountApi
 * PHP version 8.1
 *
 * @package  ck
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * plentymarkets REST-API
 *
 * The plentymarkets REST API expands the functionality of the plentymarkets CMS and allows access to resources, i.e. data records, via unique URI paths
 *
 * The version of the OpenAPI document: 1.0.0
 * @generated Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 7.1.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace ck\Api;

use InvalidArgumentException;
use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use GuzzleHttp\Promise\PromiseInterface;
use ck\ApiException;
use ck\Configuration;
use ck\HeaderSelector;
use ck\ObjectSerializer;

/**
 * AccountApi Class Doc Comment
 *
 * @package  ck
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class AccountApi
{
    /**
     * @var ClientInterface
     */
    protected ClientInterface $client;

    /**
     * @var Configuration
     */
    protected Configuration $config;

    /**
     * @var HeaderSelector
     */
    protected HeaderSelector $headerSelector;

    /**
     * @var int Host index
     */
    protected int $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'restAccountLoginPost' => [
            'application/json',
        ],
        'restAccountLoginRefreshPost' => [
            'application/json',
        ],
        'restAccountLogoutPost' => [
            'application/json',
        ],
        'restAccountsAccountIdContactsGet' => [
            'application/json',
        ],
        'restAccountsAccountIdDelete' => [
            'application/json',
        ],
        'restAccountsAccountIdGet' => [
            'application/json',
        ],
        'restAccountsAccountIdPut' => [
            'application/json',
        ],
        'restAccountsAddressesAddressIdDelete' => [
            'application/json',
        ],
        'restAccountsAddressesAddressIdGet' => [
            'application/json',
        ],
        'restAccountsAddressesAddressIdOptionsDelete' => [
            'application/json',
        ],
        'restAccountsAddressesAddressIdOptionsGet' => [
            'application/json',
        ],
        'restAccountsAddressesAddressIdOptionsPost' => [
            'application/json',
        ],
        'restAccountsAddressesAddressIdOptionsPut' => [
            'application/json',
        ],
        'restAccountsAddressesAddressIdPut' => [
            'application/json',
        ],
        'restAccountsAddressesAddressIdRelatedDataGet' => [
            'application/json',
        ],
        'restAccountsAddressesContactRelationsAddressContactRelationIdDelete' => [
            'application/json',
        ],
        'restAccountsAddressesContactRelationsAddressContactRelationIdGet' => [
            'application/json',
        ],
        'restAccountsAddressesContactRelationsGet' => [
            'application/json',
        ],
        'restAccountsAddressesContactRelationsPost' => [
            'application/json',
        ],
        'restAccountsAddressesContactRelationsPut' => [
            'application/json',
        ],
        'restAccountsAddressesGet' => [
            'application/json',
        ],
        'restAccountsAddressesOptionTypesGet' => [
            'application/json',
        ],
        'restAccountsAddressesOptionTypesOptionTypeIdDelete' => [
            'application/json',
        ],
        'restAccountsAddressesOptionTypesOptionTypeIdGet' => [
            'application/json',
        ],
        'restAccountsAddressesOptionTypesOptionTypeIdPut' => [
            'application/json',
        ],
        'restAccountsAddressesOptionTypesPost' => [
            'application/json',
        ],
        'restAccountsAddressesOptionsOptionIdDelete' => [
            'application/json',
        ],
        'restAccountsAddressesOptionsOptionIdGet' => [
            'application/json',
        ],
        'restAccountsAddressesOptionsOptionIdPut' => [
            'application/json',
        ],
        'restAccountsAddressesPosRelationsAddressPosRelationIdDelete' => [
            'application/json',
        ],
        'restAccountsAddressesPosRelationsAddressPosRelationIdGet' => [
            'application/json',
        ],
        'restAccountsAddressesPosRelationsAddressPosRelationIdPut' => [
            'application/json',
        ],
        'restAccountsAddressesPosRelationsGet' => [
            'application/json',
        ],
        'restAccountsAddressesPosRelationsPost' => [
            'application/json',
        ],
        'restAccountsAddressesPost' => [
            'application/json',
        ],
        'restAccountsAddressesRelationTypesGet' => [
            'application/json',
        ],
        'restAccountsAddressesRelationsTypesApplicationsApplicationLangGet' => [
            'application/json',
        ],
        'restAccountsAddressesWarehouseRelationsPost' => [
            'application/json',
        ],
        'restAccountsAddressesWarehouseRelationsRelationIdDelete' => [
            'application/json',
        ],
        'restAccountsAddressesWarehouseRelationsRelationIdPut' => [
            'application/json',
        ],
        'restAccountsContactRelationsAccountContactRelationIdDelete' => [
            'application/json',
        ],
        'restAccountsContactRelationsAccountContactRelationIdGet' => [
            'application/json',
        ],
        'restAccountsContactsBanksContactBankIdDelete' => [
            'application/json',
        ],
        'restAccountsContactsBanksContactBankIdGet' => [
            'application/json',
        ],
        'restAccountsContactsBanksContactBankIdPut' => [
            'application/json',
        ],
        'restAccountsContactsBanksPost' => [
            'application/json',
        ],
        'restAccountsContactsClassesContactClassIdGet' => [
            'application/json',
        ],
        'restAccountsContactsClassesGet' => [
            'application/json',
        ],
        'restAccountsContactsContactEventsContactEventIdDelete' => [
            'application/json',
        ],
        'restAccountsContactsContactEventsContactEventIdPut' => [
            'application/json',
        ],
        'restAccountsContactsContactEventsGet' => [
            'application/json',
        ],
        'restAccountsContactsContactEventsPost' => [
            'application/json',
        ],
        'restAccountsContactsContactEventsTypesPreviewGet' => [
            'application/json',
        ],
        'restAccountsContactsContactIdAccessDataLoginUrlGet' => [
            'application/json',
        ],
        'restAccountsContactsContactIdAccessDataNewPasswordPut' => [
            'application/json',
        ],
        'restAccountsContactsContactIdAccessDataSetPasswordPut' => [
            'application/json',
        ],
        'restAccountsContactsContactIdAccessDataUnblockUserPut' => [
            'application/json',
        ],
        'restAccountsContactsContactIdAccountsAccountIdDelete' => [
            'application/json',
        ],
        'restAccountsContactsContactIdAccountsAccountIdGet' => [
            'application/json',
        ],
        'restAccountsContactsContactIdAccountsAccountIdPut' => [
            'application/json',
        ],
        'restAccountsContactsContactIdAccountsPost' => [
            'application/json',
        ],
        'restAccountsContactsContactIdAddressesAddressIdDelete' => [
            'application/json',
        ],
        'restAccountsContactsContactIdAddressesAddressIdPut' => [
            'application/json',
        ],
        'restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPut' => [
            'application/json',
        ],
        'restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPut' => [
            'application/json',
        ],
        'restAccountsContactsContactIdAddressesPost' => [
            'application/json',
        ],
        'restAccountsContactsContactIdAddressesPrimaryGet' => [
            'application/json',
        ],
        'restAccountsContactsContactIdBanksGet' => [
            'application/json',
        ],
        'restAccountsContactsContactIdContactEventsGet' => [
            'application/json',
        ],
        'restAccountsContactsContactIdDelete' => [
            'application/json',
        ],
        'restAccountsContactsContactIdGet' => [
            'application/json',
        ],
        'restAccountsContactsContactIdOptionsDelete' => [
            'application/json',
        ],
        'restAccountsContactsContactIdOptionsGet' => [
            'application/json',
        ],
        'restAccountsContactsContactIdOptionsPost' => [
            'application/json',
        ],
        'restAccountsContactsContactIdOptionsPut' => [
            'application/json',
        ],
        'restAccountsContactsContactIdOptionsValidateGet' => [
            'application/json',
        ],
        'restAccountsContactsContactIdPut' => [
            'application/json',
        ],
        'restAccountsContactsContactIdRelatedDataGet' => [
            'application/json',
        ],
        'restAccountsContactsContactIdVcardGet' => [
            'application/json',
        ],
        'restAccountsContactsDepartmentsDepartmentIdDelete' => [
            'application/json',
        ],
        'restAccountsContactsDepartmentsDepartmentIdGet' => [
            'application/json',
        ],
        'restAccountsContactsDepartmentsDepartmentIdPut' => [
            'application/json',
        ],
        'restAccountsContactsDepartmentsGet' => [
            'application/json',
        ],
        'restAccountsContactsDepartmentsPost' => [
            'application/json',
        ],
        'restAccountsContactsGet' => [
            'application/json',
        ],
        'restAccountsContactsGroupFunctionsGet' => [
            'application/json',
        ],
        'restAccountsContactsGroupFunctionsPost' => [
            'application/json',
        ],
        'restAccountsContactsOptionSubTypesGet' => [
            'application/json',
        ],
        'restAccountsContactsOptionSubTypesOptionSubTypeIdDelete' => [
            'application/json',
        ],
        'restAccountsContactsOptionSubTypesOptionSubTypeIdGet' => [
            'application/json',
        ],
        'restAccountsContactsOptionSubTypesOptionSubTypeIdPut' => [
            'application/json',
        ],
        'restAccountsContactsOptionSubTypesPost' => [
            'application/json',
        ],
        'restAccountsContactsOptionTypesGet' => [
            'application/json',
        ],
        'restAccountsContactsOptionTypesOptionTypeIdDelete' => [
            'application/json',
        ],
        'restAccountsContactsOptionTypesOptionTypeIdGet' => [
            'application/json',
        ],
        'restAccountsContactsOptionTypesOptionTypeIdPut' => [
            'application/json',
        ],
        'restAccountsContactsOptionTypesPost' => [
            'application/json',
        ],
        'restAccountsContactsOptionsOptionIdDelete' => [
            'application/json',
        ],
        'restAccountsContactsOptionsOptionIdGet' => [
            'application/json',
        ],
        'restAccountsContactsOptionsOptionIdPut' => [
            'application/json',
        ],
        'restAccountsContactsPositionsGet' => [
            'application/json',
        ],
        'restAccountsContactsPositionsPositionIdDelete' => [
            'application/json',
        ],
        'restAccountsContactsPositionsPositionIdGet' => [
            'application/json',
        ],
        'restAccountsContactsPositionsPositionIdPut' => [
            'application/json',
        ],
        'restAccountsContactsPositionsPost' => [
            'application/json',
        ],
        'restAccountsContactsPost' => [
            'application/json',
        ],
        'restAccountsContactsTypesGet' => [
            'application/json',
        ],
        'restAccountsContactsTypesPost' => [
            'application/json',
        ],
        'restAccountsContactsTypesTypeIdDelete' => [
            'application/json',
        ],
        'restAccountsContactsTypesTypeIdGet' => [
            'application/json',
        ],
        'restAccountsContactsTypesTypeIdPut' => [
            'application/json',
        ],
        'restAccountsGet' => [
            'application/json',
        ],
        'restAccountsPost' => [
            'application/json',
        ],
        'restOrdersAddressesPost' => [
            'application/json',
        ],
        'restStockmanagementWarehousesAddressesPost' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface|null $client
     * @param Configuration|null   $config
     * @param HeaderSelector|null  $selector
     * @param int                  $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex(int $hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex(): int
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig(): Configuration
    {
        return $this->config;
    }

    /**
     * Operation restAccountLoginPost
     *
     * Login
     *
     * @param  \ck\Model\RestAccountLoginPostRequest|null $_rest_account_login _rest_account_login (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountLoginPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\TokenData
     */
    public function restAccountLoginPost(
        ?\ck\Model\RestAccountLoginPostRequest $_rest_account_login = null,
        string $contentType = self::contentTypes['restAccountLoginPost'][0]
    ): \ck\Model\TokenData
    {
        list($response) = $this->restAccountLoginPostWithHttpInfo($_rest_account_login, $contentType);
        return $response;
    }

    /**
     * Operation restAccountLoginPostWithHttpInfo
     *
     * Login
     *
     * @param  \ck\Model\RestAccountLoginPostRequest|null $_rest_account_login (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountLoginPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\TokenData, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountLoginPostWithHttpInfo(
        ?\ck\Model\RestAccountLoginPostRequest $_rest_account_login = null,
        string $contentType = self::contentTypes['restAccountLoginPost'][0]
    ): array
    {
        $request = $this->restAccountLoginPostRequest($_rest_account_login, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\TokenData' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\TokenData' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\TokenData', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\TokenData';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\TokenData',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountLoginPostAsync
     *
     * Login
     *
     * @param  \ck\Model\RestAccountLoginPostRequest|null $_rest_account_login (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountLoginPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountLoginPostAsync(
        ?\ck\Model\RestAccountLoginPostRequest $_rest_account_login = null,
        string $contentType = self::contentTypes['restAccountLoginPost'][0]
    ): PromiseInterface
    {
        return $this->restAccountLoginPostAsyncWithHttpInfo($_rest_account_login, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountLoginPostAsyncWithHttpInfo
     *
     * Login
     *
     * @param  \ck\Model\RestAccountLoginPostRequest|null $_rest_account_login (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountLoginPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountLoginPostAsyncWithHttpInfo(
        $_rest_account_login = null,
        string $contentType = self::contentTypes['restAccountLoginPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\TokenData';
        $request = $this->restAccountLoginPostRequest($_rest_account_login, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountLoginPost'
     *
     * @param  \ck\Model\RestAccountLoginPostRequest|null $_rest_account_login (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountLoginPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountLoginPostRequest(
        $_rest_account_login = null,
        string $contentType = self::contentTypes['restAccountLoginPost'][0]
    ): Request
    {



        $resourcePath = '/rest/account/login';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_account_login)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_account_login));
            } else {
                $httpBody = $_rest_account_login;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountLoginRefreshPost
     *
     * Refresh
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountLoginRefreshPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restAccountLoginRefreshPost(
        string $contentType = self::contentTypes['restAccountLoginRefreshPost'][0]
    ): void
    {
        $this->restAccountLoginRefreshPostWithHttpInfo($contentType);
    }

    /**
     * Operation restAccountLoginRefreshPostWithHttpInfo
     *
     * Refresh
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountLoginRefreshPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountLoginRefreshPostWithHttpInfo(
        string $contentType = self::contentTypes['restAccountLoginRefreshPost'][0]
    ): array
    {
        $request = $this->restAccountLoginRefreshPostRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountLoginRefreshPostAsync
     *
     * Refresh
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountLoginRefreshPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountLoginRefreshPostAsync(
        string $contentType = self::contentTypes['restAccountLoginRefreshPost'][0]
    ): PromiseInterface
    {
        return $this->restAccountLoginRefreshPostAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountLoginRefreshPostAsyncWithHttpInfo
     *
     * Refresh
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountLoginRefreshPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountLoginRefreshPostAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restAccountLoginRefreshPost'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restAccountLoginRefreshPostRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountLoginRefreshPost'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountLoginRefreshPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountLoginRefreshPostRequest(
        string $contentType = self::contentTypes['restAccountLoginRefreshPost'][0]
    ): Request
    {


        $resourcePath = '/rest/account/login/refresh';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountLogoutPost
     *
     * Logout
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountLogoutPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restAccountLogoutPost(
        string $contentType = self::contentTypes['restAccountLogoutPost'][0]
    ): void
    {
        $this->restAccountLogoutPostWithHttpInfo($contentType);
    }

    /**
     * Operation restAccountLogoutPostWithHttpInfo
     *
     * Logout
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountLogoutPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountLogoutPostWithHttpInfo(
        string $contentType = self::contentTypes['restAccountLogoutPost'][0]
    ): array
    {
        $request = $this->restAccountLogoutPostRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountLogoutPostAsync
     *
     * Logout
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountLogoutPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountLogoutPostAsync(
        string $contentType = self::contentTypes['restAccountLogoutPost'][0]
    ): PromiseInterface
    {
        return $this->restAccountLogoutPostAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountLogoutPostAsyncWithHttpInfo
     *
     * Logout
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountLogoutPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountLogoutPostAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restAccountLogoutPost'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restAccountLogoutPostRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountLogoutPost'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountLogoutPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountLogoutPostRequest(
        string $contentType = self::contentTypes['restAccountLogoutPost'][0]
    ): Request
    {


        $resourcePath = '/rest/account/logout';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAccountIdContactsGet
     *
     * List contacts
     *
     * @param  int $account_id The ID of the account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAccountIdContactsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Contact[]
     */
    public function restAccountsAccountIdContactsGet(
        int $account_id,
        string $contentType = self::contentTypes['restAccountsAccountIdContactsGet'][0]
    ): array
    {
        list($response) = $this->restAccountsAccountIdContactsGetWithHttpInfo($account_id, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsAccountIdContactsGetWithHttpInfo
     *
     * List contacts
     *
     * @param  int $account_id The ID of the account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAccountIdContactsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Contact[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAccountIdContactsGetWithHttpInfo(
        int $account_id,
        string $contentType = self::contentTypes['restAccountsAccountIdContactsGet'][0]
    ): array
    {
        $request = $this->restAccountsAccountIdContactsGetRequest($account_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Contact[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Contact[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Contact[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Contact[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Contact[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAccountIdContactsGetAsync
     *
     * List contacts
     *
     * @param  int $account_id The ID of the account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAccountIdContactsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAccountIdContactsGetAsync(
        int $account_id,
        string $contentType = self::contentTypes['restAccountsAccountIdContactsGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountsAccountIdContactsGetAsyncWithHttpInfo($account_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAccountIdContactsGetAsyncWithHttpInfo
     *
     * List contacts
     *
     * @param  int $account_id The ID of the account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAccountIdContactsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAccountIdContactsGetAsyncWithHttpInfo(
        $account_id,
        string $contentType = self::contentTypes['restAccountsAccountIdContactsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Contact[]';
        $request = $this->restAccountsAccountIdContactsGetRequest($account_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAccountIdContactsGet'
     *
     * @param  int $account_id The ID of the account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAccountIdContactsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsAccountIdContactsGetRequest(
        $account_id,
        string $contentType = self::contentTypes['restAccountsAccountIdContactsGet'][0]
    ): Request
    {

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $account_id when calling restAccountsAccountIdContactsGet'
            );
        }


        $resourcePath = '/rest/accounts/{accountId}/contacts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAccountIdDelete
     *
     * Delete account
     *
     * @param  int $account_id The ID of the account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAccountIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restAccountsAccountIdDelete(
        int $account_id,
        string $contentType = self::contentTypes['restAccountsAccountIdDelete'][0]
    ): void
    {
        $this->restAccountsAccountIdDeleteWithHttpInfo($account_id, $contentType);
    }

    /**
     * Operation restAccountsAccountIdDeleteWithHttpInfo
     *
     * Delete account
     *
     * @param  int $account_id The ID of the account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAccountIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAccountIdDeleteWithHttpInfo(
        int $account_id,
        string $contentType = self::contentTypes['restAccountsAccountIdDelete'][0]
    ): array
    {
        $request = $this->restAccountsAccountIdDeleteRequest($account_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAccountIdDeleteAsync
     *
     * Delete account
     *
     * @param  int $account_id The ID of the account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAccountIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAccountIdDeleteAsync(
        int $account_id,
        string $contentType = self::contentTypes['restAccountsAccountIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restAccountsAccountIdDeleteAsyncWithHttpInfo($account_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAccountIdDeleteAsyncWithHttpInfo
     *
     * Delete account
     *
     * @param  int $account_id The ID of the account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAccountIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAccountIdDeleteAsyncWithHttpInfo(
        $account_id,
        string $contentType = self::contentTypes['restAccountsAccountIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restAccountsAccountIdDeleteRequest($account_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAccountIdDelete'
     *
     * @param  int $account_id The ID of the account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAccountIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsAccountIdDeleteRequest(
        $account_id,
        string $contentType = self::contentTypes['restAccountsAccountIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $account_id when calling restAccountsAccountIdDelete'
            );
        }


        $resourcePath = '/rest/accounts/{accountId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAccountIdGet
     *
     * Get account
     *
     * @param  int $account_id The ID of the account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAccountIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Account
     */
    public function restAccountsAccountIdGet(
        int $account_id,
        string $contentType = self::contentTypes['restAccountsAccountIdGet'][0]
    ): \ck\Model\Account
    {
        list($response) = $this->restAccountsAccountIdGetWithHttpInfo($account_id, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsAccountIdGetWithHttpInfo
     *
     * Get account
     *
     * @param  int $account_id The ID of the account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAccountIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Account, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAccountIdGetWithHttpInfo(
        int $account_id,
        string $contentType = self::contentTypes['restAccountsAccountIdGet'][0]
    ): array
    {
        $request = $this->restAccountsAccountIdGetRequest($account_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Account' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Account' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Account', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Account';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Account',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAccountIdGetAsync
     *
     * Get account
     *
     * @param  int $account_id The ID of the account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAccountIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAccountIdGetAsync(
        int $account_id,
        string $contentType = self::contentTypes['restAccountsAccountIdGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountsAccountIdGetAsyncWithHttpInfo($account_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAccountIdGetAsyncWithHttpInfo
     *
     * Get account
     *
     * @param  int $account_id The ID of the account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAccountIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAccountIdGetAsyncWithHttpInfo(
        $account_id,
        string $contentType = self::contentTypes['restAccountsAccountIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Account';
        $request = $this->restAccountsAccountIdGetRequest($account_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAccountIdGet'
     *
     * @param  int $account_id The ID of the account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAccountIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsAccountIdGetRequest(
        $account_id,
        string $contentType = self::contentTypes['restAccountsAccountIdGet'][0]
    ): Request
    {

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $account_id when calling restAccountsAccountIdGet'
            );
        }


        $resourcePath = '/rest/accounts/{accountId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAccountIdPut
     *
     * Update account
     *
     * @param  int $account_id The ID of the account (required)
     * @param  \ck\Model\RestAccountsPostRequest|null $_rest_accounts_account_id _rest_accounts_account_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAccountIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Account
     */
    public function restAccountsAccountIdPut(
        int $account_id,
        ?\ck\Model\RestAccountsPostRequest $_rest_accounts_account_id = null,
        string $contentType = self::contentTypes['restAccountsAccountIdPut'][0]
    ): \ck\Model\Account
    {
        list($response) = $this->restAccountsAccountIdPutWithHttpInfo($account_id, $_rest_accounts_account_id, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsAccountIdPutWithHttpInfo
     *
     * Update account
     *
     * @param  int $account_id The ID of the account (required)
     * @param  \ck\Model\RestAccountsPostRequest|null $_rest_accounts_account_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAccountIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Account, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAccountIdPutWithHttpInfo(
        int $account_id,
        ?\ck\Model\RestAccountsPostRequest $_rest_accounts_account_id = null,
        string $contentType = self::contentTypes['restAccountsAccountIdPut'][0]
    ): array
    {
        $request = $this->restAccountsAccountIdPutRequest($account_id, $_rest_accounts_account_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Account' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Account' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Account', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Account';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Account',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAccountIdPutAsync
     *
     * Update account
     *
     * @param  int $account_id The ID of the account (required)
     * @param  \ck\Model\RestAccountsPostRequest|null $_rest_accounts_account_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAccountIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAccountIdPutAsync(
        int $account_id,
        ?\ck\Model\RestAccountsPostRequest $_rest_accounts_account_id = null,
        string $contentType = self::contentTypes['restAccountsAccountIdPut'][0]
    ): PromiseInterface
    {
        return $this->restAccountsAccountIdPutAsyncWithHttpInfo($account_id, $_rest_accounts_account_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAccountIdPutAsyncWithHttpInfo
     *
     * Update account
     *
     * @param  int $account_id The ID of the account (required)
     * @param  \ck\Model\RestAccountsPostRequest|null $_rest_accounts_account_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAccountIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAccountIdPutAsyncWithHttpInfo(
        $account_id,
        $_rest_accounts_account_id = null,
        string $contentType = self::contentTypes['restAccountsAccountIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Account';
        $request = $this->restAccountsAccountIdPutRequest($account_id, $_rest_accounts_account_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAccountIdPut'
     *
     * @param  int $account_id The ID of the account (required)
     * @param  \ck\Model\RestAccountsPostRequest|null $_rest_accounts_account_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAccountIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsAccountIdPutRequest(
        $account_id,
        $_rest_accounts_account_id = null,
        string $contentType = self::contentTypes['restAccountsAccountIdPut'][0]
    ): Request
    {

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $account_id when calling restAccountsAccountIdPut'
            );
        }



        $resourcePath = '/rest/accounts/{accountId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_accounts_account_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_accounts_account_id));
            } else {
                $httpBody = $_rest_accounts_account_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesAddressIdDelete
     *
     * Delete address
     *
     * @param  int $address_id The ID of the address (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesAddressIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restAccountsAddressesAddressIdDelete(
        int $address_id,
        string $contentType = self::contentTypes['restAccountsAddressesAddressIdDelete'][0]
    ): void
    {
        $this->restAccountsAddressesAddressIdDeleteWithHttpInfo($address_id, $contentType);
    }

    /**
     * Operation restAccountsAddressesAddressIdDeleteWithHttpInfo
     *
     * Delete address
     *
     * @param  int $address_id The ID of the address (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesAddressIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesAddressIdDeleteWithHttpInfo(
        int $address_id,
        string $contentType = self::contentTypes['restAccountsAddressesAddressIdDelete'][0]
    ): array
    {
        $request = $this->restAccountsAddressesAddressIdDeleteRequest($address_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesAddressIdDeleteAsync
     *
     * Delete address
     *
     * @param  int $address_id The ID of the address (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesAddressIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesAddressIdDeleteAsync(
        int $address_id,
        string $contentType = self::contentTypes['restAccountsAddressesAddressIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restAccountsAddressesAddressIdDeleteAsyncWithHttpInfo($address_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesAddressIdDeleteAsyncWithHttpInfo
     *
     * Delete address
     *
     * @param  int $address_id The ID of the address (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesAddressIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesAddressIdDeleteAsyncWithHttpInfo(
        $address_id,
        string $contentType = self::contentTypes['restAccountsAddressesAddressIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restAccountsAddressesAddressIdDeleteRequest($address_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesAddressIdDelete'
     *
     * @param  int $address_id The ID of the address (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesAddressIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsAddressesAddressIdDeleteRequest(
        $address_id,
        string $contentType = self::contentTypes['restAccountsAddressesAddressIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'address_id' is set
        if ($address_id === null || (is_array($address_id) && count($address_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $address_id when calling restAccountsAddressesAddressIdDelete'
            );
        }


        $resourcePath = '/rest/accounts/addresses/{addressId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($address_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addressId' . '}',
                ObjectSerializer::toPathValue($address_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesAddressIdGet
     *
     * Get address
     *
     * @param  int $address_id The ID of the address (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesAddressIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Address
     */
    public function restAccountsAddressesAddressIdGet(
        int $address_id,
        string $contentType = self::contentTypes['restAccountsAddressesAddressIdGet'][0]
    ): \ck\Model\Address
    {
        list($response) = $this->restAccountsAddressesAddressIdGetWithHttpInfo($address_id, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsAddressesAddressIdGetWithHttpInfo
     *
     * Get address
     *
     * @param  int $address_id The ID of the address (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesAddressIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Address, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesAddressIdGetWithHttpInfo(
        int $address_id,
        string $contentType = self::contentTypes['restAccountsAddressesAddressIdGet'][0]
    ): array
    {
        $request = $this->restAccountsAddressesAddressIdGetRequest($address_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Address' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Address' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Address', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Address';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Address',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesAddressIdGetAsync
     *
     * Get address
     *
     * @param  int $address_id The ID of the address (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesAddressIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesAddressIdGetAsync(
        int $address_id,
        string $contentType = self::contentTypes['restAccountsAddressesAddressIdGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountsAddressesAddressIdGetAsyncWithHttpInfo($address_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesAddressIdGetAsyncWithHttpInfo
     *
     * Get address
     *
     * @param  int $address_id The ID of the address (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesAddressIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesAddressIdGetAsyncWithHttpInfo(
        $address_id,
        string $contentType = self::contentTypes['restAccountsAddressesAddressIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Address';
        $request = $this->restAccountsAddressesAddressIdGetRequest($address_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesAddressIdGet'
     *
     * @param  int $address_id The ID of the address (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesAddressIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsAddressesAddressIdGetRequest(
        $address_id,
        string $contentType = self::contentTypes['restAccountsAddressesAddressIdGet'][0]
    ): Request
    {

        // verify the required parameter 'address_id' is set
        if ($address_id === null || (is_array($address_id) && count($address_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $address_id when calling restAccountsAddressesAddressIdGet'
            );
        }


        $resourcePath = '/rest/accounts/addresses/{addressId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($address_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addressId' . '}',
                ObjectSerializer::toPathValue($address_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesAddressIdOptionsDelete
     *
     * Delete address option by addressId
     *
     * @param  int $address_id The ID of the address (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesAddressIdOptionsDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restAccountsAddressesAddressIdOptionsDelete(
        int $address_id,
        string $contentType = self::contentTypes['restAccountsAddressesAddressIdOptionsDelete'][0]
    ): void
    {
        $this->restAccountsAddressesAddressIdOptionsDeleteWithHttpInfo($address_id, $contentType);
    }

    /**
     * Operation restAccountsAddressesAddressIdOptionsDeleteWithHttpInfo
     *
     * Delete address option by addressId
     *
     * @param  int $address_id The ID of the address (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesAddressIdOptionsDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesAddressIdOptionsDeleteWithHttpInfo(
        int $address_id,
        string $contentType = self::contentTypes['restAccountsAddressesAddressIdOptionsDelete'][0]
    ): array
    {
        $request = $this->restAccountsAddressesAddressIdOptionsDeleteRequest($address_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesAddressIdOptionsDeleteAsync
     *
     * Delete address option by addressId
     *
     * @param  int $address_id The ID of the address (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesAddressIdOptionsDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesAddressIdOptionsDeleteAsync(
        int $address_id,
        string $contentType = self::contentTypes['restAccountsAddressesAddressIdOptionsDelete'][0]
    ): PromiseInterface
    {
        return $this->restAccountsAddressesAddressIdOptionsDeleteAsyncWithHttpInfo($address_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesAddressIdOptionsDeleteAsyncWithHttpInfo
     *
     * Delete address option by addressId
     *
     * @param  int $address_id The ID of the address (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesAddressIdOptionsDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesAddressIdOptionsDeleteAsyncWithHttpInfo(
        $address_id,
        string $contentType = self::contentTypes['restAccountsAddressesAddressIdOptionsDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restAccountsAddressesAddressIdOptionsDeleteRequest($address_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesAddressIdOptionsDelete'
     *
     * @param  int $address_id The ID of the address (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesAddressIdOptionsDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsAddressesAddressIdOptionsDeleteRequest(
        $address_id,
        string $contentType = self::contentTypes['restAccountsAddressesAddressIdOptionsDelete'][0]
    ): Request
    {

        // verify the required parameter 'address_id' is set
        if ($address_id === null || (is_array($address_id) && count($address_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $address_id when calling restAccountsAddressesAddressIdOptionsDelete'
            );
        }


        $resourcePath = '/rest/accounts/addresses/{addressId}/options';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($address_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addressId' . '}',
                ObjectSerializer::toPathValue($address_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesAddressIdOptionsGet
     *
     * List address options
     *
     * @param  int $address_id The ID of the address (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesAddressIdOptionsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\AddressOption[]
     */
    public function restAccountsAddressesAddressIdOptionsGet(
        int $address_id,
        string $contentType = self::contentTypes['restAccountsAddressesAddressIdOptionsGet'][0]
    ): array
    {
        list($response) = $this->restAccountsAddressesAddressIdOptionsGetWithHttpInfo($address_id, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsAddressesAddressIdOptionsGetWithHttpInfo
     *
     * List address options
     *
     * @param  int $address_id The ID of the address (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesAddressIdOptionsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\AddressOption[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesAddressIdOptionsGetWithHttpInfo(
        int $address_id,
        string $contentType = self::contentTypes['restAccountsAddressesAddressIdOptionsGet'][0]
    ): array
    {
        $request = $this->restAccountsAddressesAddressIdOptionsGetRequest($address_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\AddressOption[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\AddressOption[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\AddressOption[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\AddressOption[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\AddressOption[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesAddressIdOptionsGetAsync
     *
     * List address options
     *
     * @param  int $address_id The ID of the address (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesAddressIdOptionsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesAddressIdOptionsGetAsync(
        int $address_id,
        string $contentType = self::contentTypes['restAccountsAddressesAddressIdOptionsGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountsAddressesAddressIdOptionsGetAsyncWithHttpInfo($address_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesAddressIdOptionsGetAsyncWithHttpInfo
     *
     * List address options
     *
     * @param  int $address_id The ID of the address (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesAddressIdOptionsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesAddressIdOptionsGetAsyncWithHttpInfo(
        $address_id,
        string $contentType = self::contentTypes['restAccountsAddressesAddressIdOptionsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\AddressOption[]';
        $request = $this->restAccountsAddressesAddressIdOptionsGetRequest($address_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesAddressIdOptionsGet'
     *
     * @param  int $address_id The ID of the address (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesAddressIdOptionsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsAddressesAddressIdOptionsGetRequest(
        $address_id,
        string $contentType = self::contentTypes['restAccountsAddressesAddressIdOptionsGet'][0]
    ): Request
    {

        // verify the required parameter 'address_id' is set
        if ($address_id === null || (is_array($address_id) && count($address_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $address_id when calling restAccountsAddressesAddressIdOptionsGet'
            );
        }


        $resourcePath = '/rest/accounts/addresses/{addressId}/options';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($address_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addressId' . '}',
                ObjectSerializer::toPathValue($address_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesAddressIdOptionsPost
     *
     * Create address option
     *
     * @param  int $address_id The ID of the address (required)
     * @param  \ck\Model\RestAccountsAddressesAddressIdOptionsPostRequest|null $_rest_accounts_addresses_address_id_options _rest_accounts_addresses_address_id_options (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesAddressIdOptionsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\AddressOption[]
     */
    public function restAccountsAddressesAddressIdOptionsPost(
        int $address_id,
        ?\ck\Model\RestAccountsAddressesAddressIdOptionsPostRequest $_rest_accounts_addresses_address_id_options = null,
        string $contentType = self::contentTypes['restAccountsAddressesAddressIdOptionsPost'][0]
    ): array
    {
        list($response) = $this->restAccountsAddressesAddressIdOptionsPostWithHttpInfo($address_id, $_rest_accounts_addresses_address_id_options, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsAddressesAddressIdOptionsPostWithHttpInfo
     *
     * Create address option
     *
     * @param  int $address_id The ID of the address (required)
     * @param  \ck\Model\RestAccountsAddressesAddressIdOptionsPostRequest|null $_rest_accounts_addresses_address_id_options (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesAddressIdOptionsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\AddressOption[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesAddressIdOptionsPostWithHttpInfo(
        int $address_id,
        ?\ck\Model\RestAccountsAddressesAddressIdOptionsPostRequest $_rest_accounts_addresses_address_id_options = null,
        string $contentType = self::contentTypes['restAccountsAddressesAddressIdOptionsPost'][0]
    ): array
    {
        $request = $this->restAccountsAddressesAddressIdOptionsPostRequest($address_id, $_rest_accounts_addresses_address_id_options, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\AddressOption[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\AddressOption[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\AddressOption[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\AddressOption[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\AddressOption[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesAddressIdOptionsPostAsync
     *
     * Create address option
     *
     * @param  int $address_id The ID of the address (required)
     * @param  \ck\Model\RestAccountsAddressesAddressIdOptionsPostRequest|null $_rest_accounts_addresses_address_id_options (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesAddressIdOptionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesAddressIdOptionsPostAsync(
        int $address_id,
        ?\ck\Model\RestAccountsAddressesAddressIdOptionsPostRequest $_rest_accounts_addresses_address_id_options = null,
        string $contentType = self::contentTypes['restAccountsAddressesAddressIdOptionsPost'][0]
    ): PromiseInterface
    {
        return $this->restAccountsAddressesAddressIdOptionsPostAsyncWithHttpInfo($address_id, $_rest_accounts_addresses_address_id_options, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesAddressIdOptionsPostAsyncWithHttpInfo
     *
     * Create address option
     *
     * @param  int $address_id The ID of the address (required)
     * @param  \ck\Model\RestAccountsAddressesAddressIdOptionsPostRequest|null $_rest_accounts_addresses_address_id_options (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesAddressIdOptionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesAddressIdOptionsPostAsyncWithHttpInfo(
        $address_id,
        $_rest_accounts_addresses_address_id_options = null,
        string $contentType = self::contentTypes['restAccountsAddressesAddressIdOptionsPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\AddressOption[]';
        $request = $this->restAccountsAddressesAddressIdOptionsPostRequest($address_id, $_rest_accounts_addresses_address_id_options, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesAddressIdOptionsPost'
     *
     * @param  int $address_id The ID of the address (required)
     * @param  \ck\Model\RestAccountsAddressesAddressIdOptionsPostRequest|null $_rest_accounts_addresses_address_id_options (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesAddressIdOptionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsAddressesAddressIdOptionsPostRequest(
        $address_id,
        $_rest_accounts_addresses_address_id_options = null,
        string $contentType = self::contentTypes['restAccountsAddressesAddressIdOptionsPost'][0]
    ): Request
    {

        // verify the required parameter 'address_id' is set
        if ($address_id === null || (is_array($address_id) && count($address_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $address_id when calling restAccountsAddressesAddressIdOptionsPost'
            );
        }



        $resourcePath = '/rest/accounts/addresses/{addressId}/options';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($address_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addressId' . '}',
                ObjectSerializer::toPathValue($address_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_accounts_addresses_address_id_options)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_accounts_addresses_address_id_options));
            } else {
                $httpBody = $_rest_accounts_addresses_address_id_options;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesAddressIdOptionsPut
     *
     * Update address option by addressId
     *
     * @param  int $address_id The ID of the address (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesAddressIdOptionsPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\AddressOption[]
     */
    public function restAccountsAddressesAddressIdOptionsPut(
        int $address_id,
        string $contentType = self::contentTypes['restAccountsAddressesAddressIdOptionsPut'][0]
    ): array
    {
        list($response) = $this->restAccountsAddressesAddressIdOptionsPutWithHttpInfo($address_id, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsAddressesAddressIdOptionsPutWithHttpInfo
     *
     * Update address option by addressId
     *
     * @param  int $address_id The ID of the address (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesAddressIdOptionsPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\AddressOption[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesAddressIdOptionsPutWithHttpInfo(
        int $address_id,
        string $contentType = self::contentTypes['restAccountsAddressesAddressIdOptionsPut'][0]
    ): array
    {
        $request = $this->restAccountsAddressesAddressIdOptionsPutRequest($address_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\AddressOption[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\AddressOption[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\AddressOption[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\AddressOption[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\AddressOption[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesAddressIdOptionsPutAsync
     *
     * Update address option by addressId
     *
     * @param  int $address_id The ID of the address (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesAddressIdOptionsPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesAddressIdOptionsPutAsync(
        int $address_id,
        string $contentType = self::contentTypes['restAccountsAddressesAddressIdOptionsPut'][0]
    ): PromiseInterface
    {
        return $this->restAccountsAddressesAddressIdOptionsPutAsyncWithHttpInfo($address_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesAddressIdOptionsPutAsyncWithHttpInfo
     *
     * Update address option by addressId
     *
     * @param  int $address_id The ID of the address (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesAddressIdOptionsPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesAddressIdOptionsPutAsyncWithHttpInfo(
        $address_id,
        string $contentType = self::contentTypes['restAccountsAddressesAddressIdOptionsPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\AddressOption[]';
        $request = $this->restAccountsAddressesAddressIdOptionsPutRequest($address_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesAddressIdOptionsPut'
     *
     * @param  int $address_id The ID of the address (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesAddressIdOptionsPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsAddressesAddressIdOptionsPutRequest(
        $address_id,
        string $contentType = self::contentTypes['restAccountsAddressesAddressIdOptionsPut'][0]
    ): Request
    {

        // verify the required parameter 'address_id' is set
        if ($address_id === null || (is_array($address_id) && count($address_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $address_id when calling restAccountsAddressesAddressIdOptionsPut'
            );
        }


        $resourcePath = '/rest/accounts/addresses/{addressId}/options';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($address_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addressId' . '}',
                ObjectSerializer::toPathValue($address_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesAddressIdPut
     *
     * Update address
     *
     * @param  int $address_id The ID of the address (required)
     * @param  \ck\Model\RestAccountsAddressesPostRequest|null $_rest_accounts_addresses_address_id _rest_accounts_addresses_address_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesAddressIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Address
     */
    public function restAccountsAddressesAddressIdPut(
        int $address_id,
        ?\ck\Model\RestAccountsAddressesPostRequest $_rest_accounts_addresses_address_id = null,
        string $contentType = self::contentTypes['restAccountsAddressesAddressIdPut'][0]
    ): \ck\Model\Address
    {
        list($response) = $this->restAccountsAddressesAddressIdPutWithHttpInfo($address_id, $_rest_accounts_addresses_address_id, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsAddressesAddressIdPutWithHttpInfo
     *
     * Update address
     *
     * @param  int $address_id The ID of the address (required)
     * @param  \ck\Model\RestAccountsAddressesPostRequest|null $_rest_accounts_addresses_address_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesAddressIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Address, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesAddressIdPutWithHttpInfo(
        int $address_id,
        ?\ck\Model\RestAccountsAddressesPostRequest $_rest_accounts_addresses_address_id = null,
        string $contentType = self::contentTypes['restAccountsAddressesAddressIdPut'][0]
    ): array
    {
        $request = $this->restAccountsAddressesAddressIdPutRequest($address_id, $_rest_accounts_addresses_address_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Address' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Address' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Address', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Address';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Address',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesAddressIdPutAsync
     *
     * Update address
     *
     * @param  int $address_id The ID of the address (required)
     * @param  \ck\Model\RestAccountsAddressesPostRequest|null $_rest_accounts_addresses_address_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesAddressIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesAddressIdPutAsync(
        int $address_id,
        ?\ck\Model\RestAccountsAddressesPostRequest $_rest_accounts_addresses_address_id = null,
        string $contentType = self::contentTypes['restAccountsAddressesAddressIdPut'][0]
    ): PromiseInterface
    {
        return $this->restAccountsAddressesAddressIdPutAsyncWithHttpInfo($address_id, $_rest_accounts_addresses_address_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesAddressIdPutAsyncWithHttpInfo
     *
     * Update address
     *
     * @param  int $address_id The ID of the address (required)
     * @param  \ck\Model\RestAccountsAddressesPostRequest|null $_rest_accounts_addresses_address_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesAddressIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesAddressIdPutAsyncWithHttpInfo(
        $address_id,
        $_rest_accounts_addresses_address_id = null,
        string $contentType = self::contentTypes['restAccountsAddressesAddressIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Address';
        $request = $this->restAccountsAddressesAddressIdPutRequest($address_id, $_rest_accounts_addresses_address_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesAddressIdPut'
     *
     * @param  int $address_id The ID of the address (required)
     * @param  \ck\Model\RestAccountsAddressesPostRequest|null $_rest_accounts_addresses_address_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesAddressIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsAddressesAddressIdPutRequest(
        $address_id,
        $_rest_accounts_addresses_address_id = null,
        string $contentType = self::contentTypes['restAccountsAddressesAddressIdPut'][0]
    ): Request
    {

        // verify the required parameter 'address_id' is set
        if ($address_id === null || (is_array($address_id) && count($address_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $address_id when calling restAccountsAddressesAddressIdPut'
            );
        }



        $resourcePath = '/rest/accounts/addresses/{addressId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($address_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addressId' . '}',
                ObjectSerializer::toPathValue($address_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_accounts_addresses_address_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_accounts_addresses_address_id));
            } else {
                $httpBody = $_rest_accounts_addresses_address_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesAddressIdRelatedDataGet
     *
     * Get address data by addressId
     *
     * @param  int $address_id The ID of the address (required)
     * @param  string|null $order_ids The ID of the orders (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesAddressIdRelatedDataGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Address
     */
    public function restAccountsAddressesAddressIdRelatedDataGet(
        int $address_id,
        ?string $order_ids = null,
        string $contentType = self::contentTypes['restAccountsAddressesAddressIdRelatedDataGet'][0]
    ): \ck\Model\Address
    {
        list($response) = $this->restAccountsAddressesAddressIdRelatedDataGetWithHttpInfo($address_id, $order_ids, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsAddressesAddressIdRelatedDataGetWithHttpInfo
     *
     * Get address data by addressId
     *
     * @param  int $address_id The ID of the address (required)
     * @param  string|null $order_ids The ID of the orders (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesAddressIdRelatedDataGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Address, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesAddressIdRelatedDataGetWithHttpInfo(
        int $address_id,
        ?string $order_ids = null,
        string $contentType = self::contentTypes['restAccountsAddressesAddressIdRelatedDataGet'][0]
    ): array
    {
        $request = $this->restAccountsAddressesAddressIdRelatedDataGetRequest($address_id, $order_ids, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Address' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Address' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Address', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Address';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Address',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesAddressIdRelatedDataGetAsync
     *
     * Get address data by addressId
     *
     * @param  int $address_id The ID of the address (required)
     * @param  string|null $order_ids The ID of the orders (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesAddressIdRelatedDataGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesAddressIdRelatedDataGetAsync(
        int $address_id,
        ?string $order_ids = null,
        string $contentType = self::contentTypes['restAccountsAddressesAddressIdRelatedDataGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountsAddressesAddressIdRelatedDataGetAsyncWithHttpInfo($address_id, $order_ids, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesAddressIdRelatedDataGetAsyncWithHttpInfo
     *
     * Get address data by addressId
     *
     * @param  int $address_id The ID of the address (required)
     * @param  string|null $order_ids The ID of the orders (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesAddressIdRelatedDataGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesAddressIdRelatedDataGetAsyncWithHttpInfo(
        $address_id,
        $order_ids = null,
        string $contentType = self::contentTypes['restAccountsAddressesAddressIdRelatedDataGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Address';
        $request = $this->restAccountsAddressesAddressIdRelatedDataGetRequest($address_id, $order_ids, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesAddressIdRelatedDataGet'
     *
     * @param  int $address_id The ID of the address (required)
     * @param  string|null $order_ids The ID of the orders (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesAddressIdRelatedDataGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsAddressesAddressIdRelatedDataGetRequest(
        $address_id,
        $order_ids = null,
        string $contentType = self::contentTypes['restAccountsAddressesAddressIdRelatedDataGet'][0]
    ): Request
    {

        // verify the required parameter 'address_id' is set
        if ($address_id === null || (is_array($address_id) && count($address_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $address_id when calling restAccountsAddressesAddressIdRelatedDataGet'
            );
        }



        $resourcePath = '/rest/accounts/addresses/{addressId}/related_data';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order_ids,
            'orderIds', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($address_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addressId' . '}',
                ObjectSerializer::toPathValue($address_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesContactRelationsAddressContactRelationIdDelete
     *
     * Delete address contact relation
     *
     * @param  int $address_contact_relation_id The ID of the address contact relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesContactRelationsAddressContactRelationIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restAccountsAddressesContactRelationsAddressContactRelationIdDelete(
        int $address_contact_relation_id,
        string $contentType = self::contentTypes['restAccountsAddressesContactRelationsAddressContactRelationIdDelete'][0]
    ): void
    {
        $this->restAccountsAddressesContactRelationsAddressContactRelationIdDeleteWithHttpInfo($address_contact_relation_id, $contentType);
    }

    /**
     * Operation restAccountsAddressesContactRelationsAddressContactRelationIdDeleteWithHttpInfo
     *
     * Delete address contact relation
     *
     * @param  int $address_contact_relation_id The ID of the address contact relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesContactRelationsAddressContactRelationIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesContactRelationsAddressContactRelationIdDeleteWithHttpInfo(
        int $address_contact_relation_id,
        string $contentType = self::contentTypes['restAccountsAddressesContactRelationsAddressContactRelationIdDelete'][0]
    ): array
    {
        $request = $this->restAccountsAddressesContactRelationsAddressContactRelationIdDeleteRequest($address_contact_relation_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesContactRelationsAddressContactRelationIdDeleteAsync
     *
     * Delete address contact relation
     *
     * @param  int $address_contact_relation_id The ID of the address contact relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesContactRelationsAddressContactRelationIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesContactRelationsAddressContactRelationIdDeleteAsync(
        int $address_contact_relation_id,
        string $contentType = self::contentTypes['restAccountsAddressesContactRelationsAddressContactRelationIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restAccountsAddressesContactRelationsAddressContactRelationIdDeleteAsyncWithHttpInfo($address_contact_relation_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesContactRelationsAddressContactRelationIdDeleteAsyncWithHttpInfo
     *
     * Delete address contact relation
     *
     * @param  int $address_contact_relation_id The ID of the address contact relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesContactRelationsAddressContactRelationIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesContactRelationsAddressContactRelationIdDeleteAsyncWithHttpInfo(
        $address_contact_relation_id,
        string $contentType = self::contentTypes['restAccountsAddressesContactRelationsAddressContactRelationIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restAccountsAddressesContactRelationsAddressContactRelationIdDeleteRequest($address_contact_relation_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesContactRelationsAddressContactRelationIdDelete'
     *
     * @param  int $address_contact_relation_id The ID of the address contact relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesContactRelationsAddressContactRelationIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsAddressesContactRelationsAddressContactRelationIdDeleteRequest(
        $address_contact_relation_id,
        string $contentType = self::contentTypes['restAccountsAddressesContactRelationsAddressContactRelationIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'address_contact_relation_id' is set
        if ($address_contact_relation_id === null || (is_array($address_contact_relation_id) && count($address_contact_relation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $address_contact_relation_id when calling restAccountsAddressesContactRelationsAddressContactRelationIdDelete'
            );
        }


        $resourcePath = '/rest/accounts/addresses/contact_relations/{addressContactRelationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($address_contact_relation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addressContactRelationId' . '}',
                ObjectSerializer::toPathValue($address_contact_relation_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesContactRelationsAddressContactRelationIdGet
     *
     * Get address contact relation
     *
     * @param  int $address_contact_relation_id The ID of the address contact relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesContactRelationsAddressContactRelationIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\AddressContactRelation
     */
    public function restAccountsAddressesContactRelationsAddressContactRelationIdGet(
        int $address_contact_relation_id,
        string $contentType = self::contentTypes['restAccountsAddressesContactRelationsAddressContactRelationIdGet'][0]
    ): \ck\Model\AddressContactRelation
    {
        list($response) = $this->restAccountsAddressesContactRelationsAddressContactRelationIdGetWithHttpInfo($address_contact_relation_id, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsAddressesContactRelationsAddressContactRelationIdGetWithHttpInfo
     *
     * Get address contact relation
     *
     * @param  int $address_contact_relation_id The ID of the address contact relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesContactRelationsAddressContactRelationIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\AddressContactRelation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesContactRelationsAddressContactRelationIdGetWithHttpInfo(
        int $address_contact_relation_id,
        string $contentType = self::contentTypes['restAccountsAddressesContactRelationsAddressContactRelationIdGet'][0]
    ): array
    {
        $request = $this->restAccountsAddressesContactRelationsAddressContactRelationIdGetRequest($address_contact_relation_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\AddressContactRelation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\AddressContactRelation' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\AddressContactRelation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\AddressContactRelation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\AddressContactRelation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesContactRelationsAddressContactRelationIdGetAsync
     *
     * Get address contact relation
     *
     * @param  int $address_contact_relation_id The ID of the address contact relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesContactRelationsAddressContactRelationIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesContactRelationsAddressContactRelationIdGetAsync(
        int $address_contact_relation_id,
        string $contentType = self::contentTypes['restAccountsAddressesContactRelationsAddressContactRelationIdGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountsAddressesContactRelationsAddressContactRelationIdGetAsyncWithHttpInfo($address_contact_relation_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesContactRelationsAddressContactRelationIdGetAsyncWithHttpInfo
     *
     * Get address contact relation
     *
     * @param  int $address_contact_relation_id The ID of the address contact relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesContactRelationsAddressContactRelationIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesContactRelationsAddressContactRelationIdGetAsyncWithHttpInfo(
        $address_contact_relation_id,
        string $contentType = self::contentTypes['restAccountsAddressesContactRelationsAddressContactRelationIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\AddressContactRelation';
        $request = $this->restAccountsAddressesContactRelationsAddressContactRelationIdGetRequest($address_contact_relation_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesContactRelationsAddressContactRelationIdGet'
     *
     * @param  int $address_contact_relation_id The ID of the address contact relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesContactRelationsAddressContactRelationIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsAddressesContactRelationsAddressContactRelationIdGetRequest(
        $address_contact_relation_id,
        string $contentType = self::contentTypes['restAccountsAddressesContactRelationsAddressContactRelationIdGet'][0]
    ): Request
    {

        // verify the required parameter 'address_contact_relation_id' is set
        if ($address_contact_relation_id === null || (is_array($address_contact_relation_id) && count($address_contact_relation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $address_contact_relation_id when calling restAccountsAddressesContactRelationsAddressContactRelationIdGet'
            );
        }


        $resourcePath = '/rest/accounts/addresses/contact_relations/{addressContactRelationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($address_contact_relation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addressContactRelationId' . '}',
                ObjectSerializer::toPathValue($address_contact_relation_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesContactRelationsGet
     *
     * List address contact relations
     *
     * @param  int|null $id Filter that restricts the search result to address contact relations with a specific ID (optional)
     * @param  int|null $contact_id Filter that restricts the search result to contacts with a specific ID (optional)
     * @param  int|null $type_id Filter that restricts the search result to address types with a specific ID (optional)
     * @param  int|null $address_id Filter that restricts the search result to addresses with a specific ID (optional)
     * @param  bool|null $is_primary Filter that restricts the search result depending on the flag used. If the flag isPrimary&#x3D;true is set, the filter restricts the search result to addresses that are primary addresses. If the flag isPrimary&#x3D;false is set, the filter restricts the search results to addresses that are not primary addresses. If no flag is set, both primary and non-primary addresses are listed. (optional)
     * @param  int|null $page The page of results to search for (optional)
     * @param  int|null $items_per_page The number of items to list per page (optional)
     * @param  string|null $with Includes the specified address contact relation information in the results. The following parameters are available: contact and address. More than one parameter should be separated by commas. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesContactRelationsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestAccountsAddressesContactRelationsGet200Response
     */
    public function restAccountsAddressesContactRelationsGet(
        ?int $id = null,
        ?int $contact_id = null,
        ?int $type_id = null,
        ?int $address_id = null,
        ?bool $is_primary = null,
        ?int $page = null,
        ?int $items_per_page = null,
        ?string $with = null,
        string $contentType = self::contentTypes['restAccountsAddressesContactRelationsGet'][0]
    ): \ck\Model\RestAccountsAddressesContactRelationsGet200Response
    {
        list($response) = $this->restAccountsAddressesContactRelationsGetWithHttpInfo($id, $contact_id, $type_id, $address_id, $is_primary, $page, $items_per_page, $with, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsAddressesContactRelationsGetWithHttpInfo
     *
     * List address contact relations
     *
     * @param  int|null $id Filter that restricts the search result to address contact relations with a specific ID (optional)
     * @param  int|null $contact_id Filter that restricts the search result to contacts with a specific ID (optional)
     * @param  int|null $type_id Filter that restricts the search result to address types with a specific ID (optional)
     * @param  int|null $address_id Filter that restricts the search result to addresses with a specific ID (optional)
     * @param  bool|null $is_primary Filter that restricts the search result depending on the flag used. If the flag isPrimary&#x3D;true is set, the filter restricts the search result to addresses that are primary addresses. If the flag isPrimary&#x3D;false is set, the filter restricts the search results to addresses that are not primary addresses. If no flag is set, both primary and non-primary addresses are listed. (optional)
     * @param  int|null $page The page of results to search for (optional)
     * @param  int|null $items_per_page The number of items to list per page (optional)
     * @param  string|null $with Includes the specified address contact relation information in the results. The following parameters are available: contact and address. More than one parameter should be separated by commas. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesContactRelationsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestAccountsAddressesContactRelationsGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesContactRelationsGetWithHttpInfo(
        ?int $id = null,
        ?int $contact_id = null,
        ?int $type_id = null,
        ?int $address_id = null,
        ?bool $is_primary = null,
        ?int $page = null,
        ?int $items_per_page = null,
        ?string $with = null,
        string $contentType = self::contentTypes['restAccountsAddressesContactRelationsGet'][0]
    ): array
    {
        $request = $this->restAccountsAddressesContactRelationsGetRequest($id, $contact_id, $type_id, $address_id, $is_primary, $page, $items_per_page, $with, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestAccountsAddressesContactRelationsGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestAccountsAddressesContactRelationsGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestAccountsAddressesContactRelationsGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestAccountsAddressesContactRelationsGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestAccountsAddressesContactRelationsGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesContactRelationsGetAsync
     *
     * List address contact relations
     *
     * @param  int|null $id Filter that restricts the search result to address contact relations with a specific ID (optional)
     * @param  int|null $contact_id Filter that restricts the search result to contacts with a specific ID (optional)
     * @param  int|null $type_id Filter that restricts the search result to address types with a specific ID (optional)
     * @param  int|null $address_id Filter that restricts the search result to addresses with a specific ID (optional)
     * @param  bool|null $is_primary Filter that restricts the search result depending on the flag used. If the flag isPrimary&#x3D;true is set, the filter restricts the search result to addresses that are primary addresses. If the flag isPrimary&#x3D;false is set, the filter restricts the search results to addresses that are not primary addresses. If no flag is set, both primary and non-primary addresses are listed. (optional)
     * @param  int|null $page The page of results to search for (optional)
     * @param  int|null $items_per_page The number of items to list per page (optional)
     * @param  string|null $with Includes the specified address contact relation information in the results. The following parameters are available: contact and address. More than one parameter should be separated by commas. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesContactRelationsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesContactRelationsGetAsync(
        ?int $id = null,
        ?int $contact_id = null,
        ?int $type_id = null,
        ?int $address_id = null,
        ?bool $is_primary = null,
        ?int $page = null,
        ?int $items_per_page = null,
        ?string $with = null,
        string $contentType = self::contentTypes['restAccountsAddressesContactRelationsGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountsAddressesContactRelationsGetAsyncWithHttpInfo($id, $contact_id, $type_id, $address_id, $is_primary, $page, $items_per_page, $with, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesContactRelationsGetAsyncWithHttpInfo
     *
     * List address contact relations
     *
     * @param  int|null $id Filter that restricts the search result to address contact relations with a specific ID (optional)
     * @param  int|null $contact_id Filter that restricts the search result to contacts with a specific ID (optional)
     * @param  int|null $type_id Filter that restricts the search result to address types with a specific ID (optional)
     * @param  int|null $address_id Filter that restricts the search result to addresses with a specific ID (optional)
     * @param  bool|null $is_primary Filter that restricts the search result depending on the flag used. If the flag isPrimary&#x3D;true is set, the filter restricts the search result to addresses that are primary addresses. If the flag isPrimary&#x3D;false is set, the filter restricts the search results to addresses that are not primary addresses. If no flag is set, both primary and non-primary addresses are listed. (optional)
     * @param  int|null $page The page of results to search for (optional)
     * @param  int|null $items_per_page The number of items to list per page (optional)
     * @param  string|null $with Includes the specified address contact relation information in the results. The following parameters are available: contact and address. More than one parameter should be separated by commas. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesContactRelationsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesContactRelationsGetAsyncWithHttpInfo(
        $id = null,
        $contact_id = null,
        $type_id = null,
        $address_id = null,
        $is_primary = null,
        $page = null,
        $items_per_page = null,
        $with = null,
        string $contentType = self::contentTypes['restAccountsAddressesContactRelationsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestAccountsAddressesContactRelationsGet200Response';
        $request = $this->restAccountsAddressesContactRelationsGetRequest($id, $contact_id, $type_id, $address_id, $is_primary, $page, $items_per_page, $with, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesContactRelationsGet'
     *
     * @param  int|null $id Filter that restricts the search result to address contact relations with a specific ID (optional)
     * @param  int|null $contact_id Filter that restricts the search result to contacts with a specific ID (optional)
     * @param  int|null $type_id Filter that restricts the search result to address types with a specific ID (optional)
     * @param  int|null $address_id Filter that restricts the search result to addresses with a specific ID (optional)
     * @param  bool|null $is_primary Filter that restricts the search result depending on the flag used. If the flag isPrimary&#x3D;true is set, the filter restricts the search result to addresses that are primary addresses. If the flag isPrimary&#x3D;false is set, the filter restricts the search results to addresses that are not primary addresses. If no flag is set, both primary and non-primary addresses are listed. (optional)
     * @param  int|null $page The page of results to search for (optional)
     * @param  int|null $items_per_page The number of items to list per page (optional)
     * @param  string|null $with Includes the specified address contact relation information in the results. The following parameters are available: contact and address. More than one parameter should be separated by commas. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesContactRelationsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsAddressesContactRelationsGetRequest(
        $id = null,
        $contact_id = null,
        $type_id = null,
        $address_id = null,
        $is_primary = null,
        $page = null,
        $items_per_page = null,
        $with = null,
        string $contentType = self::contentTypes['restAccountsAddressesContactRelationsGet'][0]
    ): Request
    {










        $resourcePath = '/rest/accounts/addresses/contact_relations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $contact_id,
            'contactId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type_id,
            'typeId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $address_id,
            'addressId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_primary,
            'isPrimary', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $items_per_page,
            'itemsPerPage', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesContactRelationsPost
     *
     * Create address contact relations
     *
     * @param  \ck\Model\RestAccountsAddressesContactRelationsPostRequest|null $_rest_accounts_addresses_contact_relations _rest_accounts_addresses_contact_relations (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesContactRelationsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\AddressContactRelation[]
     */
    public function restAccountsAddressesContactRelationsPost(
        ?\ck\Model\RestAccountsAddressesContactRelationsPostRequest $_rest_accounts_addresses_contact_relations = null,
        string $contentType = self::contentTypes['restAccountsAddressesContactRelationsPost'][0]
    ): array
    {
        list($response) = $this->restAccountsAddressesContactRelationsPostWithHttpInfo($_rest_accounts_addresses_contact_relations, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsAddressesContactRelationsPostWithHttpInfo
     *
     * Create address contact relations
     *
     * @param  \ck\Model\RestAccountsAddressesContactRelationsPostRequest|null $_rest_accounts_addresses_contact_relations (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesContactRelationsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\AddressContactRelation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesContactRelationsPostWithHttpInfo(
        ?\ck\Model\RestAccountsAddressesContactRelationsPostRequest $_rest_accounts_addresses_contact_relations = null,
        string $contentType = self::contentTypes['restAccountsAddressesContactRelationsPost'][0]
    ): array
    {
        $request = $this->restAccountsAddressesContactRelationsPostRequest($_rest_accounts_addresses_contact_relations, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\AddressContactRelation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\AddressContactRelation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\AddressContactRelation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\AddressContactRelation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\AddressContactRelation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesContactRelationsPostAsync
     *
     * Create address contact relations
     *
     * @param  \ck\Model\RestAccountsAddressesContactRelationsPostRequest|null $_rest_accounts_addresses_contact_relations (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesContactRelationsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesContactRelationsPostAsync(
        ?\ck\Model\RestAccountsAddressesContactRelationsPostRequest $_rest_accounts_addresses_contact_relations = null,
        string $contentType = self::contentTypes['restAccountsAddressesContactRelationsPost'][0]
    ): PromiseInterface
    {
        return $this->restAccountsAddressesContactRelationsPostAsyncWithHttpInfo($_rest_accounts_addresses_contact_relations, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesContactRelationsPostAsyncWithHttpInfo
     *
     * Create address contact relations
     *
     * @param  \ck\Model\RestAccountsAddressesContactRelationsPostRequest|null $_rest_accounts_addresses_contact_relations (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesContactRelationsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesContactRelationsPostAsyncWithHttpInfo(
        $_rest_accounts_addresses_contact_relations = null,
        string $contentType = self::contentTypes['restAccountsAddressesContactRelationsPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\AddressContactRelation[]';
        $request = $this->restAccountsAddressesContactRelationsPostRequest($_rest_accounts_addresses_contact_relations, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesContactRelationsPost'
     *
     * @param  \ck\Model\RestAccountsAddressesContactRelationsPostRequest|null $_rest_accounts_addresses_contact_relations (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesContactRelationsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsAddressesContactRelationsPostRequest(
        $_rest_accounts_addresses_contact_relations = null,
        string $contentType = self::contentTypes['restAccountsAddressesContactRelationsPost'][0]
    ): Request
    {



        $resourcePath = '/rest/accounts/addresses/contact_relations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_accounts_addresses_contact_relations)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_accounts_addresses_contact_relations));
            } else {
                $httpBody = $_rest_accounts_addresses_contact_relations;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesContactRelationsPut
     *
     * Update address contact relations
     *
     * @param  \ck\Model\RestAccountsAddressesContactRelationsPutRequest|null $_rest_accounts_addresses_contact_relations _rest_accounts_addresses_contact_relations (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesContactRelationsPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\AddressContactRelation[]
     */
    public function restAccountsAddressesContactRelationsPut(
        ?\ck\Model\RestAccountsAddressesContactRelationsPutRequest $_rest_accounts_addresses_contact_relations = null,
        string $contentType = self::contentTypes['restAccountsAddressesContactRelationsPut'][0]
    ): array
    {
        list($response) = $this->restAccountsAddressesContactRelationsPutWithHttpInfo($_rest_accounts_addresses_contact_relations, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsAddressesContactRelationsPutWithHttpInfo
     *
     * Update address contact relations
     *
     * @param  \ck\Model\RestAccountsAddressesContactRelationsPutRequest|null $_rest_accounts_addresses_contact_relations (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesContactRelationsPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\AddressContactRelation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesContactRelationsPutWithHttpInfo(
        ?\ck\Model\RestAccountsAddressesContactRelationsPutRequest $_rest_accounts_addresses_contact_relations = null,
        string $contentType = self::contentTypes['restAccountsAddressesContactRelationsPut'][0]
    ): array
    {
        $request = $this->restAccountsAddressesContactRelationsPutRequest($_rest_accounts_addresses_contact_relations, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\AddressContactRelation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\AddressContactRelation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\AddressContactRelation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\AddressContactRelation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\AddressContactRelation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesContactRelationsPutAsync
     *
     * Update address contact relations
     *
     * @param  \ck\Model\RestAccountsAddressesContactRelationsPutRequest|null $_rest_accounts_addresses_contact_relations (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesContactRelationsPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesContactRelationsPutAsync(
        ?\ck\Model\RestAccountsAddressesContactRelationsPutRequest $_rest_accounts_addresses_contact_relations = null,
        string $contentType = self::contentTypes['restAccountsAddressesContactRelationsPut'][0]
    ): PromiseInterface
    {
        return $this->restAccountsAddressesContactRelationsPutAsyncWithHttpInfo($_rest_accounts_addresses_contact_relations, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesContactRelationsPutAsyncWithHttpInfo
     *
     * Update address contact relations
     *
     * @param  \ck\Model\RestAccountsAddressesContactRelationsPutRequest|null $_rest_accounts_addresses_contact_relations (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesContactRelationsPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesContactRelationsPutAsyncWithHttpInfo(
        $_rest_accounts_addresses_contact_relations = null,
        string $contentType = self::contentTypes['restAccountsAddressesContactRelationsPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\AddressContactRelation[]';
        $request = $this->restAccountsAddressesContactRelationsPutRequest($_rest_accounts_addresses_contact_relations, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesContactRelationsPut'
     *
     * @param  \ck\Model\RestAccountsAddressesContactRelationsPutRequest|null $_rest_accounts_addresses_contact_relations (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesContactRelationsPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsAddressesContactRelationsPutRequest(
        $_rest_accounts_addresses_contact_relations = null,
        string $contentType = self::contentTypes['restAccountsAddressesContactRelationsPut'][0]
    ): Request
    {



        $resourcePath = '/rest/accounts/addresses/contact_relations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_accounts_addresses_contact_relations)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_accounts_addresses_contact_relations));
            } else {
                $httpBody = $_rest_accounts_addresses_contact_relations;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesGet
     *
     * Get all available addresses
     *
     * @param  string|null $updated_to Filter that restricts the search result to addresses that were updated before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $updated_from Filter that restricts the search result to addresses that were updated after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $created_to Filter that restricts the search result to addresses that were created before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $created_from Filter that restricts the search result to addresses that were created after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $with Includes the specified address information in the results. The following parameters are available: contactRelations, orderRelations. More than one parameter should be separated by commas. (optional)
     * @param  int|null $page The page of results to search for (optional)
     * @param  int|null $items_per_page The number of items to list per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Address
     */
    public function restAccountsAddressesGet(
        ?string $updated_to = null,
        ?string $updated_from = null,
        ?string $created_to = null,
        ?string $created_from = null,
        ?string $with = null,
        ?int $page = null,
        ?int $items_per_page = null,
        string $contentType = self::contentTypes['restAccountsAddressesGet'][0]
    ): \ck\Model\Address
    {
        list($response) = $this->restAccountsAddressesGetWithHttpInfo($updated_to, $updated_from, $created_to, $created_from, $with, $page, $items_per_page, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsAddressesGetWithHttpInfo
     *
     * Get all available addresses
     *
     * @param  string|null $updated_to Filter that restricts the search result to addresses that were updated before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $updated_from Filter that restricts the search result to addresses that were updated after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $created_to Filter that restricts the search result to addresses that were created before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $created_from Filter that restricts the search result to addresses that were created after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $with Includes the specified address information in the results. The following parameters are available: contactRelations, orderRelations. More than one parameter should be separated by commas. (optional)
     * @param  int|null $page The page of results to search for (optional)
     * @param  int|null $items_per_page The number of items to list per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Address, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesGetWithHttpInfo(
        ?string $updated_to = null,
        ?string $updated_from = null,
        ?string $created_to = null,
        ?string $created_from = null,
        ?string $with = null,
        ?int $page = null,
        ?int $items_per_page = null,
        string $contentType = self::contentTypes['restAccountsAddressesGet'][0]
    ): array
    {
        $request = $this->restAccountsAddressesGetRequest($updated_to, $updated_from, $created_to, $created_from, $with, $page, $items_per_page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Address' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Address' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Address', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Address';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Address',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesGetAsync
     *
     * Get all available addresses
     *
     * @param  string|null $updated_to Filter that restricts the search result to addresses that were updated before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $updated_from Filter that restricts the search result to addresses that were updated after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $created_to Filter that restricts the search result to addresses that were created before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $created_from Filter that restricts the search result to addresses that were created after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $with Includes the specified address information in the results. The following parameters are available: contactRelations, orderRelations. More than one parameter should be separated by commas. (optional)
     * @param  int|null $page The page of results to search for (optional)
     * @param  int|null $items_per_page The number of items to list per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesGetAsync(
        ?string $updated_to = null,
        ?string $updated_from = null,
        ?string $created_to = null,
        ?string $created_from = null,
        ?string $with = null,
        ?int $page = null,
        ?int $items_per_page = null,
        string $contentType = self::contentTypes['restAccountsAddressesGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountsAddressesGetAsyncWithHttpInfo($updated_to, $updated_from, $created_to, $created_from, $with, $page, $items_per_page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesGetAsyncWithHttpInfo
     *
     * Get all available addresses
     *
     * @param  string|null $updated_to Filter that restricts the search result to addresses that were updated before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $updated_from Filter that restricts the search result to addresses that were updated after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $created_to Filter that restricts the search result to addresses that were created before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $created_from Filter that restricts the search result to addresses that were created after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $with Includes the specified address information in the results. The following parameters are available: contactRelations, orderRelations. More than one parameter should be separated by commas. (optional)
     * @param  int|null $page The page of results to search for (optional)
     * @param  int|null $items_per_page The number of items to list per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesGetAsyncWithHttpInfo(
        $updated_to = null,
        $updated_from = null,
        $created_to = null,
        $created_from = null,
        $with = null,
        $page = null,
        $items_per_page = null,
        string $contentType = self::contentTypes['restAccountsAddressesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Address';
        $request = $this->restAccountsAddressesGetRequest($updated_to, $updated_from, $created_to, $created_from, $with, $page, $items_per_page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesGet'
     *
     * @param  string|null $updated_to Filter that restricts the search result to addresses that were updated before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $updated_from Filter that restricts the search result to addresses that were updated after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $created_to Filter that restricts the search result to addresses that were created before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $created_from Filter that restricts the search result to addresses that were created after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $with Includes the specified address information in the results. The following parameters are available: contactRelations, orderRelations. More than one parameter should be separated by commas. (optional)
     * @param  int|null $page The page of results to search for (optional)
     * @param  int|null $items_per_page The number of items to list per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsAddressesGetRequest(
        $updated_to = null,
        $updated_from = null,
        $created_to = null,
        $created_from = null,
        $with = null,
        $page = null,
        $items_per_page = null,
        string $contentType = self::contentTypes['restAccountsAddressesGet'][0]
    ): Request
    {









        $resourcePath = '/rest/accounts/addresses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_to,
            'updatedTo', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_from,
            'updatedFrom', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_to,
            'createdTo', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_from,
            'createdFrom', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $items_per_page,
            'itemsPerPage', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesOptionTypesGet
     *
     * List address option types
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesOptionTypesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\AddressOptionType[]
     */
    public function restAccountsAddressesOptionTypesGet(
        string $contentType = self::contentTypes['restAccountsAddressesOptionTypesGet'][0]
    ): array
    {
        list($response) = $this->restAccountsAddressesOptionTypesGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restAccountsAddressesOptionTypesGetWithHttpInfo
     *
     * List address option types
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesOptionTypesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\AddressOptionType[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesOptionTypesGetWithHttpInfo(
        string $contentType = self::contentTypes['restAccountsAddressesOptionTypesGet'][0]
    ): array
    {
        $request = $this->restAccountsAddressesOptionTypesGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\AddressOptionType[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\AddressOptionType[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\AddressOptionType[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\AddressOptionType[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\AddressOptionType[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesOptionTypesGetAsync
     *
     * List address option types
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesOptionTypesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesOptionTypesGetAsync(
        string $contentType = self::contentTypes['restAccountsAddressesOptionTypesGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountsAddressesOptionTypesGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesOptionTypesGetAsyncWithHttpInfo
     *
     * List address option types
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesOptionTypesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesOptionTypesGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restAccountsAddressesOptionTypesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\AddressOptionType[]';
        $request = $this->restAccountsAddressesOptionTypesGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesOptionTypesGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesOptionTypesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsAddressesOptionTypesGetRequest(
        string $contentType = self::contentTypes['restAccountsAddressesOptionTypesGet'][0]
    ): Request
    {


        $resourcePath = '/rest/accounts/addresses/option_types';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesOptionTypesOptionTypeIdDelete
     *
     * Delete address option type
     *
     * @param  int $option_type_id The ID of the address option type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesOptionTypesOptionTypeIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restAccountsAddressesOptionTypesOptionTypeIdDelete(
        int $option_type_id,
        string $contentType = self::contentTypes['restAccountsAddressesOptionTypesOptionTypeIdDelete'][0]
    ): void
    {
        $this->restAccountsAddressesOptionTypesOptionTypeIdDeleteWithHttpInfo($option_type_id, $contentType);
    }

    /**
     * Operation restAccountsAddressesOptionTypesOptionTypeIdDeleteWithHttpInfo
     *
     * Delete address option type
     *
     * @param  int $option_type_id The ID of the address option type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesOptionTypesOptionTypeIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesOptionTypesOptionTypeIdDeleteWithHttpInfo(
        int $option_type_id,
        string $contentType = self::contentTypes['restAccountsAddressesOptionTypesOptionTypeIdDelete'][0]
    ): array
    {
        $request = $this->restAccountsAddressesOptionTypesOptionTypeIdDeleteRequest($option_type_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesOptionTypesOptionTypeIdDeleteAsync
     *
     * Delete address option type
     *
     * @param  int $option_type_id The ID of the address option type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesOptionTypesOptionTypeIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesOptionTypesOptionTypeIdDeleteAsync(
        int $option_type_id,
        string $contentType = self::contentTypes['restAccountsAddressesOptionTypesOptionTypeIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restAccountsAddressesOptionTypesOptionTypeIdDeleteAsyncWithHttpInfo($option_type_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesOptionTypesOptionTypeIdDeleteAsyncWithHttpInfo
     *
     * Delete address option type
     *
     * @param  int $option_type_id The ID of the address option type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesOptionTypesOptionTypeIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesOptionTypesOptionTypeIdDeleteAsyncWithHttpInfo(
        $option_type_id,
        string $contentType = self::contentTypes['restAccountsAddressesOptionTypesOptionTypeIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restAccountsAddressesOptionTypesOptionTypeIdDeleteRequest($option_type_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesOptionTypesOptionTypeIdDelete'
     *
     * @param  int $option_type_id The ID of the address option type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesOptionTypesOptionTypeIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsAddressesOptionTypesOptionTypeIdDeleteRequest(
        $option_type_id,
        string $contentType = self::contentTypes['restAccountsAddressesOptionTypesOptionTypeIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'option_type_id' is set
        if ($option_type_id === null || (is_array($option_type_id) && count($option_type_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $option_type_id when calling restAccountsAddressesOptionTypesOptionTypeIdDelete'
            );
        }


        $resourcePath = '/rest/accounts/addresses/option_types/{optionTypeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($option_type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'optionTypeId' . '}',
                ObjectSerializer::toPathValue($option_type_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesOptionTypesOptionTypeIdGet
     *
     * Get address option type
     *
     * @param  int $option_type_id The ID of the address option type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesOptionTypesOptionTypeIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\AddressOptionType
     */
    public function restAccountsAddressesOptionTypesOptionTypeIdGet(
        int $option_type_id,
        string $contentType = self::contentTypes['restAccountsAddressesOptionTypesOptionTypeIdGet'][0]
    ): \ck\Model\AddressOptionType
    {
        list($response) = $this->restAccountsAddressesOptionTypesOptionTypeIdGetWithHttpInfo($option_type_id, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsAddressesOptionTypesOptionTypeIdGetWithHttpInfo
     *
     * Get address option type
     *
     * @param  int $option_type_id The ID of the address option type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesOptionTypesOptionTypeIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\AddressOptionType, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesOptionTypesOptionTypeIdGetWithHttpInfo(
        int $option_type_id,
        string $contentType = self::contentTypes['restAccountsAddressesOptionTypesOptionTypeIdGet'][0]
    ): array
    {
        $request = $this->restAccountsAddressesOptionTypesOptionTypeIdGetRequest($option_type_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\AddressOptionType' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\AddressOptionType' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\AddressOptionType', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\AddressOptionType';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\AddressOptionType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesOptionTypesOptionTypeIdGetAsync
     *
     * Get address option type
     *
     * @param  int $option_type_id The ID of the address option type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesOptionTypesOptionTypeIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesOptionTypesOptionTypeIdGetAsync(
        int $option_type_id,
        string $contentType = self::contentTypes['restAccountsAddressesOptionTypesOptionTypeIdGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountsAddressesOptionTypesOptionTypeIdGetAsyncWithHttpInfo($option_type_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesOptionTypesOptionTypeIdGetAsyncWithHttpInfo
     *
     * Get address option type
     *
     * @param  int $option_type_id The ID of the address option type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesOptionTypesOptionTypeIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesOptionTypesOptionTypeIdGetAsyncWithHttpInfo(
        $option_type_id,
        string $contentType = self::contentTypes['restAccountsAddressesOptionTypesOptionTypeIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\AddressOptionType';
        $request = $this->restAccountsAddressesOptionTypesOptionTypeIdGetRequest($option_type_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesOptionTypesOptionTypeIdGet'
     *
     * @param  int $option_type_id The ID of the address option type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesOptionTypesOptionTypeIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsAddressesOptionTypesOptionTypeIdGetRequest(
        $option_type_id,
        string $contentType = self::contentTypes['restAccountsAddressesOptionTypesOptionTypeIdGet'][0]
    ): Request
    {

        // verify the required parameter 'option_type_id' is set
        if ($option_type_id === null || (is_array($option_type_id) && count($option_type_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $option_type_id when calling restAccountsAddressesOptionTypesOptionTypeIdGet'
            );
        }


        $resourcePath = '/rest/accounts/addresses/option_types/{optionTypeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($option_type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'optionTypeId' . '}',
                ObjectSerializer::toPathValue($option_type_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesOptionTypesOptionTypeIdPut
     *
     * Update address option type
     *
     * @param  int $option_type_id The ID of the address option type (required)
     * @param  \ck\Model\RestAccountsAddressesOptionTypesPostRequest|null $_rest_accounts_addresses_option_types_option_type_id _rest_accounts_addresses_option_types_option_type_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesOptionTypesOptionTypeIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\AddressOptionType
     */
    public function restAccountsAddressesOptionTypesOptionTypeIdPut(
        int $option_type_id,
        ?\ck\Model\RestAccountsAddressesOptionTypesPostRequest $_rest_accounts_addresses_option_types_option_type_id = null,
        string $contentType = self::contentTypes['restAccountsAddressesOptionTypesOptionTypeIdPut'][0]
    ): \ck\Model\AddressOptionType
    {
        list($response) = $this->restAccountsAddressesOptionTypesOptionTypeIdPutWithHttpInfo($option_type_id, $_rest_accounts_addresses_option_types_option_type_id, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsAddressesOptionTypesOptionTypeIdPutWithHttpInfo
     *
     * Update address option type
     *
     * @param  int $option_type_id The ID of the address option type (required)
     * @param  \ck\Model\RestAccountsAddressesOptionTypesPostRequest|null $_rest_accounts_addresses_option_types_option_type_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesOptionTypesOptionTypeIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\AddressOptionType, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesOptionTypesOptionTypeIdPutWithHttpInfo(
        int $option_type_id,
        ?\ck\Model\RestAccountsAddressesOptionTypesPostRequest $_rest_accounts_addresses_option_types_option_type_id = null,
        string $contentType = self::contentTypes['restAccountsAddressesOptionTypesOptionTypeIdPut'][0]
    ): array
    {
        $request = $this->restAccountsAddressesOptionTypesOptionTypeIdPutRequest($option_type_id, $_rest_accounts_addresses_option_types_option_type_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\AddressOptionType' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\AddressOptionType' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\AddressOptionType', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\AddressOptionType';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\AddressOptionType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesOptionTypesOptionTypeIdPutAsync
     *
     * Update address option type
     *
     * @param  int $option_type_id The ID of the address option type (required)
     * @param  \ck\Model\RestAccountsAddressesOptionTypesPostRequest|null $_rest_accounts_addresses_option_types_option_type_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesOptionTypesOptionTypeIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesOptionTypesOptionTypeIdPutAsync(
        int $option_type_id,
        ?\ck\Model\RestAccountsAddressesOptionTypesPostRequest $_rest_accounts_addresses_option_types_option_type_id = null,
        string $contentType = self::contentTypes['restAccountsAddressesOptionTypesOptionTypeIdPut'][0]
    ): PromiseInterface
    {
        return $this->restAccountsAddressesOptionTypesOptionTypeIdPutAsyncWithHttpInfo($option_type_id, $_rest_accounts_addresses_option_types_option_type_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesOptionTypesOptionTypeIdPutAsyncWithHttpInfo
     *
     * Update address option type
     *
     * @param  int $option_type_id The ID of the address option type (required)
     * @param  \ck\Model\RestAccountsAddressesOptionTypesPostRequest|null $_rest_accounts_addresses_option_types_option_type_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesOptionTypesOptionTypeIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesOptionTypesOptionTypeIdPutAsyncWithHttpInfo(
        $option_type_id,
        $_rest_accounts_addresses_option_types_option_type_id = null,
        string $contentType = self::contentTypes['restAccountsAddressesOptionTypesOptionTypeIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\AddressOptionType';
        $request = $this->restAccountsAddressesOptionTypesOptionTypeIdPutRequest($option_type_id, $_rest_accounts_addresses_option_types_option_type_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesOptionTypesOptionTypeIdPut'
     *
     * @param  int $option_type_id The ID of the address option type (required)
     * @param  \ck\Model\RestAccountsAddressesOptionTypesPostRequest|null $_rest_accounts_addresses_option_types_option_type_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesOptionTypesOptionTypeIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsAddressesOptionTypesOptionTypeIdPutRequest(
        $option_type_id,
        $_rest_accounts_addresses_option_types_option_type_id = null,
        string $contentType = self::contentTypes['restAccountsAddressesOptionTypesOptionTypeIdPut'][0]
    ): Request
    {

        // verify the required parameter 'option_type_id' is set
        if ($option_type_id === null || (is_array($option_type_id) && count($option_type_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $option_type_id when calling restAccountsAddressesOptionTypesOptionTypeIdPut'
            );
        }



        $resourcePath = '/rest/accounts/addresses/option_types/{optionTypeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($option_type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'optionTypeId' . '}',
                ObjectSerializer::toPathValue($option_type_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_accounts_addresses_option_types_option_type_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_accounts_addresses_option_types_option_type_id));
            } else {
                $httpBody = $_rest_accounts_addresses_option_types_option_type_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesOptionTypesPost
     *
     * Create address option type
     *
     * @param  \ck\Model\RestAccountsAddressesOptionTypesPostRequest|null $_rest_accounts_addresses_option_types _rest_accounts_addresses_option_types (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesOptionTypesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\AddressOptionType
     */
    public function restAccountsAddressesOptionTypesPost(
        ?\ck\Model\RestAccountsAddressesOptionTypesPostRequest $_rest_accounts_addresses_option_types = null,
        string $contentType = self::contentTypes['restAccountsAddressesOptionTypesPost'][0]
    ): \ck\Model\AddressOptionType
    {
        list($response) = $this->restAccountsAddressesOptionTypesPostWithHttpInfo($_rest_accounts_addresses_option_types, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsAddressesOptionTypesPostWithHttpInfo
     *
     * Create address option type
     *
     * @param  \ck\Model\RestAccountsAddressesOptionTypesPostRequest|null $_rest_accounts_addresses_option_types (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesOptionTypesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\AddressOptionType, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesOptionTypesPostWithHttpInfo(
        ?\ck\Model\RestAccountsAddressesOptionTypesPostRequest $_rest_accounts_addresses_option_types = null,
        string $contentType = self::contentTypes['restAccountsAddressesOptionTypesPost'][0]
    ): array
    {
        $request = $this->restAccountsAddressesOptionTypesPostRequest($_rest_accounts_addresses_option_types, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\AddressOptionType' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\AddressOptionType' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\AddressOptionType', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\AddressOptionType';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\AddressOptionType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesOptionTypesPostAsync
     *
     * Create address option type
     *
     * @param  \ck\Model\RestAccountsAddressesOptionTypesPostRequest|null $_rest_accounts_addresses_option_types (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesOptionTypesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesOptionTypesPostAsync(
        ?\ck\Model\RestAccountsAddressesOptionTypesPostRequest $_rest_accounts_addresses_option_types = null,
        string $contentType = self::contentTypes['restAccountsAddressesOptionTypesPost'][0]
    ): PromiseInterface
    {
        return $this->restAccountsAddressesOptionTypesPostAsyncWithHttpInfo($_rest_accounts_addresses_option_types, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesOptionTypesPostAsyncWithHttpInfo
     *
     * Create address option type
     *
     * @param  \ck\Model\RestAccountsAddressesOptionTypesPostRequest|null $_rest_accounts_addresses_option_types (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesOptionTypesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesOptionTypesPostAsyncWithHttpInfo(
        $_rest_accounts_addresses_option_types = null,
        string $contentType = self::contentTypes['restAccountsAddressesOptionTypesPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\AddressOptionType';
        $request = $this->restAccountsAddressesOptionTypesPostRequest($_rest_accounts_addresses_option_types, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesOptionTypesPost'
     *
     * @param  \ck\Model\RestAccountsAddressesOptionTypesPostRequest|null $_rest_accounts_addresses_option_types (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesOptionTypesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsAddressesOptionTypesPostRequest(
        $_rest_accounts_addresses_option_types = null,
        string $contentType = self::contentTypes['restAccountsAddressesOptionTypesPost'][0]
    ): Request
    {



        $resourcePath = '/rest/accounts/addresses/option_types';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_accounts_addresses_option_types)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_accounts_addresses_option_types));
            } else {
                $httpBody = $_rest_accounts_addresses_option_types;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesOptionsOptionIdDelete
     *
     * Delete address option by option ID
     *
     * @param  int $option_id The ID of the address option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesOptionsOptionIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restAccountsAddressesOptionsOptionIdDelete(
        int $option_id,
        string $contentType = self::contentTypes['restAccountsAddressesOptionsOptionIdDelete'][0]
    ): void
    {
        $this->restAccountsAddressesOptionsOptionIdDeleteWithHttpInfo($option_id, $contentType);
    }

    /**
     * Operation restAccountsAddressesOptionsOptionIdDeleteWithHttpInfo
     *
     * Delete address option by option ID
     *
     * @param  int $option_id The ID of the address option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesOptionsOptionIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesOptionsOptionIdDeleteWithHttpInfo(
        int $option_id,
        string $contentType = self::contentTypes['restAccountsAddressesOptionsOptionIdDelete'][0]
    ): array
    {
        $request = $this->restAccountsAddressesOptionsOptionIdDeleteRequest($option_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesOptionsOptionIdDeleteAsync
     *
     * Delete address option by option ID
     *
     * @param  int $option_id The ID of the address option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesOptionsOptionIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesOptionsOptionIdDeleteAsync(
        int $option_id,
        string $contentType = self::contentTypes['restAccountsAddressesOptionsOptionIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restAccountsAddressesOptionsOptionIdDeleteAsyncWithHttpInfo($option_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesOptionsOptionIdDeleteAsyncWithHttpInfo
     *
     * Delete address option by option ID
     *
     * @param  int $option_id The ID of the address option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesOptionsOptionIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesOptionsOptionIdDeleteAsyncWithHttpInfo(
        $option_id,
        string $contentType = self::contentTypes['restAccountsAddressesOptionsOptionIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restAccountsAddressesOptionsOptionIdDeleteRequest($option_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesOptionsOptionIdDelete'
     *
     * @param  int $option_id The ID of the address option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesOptionsOptionIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsAddressesOptionsOptionIdDeleteRequest(
        $option_id,
        string $contentType = self::contentTypes['restAccountsAddressesOptionsOptionIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'option_id' is set
        if ($option_id === null || (is_array($option_id) && count($option_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $option_id when calling restAccountsAddressesOptionsOptionIdDelete'
            );
        }


        $resourcePath = '/rest/accounts/addresses/options/{optionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($option_id !== null) {
            $resourcePath = str_replace(
                '{' . 'optionId' . '}',
                ObjectSerializer::toPathValue($option_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesOptionsOptionIdGet
     *
     * Get address option
     *
     * @param  int $option_id The ID of the address option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesOptionsOptionIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\AddressOption
     */
    public function restAccountsAddressesOptionsOptionIdGet(
        int $option_id,
        string $contentType = self::contentTypes['restAccountsAddressesOptionsOptionIdGet'][0]
    ): \ck\Model\AddressOption
    {
        list($response) = $this->restAccountsAddressesOptionsOptionIdGetWithHttpInfo($option_id, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsAddressesOptionsOptionIdGetWithHttpInfo
     *
     * Get address option
     *
     * @param  int $option_id The ID of the address option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesOptionsOptionIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\AddressOption, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesOptionsOptionIdGetWithHttpInfo(
        int $option_id,
        string $contentType = self::contentTypes['restAccountsAddressesOptionsOptionIdGet'][0]
    ): array
    {
        $request = $this->restAccountsAddressesOptionsOptionIdGetRequest($option_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\AddressOption' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\AddressOption' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\AddressOption', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\AddressOption';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\AddressOption',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesOptionsOptionIdGetAsync
     *
     * Get address option
     *
     * @param  int $option_id The ID of the address option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesOptionsOptionIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesOptionsOptionIdGetAsync(
        int $option_id,
        string $contentType = self::contentTypes['restAccountsAddressesOptionsOptionIdGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountsAddressesOptionsOptionIdGetAsyncWithHttpInfo($option_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesOptionsOptionIdGetAsyncWithHttpInfo
     *
     * Get address option
     *
     * @param  int $option_id The ID of the address option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesOptionsOptionIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesOptionsOptionIdGetAsyncWithHttpInfo(
        $option_id,
        string $contentType = self::contentTypes['restAccountsAddressesOptionsOptionIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\AddressOption';
        $request = $this->restAccountsAddressesOptionsOptionIdGetRequest($option_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesOptionsOptionIdGet'
     *
     * @param  int $option_id The ID of the address option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesOptionsOptionIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsAddressesOptionsOptionIdGetRequest(
        $option_id,
        string $contentType = self::contentTypes['restAccountsAddressesOptionsOptionIdGet'][0]
    ): Request
    {

        // verify the required parameter 'option_id' is set
        if ($option_id === null || (is_array($option_id) && count($option_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $option_id when calling restAccountsAddressesOptionsOptionIdGet'
            );
        }


        $resourcePath = '/rest/accounts/addresses/options/{optionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($option_id !== null) {
            $resourcePath = str_replace(
                '{' . 'optionId' . '}',
                ObjectSerializer::toPathValue($option_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesOptionsOptionIdPut
     *
     * Update address option
     *
     * @param  int $option_id The ID of the address option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesOptionsOptionIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\AddressOption
     */
    public function restAccountsAddressesOptionsOptionIdPut(
        int $option_id,
        string $contentType = self::contentTypes['restAccountsAddressesOptionsOptionIdPut'][0]
    ): \ck\Model\AddressOption
    {
        list($response) = $this->restAccountsAddressesOptionsOptionIdPutWithHttpInfo($option_id, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsAddressesOptionsOptionIdPutWithHttpInfo
     *
     * Update address option
     *
     * @param  int $option_id The ID of the address option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesOptionsOptionIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\AddressOption, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesOptionsOptionIdPutWithHttpInfo(
        int $option_id,
        string $contentType = self::contentTypes['restAccountsAddressesOptionsOptionIdPut'][0]
    ): array
    {
        $request = $this->restAccountsAddressesOptionsOptionIdPutRequest($option_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\AddressOption' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\AddressOption' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\AddressOption', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\AddressOption';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\AddressOption',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesOptionsOptionIdPutAsync
     *
     * Update address option
     *
     * @param  int $option_id The ID of the address option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesOptionsOptionIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesOptionsOptionIdPutAsync(
        int $option_id,
        string $contentType = self::contentTypes['restAccountsAddressesOptionsOptionIdPut'][0]
    ): PromiseInterface
    {
        return $this->restAccountsAddressesOptionsOptionIdPutAsyncWithHttpInfo($option_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesOptionsOptionIdPutAsyncWithHttpInfo
     *
     * Update address option
     *
     * @param  int $option_id The ID of the address option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesOptionsOptionIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesOptionsOptionIdPutAsyncWithHttpInfo(
        $option_id,
        string $contentType = self::contentTypes['restAccountsAddressesOptionsOptionIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\AddressOption';
        $request = $this->restAccountsAddressesOptionsOptionIdPutRequest($option_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesOptionsOptionIdPut'
     *
     * @param  int $option_id The ID of the address option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesOptionsOptionIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsAddressesOptionsOptionIdPutRequest(
        $option_id,
        string $contentType = self::contentTypes['restAccountsAddressesOptionsOptionIdPut'][0]
    ): Request
    {

        // verify the required parameter 'option_id' is set
        if ($option_id === null || (is_array($option_id) && count($option_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $option_id when calling restAccountsAddressesOptionsOptionIdPut'
            );
        }


        $resourcePath = '/rest/accounts/addresses/options/{optionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($option_id !== null) {
            $resourcePath = str_replace(
                '{' . 'optionId' . '}',
                ObjectSerializer::toPathValue($option_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesPosRelationsAddressPosRelationIdDelete
     *
     * Delete address POS relation
     *
     * @param  int $address_pos_relation_id The ID of the address POS relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesPosRelationsAddressPosRelationIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restAccountsAddressesPosRelationsAddressPosRelationIdDelete(
        int $address_pos_relation_id,
        string $contentType = self::contentTypes['restAccountsAddressesPosRelationsAddressPosRelationIdDelete'][0]
    ): void
    {
        $this->restAccountsAddressesPosRelationsAddressPosRelationIdDeleteWithHttpInfo($address_pos_relation_id, $contentType);
    }

    /**
     * Operation restAccountsAddressesPosRelationsAddressPosRelationIdDeleteWithHttpInfo
     *
     * Delete address POS relation
     *
     * @param  int $address_pos_relation_id The ID of the address POS relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesPosRelationsAddressPosRelationIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesPosRelationsAddressPosRelationIdDeleteWithHttpInfo(
        int $address_pos_relation_id,
        string $contentType = self::contentTypes['restAccountsAddressesPosRelationsAddressPosRelationIdDelete'][0]
    ): array
    {
        $request = $this->restAccountsAddressesPosRelationsAddressPosRelationIdDeleteRequest($address_pos_relation_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesPosRelationsAddressPosRelationIdDeleteAsync
     *
     * Delete address POS relation
     *
     * @param  int $address_pos_relation_id The ID of the address POS relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesPosRelationsAddressPosRelationIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesPosRelationsAddressPosRelationIdDeleteAsync(
        int $address_pos_relation_id,
        string $contentType = self::contentTypes['restAccountsAddressesPosRelationsAddressPosRelationIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restAccountsAddressesPosRelationsAddressPosRelationIdDeleteAsyncWithHttpInfo($address_pos_relation_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesPosRelationsAddressPosRelationIdDeleteAsyncWithHttpInfo
     *
     * Delete address POS relation
     *
     * @param  int $address_pos_relation_id The ID of the address POS relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesPosRelationsAddressPosRelationIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesPosRelationsAddressPosRelationIdDeleteAsyncWithHttpInfo(
        $address_pos_relation_id,
        string $contentType = self::contentTypes['restAccountsAddressesPosRelationsAddressPosRelationIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restAccountsAddressesPosRelationsAddressPosRelationIdDeleteRequest($address_pos_relation_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesPosRelationsAddressPosRelationIdDelete'
     *
     * @param  int $address_pos_relation_id The ID of the address POS relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesPosRelationsAddressPosRelationIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsAddressesPosRelationsAddressPosRelationIdDeleteRequest(
        $address_pos_relation_id,
        string $contentType = self::contentTypes['restAccountsAddressesPosRelationsAddressPosRelationIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'address_pos_relation_id' is set
        if ($address_pos_relation_id === null || (is_array($address_pos_relation_id) && count($address_pos_relation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $address_pos_relation_id when calling restAccountsAddressesPosRelationsAddressPosRelationIdDelete'
            );
        }


        $resourcePath = '/rest/accounts/addresses/pos_relations/{addressPosRelationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($address_pos_relation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addressPosRelationId' . '}',
                ObjectSerializer::toPathValue($address_pos_relation_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesPosRelationsAddressPosRelationIdGet
     *
     * Get address POS relation
     *
     * @param  int $address_pos_relation_id The ID of the address POS relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesPosRelationsAddressPosRelationIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\AddressPosRelation
     */
    public function restAccountsAddressesPosRelationsAddressPosRelationIdGet(
        int $address_pos_relation_id,
        string $contentType = self::contentTypes['restAccountsAddressesPosRelationsAddressPosRelationIdGet'][0]
    ): \ck\Model\AddressPosRelation
    {
        list($response) = $this->restAccountsAddressesPosRelationsAddressPosRelationIdGetWithHttpInfo($address_pos_relation_id, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsAddressesPosRelationsAddressPosRelationIdGetWithHttpInfo
     *
     * Get address POS relation
     *
     * @param  int $address_pos_relation_id The ID of the address POS relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesPosRelationsAddressPosRelationIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\AddressPosRelation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesPosRelationsAddressPosRelationIdGetWithHttpInfo(
        int $address_pos_relation_id,
        string $contentType = self::contentTypes['restAccountsAddressesPosRelationsAddressPosRelationIdGet'][0]
    ): array
    {
        $request = $this->restAccountsAddressesPosRelationsAddressPosRelationIdGetRequest($address_pos_relation_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\AddressPosRelation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\AddressPosRelation' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\AddressPosRelation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\AddressPosRelation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\AddressPosRelation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesPosRelationsAddressPosRelationIdGetAsync
     *
     * Get address POS relation
     *
     * @param  int $address_pos_relation_id The ID of the address POS relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesPosRelationsAddressPosRelationIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesPosRelationsAddressPosRelationIdGetAsync(
        int $address_pos_relation_id,
        string $contentType = self::contentTypes['restAccountsAddressesPosRelationsAddressPosRelationIdGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountsAddressesPosRelationsAddressPosRelationIdGetAsyncWithHttpInfo($address_pos_relation_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesPosRelationsAddressPosRelationIdGetAsyncWithHttpInfo
     *
     * Get address POS relation
     *
     * @param  int $address_pos_relation_id The ID of the address POS relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesPosRelationsAddressPosRelationIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesPosRelationsAddressPosRelationIdGetAsyncWithHttpInfo(
        $address_pos_relation_id,
        string $contentType = self::contentTypes['restAccountsAddressesPosRelationsAddressPosRelationIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\AddressPosRelation';
        $request = $this->restAccountsAddressesPosRelationsAddressPosRelationIdGetRequest($address_pos_relation_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesPosRelationsAddressPosRelationIdGet'
     *
     * @param  int $address_pos_relation_id The ID of the address POS relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesPosRelationsAddressPosRelationIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsAddressesPosRelationsAddressPosRelationIdGetRequest(
        $address_pos_relation_id,
        string $contentType = self::contentTypes['restAccountsAddressesPosRelationsAddressPosRelationIdGet'][0]
    ): Request
    {

        // verify the required parameter 'address_pos_relation_id' is set
        if ($address_pos_relation_id === null || (is_array($address_pos_relation_id) && count($address_pos_relation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $address_pos_relation_id when calling restAccountsAddressesPosRelationsAddressPosRelationIdGet'
            );
        }


        $resourcePath = '/rest/accounts/addresses/pos_relations/{addressPosRelationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($address_pos_relation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addressPosRelationId' . '}',
                ObjectSerializer::toPathValue($address_pos_relation_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesPosRelationsAddressPosRelationIdPut
     *
     * Update address POS relation
     *
     * @param  int $address_pos_relation_id The ID of the address POS relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesPosRelationsAddressPosRelationIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\AddressPosRelation
     */
    public function restAccountsAddressesPosRelationsAddressPosRelationIdPut(
        int $address_pos_relation_id,
        string $contentType = self::contentTypes['restAccountsAddressesPosRelationsAddressPosRelationIdPut'][0]
    ): \ck\Model\AddressPosRelation
    {
        list($response) = $this->restAccountsAddressesPosRelationsAddressPosRelationIdPutWithHttpInfo($address_pos_relation_id, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsAddressesPosRelationsAddressPosRelationIdPutWithHttpInfo
     *
     * Update address POS relation
     *
     * @param  int $address_pos_relation_id The ID of the address POS relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesPosRelationsAddressPosRelationIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\AddressPosRelation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesPosRelationsAddressPosRelationIdPutWithHttpInfo(
        int $address_pos_relation_id,
        string $contentType = self::contentTypes['restAccountsAddressesPosRelationsAddressPosRelationIdPut'][0]
    ): array
    {
        $request = $this->restAccountsAddressesPosRelationsAddressPosRelationIdPutRequest($address_pos_relation_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\AddressPosRelation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\AddressPosRelation' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\AddressPosRelation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\AddressPosRelation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\AddressPosRelation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesPosRelationsAddressPosRelationIdPutAsync
     *
     * Update address POS relation
     *
     * @param  int $address_pos_relation_id The ID of the address POS relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesPosRelationsAddressPosRelationIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesPosRelationsAddressPosRelationIdPutAsync(
        int $address_pos_relation_id,
        string $contentType = self::contentTypes['restAccountsAddressesPosRelationsAddressPosRelationIdPut'][0]
    ): PromiseInterface
    {
        return $this->restAccountsAddressesPosRelationsAddressPosRelationIdPutAsyncWithHttpInfo($address_pos_relation_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesPosRelationsAddressPosRelationIdPutAsyncWithHttpInfo
     *
     * Update address POS relation
     *
     * @param  int $address_pos_relation_id The ID of the address POS relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesPosRelationsAddressPosRelationIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesPosRelationsAddressPosRelationIdPutAsyncWithHttpInfo(
        $address_pos_relation_id,
        string $contentType = self::contentTypes['restAccountsAddressesPosRelationsAddressPosRelationIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\AddressPosRelation';
        $request = $this->restAccountsAddressesPosRelationsAddressPosRelationIdPutRequest($address_pos_relation_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesPosRelationsAddressPosRelationIdPut'
     *
     * @param  int $address_pos_relation_id The ID of the address POS relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesPosRelationsAddressPosRelationIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsAddressesPosRelationsAddressPosRelationIdPutRequest(
        $address_pos_relation_id,
        string $contentType = self::contentTypes['restAccountsAddressesPosRelationsAddressPosRelationIdPut'][0]
    ): Request
    {

        // verify the required parameter 'address_pos_relation_id' is set
        if ($address_pos_relation_id === null || (is_array($address_pos_relation_id) && count($address_pos_relation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $address_pos_relation_id when calling restAccountsAddressesPosRelationsAddressPosRelationIdPut'
            );
        }


        $resourcePath = '/rest/accounts/addresses/pos_relations/{addressPosRelationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($address_pos_relation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addressPosRelationId' . '}',
                ObjectSerializer::toPathValue($address_pos_relation_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesPosRelationsGet
     *
     * List address POS relations
     *
     * @param  int|null $page page (optional)
     * @param  int|null $items_per_page items per page (optional)
     * @param  string|null $with Includes the specified address pos relation information in the results. The following parameters are available: address and type. More than one parameter should be separated by commas. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesPosRelationsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestAccountsAddressesPosRelationsGet200Response
     */
    public function restAccountsAddressesPosRelationsGet(
        ?int $page = null,
        ?int $items_per_page = null,
        ?string $with = null,
        string $contentType = self::contentTypes['restAccountsAddressesPosRelationsGet'][0]
    ): \ck\Model\RestAccountsAddressesPosRelationsGet200Response
    {
        list($response) = $this->restAccountsAddressesPosRelationsGetWithHttpInfo($page, $items_per_page, $with, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsAddressesPosRelationsGetWithHttpInfo
     *
     * List address POS relations
     *
     * @param  int|null $page page (optional)
     * @param  int|null $items_per_page items per page (optional)
     * @param  string|null $with Includes the specified address pos relation information in the results. The following parameters are available: address and type. More than one parameter should be separated by commas. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesPosRelationsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestAccountsAddressesPosRelationsGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesPosRelationsGetWithHttpInfo(
        ?int $page = null,
        ?int $items_per_page = null,
        ?string $with = null,
        string $contentType = self::contentTypes['restAccountsAddressesPosRelationsGet'][0]
    ): array
    {
        $request = $this->restAccountsAddressesPosRelationsGetRequest($page, $items_per_page, $with, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestAccountsAddressesPosRelationsGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestAccountsAddressesPosRelationsGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestAccountsAddressesPosRelationsGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestAccountsAddressesPosRelationsGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestAccountsAddressesPosRelationsGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesPosRelationsGetAsync
     *
     * List address POS relations
     *
     * @param  int|null $page page (optional)
     * @param  int|null $items_per_page items per page (optional)
     * @param  string|null $with Includes the specified address pos relation information in the results. The following parameters are available: address and type. More than one parameter should be separated by commas. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesPosRelationsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesPosRelationsGetAsync(
        ?int $page = null,
        ?int $items_per_page = null,
        ?string $with = null,
        string $contentType = self::contentTypes['restAccountsAddressesPosRelationsGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountsAddressesPosRelationsGetAsyncWithHttpInfo($page, $items_per_page, $with, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesPosRelationsGetAsyncWithHttpInfo
     *
     * List address POS relations
     *
     * @param  int|null $page page (optional)
     * @param  int|null $items_per_page items per page (optional)
     * @param  string|null $with Includes the specified address pos relation information in the results. The following parameters are available: address and type. More than one parameter should be separated by commas. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesPosRelationsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesPosRelationsGetAsyncWithHttpInfo(
        $page = null,
        $items_per_page = null,
        $with = null,
        string $contentType = self::contentTypes['restAccountsAddressesPosRelationsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestAccountsAddressesPosRelationsGet200Response';
        $request = $this->restAccountsAddressesPosRelationsGetRequest($page, $items_per_page, $with, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesPosRelationsGet'
     *
     * @param  int|null $page page (optional)
     * @param  int|null $items_per_page items per page (optional)
     * @param  string|null $with Includes the specified address pos relation information in the results. The following parameters are available: address and type. More than one parameter should be separated by commas. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesPosRelationsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsAddressesPosRelationsGetRequest(
        $page = null,
        $items_per_page = null,
        $with = null,
        string $contentType = self::contentTypes['restAccountsAddressesPosRelationsGet'][0]
    ): Request
    {





        $resourcePath = '/rest/accounts/addresses/pos_relations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $items_per_page,
            'itemsPerPage', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesPosRelationsPost
     *
     * Create address POS relation
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesPosRelationsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\AddressPosRelation
     */
    public function restAccountsAddressesPosRelationsPost(
        string $contentType = self::contentTypes['restAccountsAddressesPosRelationsPost'][0]
    ): \ck\Model\AddressPosRelation
    {
        list($response) = $this->restAccountsAddressesPosRelationsPostWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restAccountsAddressesPosRelationsPostWithHttpInfo
     *
     * Create address POS relation
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesPosRelationsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\AddressPosRelation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesPosRelationsPostWithHttpInfo(
        string $contentType = self::contentTypes['restAccountsAddressesPosRelationsPost'][0]
    ): array
    {
        $request = $this->restAccountsAddressesPosRelationsPostRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\AddressPosRelation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\AddressPosRelation' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\AddressPosRelation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\AddressPosRelation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\AddressPosRelation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesPosRelationsPostAsync
     *
     * Create address POS relation
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesPosRelationsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesPosRelationsPostAsync(
        string $contentType = self::contentTypes['restAccountsAddressesPosRelationsPost'][0]
    ): PromiseInterface
    {
        return $this->restAccountsAddressesPosRelationsPostAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesPosRelationsPostAsyncWithHttpInfo
     *
     * Create address POS relation
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesPosRelationsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesPosRelationsPostAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restAccountsAddressesPosRelationsPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\AddressPosRelation';
        $request = $this->restAccountsAddressesPosRelationsPostRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesPosRelationsPost'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesPosRelationsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsAddressesPosRelationsPostRequest(
        string $contentType = self::contentTypes['restAccountsAddressesPosRelationsPost'][0]
    ): Request
    {


        $resourcePath = '/rest/accounts/addresses/pos_relations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesPost
     *
     * Create address
     *
     * @param  \ck\Model\RestAccountsAddressesPostRequest|null $_rest_accounts_addresses _rest_accounts_addresses (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Address
     */
    public function restAccountsAddressesPost(
        ?\ck\Model\RestAccountsAddressesPostRequest $_rest_accounts_addresses = null,
        string $contentType = self::contentTypes['restAccountsAddressesPost'][0]
    ): \ck\Model\Address
    {
        list($response) = $this->restAccountsAddressesPostWithHttpInfo($_rest_accounts_addresses, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsAddressesPostWithHttpInfo
     *
     * Create address
     *
     * @param  \ck\Model\RestAccountsAddressesPostRequest|null $_rest_accounts_addresses (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Address, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesPostWithHttpInfo(
        ?\ck\Model\RestAccountsAddressesPostRequest $_rest_accounts_addresses = null,
        string $contentType = self::contentTypes['restAccountsAddressesPost'][0]
    ): array
    {
        $request = $this->restAccountsAddressesPostRequest($_rest_accounts_addresses, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Address' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Address' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Address', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Address';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Address',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesPostAsync
     *
     * Create address
     *
     * @param  \ck\Model\RestAccountsAddressesPostRequest|null $_rest_accounts_addresses (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesPostAsync(
        ?\ck\Model\RestAccountsAddressesPostRequest $_rest_accounts_addresses = null,
        string $contentType = self::contentTypes['restAccountsAddressesPost'][0]
    ): PromiseInterface
    {
        return $this->restAccountsAddressesPostAsyncWithHttpInfo($_rest_accounts_addresses, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesPostAsyncWithHttpInfo
     *
     * Create address
     *
     * @param  \ck\Model\RestAccountsAddressesPostRequest|null $_rest_accounts_addresses (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesPostAsyncWithHttpInfo(
        $_rest_accounts_addresses = null,
        string $contentType = self::contentTypes['restAccountsAddressesPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Address';
        $request = $this->restAccountsAddressesPostRequest($_rest_accounts_addresses, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesPost'
     *
     * @param  \ck\Model\RestAccountsAddressesPostRequest|null $_rest_accounts_addresses (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsAddressesPostRequest(
        $_rest_accounts_addresses = null,
        string $contentType = self::contentTypes['restAccountsAddressesPost'][0]
    ): Request
    {



        $resourcePath = '/rest/accounts/addresses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_accounts_addresses)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_accounts_addresses));
            } else {
                $httpBody = $_rest_accounts_addresses;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesRelationTypesGet
     *
     * List address relation types
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesRelationTypesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\AddressRelationType[]
     */
    public function restAccountsAddressesRelationTypesGet(
        string $contentType = self::contentTypes['restAccountsAddressesRelationTypesGet'][0]
    ): array
    {
        list($response) = $this->restAccountsAddressesRelationTypesGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restAccountsAddressesRelationTypesGetWithHttpInfo
     *
     * List address relation types
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesRelationTypesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\AddressRelationType[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesRelationTypesGetWithHttpInfo(
        string $contentType = self::contentTypes['restAccountsAddressesRelationTypesGet'][0]
    ): array
    {
        $request = $this->restAccountsAddressesRelationTypesGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\AddressRelationType[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\AddressRelationType[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\AddressRelationType[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\AddressRelationType[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\AddressRelationType[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesRelationTypesGetAsync
     *
     * List address relation types
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesRelationTypesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesRelationTypesGetAsync(
        string $contentType = self::contentTypes['restAccountsAddressesRelationTypesGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountsAddressesRelationTypesGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesRelationTypesGetAsyncWithHttpInfo
     *
     * List address relation types
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesRelationTypesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesRelationTypesGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restAccountsAddressesRelationTypesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\AddressRelationType[]';
        $request = $this->restAccountsAddressesRelationTypesGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesRelationTypesGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesRelationTypesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsAddressesRelationTypesGetRequest(
        string $contentType = self::contentTypes['restAccountsAddressesRelationTypesGet'][0]
    ): Request
    {


        $resourcePath = '/rest/accounts/addresses/relation_types';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesRelationsTypesApplicationsApplicationLangGet
     *
     * List address relation types
     *
     * @param  string $application The application type (required)
     * @param  string $lang The language as ISO 639-1 code (e.g. &#x60;en&#x60; for English) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesRelationsTypesApplicationsApplicationLangGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restAccountsAddressesRelationsTypesApplicationsApplicationLangGet(
        string $application,
        string $lang,
        string $contentType = self::contentTypes['restAccountsAddressesRelationsTypesApplicationsApplicationLangGet'][0]
    ): object
    {
        list($response) = $this->restAccountsAddressesRelationsTypesApplicationsApplicationLangGetWithHttpInfo($application, $lang, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsAddressesRelationsTypesApplicationsApplicationLangGetWithHttpInfo
     *
     * List address relation types
     *
     * @param  string $application The application type (required)
     * @param  string $lang The language as ISO 639-1 code (e.g. &#x60;en&#x60; for English) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesRelationsTypesApplicationsApplicationLangGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesRelationsTypesApplicationsApplicationLangGetWithHttpInfo(
        string $application,
        string $lang,
        string $contentType = self::contentTypes['restAccountsAddressesRelationsTypesApplicationsApplicationLangGet'][0]
    ): array
    {
        $request = $this->restAccountsAddressesRelationsTypesApplicationsApplicationLangGetRequest($application, $lang, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesRelationsTypesApplicationsApplicationLangGetAsync
     *
     * List address relation types
     *
     * @param  string $application The application type (required)
     * @param  string $lang The language as ISO 639-1 code (e.g. &#x60;en&#x60; for English) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesRelationsTypesApplicationsApplicationLangGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesRelationsTypesApplicationsApplicationLangGetAsync(
        string $application,
        string $lang,
        string $contentType = self::contentTypes['restAccountsAddressesRelationsTypesApplicationsApplicationLangGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountsAddressesRelationsTypesApplicationsApplicationLangGetAsyncWithHttpInfo($application, $lang, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesRelationsTypesApplicationsApplicationLangGetAsyncWithHttpInfo
     *
     * List address relation types
     *
     * @param  string $application The application type (required)
     * @param  string $lang The language as ISO 639-1 code (e.g. &#x60;en&#x60; for English) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesRelationsTypesApplicationsApplicationLangGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesRelationsTypesApplicationsApplicationLangGetAsyncWithHttpInfo(
        $application,
        $lang,
        string $contentType = self::contentTypes['restAccountsAddressesRelationsTypesApplicationsApplicationLangGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restAccountsAddressesRelationsTypesApplicationsApplicationLangGetRequest($application, $lang, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesRelationsTypesApplicationsApplicationLangGet'
     *
     * @param  string $application The application type (required)
     * @param  string $lang The language as ISO 639-1 code (e.g. &#x60;en&#x60; for English) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesRelationsTypesApplicationsApplicationLangGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsAddressesRelationsTypesApplicationsApplicationLangGetRequest(
        $application,
        $lang,
        string $contentType = self::contentTypes['restAccountsAddressesRelationsTypesApplicationsApplicationLangGet'][0]
    ): Request
    {

        // verify the required parameter 'application' is set
        if ($application === null || (is_array($application) && count($application) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $application when calling restAccountsAddressesRelationsTypesApplicationsApplicationLangGet'
            );
        }

        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $lang when calling restAccountsAddressesRelationsTypesApplicationsApplicationLangGet'
            );
        }


        $resourcePath = '/rest/accounts/addresses/relations/types/applications/{application}/{lang}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($application !== null) {
            $resourcePath = str_replace(
                '{' . 'application' . '}',
                ObjectSerializer::toPathValue($application),
                $resourcePath
            );
        }
        // path params
        if ($lang !== null) {
            $resourcePath = str_replace(
                '{' . 'lang' . '}',
                ObjectSerializer::toPathValue($lang),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesWarehouseRelationsPost
     *
     * Create address warehouse relation
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesWarehouseRelationsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\AddressWarehouseRelation
     */
    public function restAccountsAddressesWarehouseRelationsPost(
        string $contentType = self::contentTypes['restAccountsAddressesWarehouseRelationsPost'][0]
    ): \ck\Model\AddressWarehouseRelation
    {
        list($response) = $this->restAccountsAddressesWarehouseRelationsPostWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restAccountsAddressesWarehouseRelationsPostWithHttpInfo
     *
     * Create address warehouse relation
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesWarehouseRelationsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\AddressWarehouseRelation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesWarehouseRelationsPostWithHttpInfo(
        string $contentType = self::contentTypes['restAccountsAddressesWarehouseRelationsPost'][0]
    ): array
    {
        $request = $this->restAccountsAddressesWarehouseRelationsPostRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\AddressWarehouseRelation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\AddressWarehouseRelation' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\AddressWarehouseRelation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\AddressWarehouseRelation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\AddressWarehouseRelation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesWarehouseRelationsPostAsync
     *
     * Create address warehouse relation
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesWarehouseRelationsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesWarehouseRelationsPostAsync(
        string $contentType = self::contentTypes['restAccountsAddressesWarehouseRelationsPost'][0]
    ): PromiseInterface
    {
        return $this->restAccountsAddressesWarehouseRelationsPostAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesWarehouseRelationsPostAsyncWithHttpInfo
     *
     * Create address warehouse relation
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesWarehouseRelationsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesWarehouseRelationsPostAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restAccountsAddressesWarehouseRelationsPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\AddressWarehouseRelation';
        $request = $this->restAccountsAddressesWarehouseRelationsPostRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesWarehouseRelationsPost'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesWarehouseRelationsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsAddressesWarehouseRelationsPostRequest(
        string $contentType = self::contentTypes['restAccountsAddressesWarehouseRelationsPost'][0]
    ): Request
    {


        $resourcePath = '/rest/accounts/addresses/warehouse_relations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesWarehouseRelationsRelationIdDelete
     *
     * Delete address warehouse relation
     *
     * @param  int $relation_id The ID of the address warehouse relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesWarehouseRelationsRelationIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restAccountsAddressesWarehouseRelationsRelationIdDelete(
        int $relation_id,
        string $contentType = self::contentTypes['restAccountsAddressesWarehouseRelationsRelationIdDelete'][0]
    ): void
    {
        $this->restAccountsAddressesWarehouseRelationsRelationIdDeleteWithHttpInfo($relation_id, $contentType);
    }

    /**
     * Operation restAccountsAddressesWarehouseRelationsRelationIdDeleteWithHttpInfo
     *
     * Delete address warehouse relation
     *
     * @param  int $relation_id The ID of the address warehouse relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesWarehouseRelationsRelationIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesWarehouseRelationsRelationIdDeleteWithHttpInfo(
        int $relation_id,
        string $contentType = self::contentTypes['restAccountsAddressesWarehouseRelationsRelationIdDelete'][0]
    ): array
    {
        $request = $this->restAccountsAddressesWarehouseRelationsRelationIdDeleteRequest($relation_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesWarehouseRelationsRelationIdDeleteAsync
     *
     * Delete address warehouse relation
     *
     * @param  int $relation_id The ID of the address warehouse relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesWarehouseRelationsRelationIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesWarehouseRelationsRelationIdDeleteAsync(
        int $relation_id,
        string $contentType = self::contentTypes['restAccountsAddressesWarehouseRelationsRelationIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restAccountsAddressesWarehouseRelationsRelationIdDeleteAsyncWithHttpInfo($relation_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesWarehouseRelationsRelationIdDeleteAsyncWithHttpInfo
     *
     * Delete address warehouse relation
     *
     * @param  int $relation_id The ID of the address warehouse relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesWarehouseRelationsRelationIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesWarehouseRelationsRelationIdDeleteAsyncWithHttpInfo(
        $relation_id,
        string $contentType = self::contentTypes['restAccountsAddressesWarehouseRelationsRelationIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restAccountsAddressesWarehouseRelationsRelationIdDeleteRequest($relation_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesWarehouseRelationsRelationIdDelete'
     *
     * @param  int $relation_id The ID of the address warehouse relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesWarehouseRelationsRelationIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsAddressesWarehouseRelationsRelationIdDeleteRequest(
        $relation_id,
        string $contentType = self::contentTypes['restAccountsAddressesWarehouseRelationsRelationIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'relation_id' is set
        if ($relation_id === null || (is_array($relation_id) && count($relation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $relation_id when calling restAccountsAddressesWarehouseRelationsRelationIdDelete'
            );
        }


        $resourcePath = '/rest/accounts/addresses/warehouse_relations/{relationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($relation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'relationId' . '}',
                ObjectSerializer::toPathValue($relation_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesWarehouseRelationsRelationIdPut
     *
     * Update address warehouse relation
     *
     * @param  int $relation_id The ID of the address warehouse relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesWarehouseRelationsRelationIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\AddressWarehouseRelation
     */
    public function restAccountsAddressesWarehouseRelationsRelationIdPut(
        int $relation_id,
        string $contentType = self::contentTypes['restAccountsAddressesWarehouseRelationsRelationIdPut'][0]
    ): \ck\Model\AddressWarehouseRelation
    {
        list($response) = $this->restAccountsAddressesWarehouseRelationsRelationIdPutWithHttpInfo($relation_id, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsAddressesWarehouseRelationsRelationIdPutWithHttpInfo
     *
     * Update address warehouse relation
     *
     * @param  int $relation_id The ID of the address warehouse relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesWarehouseRelationsRelationIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\AddressWarehouseRelation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesWarehouseRelationsRelationIdPutWithHttpInfo(
        int $relation_id,
        string $contentType = self::contentTypes['restAccountsAddressesWarehouseRelationsRelationIdPut'][0]
    ): array
    {
        $request = $this->restAccountsAddressesWarehouseRelationsRelationIdPutRequest($relation_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\AddressWarehouseRelation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\AddressWarehouseRelation' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\AddressWarehouseRelation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\AddressWarehouseRelation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\AddressWarehouseRelation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesWarehouseRelationsRelationIdPutAsync
     *
     * Update address warehouse relation
     *
     * @param  int $relation_id The ID of the address warehouse relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesWarehouseRelationsRelationIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesWarehouseRelationsRelationIdPutAsync(
        int $relation_id,
        string $contentType = self::contentTypes['restAccountsAddressesWarehouseRelationsRelationIdPut'][0]
    ): PromiseInterface
    {
        return $this->restAccountsAddressesWarehouseRelationsRelationIdPutAsyncWithHttpInfo($relation_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesWarehouseRelationsRelationIdPutAsyncWithHttpInfo
     *
     * Update address warehouse relation
     *
     * @param  int $relation_id The ID of the address warehouse relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesWarehouseRelationsRelationIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsAddressesWarehouseRelationsRelationIdPutAsyncWithHttpInfo(
        $relation_id,
        string $contentType = self::contentTypes['restAccountsAddressesWarehouseRelationsRelationIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\AddressWarehouseRelation';
        $request = $this->restAccountsAddressesWarehouseRelationsRelationIdPutRequest($relation_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesWarehouseRelationsRelationIdPut'
     *
     * @param  int $relation_id The ID of the address warehouse relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsAddressesWarehouseRelationsRelationIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsAddressesWarehouseRelationsRelationIdPutRequest(
        $relation_id,
        string $contentType = self::contentTypes['restAccountsAddressesWarehouseRelationsRelationIdPut'][0]
    ): Request
    {

        // verify the required parameter 'relation_id' is set
        if ($relation_id === null || (is_array($relation_id) && count($relation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $relation_id when calling restAccountsAddressesWarehouseRelationsRelationIdPut'
            );
        }


        $resourcePath = '/rest/accounts/addresses/warehouse_relations/{relationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($relation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'relationId' . '}',
                ObjectSerializer::toPathValue($relation_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactRelationsAccountContactRelationIdDelete
     *
     * Delete account contact relation
     *
     * @param  int $account_contact_relation_id The ID of the account contact relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactRelationsAccountContactRelationIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restAccountsContactRelationsAccountContactRelationIdDelete(
        int $account_contact_relation_id,
        string $contentType = self::contentTypes['restAccountsContactRelationsAccountContactRelationIdDelete'][0]
    ): void
    {
        $this->restAccountsContactRelationsAccountContactRelationIdDeleteWithHttpInfo($account_contact_relation_id, $contentType);
    }

    /**
     * Operation restAccountsContactRelationsAccountContactRelationIdDeleteWithHttpInfo
     *
     * Delete account contact relation
     *
     * @param  int $account_contact_relation_id The ID of the account contact relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactRelationsAccountContactRelationIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactRelationsAccountContactRelationIdDeleteWithHttpInfo(
        int $account_contact_relation_id,
        string $contentType = self::contentTypes['restAccountsContactRelationsAccountContactRelationIdDelete'][0]
    ): array
    {
        $request = $this->restAccountsContactRelationsAccountContactRelationIdDeleteRequest($account_contact_relation_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactRelationsAccountContactRelationIdDeleteAsync
     *
     * Delete account contact relation
     *
     * @param  int $account_contact_relation_id The ID of the account contact relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactRelationsAccountContactRelationIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactRelationsAccountContactRelationIdDeleteAsync(
        int $account_contact_relation_id,
        string $contentType = self::contentTypes['restAccountsContactRelationsAccountContactRelationIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactRelationsAccountContactRelationIdDeleteAsyncWithHttpInfo($account_contact_relation_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactRelationsAccountContactRelationIdDeleteAsyncWithHttpInfo
     *
     * Delete account contact relation
     *
     * @param  int $account_contact_relation_id The ID of the account contact relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactRelationsAccountContactRelationIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactRelationsAccountContactRelationIdDeleteAsyncWithHttpInfo(
        $account_contact_relation_id,
        string $contentType = self::contentTypes['restAccountsContactRelationsAccountContactRelationIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restAccountsContactRelationsAccountContactRelationIdDeleteRequest($account_contact_relation_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactRelationsAccountContactRelationIdDelete'
     *
     * @param  int $account_contact_relation_id The ID of the account contact relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactRelationsAccountContactRelationIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactRelationsAccountContactRelationIdDeleteRequest(
        $account_contact_relation_id,
        string $contentType = self::contentTypes['restAccountsContactRelationsAccountContactRelationIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'account_contact_relation_id' is set
        if ($account_contact_relation_id === null || (is_array($account_contact_relation_id) && count($account_contact_relation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $account_contact_relation_id when calling restAccountsContactRelationsAccountContactRelationIdDelete'
            );
        }


        $resourcePath = '/rest/accounts/contact_relations/{accountContactRelationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_contact_relation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountContactRelationId' . '}',
                ObjectSerializer::toPathValue($account_contact_relation_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactRelationsAccountContactRelationIdGet
     *
     * Get account contact relation
     *
     * @param  int $account_contact_relation_id The ID of the account contact relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactRelationsAccountContactRelationIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\AccountContactRelation
     */
    public function restAccountsContactRelationsAccountContactRelationIdGet(
        int $account_contact_relation_id,
        string $contentType = self::contentTypes['restAccountsContactRelationsAccountContactRelationIdGet'][0]
    ): \ck\Model\AccountContactRelation
    {
        list($response) = $this->restAccountsContactRelationsAccountContactRelationIdGetWithHttpInfo($account_contact_relation_id, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsContactRelationsAccountContactRelationIdGetWithHttpInfo
     *
     * Get account contact relation
     *
     * @param  int $account_contact_relation_id The ID of the account contact relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactRelationsAccountContactRelationIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\AccountContactRelation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactRelationsAccountContactRelationIdGetWithHttpInfo(
        int $account_contact_relation_id,
        string $contentType = self::contentTypes['restAccountsContactRelationsAccountContactRelationIdGet'][0]
    ): array
    {
        $request = $this->restAccountsContactRelationsAccountContactRelationIdGetRequest($account_contact_relation_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\AccountContactRelation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\AccountContactRelation' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\AccountContactRelation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\AccountContactRelation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\AccountContactRelation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactRelationsAccountContactRelationIdGetAsync
     *
     * Get account contact relation
     *
     * @param  int $account_contact_relation_id The ID of the account contact relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactRelationsAccountContactRelationIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactRelationsAccountContactRelationIdGetAsync(
        int $account_contact_relation_id,
        string $contentType = self::contentTypes['restAccountsContactRelationsAccountContactRelationIdGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactRelationsAccountContactRelationIdGetAsyncWithHttpInfo($account_contact_relation_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactRelationsAccountContactRelationIdGetAsyncWithHttpInfo
     *
     * Get account contact relation
     *
     * @param  int $account_contact_relation_id The ID of the account contact relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactRelationsAccountContactRelationIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactRelationsAccountContactRelationIdGetAsyncWithHttpInfo(
        $account_contact_relation_id,
        string $contentType = self::contentTypes['restAccountsContactRelationsAccountContactRelationIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\AccountContactRelation';
        $request = $this->restAccountsContactRelationsAccountContactRelationIdGetRequest($account_contact_relation_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactRelationsAccountContactRelationIdGet'
     *
     * @param  int $account_contact_relation_id The ID of the account contact relation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactRelationsAccountContactRelationIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactRelationsAccountContactRelationIdGetRequest(
        $account_contact_relation_id,
        string $contentType = self::contentTypes['restAccountsContactRelationsAccountContactRelationIdGet'][0]
    ): Request
    {

        // verify the required parameter 'account_contact_relation_id' is set
        if ($account_contact_relation_id === null || (is_array($account_contact_relation_id) && count($account_contact_relation_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $account_contact_relation_id when calling restAccountsContactRelationsAccountContactRelationIdGet'
            );
        }


        $resourcePath = '/rest/accounts/contact_relations/{accountContactRelationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_contact_relation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountContactRelationId' . '}',
                ObjectSerializer::toPathValue($account_contact_relation_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsBanksContactBankIdDelete
     *
     * Delete bank account
     *
     * @param  int $contact_bank_id The ID of the bank account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsBanksContactBankIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restAccountsContactsBanksContactBankIdDelete(
        int $contact_bank_id,
        string $contentType = self::contentTypes['restAccountsContactsBanksContactBankIdDelete'][0]
    ): void
    {
        $this->restAccountsContactsBanksContactBankIdDeleteWithHttpInfo($contact_bank_id, $contentType);
    }

    /**
     * Operation restAccountsContactsBanksContactBankIdDeleteWithHttpInfo
     *
     * Delete bank account
     *
     * @param  int $contact_bank_id The ID of the bank account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsBanksContactBankIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsBanksContactBankIdDeleteWithHttpInfo(
        int $contact_bank_id,
        string $contentType = self::contentTypes['restAccountsContactsBanksContactBankIdDelete'][0]
    ): array
    {
        $request = $this->restAccountsContactsBanksContactBankIdDeleteRequest($contact_bank_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsBanksContactBankIdDeleteAsync
     *
     * Delete bank account
     *
     * @param  int $contact_bank_id The ID of the bank account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsBanksContactBankIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsBanksContactBankIdDeleteAsync(
        int $contact_bank_id,
        string $contentType = self::contentTypes['restAccountsContactsBanksContactBankIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsBanksContactBankIdDeleteAsyncWithHttpInfo($contact_bank_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsBanksContactBankIdDeleteAsyncWithHttpInfo
     *
     * Delete bank account
     *
     * @param  int $contact_bank_id The ID of the bank account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsBanksContactBankIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsBanksContactBankIdDeleteAsyncWithHttpInfo(
        $contact_bank_id,
        string $contentType = self::contentTypes['restAccountsContactsBanksContactBankIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restAccountsContactsBanksContactBankIdDeleteRequest($contact_bank_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsBanksContactBankIdDelete'
     *
     * @param  int $contact_bank_id The ID of the bank account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsBanksContactBankIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsBanksContactBankIdDeleteRequest(
        $contact_bank_id,
        string $contentType = self::contentTypes['restAccountsContactsBanksContactBankIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'contact_bank_id' is set
        if ($contact_bank_id === null || (is_array($contact_bank_id) && count($contact_bank_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contact_bank_id when calling restAccountsContactsBanksContactBankIdDelete'
            );
        }


        $resourcePath = '/rest/accounts/contacts/banks/{contactBankId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contact_bank_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactBankId' . '}',
                ObjectSerializer::toPathValue($contact_bank_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsBanksContactBankIdGet
     *
     * Get bank account
     *
     * @param  int $contact_bank_id The ID of the bank account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsBanksContactBankIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ContactBank
     */
    public function restAccountsContactsBanksContactBankIdGet(
        int $contact_bank_id,
        string $contentType = self::contentTypes['restAccountsContactsBanksContactBankIdGet'][0]
    ): \ck\Model\ContactBank
    {
        list($response) = $this->restAccountsContactsBanksContactBankIdGetWithHttpInfo($contact_bank_id, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsContactsBanksContactBankIdGetWithHttpInfo
     *
     * Get bank account
     *
     * @param  int $contact_bank_id The ID of the bank account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsBanksContactBankIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ContactBank, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsBanksContactBankIdGetWithHttpInfo(
        int $contact_bank_id,
        string $contentType = self::contentTypes['restAccountsContactsBanksContactBankIdGet'][0]
    ): array
    {
        $request = $this->restAccountsContactsBanksContactBankIdGetRequest($contact_bank_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ContactBank' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ContactBank' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ContactBank', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ContactBank';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ContactBank',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsBanksContactBankIdGetAsync
     *
     * Get bank account
     *
     * @param  int $contact_bank_id The ID of the bank account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsBanksContactBankIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsBanksContactBankIdGetAsync(
        int $contact_bank_id,
        string $contentType = self::contentTypes['restAccountsContactsBanksContactBankIdGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsBanksContactBankIdGetAsyncWithHttpInfo($contact_bank_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsBanksContactBankIdGetAsyncWithHttpInfo
     *
     * Get bank account
     *
     * @param  int $contact_bank_id The ID of the bank account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsBanksContactBankIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsBanksContactBankIdGetAsyncWithHttpInfo(
        $contact_bank_id,
        string $contentType = self::contentTypes['restAccountsContactsBanksContactBankIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ContactBank';
        $request = $this->restAccountsContactsBanksContactBankIdGetRequest($contact_bank_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsBanksContactBankIdGet'
     *
     * @param  int $contact_bank_id The ID of the bank account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsBanksContactBankIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsBanksContactBankIdGetRequest(
        $contact_bank_id,
        string $contentType = self::contentTypes['restAccountsContactsBanksContactBankIdGet'][0]
    ): Request
    {

        // verify the required parameter 'contact_bank_id' is set
        if ($contact_bank_id === null || (is_array($contact_bank_id) && count($contact_bank_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contact_bank_id when calling restAccountsContactsBanksContactBankIdGet'
            );
        }


        $resourcePath = '/rest/accounts/contacts/banks/{contactBankId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contact_bank_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactBankId' . '}',
                ObjectSerializer::toPathValue($contact_bank_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsBanksContactBankIdPut
     *
     * Update bank account
     *
     * @param  int $contact_bank_id The ID of the bank account (required)
     * @param  \ck\Model\RestAccountsContactsBanksPostRequest|null $_rest_accounts_contacts_banks_contact_bank_id _rest_accounts_contacts_banks_contact_bank_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsBanksContactBankIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ContactBank
     */
    public function restAccountsContactsBanksContactBankIdPut(
        int $contact_bank_id,
        ?\ck\Model\RestAccountsContactsBanksPostRequest $_rest_accounts_contacts_banks_contact_bank_id = null,
        string $contentType = self::contentTypes['restAccountsContactsBanksContactBankIdPut'][0]
    ): \ck\Model\ContactBank
    {
        list($response) = $this->restAccountsContactsBanksContactBankIdPutWithHttpInfo($contact_bank_id, $_rest_accounts_contacts_banks_contact_bank_id, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsContactsBanksContactBankIdPutWithHttpInfo
     *
     * Update bank account
     *
     * @param  int $contact_bank_id The ID of the bank account (required)
     * @param  \ck\Model\RestAccountsContactsBanksPostRequest|null $_rest_accounts_contacts_banks_contact_bank_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsBanksContactBankIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ContactBank, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsBanksContactBankIdPutWithHttpInfo(
        int $contact_bank_id,
        ?\ck\Model\RestAccountsContactsBanksPostRequest $_rest_accounts_contacts_banks_contact_bank_id = null,
        string $contentType = self::contentTypes['restAccountsContactsBanksContactBankIdPut'][0]
    ): array
    {
        $request = $this->restAccountsContactsBanksContactBankIdPutRequest($contact_bank_id, $_rest_accounts_contacts_banks_contact_bank_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ContactBank' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ContactBank' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ContactBank', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ContactBank';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ContactBank',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsBanksContactBankIdPutAsync
     *
     * Update bank account
     *
     * @param  int $contact_bank_id The ID of the bank account (required)
     * @param  \ck\Model\RestAccountsContactsBanksPostRequest|null $_rest_accounts_contacts_banks_contact_bank_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsBanksContactBankIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsBanksContactBankIdPutAsync(
        int $contact_bank_id,
        ?\ck\Model\RestAccountsContactsBanksPostRequest $_rest_accounts_contacts_banks_contact_bank_id = null,
        string $contentType = self::contentTypes['restAccountsContactsBanksContactBankIdPut'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsBanksContactBankIdPutAsyncWithHttpInfo($contact_bank_id, $_rest_accounts_contacts_banks_contact_bank_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsBanksContactBankIdPutAsyncWithHttpInfo
     *
     * Update bank account
     *
     * @param  int $contact_bank_id The ID of the bank account (required)
     * @param  \ck\Model\RestAccountsContactsBanksPostRequest|null $_rest_accounts_contacts_banks_contact_bank_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsBanksContactBankIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsBanksContactBankIdPutAsyncWithHttpInfo(
        $contact_bank_id,
        $_rest_accounts_contacts_banks_contact_bank_id = null,
        string $contentType = self::contentTypes['restAccountsContactsBanksContactBankIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ContactBank';
        $request = $this->restAccountsContactsBanksContactBankIdPutRequest($contact_bank_id, $_rest_accounts_contacts_banks_contact_bank_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsBanksContactBankIdPut'
     *
     * @param  int $contact_bank_id The ID of the bank account (required)
     * @param  \ck\Model\RestAccountsContactsBanksPostRequest|null $_rest_accounts_contacts_banks_contact_bank_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsBanksContactBankIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsBanksContactBankIdPutRequest(
        $contact_bank_id,
        $_rest_accounts_contacts_banks_contact_bank_id = null,
        string $contentType = self::contentTypes['restAccountsContactsBanksContactBankIdPut'][0]
    ): Request
    {

        // verify the required parameter 'contact_bank_id' is set
        if ($contact_bank_id === null || (is_array($contact_bank_id) && count($contact_bank_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contact_bank_id when calling restAccountsContactsBanksContactBankIdPut'
            );
        }



        $resourcePath = '/rest/accounts/contacts/banks/{contactBankId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contact_bank_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactBankId' . '}',
                ObjectSerializer::toPathValue($contact_bank_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_accounts_contacts_banks_contact_bank_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_accounts_contacts_banks_contact_bank_id));
            } else {
                $httpBody = $_rest_accounts_contacts_banks_contact_bank_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsBanksPost
     *
     * Create bank account
     *
     * @param  \ck\Model\RestAccountsContactsBanksPostRequest|null $_rest_accounts_contacts_banks _rest_accounts_contacts_banks (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsBanksPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ContactBank
     */
    public function restAccountsContactsBanksPost(
        ?\ck\Model\RestAccountsContactsBanksPostRequest $_rest_accounts_contacts_banks = null,
        string $contentType = self::contentTypes['restAccountsContactsBanksPost'][0]
    ): \ck\Model\ContactBank
    {
        list($response) = $this->restAccountsContactsBanksPostWithHttpInfo($_rest_accounts_contacts_banks, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsContactsBanksPostWithHttpInfo
     *
     * Create bank account
     *
     * @param  \ck\Model\RestAccountsContactsBanksPostRequest|null $_rest_accounts_contacts_banks (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsBanksPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ContactBank, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsBanksPostWithHttpInfo(
        ?\ck\Model\RestAccountsContactsBanksPostRequest $_rest_accounts_contacts_banks = null,
        string $contentType = self::contentTypes['restAccountsContactsBanksPost'][0]
    ): array
    {
        $request = $this->restAccountsContactsBanksPostRequest($_rest_accounts_contacts_banks, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ContactBank' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ContactBank' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ContactBank', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ContactBank';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ContactBank',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsBanksPostAsync
     *
     * Create bank account
     *
     * @param  \ck\Model\RestAccountsContactsBanksPostRequest|null $_rest_accounts_contacts_banks (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsBanksPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsBanksPostAsync(
        ?\ck\Model\RestAccountsContactsBanksPostRequest $_rest_accounts_contacts_banks = null,
        string $contentType = self::contentTypes['restAccountsContactsBanksPost'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsBanksPostAsyncWithHttpInfo($_rest_accounts_contacts_banks, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsBanksPostAsyncWithHttpInfo
     *
     * Create bank account
     *
     * @param  \ck\Model\RestAccountsContactsBanksPostRequest|null $_rest_accounts_contacts_banks (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsBanksPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsBanksPostAsyncWithHttpInfo(
        $_rest_accounts_contacts_banks = null,
        string $contentType = self::contentTypes['restAccountsContactsBanksPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ContactBank';
        $request = $this->restAccountsContactsBanksPostRequest($_rest_accounts_contacts_banks, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsBanksPost'
     *
     * @param  \ck\Model\RestAccountsContactsBanksPostRequest|null $_rest_accounts_contacts_banks (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsBanksPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsBanksPostRequest(
        $_rest_accounts_contacts_banks = null,
        string $contentType = self::contentTypes['restAccountsContactsBanksPost'][0]
    ): Request
    {



        $resourcePath = '/rest/accounts/contacts/banks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_accounts_contacts_banks)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_accounts_contacts_banks));
            } else {
                $httpBody = $_rest_accounts_contacts_banks;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsClassesContactClassIdGet
     *
     * Get contact class
     *
     * @param  int $contact_class_id The ID of the contact class (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsClassesContactClassIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restAccountsContactsClassesContactClassIdGet(
        int $contact_class_id,
        string $contentType = self::contentTypes['restAccountsContactsClassesContactClassIdGet'][0]
    ): object
    {
        list($response) = $this->restAccountsContactsClassesContactClassIdGetWithHttpInfo($contact_class_id, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsContactsClassesContactClassIdGetWithHttpInfo
     *
     * Get contact class
     *
     * @param  int $contact_class_id The ID of the contact class (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsClassesContactClassIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsClassesContactClassIdGetWithHttpInfo(
        int $contact_class_id,
        string $contentType = self::contentTypes['restAccountsContactsClassesContactClassIdGet'][0]
    ): array
    {
        $request = $this->restAccountsContactsClassesContactClassIdGetRequest($contact_class_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsClassesContactClassIdGetAsync
     *
     * Get contact class
     *
     * @param  int $contact_class_id The ID of the contact class (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsClassesContactClassIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsClassesContactClassIdGetAsync(
        int $contact_class_id,
        string $contentType = self::contentTypes['restAccountsContactsClassesContactClassIdGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsClassesContactClassIdGetAsyncWithHttpInfo($contact_class_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsClassesContactClassIdGetAsyncWithHttpInfo
     *
     * Get contact class
     *
     * @param  int $contact_class_id The ID of the contact class (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsClassesContactClassIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsClassesContactClassIdGetAsyncWithHttpInfo(
        $contact_class_id,
        string $contentType = self::contentTypes['restAccountsContactsClassesContactClassIdGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restAccountsContactsClassesContactClassIdGetRequest($contact_class_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsClassesContactClassIdGet'
     *
     * @param  int $contact_class_id The ID of the contact class (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsClassesContactClassIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsClassesContactClassIdGetRequest(
        $contact_class_id,
        string $contentType = self::contentTypes['restAccountsContactsClassesContactClassIdGet'][0]
    ): Request
    {

        // verify the required parameter 'contact_class_id' is set
        if ($contact_class_id === null || (is_array($contact_class_id) && count($contact_class_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contact_class_id when calling restAccountsContactsClassesContactClassIdGet'
            );
        }


        $resourcePath = '/rest/accounts/contacts/classes/{contactClassId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contact_class_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactClassId' . '}',
                ObjectSerializer::toPathValue($contact_class_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsClassesGet
     *
     * List contact classes
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsClassesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object[]
     */
    public function restAccountsContactsClassesGet(
        string $contentType = self::contentTypes['restAccountsContactsClassesGet'][0]
    ): array
    {
        list($response) = $this->restAccountsContactsClassesGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restAccountsContactsClassesGetWithHttpInfo
     *
     * List contact classes
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsClassesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsClassesGetWithHttpInfo(
        string $contentType = self::contentTypes['restAccountsContactsClassesGet'][0]
    ): array
    {
        $request = $this->restAccountsContactsClassesGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsClassesGetAsync
     *
     * List contact classes
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsClassesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsClassesGetAsync(
        string $contentType = self::contentTypes['restAccountsContactsClassesGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsClassesGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsClassesGetAsyncWithHttpInfo
     *
     * List contact classes
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsClassesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsClassesGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restAccountsContactsClassesGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object[]';
        $request = $this->restAccountsContactsClassesGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsClassesGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsClassesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsClassesGetRequest(
        string $contentType = self::contentTypes['restAccountsContactsClassesGet'][0]
    ): Request
    {


        $resourcePath = '/rest/accounts/contacts/classes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactEventsContactEventIdDelete
     *
     * Delete contact event
     *
     * @param  int $contact_event_id The ID of the contact event (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactEventsContactEventIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restAccountsContactsContactEventsContactEventIdDelete(
        int $contact_event_id,
        string $contentType = self::contentTypes['restAccountsContactsContactEventsContactEventIdDelete'][0]
    ): void
    {
        $this->restAccountsContactsContactEventsContactEventIdDeleteWithHttpInfo($contact_event_id, $contentType);
    }

    /**
     * Operation restAccountsContactsContactEventsContactEventIdDeleteWithHttpInfo
     *
     * Delete contact event
     *
     * @param  int $contact_event_id The ID of the contact event (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactEventsContactEventIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactEventsContactEventIdDeleteWithHttpInfo(
        int $contact_event_id,
        string $contentType = self::contentTypes['restAccountsContactsContactEventsContactEventIdDelete'][0]
    ): array
    {
        $request = $this->restAccountsContactsContactEventsContactEventIdDeleteRequest($contact_event_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactEventsContactEventIdDeleteAsync
     *
     * Delete contact event
     *
     * @param  int $contact_event_id The ID of the contact event (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactEventsContactEventIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactEventsContactEventIdDeleteAsync(
        int $contact_event_id,
        string $contentType = self::contentTypes['restAccountsContactsContactEventsContactEventIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsContactEventsContactEventIdDeleteAsyncWithHttpInfo($contact_event_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactEventsContactEventIdDeleteAsyncWithHttpInfo
     *
     * Delete contact event
     *
     * @param  int $contact_event_id The ID of the contact event (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactEventsContactEventIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactEventsContactEventIdDeleteAsyncWithHttpInfo(
        $contact_event_id,
        string $contentType = self::contentTypes['restAccountsContactsContactEventsContactEventIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restAccountsContactsContactEventsContactEventIdDeleteRequest($contact_event_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactEventsContactEventIdDelete'
     *
     * @param  int $contact_event_id The ID of the contact event (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactEventsContactEventIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsContactEventsContactEventIdDeleteRequest(
        $contact_event_id,
        string $contentType = self::contentTypes['restAccountsContactsContactEventsContactEventIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'contact_event_id' is set
        if ($contact_event_id === null || (is_array($contact_event_id) && count($contact_event_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contact_event_id when calling restAccountsContactsContactEventsContactEventIdDelete'
            );
        }


        $resourcePath = '/rest/accounts/contacts/contact_events/{contactEventId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contact_event_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactEventId' . '}',
                ObjectSerializer::toPathValue($contact_event_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactEventsContactEventIdPut
     *
     * Update contact event
     *
     * @param  int $contact_event_id The ID of the contact event (required)
     * @param  \ck\Model\RestAccountsContactsContactEventsPostRequest|null $_rest_accounts_contacts_contact_events_contact_event_id _rest_accounts_contacts_contact_events_contact_event_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactEventsContactEventIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ContactEvent
     */
    public function restAccountsContactsContactEventsContactEventIdPut(
        int $contact_event_id,
        ?\ck\Model\RestAccountsContactsContactEventsPostRequest $_rest_accounts_contacts_contact_events_contact_event_id = null,
        string $contentType = self::contentTypes['restAccountsContactsContactEventsContactEventIdPut'][0]
    ): \ck\Model\ContactEvent
    {
        list($response) = $this->restAccountsContactsContactEventsContactEventIdPutWithHttpInfo($contact_event_id, $_rest_accounts_contacts_contact_events_contact_event_id, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactEventsContactEventIdPutWithHttpInfo
     *
     * Update contact event
     *
     * @param  int $contact_event_id The ID of the contact event (required)
     * @param  \ck\Model\RestAccountsContactsContactEventsPostRequest|null $_rest_accounts_contacts_contact_events_contact_event_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactEventsContactEventIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ContactEvent, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactEventsContactEventIdPutWithHttpInfo(
        int $contact_event_id,
        ?\ck\Model\RestAccountsContactsContactEventsPostRequest $_rest_accounts_contacts_contact_events_contact_event_id = null,
        string $contentType = self::contentTypes['restAccountsContactsContactEventsContactEventIdPut'][0]
    ): array
    {
        $request = $this->restAccountsContactsContactEventsContactEventIdPutRequest($contact_event_id, $_rest_accounts_contacts_contact_events_contact_event_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ContactEvent' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ContactEvent' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ContactEvent', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ContactEvent';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ContactEvent',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactEventsContactEventIdPutAsync
     *
     * Update contact event
     *
     * @param  int $contact_event_id The ID of the contact event (required)
     * @param  \ck\Model\RestAccountsContactsContactEventsPostRequest|null $_rest_accounts_contacts_contact_events_contact_event_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactEventsContactEventIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactEventsContactEventIdPutAsync(
        int $contact_event_id,
        ?\ck\Model\RestAccountsContactsContactEventsPostRequest $_rest_accounts_contacts_contact_events_contact_event_id = null,
        string $contentType = self::contentTypes['restAccountsContactsContactEventsContactEventIdPut'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsContactEventsContactEventIdPutAsyncWithHttpInfo($contact_event_id, $_rest_accounts_contacts_contact_events_contact_event_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactEventsContactEventIdPutAsyncWithHttpInfo
     *
     * Update contact event
     *
     * @param  int $contact_event_id The ID of the contact event (required)
     * @param  \ck\Model\RestAccountsContactsContactEventsPostRequest|null $_rest_accounts_contacts_contact_events_contact_event_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactEventsContactEventIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactEventsContactEventIdPutAsyncWithHttpInfo(
        $contact_event_id,
        $_rest_accounts_contacts_contact_events_contact_event_id = null,
        string $contentType = self::contentTypes['restAccountsContactsContactEventsContactEventIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ContactEvent';
        $request = $this->restAccountsContactsContactEventsContactEventIdPutRequest($contact_event_id, $_rest_accounts_contacts_contact_events_contact_event_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactEventsContactEventIdPut'
     *
     * @param  int $contact_event_id The ID of the contact event (required)
     * @param  \ck\Model\RestAccountsContactsContactEventsPostRequest|null $_rest_accounts_contacts_contact_events_contact_event_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactEventsContactEventIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsContactEventsContactEventIdPutRequest(
        $contact_event_id,
        $_rest_accounts_contacts_contact_events_contact_event_id = null,
        string $contentType = self::contentTypes['restAccountsContactsContactEventsContactEventIdPut'][0]
    ): Request
    {

        // verify the required parameter 'contact_event_id' is set
        if ($contact_event_id === null || (is_array($contact_event_id) && count($contact_event_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contact_event_id when calling restAccountsContactsContactEventsContactEventIdPut'
            );
        }



        $resourcePath = '/rest/accounts/contacts/contact_events/{contactEventId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contact_event_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactEventId' . '}',
                ObjectSerializer::toPathValue($contact_event_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_accounts_contacts_contact_events_contact_event_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_accounts_contacts_contact_events_contact_event_id));
            } else {
                $httpBody = $_rest_accounts_contacts_contact_events_contact_event_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactEventsGet
     *
     * List contact events
     *
     * @param  int|null $page The page of results to search for (optional)
     * @param  int|null $items_per_page The number of items to list per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactEventsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestAccountsContactsContactEventsGet200Response
     */
    public function restAccountsContactsContactEventsGet(
        ?int $page = null,
        ?int $items_per_page = null,
        string $contentType = self::contentTypes['restAccountsContactsContactEventsGet'][0]
    ): \ck\Model\RestAccountsContactsContactEventsGet200Response
    {
        list($response) = $this->restAccountsContactsContactEventsGetWithHttpInfo($page, $items_per_page, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactEventsGetWithHttpInfo
     *
     * List contact events
     *
     * @param  int|null $page The page of results to search for (optional)
     * @param  int|null $items_per_page The number of items to list per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactEventsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestAccountsContactsContactEventsGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactEventsGetWithHttpInfo(
        ?int $page = null,
        ?int $items_per_page = null,
        string $contentType = self::contentTypes['restAccountsContactsContactEventsGet'][0]
    ): array
    {
        $request = $this->restAccountsContactsContactEventsGetRequest($page, $items_per_page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestAccountsContactsContactEventsGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestAccountsContactsContactEventsGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestAccountsContactsContactEventsGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestAccountsContactsContactEventsGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestAccountsContactsContactEventsGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactEventsGetAsync
     *
     * List contact events
     *
     * @param  int|null $page The page of results to search for (optional)
     * @param  int|null $items_per_page The number of items to list per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactEventsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactEventsGetAsync(
        ?int $page = null,
        ?int $items_per_page = null,
        string $contentType = self::contentTypes['restAccountsContactsContactEventsGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsContactEventsGetAsyncWithHttpInfo($page, $items_per_page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactEventsGetAsyncWithHttpInfo
     *
     * List contact events
     *
     * @param  int|null $page The page of results to search for (optional)
     * @param  int|null $items_per_page The number of items to list per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactEventsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactEventsGetAsyncWithHttpInfo(
        $page = null,
        $items_per_page = null,
        string $contentType = self::contentTypes['restAccountsContactsContactEventsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestAccountsContactsContactEventsGet200Response';
        $request = $this->restAccountsContactsContactEventsGetRequest($page, $items_per_page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactEventsGet'
     *
     * @param  int|null $page The page of results to search for (optional)
     * @param  int|null $items_per_page The number of items to list per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactEventsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsContactEventsGetRequest(
        $page = null,
        $items_per_page = null,
        string $contentType = self::contentTypes['restAccountsContactsContactEventsGet'][0]
    ): Request
    {




        $resourcePath = '/rest/accounts/contacts/contact_events';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $items_per_page,
            'itemsPerPage', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactEventsPost
     *
     * Create contact event
     *
     * @param  int|null $page The page of results to search for (optional)
     * @param  int|null $items_per_page The number of items to list per page (optional)
     * @param  \ck\Model\RestAccountsContactsContactEventsPostRequest|null $_rest_accounts_contacts_contact_events _rest_accounts_contacts_contact_events (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactEventsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ContactEvent
     */
    public function restAccountsContactsContactEventsPost(
        ?int $page = null,
        ?int $items_per_page = null,
        ?\ck\Model\RestAccountsContactsContactEventsPostRequest $_rest_accounts_contacts_contact_events = null,
        string $contentType = self::contentTypes['restAccountsContactsContactEventsPost'][0]
    ): \ck\Model\ContactEvent
    {
        list($response) = $this->restAccountsContactsContactEventsPostWithHttpInfo($page, $items_per_page, $_rest_accounts_contacts_contact_events, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactEventsPostWithHttpInfo
     *
     * Create contact event
     *
     * @param  int|null $page The page of results to search for (optional)
     * @param  int|null $items_per_page The number of items to list per page (optional)
     * @param  \ck\Model\RestAccountsContactsContactEventsPostRequest|null $_rest_accounts_contacts_contact_events (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactEventsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ContactEvent, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactEventsPostWithHttpInfo(
        ?int $page = null,
        ?int $items_per_page = null,
        ?\ck\Model\RestAccountsContactsContactEventsPostRequest $_rest_accounts_contacts_contact_events = null,
        string $contentType = self::contentTypes['restAccountsContactsContactEventsPost'][0]
    ): array
    {
        $request = $this->restAccountsContactsContactEventsPostRequest($page, $items_per_page, $_rest_accounts_contacts_contact_events, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ContactEvent' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ContactEvent' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ContactEvent', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ContactEvent';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ContactEvent',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactEventsPostAsync
     *
     * Create contact event
     *
     * @param  int|null $page The page of results to search for (optional)
     * @param  int|null $items_per_page The number of items to list per page (optional)
     * @param  \ck\Model\RestAccountsContactsContactEventsPostRequest|null $_rest_accounts_contacts_contact_events (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactEventsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactEventsPostAsync(
        ?int $page = null,
        ?int $items_per_page = null,
        ?\ck\Model\RestAccountsContactsContactEventsPostRequest $_rest_accounts_contacts_contact_events = null,
        string $contentType = self::contentTypes['restAccountsContactsContactEventsPost'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsContactEventsPostAsyncWithHttpInfo($page, $items_per_page, $_rest_accounts_contacts_contact_events, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactEventsPostAsyncWithHttpInfo
     *
     * Create contact event
     *
     * @param  int|null $page The page of results to search for (optional)
     * @param  int|null $items_per_page The number of items to list per page (optional)
     * @param  \ck\Model\RestAccountsContactsContactEventsPostRequest|null $_rest_accounts_contacts_contact_events (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactEventsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactEventsPostAsyncWithHttpInfo(
        $page = null,
        $items_per_page = null,
        $_rest_accounts_contacts_contact_events = null,
        string $contentType = self::contentTypes['restAccountsContactsContactEventsPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ContactEvent';
        $request = $this->restAccountsContactsContactEventsPostRequest($page, $items_per_page, $_rest_accounts_contacts_contact_events, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactEventsPost'
     *
     * @param  int|null $page The page of results to search for (optional)
     * @param  int|null $items_per_page The number of items to list per page (optional)
     * @param  \ck\Model\RestAccountsContactsContactEventsPostRequest|null $_rest_accounts_contacts_contact_events (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactEventsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsContactEventsPostRequest(
        $page = null,
        $items_per_page = null,
        $_rest_accounts_contacts_contact_events = null,
        string $contentType = self::contentTypes['restAccountsContactsContactEventsPost'][0]
    ): Request
    {





        $resourcePath = '/rest/accounts/contacts/contact_events';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $items_per_page,
            'itemsPerPage', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_accounts_contacts_contact_events)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_accounts_contacts_contact_events));
            } else {
                $httpBody = $_rest_accounts_contacts_contact_events;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactEventsTypesPreviewGet
     *
     * Get contact event types as a key/value array
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactEventsTypesPreviewGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object[]
     */
    public function restAccountsContactsContactEventsTypesPreviewGet(
        string $contentType = self::contentTypes['restAccountsContactsContactEventsTypesPreviewGet'][0]
    ): array
    {
        list($response) = $this->restAccountsContactsContactEventsTypesPreviewGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactEventsTypesPreviewGetWithHttpInfo
     *
     * Get contact event types as a key/value array
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactEventsTypesPreviewGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactEventsTypesPreviewGetWithHttpInfo(
        string $contentType = self::contentTypes['restAccountsContactsContactEventsTypesPreviewGet'][0]
    ): array
    {
        $request = $this->restAccountsContactsContactEventsTypesPreviewGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactEventsTypesPreviewGetAsync
     *
     * Get contact event types as a key/value array
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactEventsTypesPreviewGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactEventsTypesPreviewGetAsync(
        string $contentType = self::contentTypes['restAccountsContactsContactEventsTypesPreviewGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsContactEventsTypesPreviewGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactEventsTypesPreviewGetAsyncWithHttpInfo
     *
     * Get contact event types as a key/value array
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactEventsTypesPreviewGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactEventsTypesPreviewGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restAccountsContactsContactEventsTypesPreviewGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object[]';
        $request = $this->restAccountsContactsContactEventsTypesPreviewGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactEventsTypesPreviewGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactEventsTypesPreviewGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsContactEventsTypesPreviewGetRequest(
        string $contentType = self::contentTypes['restAccountsContactsContactEventsTypesPreviewGet'][0]
    ): Request
    {


        $resourcePath = '/rest/accounts/contacts/contact_events/types/preview';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdAccessDataLoginUrlGet
     *
     * Get login URL
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAccessDataLoginUrlGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restAccountsContactsContactIdAccessDataLoginUrlGet(
        int $contact_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAccessDataLoginUrlGet'][0]
    ): void
    {
        $this->restAccountsContactsContactIdAccessDataLoginUrlGetWithHttpInfo($contact_id, $contentType);
    }

    /**
     * Operation restAccountsContactsContactIdAccessDataLoginUrlGetWithHttpInfo
     *
     * Get login URL
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAccessDataLoginUrlGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdAccessDataLoginUrlGetWithHttpInfo(
        int $contact_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAccessDataLoginUrlGet'][0]
    ): array
    {
        $request = $this->restAccountsContactsContactIdAccessDataLoginUrlGetRequest($contact_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdAccessDataLoginUrlGetAsync
     *
     * Get login URL
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAccessDataLoginUrlGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactIdAccessDataLoginUrlGetAsync(
        int $contact_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAccessDataLoginUrlGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsContactIdAccessDataLoginUrlGetAsyncWithHttpInfo($contact_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdAccessDataLoginUrlGetAsyncWithHttpInfo
     *
     * Get login URL
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAccessDataLoginUrlGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactIdAccessDataLoginUrlGetAsyncWithHttpInfo(
        $contact_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAccessDataLoginUrlGet'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restAccountsContactsContactIdAccessDataLoginUrlGetRequest($contact_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdAccessDataLoginUrlGet'
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAccessDataLoginUrlGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsContactIdAccessDataLoginUrlGetRequest(
        $contact_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAccessDataLoginUrlGet'][0]
    ): Request
    {

        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdAccessDataLoginUrlGet'
            );
        }


        $resourcePath = '/rest/accounts/contacts/{contactId}/access_data/login_url';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdAccessDataNewPasswordPut
     *
     * Send password link for contact
     *
     * @param  string $password The new password (required)
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAccessDataNewPasswordPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restAccountsContactsContactIdAccessDataNewPasswordPut(
        string $password,
        int $contact_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAccessDataNewPasswordPut'][0]
    ): object
    {
        list($response) = $this->restAccountsContactsContactIdAccessDataNewPasswordPutWithHttpInfo($password, $contact_id, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdAccessDataNewPasswordPutWithHttpInfo
     *
     * Send password link for contact
     *
     * @param  string $password The new password (required)
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAccessDataNewPasswordPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdAccessDataNewPasswordPutWithHttpInfo(
        string $password,
        int $contact_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAccessDataNewPasswordPut'][0]
    ): array
    {
        $request = $this->restAccountsContactsContactIdAccessDataNewPasswordPutRequest($password, $contact_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdAccessDataNewPasswordPutAsync
     *
     * Send password link for contact
     *
     * @param  string $password The new password (required)
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAccessDataNewPasswordPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactIdAccessDataNewPasswordPutAsync(
        string $password,
        int $contact_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAccessDataNewPasswordPut'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsContactIdAccessDataNewPasswordPutAsyncWithHttpInfo($password, $contact_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdAccessDataNewPasswordPutAsyncWithHttpInfo
     *
     * Send password link for contact
     *
     * @param  string $password The new password (required)
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAccessDataNewPasswordPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactIdAccessDataNewPasswordPutAsyncWithHttpInfo(
        $password,
        $contact_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAccessDataNewPasswordPut'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restAccountsContactsContactIdAccessDataNewPasswordPutRequest($password, $contact_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdAccessDataNewPasswordPut'
     *
     * @param  string $password The new password (required)
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAccessDataNewPasswordPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsContactIdAccessDataNewPasswordPutRequest(
        $password,
        $contact_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAccessDataNewPasswordPut'][0]
    ): Request
    {

        // verify the required parameter 'password' is set
        if ($password === null || (is_array($password) && count($password) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $password when calling restAccountsContactsContactIdAccessDataNewPasswordPut'
            );
        }

        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdAccessDataNewPasswordPut'
            );
        }


        $resourcePath = '/rest/accounts/contacts/{contactId}/access_data/new_password';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $password,
            'password', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);


        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdAccessDataSetPasswordPut
     *
     * Update password for contact
     *
     * @param  string $password The new password (required)
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAccessDataSetPasswordPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restAccountsContactsContactIdAccessDataSetPasswordPut(
        string $password,
        int $contact_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAccessDataSetPasswordPut'][0]
    ): object
    {
        list($response) = $this->restAccountsContactsContactIdAccessDataSetPasswordPutWithHttpInfo($password, $contact_id, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdAccessDataSetPasswordPutWithHttpInfo
     *
     * Update password for contact
     *
     * @param  string $password The new password (required)
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAccessDataSetPasswordPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdAccessDataSetPasswordPutWithHttpInfo(
        string $password,
        int $contact_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAccessDataSetPasswordPut'][0]
    ): array
    {
        $request = $this->restAccountsContactsContactIdAccessDataSetPasswordPutRequest($password, $contact_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdAccessDataSetPasswordPutAsync
     *
     * Update password for contact
     *
     * @param  string $password The new password (required)
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAccessDataSetPasswordPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactIdAccessDataSetPasswordPutAsync(
        string $password,
        int $contact_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAccessDataSetPasswordPut'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsContactIdAccessDataSetPasswordPutAsyncWithHttpInfo($password, $contact_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdAccessDataSetPasswordPutAsyncWithHttpInfo
     *
     * Update password for contact
     *
     * @param  string $password The new password (required)
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAccessDataSetPasswordPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactIdAccessDataSetPasswordPutAsyncWithHttpInfo(
        $password,
        $contact_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAccessDataSetPasswordPut'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restAccountsContactsContactIdAccessDataSetPasswordPutRequest($password, $contact_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdAccessDataSetPasswordPut'
     *
     * @param  string $password The new password (required)
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAccessDataSetPasswordPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsContactIdAccessDataSetPasswordPutRequest(
        $password,
        $contact_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAccessDataSetPasswordPut'][0]
    ): Request
    {

        // verify the required parameter 'password' is set
        if ($password === null || (is_array($password) && count($password) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $password when calling restAccountsContactsContactIdAccessDataSetPasswordPut'
            );
        }

        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdAccessDataSetPasswordPut'
            );
        }


        $resourcePath = '/rest/accounts/contacts/{contactId}/access_data/set_password';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $password,
            'password', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);


        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdAccessDataUnblockUserPut
     *
     * Unblock contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAccessDataUnblockUserPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restAccountsContactsContactIdAccessDataUnblockUserPut(
        int $contact_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAccessDataUnblockUserPut'][0]
    ): object
    {
        list($response) = $this->restAccountsContactsContactIdAccessDataUnblockUserPutWithHttpInfo($contact_id, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdAccessDataUnblockUserPutWithHttpInfo
     *
     * Unblock contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAccessDataUnblockUserPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdAccessDataUnblockUserPutWithHttpInfo(
        int $contact_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAccessDataUnblockUserPut'][0]
    ): array
    {
        $request = $this->restAccountsContactsContactIdAccessDataUnblockUserPutRequest($contact_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdAccessDataUnblockUserPutAsync
     *
     * Unblock contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAccessDataUnblockUserPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactIdAccessDataUnblockUserPutAsync(
        int $contact_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAccessDataUnblockUserPut'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsContactIdAccessDataUnblockUserPutAsyncWithHttpInfo($contact_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdAccessDataUnblockUserPutAsyncWithHttpInfo
     *
     * Unblock contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAccessDataUnblockUserPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactIdAccessDataUnblockUserPutAsyncWithHttpInfo(
        $contact_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAccessDataUnblockUserPut'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restAccountsContactsContactIdAccessDataUnblockUserPutRequest($contact_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdAccessDataUnblockUserPut'
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAccessDataUnblockUserPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsContactIdAccessDataUnblockUserPutRequest(
        $contact_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAccessDataUnblockUserPut'][0]
    ): Request
    {

        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdAccessDataUnblockUserPut'
            );
        }


        $resourcePath = '/rest/accounts/contacts/{contactId}/access_data/unblock_user';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdAccountsAccountIdDelete
     *
     * Delete account of the contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $account_id The ID of the account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAccountsAccountIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restAccountsContactsContactIdAccountsAccountIdDelete(
        int $contact_id,
        int $account_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAccountsAccountIdDelete'][0]
    ): void
    {
        $this->restAccountsContactsContactIdAccountsAccountIdDeleteWithHttpInfo($contact_id, $account_id, $contentType);
    }

    /**
     * Operation restAccountsContactsContactIdAccountsAccountIdDeleteWithHttpInfo
     *
     * Delete account of the contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $account_id The ID of the account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAccountsAccountIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdAccountsAccountIdDeleteWithHttpInfo(
        int $contact_id,
        int $account_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAccountsAccountIdDelete'][0]
    ): array
    {
        $request = $this->restAccountsContactsContactIdAccountsAccountIdDeleteRequest($contact_id, $account_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdAccountsAccountIdDeleteAsync
     *
     * Delete account of the contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $account_id The ID of the account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAccountsAccountIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactIdAccountsAccountIdDeleteAsync(
        int $contact_id,
        int $account_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAccountsAccountIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsContactIdAccountsAccountIdDeleteAsyncWithHttpInfo($contact_id, $account_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdAccountsAccountIdDeleteAsyncWithHttpInfo
     *
     * Delete account of the contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $account_id The ID of the account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAccountsAccountIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactIdAccountsAccountIdDeleteAsyncWithHttpInfo(
        $contact_id,
        $account_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAccountsAccountIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restAccountsContactsContactIdAccountsAccountIdDeleteRequest($contact_id, $account_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdAccountsAccountIdDelete'
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $account_id The ID of the account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAccountsAccountIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsContactIdAccountsAccountIdDeleteRequest(
        $contact_id,
        $account_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAccountsAccountIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdAccountsAccountIdDelete'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $account_id when calling restAccountsContactsContactIdAccountsAccountIdDelete'
            );
        }


        $resourcePath = '/rest/accounts/contacts/{contactId}/accounts/{accountId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }
        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdAccountsAccountIdGet
     *
     * Get account of the contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $account_id The ID of the account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAccountsAccountIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Account
     */
    public function restAccountsContactsContactIdAccountsAccountIdGet(
        int $contact_id,
        int $account_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAccountsAccountIdGet'][0]
    ): \ck\Model\Account
    {
        list($response) = $this->restAccountsContactsContactIdAccountsAccountIdGetWithHttpInfo($contact_id, $account_id, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdAccountsAccountIdGetWithHttpInfo
     *
     * Get account of the contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $account_id The ID of the account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAccountsAccountIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Account, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdAccountsAccountIdGetWithHttpInfo(
        int $contact_id,
        int $account_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAccountsAccountIdGet'][0]
    ): array
    {
        $request = $this->restAccountsContactsContactIdAccountsAccountIdGetRequest($contact_id, $account_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Account' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Account' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Account', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Account';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Account',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdAccountsAccountIdGetAsync
     *
     * Get account of the contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $account_id The ID of the account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAccountsAccountIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactIdAccountsAccountIdGetAsync(
        int $contact_id,
        int $account_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAccountsAccountIdGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsContactIdAccountsAccountIdGetAsyncWithHttpInfo($contact_id, $account_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdAccountsAccountIdGetAsyncWithHttpInfo
     *
     * Get account of the contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $account_id The ID of the account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAccountsAccountIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactIdAccountsAccountIdGetAsyncWithHttpInfo(
        $contact_id,
        $account_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAccountsAccountIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Account';
        $request = $this->restAccountsContactsContactIdAccountsAccountIdGetRequest($contact_id, $account_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdAccountsAccountIdGet'
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $account_id The ID of the account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAccountsAccountIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsContactIdAccountsAccountIdGetRequest(
        $contact_id,
        $account_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAccountsAccountIdGet'][0]
    ): Request
    {

        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdAccountsAccountIdGet'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $account_id when calling restAccountsContactsContactIdAccountsAccountIdGet'
            );
        }


        $resourcePath = '/rest/accounts/contacts/{contactId}/accounts/{accountId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }
        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdAccountsAccountIdPut
     *
     * Update account
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $account_id The ID of the account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAccountsAccountIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Account
     */
    public function restAccountsContactsContactIdAccountsAccountIdPut(
        int $contact_id,
        int $account_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAccountsAccountIdPut'][0]
    ): \ck\Model\Account
    {
        list($response) = $this->restAccountsContactsContactIdAccountsAccountIdPutWithHttpInfo($contact_id, $account_id, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdAccountsAccountIdPutWithHttpInfo
     *
     * Update account
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $account_id The ID of the account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAccountsAccountIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Account, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdAccountsAccountIdPutWithHttpInfo(
        int $contact_id,
        int $account_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAccountsAccountIdPut'][0]
    ): array
    {
        $request = $this->restAccountsContactsContactIdAccountsAccountIdPutRequest($contact_id, $account_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Account' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Account' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Account', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Account';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Account',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdAccountsAccountIdPutAsync
     *
     * Update account
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $account_id The ID of the account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAccountsAccountIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactIdAccountsAccountIdPutAsync(
        int $contact_id,
        int $account_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAccountsAccountIdPut'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsContactIdAccountsAccountIdPutAsyncWithHttpInfo($contact_id, $account_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdAccountsAccountIdPutAsyncWithHttpInfo
     *
     * Update account
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $account_id The ID of the account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAccountsAccountIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactIdAccountsAccountIdPutAsyncWithHttpInfo(
        $contact_id,
        $account_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAccountsAccountIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Account';
        $request = $this->restAccountsContactsContactIdAccountsAccountIdPutRequest($contact_id, $account_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdAccountsAccountIdPut'
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $account_id The ID of the account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAccountsAccountIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsContactIdAccountsAccountIdPutRequest(
        $contact_id,
        $account_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAccountsAccountIdPut'][0]
    ): Request
    {

        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdAccountsAccountIdPut'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $account_id when calling restAccountsContactsContactIdAccountsAccountIdPut'
            );
        }


        $resourcePath = '/rest/accounts/contacts/{contactId}/accounts/{accountId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }
        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdAccountsPost
     *
     * Create account for existing contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  \ck\Model\RestAccountsPostRequest|null $_rest_accounts_contacts_contact_id_accounts _rest_accounts_contacts_contact_id_accounts (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAccountsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Account
     */
    public function restAccountsContactsContactIdAccountsPost(
        int $contact_id,
        ?\ck\Model\RestAccountsPostRequest $_rest_accounts_contacts_contact_id_accounts = null,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAccountsPost'][0]
    ): \ck\Model\Account
    {
        list($response) = $this->restAccountsContactsContactIdAccountsPostWithHttpInfo($contact_id, $_rest_accounts_contacts_contact_id_accounts, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdAccountsPostWithHttpInfo
     *
     * Create account for existing contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  \ck\Model\RestAccountsPostRequest|null $_rest_accounts_contacts_contact_id_accounts (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAccountsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Account, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdAccountsPostWithHttpInfo(
        int $contact_id,
        ?\ck\Model\RestAccountsPostRequest $_rest_accounts_contacts_contact_id_accounts = null,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAccountsPost'][0]
    ): array
    {
        $request = $this->restAccountsContactsContactIdAccountsPostRequest($contact_id, $_rest_accounts_contacts_contact_id_accounts, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Account' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Account' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Account', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Account';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Account',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdAccountsPostAsync
     *
     * Create account for existing contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  \ck\Model\RestAccountsPostRequest|null $_rest_accounts_contacts_contact_id_accounts (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAccountsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactIdAccountsPostAsync(
        int $contact_id,
        ?\ck\Model\RestAccountsPostRequest $_rest_accounts_contacts_contact_id_accounts = null,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAccountsPost'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsContactIdAccountsPostAsyncWithHttpInfo($contact_id, $_rest_accounts_contacts_contact_id_accounts, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdAccountsPostAsyncWithHttpInfo
     *
     * Create account for existing contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  \ck\Model\RestAccountsPostRequest|null $_rest_accounts_contacts_contact_id_accounts (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAccountsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactIdAccountsPostAsyncWithHttpInfo(
        $contact_id,
        $_rest_accounts_contacts_contact_id_accounts = null,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAccountsPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Account';
        $request = $this->restAccountsContactsContactIdAccountsPostRequest($contact_id, $_rest_accounts_contacts_contact_id_accounts, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdAccountsPost'
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  \ck\Model\RestAccountsPostRequest|null $_rest_accounts_contacts_contact_id_accounts (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAccountsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsContactIdAccountsPostRequest(
        $contact_id,
        $_rest_accounts_contacts_contact_id_accounts = null,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAccountsPost'][0]
    ): Request
    {

        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdAccountsPost'
            );
        }



        $resourcePath = '/rest/accounts/contacts/{contactId}/accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_accounts_contacts_contact_id_accounts)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_accounts_contacts_contact_id_accounts));
            } else {
                $httpBody = $_rest_accounts_contacts_contact_id_accounts;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdAddressesAddressIdDelete
     *
     * Delete address of the contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $address_id The ID of the address (required)
     * @param  int|null $type_id The type ID of the address. Possible values: &lt;ul&gt;&lt;li&gt;Invoice address &#x3D; 1&lt;/li&gt;&lt;li&gt; Delivery address &#x3D; 2&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAddressesAddressIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restAccountsContactsContactIdAddressesAddressIdDelete(
        int $contact_id,
        int $address_id,
        ?int $type_id = null,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAddressesAddressIdDelete'][0]
    ): void
    {
        $this->restAccountsContactsContactIdAddressesAddressIdDeleteWithHttpInfo($contact_id, $address_id, $type_id, $contentType);
    }

    /**
     * Operation restAccountsContactsContactIdAddressesAddressIdDeleteWithHttpInfo
     *
     * Delete address of the contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $address_id The ID of the address (required)
     * @param  int|null $type_id The type ID of the address. Possible values: &lt;ul&gt;&lt;li&gt;Invoice address &#x3D; 1&lt;/li&gt;&lt;li&gt; Delivery address &#x3D; 2&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAddressesAddressIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdAddressesAddressIdDeleteWithHttpInfo(
        int $contact_id,
        int $address_id,
        ?int $type_id = null,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAddressesAddressIdDelete'][0]
    ): array
    {
        $request = $this->restAccountsContactsContactIdAddressesAddressIdDeleteRequest($contact_id, $address_id, $type_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdAddressesAddressIdDeleteAsync
     *
     * Delete address of the contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $address_id The ID of the address (required)
     * @param  int|null $type_id The type ID of the address. Possible values: &lt;ul&gt;&lt;li&gt;Invoice address &#x3D; 1&lt;/li&gt;&lt;li&gt; Delivery address &#x3D; 2&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAddressesAddressIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactIdAddressesAddressIdDeleteAsync(
        int $contact_id,
        int $address_id,
        ?int $type_id = null,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAddressesAddressIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsContactIdAddressesAddressIdDeleteAsyncWithHttpInfo($contact_id, $address_id, $type_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdAddressesAddressIdDeleteAsyncWithHttpInfo
     *
     * Delete address of the contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $address_id The ID of the address (required)
     * @param  int|null $type_id The type ID of the address. Possible values: &lt;ul&gt;&lt;li&gt;Invoice address &#x3D; 1&lt;/li&gt;&lt;li&gt; Delivery address &#x3D; 2&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAddressesAddressIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactIdAddressesAddressIdDeleteAsyncWithHttpInfo(
        $contact_id,
        $address_id,
        $type_id = null,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAddressesAddressIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restAccountsContactsContactIdAddressesAddressIdDeleteRequest($contact_id, $address_id, $type_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdAddressesAddressIdDelete'
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $address_id The ID of the address (required)
     * @param  int|null $type_id The type ID of the address. Possible values: &lt;ul&gt;&lt;li&gt;Invoice address &#x3D; 1&lt;/li&gt;&lt;li&gt; Delivery address &#x3D; 2&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAddressesAddressIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsContactIdAddressesAddressIdDeleteRequest(
        $contact_id,
        $address_id,
        $type_id = null,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAddressesAddressIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdAddressesAddressIdDelete'
            );
        }

        // verify the required parameter 'address_id' is set
        if ($address_id === null || (is_array($address_id) && count($address_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $address_id when calling restAccountsContactsContactIdAddressesAddressIdDelete'
            );
        }



        $resourcePath = '/rest/accounts/contacts/{contactId}/addresses/{addressId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type_id,
            'typeId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }
        // path params
        if ($address_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addressId' . '}',
                ObjectSerializer::toPathValue($address_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdAddressesAddressIdPut
     *
     * Update address of the contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $address_id The ID of the address (required)
     * @param  bool|null $is_primary Sets a contact address per address type as the primary address. (optional)
     * @param  int|null $type_id The type ID of the address. Possible values: &lt;ul&gt;&lt;li&gt;Invoice address &#x3D; 1&lt;/li&gt;&lt;li&gt; Delivery address &#x3D; 2&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAddressesAddressIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Address
     */
    public function restAccountsContactsContactIdAddressesAddressIdPut(
        int $contact_id,
        int $address_id,
        ?bool $is_primary = null,
        ?int $type_id = null,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAddressesAddressIdPut'][0]
    ): \ck\Model\Address
    {
        list($response) = $this->restAccountsContactsContactIdAddressesAddressIdPutWithHttpInfo($contact_id, $address_id, $is_primary, $type_id, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdAddressesAddressIdPutWithHttpInfo
     *
     * Update address of the contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $address_id The ID of the address (required)
     * @param  bool|null $is_primary Sets a contact address per address type as the primary address. (optional)
     * @param  int|null $type_id The type ID of the address. Possible values: &lt;ul&gt;&lt;li&gt;Invoice address &#x3D; 1&lt;/li&gt;&lt;li&gt; Delivery address &#x3D; 2&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAddressesAddressIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Address, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdAddressesAddressIdPutWithHttpInfo(
        int $contact_id,
        int $address_id,
        ?bool $is_primary = null,
        ?int $type_id = null,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAddressesAddressIdPut'][0]
    ): array
    {
        $request = $this->restAccountsContactsContactIdAddressesAddressIdPutRequest($contact_id, $address_id, $is_primary, $type_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Address' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Address' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Address', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Address';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Address',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdAddressesAddressIdPutAsync
     *
     * Update address of the contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $address_id The ID of the address (required)
     * @param  bool|null $is_primary Sets a contact address per address type as the primary address. (optional)
     * @param  int|null $type_id The type ID of the address. Possible values: &lt;ul&gt;&lt;li&gt;Invoice address &#x3D; 1&lt;/li&gt;&lt;li&gt; Delivery address &#x3D; 2&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAddressesAddressIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactIdAddressesAddressIdPutAsync(
        int $contact_id,
        int $address_id,
        ?bool $is_primary = null,
        ?int $type_id = null,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAddressesAddressIdPut'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsContactIdAddressesAddressIdPutAsyncWithHttpInfo($contact_id, $address_id, $is_primary, $type_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdAddressesAddressIdPutAsyncWithHttpInfo
     *
     * Update address of the contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $address_id The ID of the address (required)
     * @param  bool|null $is_primary Sets a contact address per address type as the primary address. (optional)
     * @param  int|null $type_id The type ID of the address. Possible values: &lt;ul&gt;&lt;li&gt;Invoice address &#x3D; 1&lt;/li&gt;&lt;li&gt; Delivery address &#x3D; 2&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAddressesAddressIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactIdAddressesAddressIdPutAsyncWithHttpInfo(
        $contact_id,
        $address_id,
        $is_primary = null,
        $type_id = null,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAddressesAddressIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Address';
        $request = $this->restAccountsContactsContactIdAddressesAddressIdPutRequest($contact_id, $address_id, $is_primary, $type_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdAddressesAddressIdPut'
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $address_id The ID of the address (required)
     * @param  bool|null $is_primary Sets a contact address per address type as the primary address. (optional)
     * @param  int|null $type_id The type ID of the address. Possible values: &lt;ul&gt;&lt;li&gt;Invoice address &#x3D; 1&lt;/li&gt;&lt;li&gt; Delivery address &#x3D; 2&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAddressesAddressIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsContactIdAddressesAddressIdPutRequest(
        $contact_id,
        $address_id,
        $is_primary = null,
        $type_id = null,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAddressesAddressIdPut'][0]
    ): Request
    {

        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdAddressesAddressIdPut'
            );
        }

        // verify the required parameter 'address_id' is set
        if ($address_id === null || (is_array($address_id) && count($address_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $address_id when calling restAccountsContactsContactIdAddressesAddressIdPut'
            );
        }




        $resourcePath = '/rest/accounts/contacts/{contactId}/addresses/{addressId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_primary,
            'isPrimary', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type_id,
            'typeId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }
        // path params
        if ($address_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addressId' . '}',
                ObjectSerializer::toPathValue($address_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPut
     *
     * Set contact address per address type as primary address
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $address_id The ID of the address (required)
     * @param  int $address_type_id The ID of the address type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\AddressContactRelation
     */
    public function restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPut(
        int $contact_id,
        int $address_id,
        int $address_type_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPut'][0]
    ): \ck\Model\AddressContactRelation
    {
        list($response) = $this->restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPutWithHttpInfo($contact_id, $address_id, $address_type_id, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPutWithHttpInfo
     *
     * Set contact address per address type as primary address
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $address_id The ID of the address (required)
     * @param  int $address_type_id The ID of the address type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\AddressContactRelation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPutWithHttpInfo(
        int $contact_id,
        int $address_id,
        int $address_type_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPut'][0]
    ): array
    {
        $request = $this->restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPutRequest($contact_id, $address_id, $address_type_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\AddressContactRelation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\AddressContactRelation' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\AddressContactRelation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\AddressContactRelation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\AddressContactRelation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPutAsync
     *
     * Set contact address per address type as primary address
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $address_id The ID of the address (required)
     * @param  int $address_type_id The ID of the address type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPutAsync(
        int $contact_id,
        int $address_id,
        int $address_type_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPut'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPutAsyncWithHttpInfo($contact_id, $address_id, $address_type_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPutAsyncWithHttpInfo
     *
     * Set contact address per address type as primary address
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $address_id The ID of the address (required)
     * @param  int $address_type_id The ID of the address type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPutAsyncWithHttpInfo(
        $contact_id,
        $address_id,
        $address_type_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\AddressContactRelation';
        $request = $this->restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPutRequest($contact_id, $address_id, $address_type_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPut'
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $address_id The ID of the address (required)
     * @param  int $address_type_id The ID of the address type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPutRequest(
        $contact_id,
        $address_id,
        $address_type_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPut'][0]
    ): Request
    {

        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPut'
            );
        }

        // verify the required parameter 'address_id' is set
        if ($address_id === null || (is_array($address_id) && count($address_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $address_id when calling restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPut'
            );
        }

        // verify the required parameter 'address_type_id' is set
        if ($address_type_id === null || (is_array($address_type_id) && count($address_type_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $address_type_id when calling restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPut'
            );
        }


        $resourcePath = '/rest/accounts/contacts/{contactId}/addresses/{addressId}/types/{addressTypeId}/primary';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }
        // path params
        if ($address_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addressId' . '}',
                ObjectSerializer::toPathValue($address_id),
                $resourcePath
            );
        }
        // path params
        if ($address_type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addressTypeId' . '}',
                ObjectSerializer::toPathValue($address_type_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPut
     *
     * Reset contact primary address
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $address_id The ID of the address (required)
     * @param  int $address_type_id The ID of the address type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\AddressContactRelation
     */
    public function restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPut(
        int $contact_id,
        int $address_id,
        int $address_type_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPut'][0]
    ): \ck\Model\AddressContactRelation
    {
        list($response) = $this->restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPutWithHttpInfo($contact_id, $address_id, $address_type_id, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPutWithHttpInfo
     *
     * Reset contact primary address
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $address_id The ID of the address (required)
     * @param  int $address_type_id The ID of the address type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\AddressContactRelation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPutWithHttpInfo(
        int $contact_id,
        int $address_id,
        int $address_type_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPut'][0]
    ): array
    {
        $request = $this->restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPutRequest($contact_id, $address_id, $address_type_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\AddressContactRelation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\AddressContactRelation' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\AddressContactRelation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\AddressContactRelation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\AddressContactRelation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPutAsync
     *
     * Reset contact primary address
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $address_id The ID of the address (required)
     * @param  int $address_type_id The ID of the address type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPutAsync(
        int $contact_id,
        int $address_id,
        int $address_type_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPut'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPutAsyncWithHttpInfo($contact_id, $address_id, $address_type_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPutAsyncWithHttpInfo
     *
     * Reset contact primary address
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $address_id The ID of the address (required)
     * @param  int $address_type_id The ID of the address type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPutAsyncWithHttpInfo(
        $contact_id,
        $address_id,
        $address_type_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\AddressContactRelation';
        $request = $this->restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPutRequest($contact_id, $address_id, $address_type_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPut'
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int $address_id The ID of the address (required)
     * @param  int $address_type_id The ID of the address type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPutRequest(
        $contact_id,
        $address_id,
        $address_type_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPut'][0]
    ): Request
    {

        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPut'
            );
        }

        // verify the required parameter 'address_id' is set
        if ($address_id === null || (is_array($address_id) && count($address_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $address_id when calling restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPut'
            );
        }

        // verify the required parameter 'address_type_id' is set
        if ($address_type_id === null || (is_array($address_type_id) && count($address_type_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $address_type_id when calling restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPut'
            );
        }


        $resourcePath = '/rest/accounts/contacts/{contactId}/addresses/{addressId}/types/{addressTypeId}/reset_primary';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }
        // path params
        if ($address_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addressId' . '}',
                ObjectSerializer::toPathValue($address_id),
                $resourcePath
            );
        }
        // path params
        if ($address_type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addressTypeId' . '}',
                ObjectSerializer::toPathValue($address_type_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdAddressesPost
     *
     * Create address for existing contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  bool|null $is_primary Sets a contact address per address type as the primary address. (optional)
     * @param  int|null $type_id The type ID of the address. Possible values: &lt;ul&gt;&lt;li&gt;Invoice address &#x3D; 1&lt;/li&gt;&lt;li&gt; Delivery address &#x3D; 2&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  \ck\Model\RestAccountsAddressesPostRequest|null $_rest_accounts_contacts_contact_id_addresses _rest_accounts_contacts_contact_id_addresses (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAddressesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Address
     */
    public function restAccountsContactsContactIdAddressesPost(
        int $contact_id,
        ?bool $is_primary = null,
        ?int $type_id = null,
        ?\ck\Model\RestAccountsAddressesPostRequest $_rest_accounts_contacts_contact_id_addresses = null,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAddressesPost'][0]
    ): \ck\Model\Address
    {
        list($response) = $this->restAccountsContactsContactIdAddressesPostWithHttpInfo($contact_id, $is_primary, $type_id, $_rest_accounts_contacts_contact_id_addresses, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdAddressesPostWithHttpInfo
     *
     * Create address for existing contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  bool|null $is_primary Sets a contact address per address type as the primary address. (optional)
     * @param  int|null $type_id The type ID of the address. Possible values: &lt;ul&gt;&lt;li&gt;Invoice address &#x3D; 1&lt;/li&gt;&lt;li&gt; Delivery address &#x3D; 2&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  \ck\Model\RestAccountsAddressesPostRequest|null $_rest_accounts_contacts_contact_id_addresses (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAddressesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Address, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdAddressesPostWithHttpInfo(
        int $contact_id,
        ?bool $is_primary = null,
        ?int $type_id = null,
        ?\ck\Model\RestAccountsAddressesPostRequest $_rest_accounts_contacts_contact_id_addresses = null,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAddressesPost'][0]
    ): array
    {
        $request = $this->restAccountsContactsContactIdAddressesPostRequest($contact_id, $is_primary, $type_id, $_rest_accounts_contacts_contact_id_addresses, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Address' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Address' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Address', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Address';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Address',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdAddressesPostAsync
     *
     * Create address for existing contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  bool|null $is_primary Sets a contact address per address type as the primary address. (optional)
     * @param  int|null $type_id The type ID of the address. Possible values: &lt;ul&gt;&lt;li&gt;Invoice address &#x3D; 1&lt;/li&gt;&lt;li&gt; Delivery address &#x3D; 2&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  \ck\Model\RestAccountsAddressesPostRequest|null $_rest_accounts_contacts_contact_id_addresses (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAddressesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactIdAddressesPostAsync(
        int $contact_id,
        ?bool $is_primary = null,
        ?int $type_id = null,
        ?\ck\Model\RestAccountsAddressesPostRequest $_rest_accounts_contacts_contact_id_addresses = null,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAddressesPost'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsContactIdAddressesPostAsyncWithHttpInfo($contact_id, $is_primary, $type_id, $_rest_accounts_contacts_contact_id_addresses, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdAddressesPostAsyncWithHttpInfo
     *
     * Create address for existing contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  bool|null $is_primary Sets a contact address per address type as the primary address. (optional)
     * @param  int|null $type_id The type ID of the address. Possible values: &lt;ul&gt;&lt;li&gt;Invoice address &#x3D; 1&lt;/li&gt;&lt;li&gt; Delivery address &#x3D; 2&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  \ck\Model\RestAccountsAddressesPostRequest|null $_rest_accounts_contacts_contact_id_addresses (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAddressesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactIdAddressesPostAsyncWithHttpInfo(
        $contact_id,
        $is_primary = null,
        $type_id = null,
        $_rest_accounts_contacts_contact_id_addresses = null,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAddressesPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Address';
        $request = $this->restAccountsContactsContactIdAddressesPostRequest($contact_id, $is_primary, $type_id, $_rest_accounts_contacts_contact_id_addresses, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdAddressesPost'
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  bool|null $is_primary Sets a contact address per address type as the primary address. (optional)
     * @param  int|null $type_id The type ID of the address. Possible values: &lt;ul&gt;&lt;li&gt;Invoice address &#x3D; 1&lt;/li&gt;&lt;li&gt; Delivery address &#x3D; 2&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  \ck\Model\RestAccountsAddressesPostRequest|null $_rest_accounts_contacts_contact_id_addresses (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAddressesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsContactIdAddressesPostRequest(
        $contact_id,
        $is_primary = null,
        $type_id = null,
        $_rest_accounts_contacts_contact_id_addresses = null,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAddressesPost'][0]
    ): Request
    {

        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdAddressesPost'
            );
        }





        $resourcePath = '/rest/accounts/contacts/{contactId}/addresses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_primary,
            'isPrimary', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type_id,
            'typeId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_accounts_contacts_contact_id_addresses)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_accounts_contacts_contact_id_addresses));
            } else {
                $httpBody = $_rest_accounts_contacts_contact_id_addresses;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdAddressesPrimaryGet
     *
     * Get primary or last created addresses of contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAddressesPrimaryGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restAccountsContactsContactIdAddressesPrimaryGet(
        int $contact_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAddressesPrimaryGet'][0]
    ): object
    {
        list($response) = $this->restAccountsContactsContactIdAddressesPrimaryGetWithHttpInfo($contact_id, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdAddressesPrimaryGetWithHttpInfo
     *
     * Get primary or last created addresses of contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAddressesPrimaryGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdAddressesPrimaryGetWithHttpInfo(
        int $contact_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAddressesPrimaryGet'][0]
    ): array
    {
        $request = $this->restAccountsContactsContactIdAddressesPrimaryGetRequest($contact_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdAddressesPrimaryGetAsync
     *
     * Get primary or last created addresses of contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAddressesPrimaryGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactIdAddressesPrimaryGetAsync(
        int $contact_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAddressesPrimaryGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsContactIdAddressesPrimaryGetAsyncWithHttpInfo($contact_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdAddressesPrimaryGetAsyncWithHttpInfo
     *
     * Get primary or last created addresses of contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAddressesPrimaryGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactIdAddressesPrimaryGetAsyncWithHttpInfo(
        $contact_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAddressesPrimaryGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restAccountsContactsContactIdAddressesPrimaryGetRequest($contact_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdAddressesPrimaryGet'
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdAddressesPrimaryGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsContactIdAddressesPrimaryGetRequest(
        $contact_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdAddressesPrimaryGet'][0]
    ): Request
    {

        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdAddressesPrimaryGet'
            );
        }


        $resourcePath = '/rest/accounts/contacts/{contactId}/addresses/primary';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdBanksGet
     *
     * List bank accounts
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int|null $items_per_page The number of items per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdBanksGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ContactBank[]
     */
    public function restAccountsContactsContactIdBanksGet(
        int $contact_id,
        ?int $items_per_page = null,
        string $contentType = self::contentTypes['restAccountsContactsContactIdBanksGet'][0]
    ): array
    {
        list($response) = $this->restAccountsContactsContactIdBanksGetWithHttpInfo($contact_id, $items_per_page, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdBanksGetWithHttpInfo
     *
     * List bank accounts
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int|null $items_per_page The number of items per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdBanksGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ContactBank[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdBanksGetWithHttpInfo(
        int $contact_id,
        ?int $items_per_page = null,
        string $contentType = self::contentTypes['restAccountsContactsContactIdBanksGet'][0]
    ): array
    {
        $request = $this->restAccountsContactsContactIdBanksGetRequest($contact_id, $items_per_page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ContactBank[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ContactBank[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ContactBank[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ContactBank[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ContactBank[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdBanksGetAsync
     *
     * List bank accounts
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int|null $items_per_page The number of items per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdBanksGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactIdBanksGetAsync(
        int $contact_id,
        ?int $items_per_page = null,
        string $contentType = self::contentTypes['restAccountsContactsContactIdBanksGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsContactIdBanksGetAsyncWithHttpInfo($contact_id, $items_per_page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdBanksGetAsyncWithHttpInfo
     *
     * List bank accounts
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int|null $items_per_page The number of items per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdBanksGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactIdBanksGetAsyncWithHttpInfo(
        $contact_id,
        $items_per_page = null,
        string $contentType = self::contentTypes['restAccountsContactsContactIdBanksGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ContactBank[]';
        $request = $this->restAccountsContactsContactIdBanksGetRequest($contact_id, $items_per_page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdBanksGet'
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int|null $items_per_page The number of items per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdBanksGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsContactIdBanksGetRequest(
        $contact_id,
        $items_per_page = null,
        string $contentType = self::contentTypes['restAccountsContactsContactIdBanksGet'][0]
    ): Request
    {

        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdBanksGet'
            );
        }



        $resourcePath = '/rest/accounts/contacts/{contactId}/banks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $items_per_page,
            'itemsPerPage', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdContactEventsGet
     *
     * List contact events by contact ID
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int|null $page The page of results to search for (optional)
     * @param  int|null $items_per_page The number of items to list per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdContactEventsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestAccountsContactsContactEventsGet200Response
     */
    public function restAccountsContactsContactIdContactEventsGet(
        int $contact_id,
        ?int $page = null,
        ?int $items_per_page = null,
        string $contentType = self::contentTypes['restAccountsContactsContactIdContactEventsGet'][0]
    ): \ck\Model\RestAccountsContactsContactEventsGet200Response
    {
        list($response) = $this->restAccountsContactsContactIdContactEventsGetWithHttpInfo($contact_id, $page, $items_per_page, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdContactEventsGetWithHttpInfo
     *
     * List contact events by contact ID
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int|null $page The page of results to search for (optional)
     * @param  int|null $items_per_page The number of items to list per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdContactEventsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestAccountsContactsContactEventsGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdContactEventsGetWithHttpInfo(
        int $contact_id,
        ?int $page = null,
        ?int $items_per_page = null,
        string $contentType = self::contentTypes['restAccountsContactsContactIdContactEventsGet'][0]
    ): array
    {
        $request = $this->restAccountsContactsContactIdContactEventsGetRequest($contact_id, $page, $items_per_page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestAccountsContactsContactEventsGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestAccountsContactsContactEventsGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestAccountsContactsContactEventsGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestAccountsContactsContactEventsGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestAccountsContactsContactEventsGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdContactEventsGetAsync
     *
     * List contact events by contact ID
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int|null $page The page of results to search for (optional)
     * @param  int|null $items_per_page The number of items to list per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdContactEventsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactIdContactEventsGetAsync(
        int $contact_id,
        ?int $page = null,
        ?int $items_per_page = null,
        string $contentType = self::contentTypes['restAccountsContactsContactIdContactEventsGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsContactIdContactEventsGetAsyncWithHttpInfo($contact_id, $page, $items_per_page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdContactEventsGetAsyncWithHttpInfo
     *
     * List contact events by contact ID
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int|null $page The page of results to search for (optional)
     * @param  int|null $items_per_page The number of items to list per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdContactEventsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactIdContactEventsGetAsyncWithHttpInfo(
        $contact_id,
        $page = null,
        $items_per_page = null,
        string $contentType = self::contentTypes['restAccountsContactsContactIdContactEventsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestAccountsContactsContactEventsGet200Response';
        $request = $this->restAccountsContactsContactIdContactEventsGetRequest($contact_id, $page, $items_per_page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdContactEventsGet'
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int|null $page The page of results to search for (optional)
     * @param  int|null $items_per_page The number of items to list per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdContactEventsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsContactIdContactEventsGetRequest(
        $contact_id,
        $page = null,
        $items_per_page = null,
        string $contentType = self::contentTypes['restAccountsContactsContactIdContactEventsGet'][0]
    ): Request
    {

        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdContactEventsGet'
            );
        }




        $resourcePath = '/rest/accounts/contacts/{contactId}/contact_events';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $items_per_page,
            'itemsPerPage', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdDelete
     *
     * Delete contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  bool|null $check_existing_orders Flag that checks if the contact is linked to orders. If the contact is linked to orders, CustomerDeleteException is thrown and the contact will not be deleted. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restAccountsContactsContactIdDelete(
        int $contact_id,
        ?bool $check_existing_orders = null,
        string $contentType = self::contentTypes['restAccountsContactsContactIdDelete'][0]
    ): void
    {
        $this->restAccountsContactsContactIdDeleteWithHttpInfo($contact_id, $check_existing_orders, $contentType);
    }

    /**
     * Operation restAccountsContactsContactIdDeleteWithHttpInfo
     *
     * Delete contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  bool|null $check_existing_orders Flag that checks if the contact is linked to orders. If the contact is linked to orders, CustomerDeleteException is thrown and the contact will not be deleted. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdDeleteWithHttpInfo(
        int $contact_id,
        ?bool $check_existing_orders = null,
        string $contentType = self::contentTypes['restAccountsContactsContactIdDelete'][0]
    ): array
    {
        $request = $this->restAccountsContactsContactIdDeleteRequest($contact_id, $check_existing_orders, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdDeleteAsync
     *
     * Delete contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  bool|null $check_existing_orders Flag that checks if the contact is linked to orders. If the contact is linked to orders, CustomerDeleteException is thrown and the contact will not be deleted. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactIdDeleteAsync(
        int $contact_id,
        ?bool $check_existing_orders = null,
        string $contentType = self::contentTypes['restAccountsContactsContactIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsContactIdDeleteAsyncWithHttpInfo($contact_id, $check_existing_orders, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdDeleteAsyncWithHttpInfo
     *
     * Delete contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  bool|null $check_existing_orders Flag that checks if the contact is linked to orders. If the contact is linked to orders, CustomerDeleteException is thrown and the contact will not be deleted. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactIdDeleteAsyncWithHttpInfo(
        $contact_id,
        $check_existing_orders = null,
        string $contentType = self::contentTypes['restAccountsContactsContactIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restAccountsContactsContactIdDeleteRequest($contact_id, $check_existing_orders, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdDelete'
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  bool|null $check_existing_orders Flag that checks if the contact is linked to orders. If the contact is linked to orders, CustomerDeleteException is thrown and the contact will not be deleted. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsContactIdDeleteRequest(
        $contact_id,
        $check_existing_orders = null,
        string $contentType = self::contentTypes['restAccountsContactsContactIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdDelete'
            );
        }



        $resourcePath = '/rest/accounts/contacts/{contactId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $check_existing_orders,
            'checkExistingOrders', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdGet
     *
     * Get contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  string|null $with Includes the specified contact information in the results. The following parameters are available: addresses, accounts. More than one parameter should be separated by commas. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Contact
     */
    public function restAccountsContactsContactIdGet(
        int $contact_id,
        ?string $with = null,
        string $contentType = self::contentTypes['restAccountsContactsContactIdGet'][0]
    ): \ck\Model\Contact
    {
        list($response) = $this->restAccountsContactsContactIdGetWithHttpInfo($contact_id, $with, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdGetWithHttpInfo
     *
     * Get contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  string|null $with Includes the specified contact information in the results. The following parameters are available: addresses, accounts. More than one parameter should be separated by commas. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Contact, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdGetWithHttpInfo(
        int $contact_id,
        ?string $with = null,
        string $contentType = self::contentTypes['restAccountsContactsContactIdGet'][0]
    ): array
    {
        $request = $this->restAccountsContactsContactIdGetRequest($contact_id, $with, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Contact' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Contact' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Contact', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Contact';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Contact',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdGetAsync
     *
     * Get contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  string|null $with Includes the specified contact information in the results. The following parameters are available: addresses, accounts. More than one parameter should be separated by commas. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactIdGetAsync(
        int $contact_id,
        ?string $with = null,
        string $contentType = self::contentTypes['restAccountsContactsContactIdGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsContactIdGetAsyncWithHttpInfo($contact_id, $with, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdGetAsyncWithHttpInfo
     *
     * Get contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  string|null $with Includes the specified contact information in the results. The following parameters are available: addresses, accounts. More than one parameter should be separated by commas. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactIdGetAsyncWithHttpInfo(
        $contact_id,
        $with = null,
        string $contentType = self::contentTypes['restAccountsContactsContactIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Contact';
        $request = $this->restAccountsContactsContactIdGetRequest($contact_id, $with, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdGet'
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  string|null $with Includes the specified contact information in the results. The following parameters are available: addresses, accounts. More than one parameter should be separated by commas. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsContactIdGetRequest(
        $contact_id,
        $with = null,
        string $contentType = self::contentTypes['restAccountsContactsContactIdGet'][0]
    ): Request
    {

        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdGet'
            );
        }



        $resourcePath = '/rest/accounts/contacts/{contactId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdOptionsDelete
     *
     * Delete contact option
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdOptionsDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restAccountsContactsContactIdOptionsDelete(
        int $contact_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdOptionsDelete'][0]
    ): void
    {
        $this->restAccountsContactsContactIdOptionsDeleteWithHttpInfo($contact_id, $contentType);
    }

    /**
     * Operation restAccountsContactsContactIdOptionsDeleteWithHttpInfo
     *
     * Delete contact option
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdOptionsDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdOptionsDeleteWithHttpInfo(
        int $contact_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdOptionsDelete'][0]
    ): array
    {
        $request = $this->restAccountsContactsContactIdOptionsDeleteRequest($contact_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdOptionsDeleteAsync
     *
     * Delete contact option
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdOptionsDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactIdOptionsDeleteAsync(
        int $contact_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdOptionsDelete'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsContactIdOptionsDeleteAsyncWithHttpInfo($contact_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdOptionsDeleteAsyncWithHttpInfo
     *
     * Delete contact option
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdOptionsDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactIdOptionsDeleteAsyncWithHttpInfo(
        $contact_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdOptionsDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restAccountsContactsContactIdOptionsDeleteRequest($contact_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdOptionsDelete'
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdOptionsDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsContactIdOptionsDeleteRequest(
        $contact_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdOptionsDelete'][0]
    ): Request
    {

        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdOptionsDelete'
            );
        }


        $resourcePath = '/rest/accounts/contacts/{contactId}/options';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdOptionsGet
     *
     * List contact options
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int|null $type_id The ID of the type (optional)
     * @param  int|null $sub_type_id The ID of the sub type (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdOptionsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ContactOption[]
     */
    public function restAccountsContactsContactIdOptionsGet(
        int $contact_id,
        ?int $type_id = null,
        ?int $sub_type_id = null,
        string $contentType = self::contentTypes['restAccountsContactsContactIdOptionsGet'][0]
    ): array
    {
        list($response) = $this->restAccountsContactsContactIdOptionsGetWithHttpInfo($contact_id, $type_id, $sub_type_id, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdOptionsGetWithHttpInfo
     *
     * List contact options
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int|null $type_id The ID of the type (optional)
     * @param  int|null $sub_type_id The ID of the sub type (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdOptionsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ContactOption[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdOptionsGetWithHttpInfo(
        int $contact_id,
        ?int $type_id = null,
        ?int $sub_type_id = null,
        string $contentType = self::contentTypes['restAccountsContactsContactIdOptionsGet'][0]
    ): array
    {
        $request = $this->restAccountsContactsContactIdOptionsGetRequest($contact_id, $type_id, $sub_type_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ContactOption[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ContactOption[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ContactOption[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ContactOption[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ContactOption[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdOptionsGetAsync
     *
     * List contact options
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int|null $type_id The ID of the type (optional)
     * @param  int|null $sub_type_id The ID of the sub type (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdOptionsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactIdOptionsGetAsync(
        int $contact_id,
        ?int $type_id = null,
        ?int $sub_type_id = null,
        string $contentType = self::contentTypes['restAccountsContactsContactIdOptionsGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsContactIdOptionsGetAsyncWithHttpInfo($contact_id, $type_id, $sub_type_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdOptionsGetAsyncWithHttpInfo
     *
     * List contact options
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int|null $type_id The ID of the type (optional)
     * @param  int|null $sub_type_id The ID of the sub type (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdOptionsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactIdOptionsGetAsyncWithHttpInfo(
        $contact_id,
        $type_id = null,
        $sub_type_id = null,
        string $contentType = self::contentTypes['restAccountsContactsContactIdOptionsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ContactOption[]';
        $request = $this->restAccountsContactsContactIdOptionsGetRequest($contact_id, $type_id, $sub_type_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdOptionsGet'
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int|null $type_id The ID of the type (optional)
     * @param  int|null $sub_type_id The ID of the sub type (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdOptionsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsContactIdOptionsGetRequest(
        $contact_id,
        $type_id = null,
        $sub_type_id = null,
        string $contentType = self::contentTypes['restAccountsContactsContactIdOptionsGet'][0]
    ): Request
    {

        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdOptionsGet'
            );
        }




        $resourcePath = '/rest/accounts/contacts/{contactId}/options';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type_id,
            'typeId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sub_type_id,
            'subTypeId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdOptionsPost
     *
     * Create contact option
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdOptionsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ContactOption[]
     */
    public function restAccountsContactsContactIdOptionsPost(
        int $contact_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdOptionsPost'][0]
    ): array
    {
        list($response) = $this->restAccountsContactsContactIdOptionsPostWithHttpInfo($contact_id, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdOptionsPostWithHttpInfo
     *
     * Create contact option
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdOptionsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ContactOption[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdOptionsPostWithHttpInfo(
        int $contact_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdOptionsPost'][0]
    ): array
    {
        $request = $this->restAccountsContactsContactIdOptionsPostRequest($contact_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ContactOption[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ContactOption[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ContactOption[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ContactOption[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ContactOption[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdOptionsPostAsync
     *
     * Create contact option
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdOptionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactIdOptionsPostAsync(
        int $contact_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdOptionsPost'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsContactIdOptionsPostAsyncWithHttpInfo($contact_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdOptionsPostAsyncWithHttpInfo
     *
     * Create contact option
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdOptionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactIdOptionsPostAsyncWithHttpInfo(
        $contact_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdOptionsPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ContactOption[]';
        $request = $this->restAccountsContactsContactIdOptionsPostRequest($contact_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdOptionsPost'
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdOptionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsContactIdOptionsPostRequest(
        $contact_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdOptionsPost'][0]
    ): Request
    {

        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdOptionsPost'
            );
        }


        $resourcePath = '/rest/accounts/contacts/{contactId}/options';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdOptionsPut
     *
     * Update contact option
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdOptionsPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ContactOption[]
     */
    public function restAccountsContactsContactIdOptionsPut(
        int $contact_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdOptionsPut'][0]
    ): array
    {
        list($response) = $this->restAccountsContactsContactIdOptionsPutWithHttpInfo($contact_id, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdOptionsPutWithHttpInfo
     *
     * Update contact option
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdOptionsPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ContactOption[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdOptionsPutWithHttpInfo(
        int $contact_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdOptionsPut'][0]
    ): array
    {
        $request = $this->restAccountsContactsContactIdOptionsPutRequest($contact_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ContactOption[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ContactOption[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ContactOption[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ContactOption[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ContactOption[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdOptionsPutAsync
     *
     * Update contact option
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdOptionsPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactIdOptionsPutAsync(
        int $contact_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdOptionsPut'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsContactIdOptionsPutAsyncWithHttpInfo($contact_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdOptionsPutAsyncWithHttpInfo
     *
     * Update contact option
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdOptionsPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactIdOptionsPutAsyncWithHttpInfo(
        $contact_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdOptionsPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ContactOption[]';
        $request = $this->restAccountsContactsContactIdOptionsPutRequest($contact_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdOptionsPut'
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdOptionsPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsContactIdOptionsPutRequest(
        $contact_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdOptionsPut'][0]
    ): Request
    {

        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdOptionsPut'
            );
        }


        $resourcePath = '/rest/accounts/contacts/{contactId}/options';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdOptionsValidateGet
     *
     * Validate contact option by given value
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdOptionsValidateGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restAccountsContactsContactIdOptionsValidateGet(
        int $contact_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdOptionsValidateGet'][0]
    ): object
    {
        list($response) = $this->restAccountsContactsContactIdOptionsValidateGetWithHttpInfo($contact_id, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdOptionsValidateGetWithHttpInfo
     *
     * Validate contact option by given value
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdOptionsValidateGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdOptionsValidateGetWithHttpInfo(
        int $contact_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdOptionsValidateGet'][0]
    ): array
    {
        $request = $this->restAccountsContactsContactIdOptionsValidateGetRequest($contact_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdOptionsValidateGetAsync
     *
     * Validate contact option by given value
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdOptionsValidateGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactIdOptionsValidateGetAsync(
        int $contact_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdOptionsValidateGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsContactIdOptionsValidateGetAsyncWithHttpInfo($contact_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdOptionsValidateGetAsyncWithHttpInfo
     *
     * Validate contact option by given value
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdOptionsValidateGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactIdOptionsValidateGetAsyncWithHttpInfo(
        $contact_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdOptionsValidateGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restAccountsContactsContactIdOptionsValidateGetRequest($contact_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdOptionsValidateGet'
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdOptionsValidateGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsContactIdOptionsValidateGetRequest(
        $contact_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdOptionsValidateGet'][0]
    ): Request
    {

        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdOptionsValidateGet'
            );
        }


        $resourcePath = '/rest/accounts/contacts/{contactId}/options/validate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdPut
     *
     * Update contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int|null $tag_relationships When this parameter is used, the current relations between contacts and tags will be deleted and replaced by the given ones. If the parameter is not used, the current relations remain. (optional)
     * @param  \ck\Model\RestAccountsContactsContactIdPutRequest|null $_rest_accounts_contacts_contact_id _rest_accounts_contacts_contact_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Contact
     */
    public function restAccountsContactsContactIdPut(
        int $contact_id,
        ?int $tag_relationships = null,
        ?\ck\Model\RestAccountsContactsContactIdPutRequest $_rest_accounts_contacts_contact_id = null,
        string $contentType = self::contentTypes['restAccountsContactsContactIdPut'][0]
    ): \ck\Model\Contact
    {
        list($response) = $this->restAccountsContactsContactIdPutWithHttpInfo($contact_id, $tag_relationships, $_rest_accounts_contacts_contact_id, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdPutWithHttpInfo
     *
     * Update contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int|null $tag_relationships When this parameter is used, the current relations between contacts and tags will be deleted and replaced by the given ones. If the parameter is not used, the current relations remain. (optional)
     * @param  \ck\Model\RestAccountsContactsContactIdPutRequest|null $_rest_accounts_contacts_contact_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Contact, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdPutWithHttpInfo(
        int $contact_id,
        ?int $tag_relationships = null,
        ?\ck\Model\RestAccountsContactsContactIdPutRequest $_rest_accounts_contacts_contact_id = null,
        string $contentType = self::contentTypes['restAccountsContactsContactIdPut'][0]
    ): array
    {
        $request = $this->restAccountsContactsContactIdPutRequest($contact_id, $tag_relationships, $_rest_accounts_contacts_contact_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Contact' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Contact' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Contact', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Contact';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Contact',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdPutAsync
     *
     * Update contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int|null $tag_relationships When this parameter is used, the current relations between contacts and tags will be deleted and replaced by the given ones. If the parameter is not used, the current relations remain. (optional)
     * @param  \ck\Model\RestAccountsContactsContactIdPutRequest|null $_rest_accounts_contacts_contact_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactIdPutAsync(
        int $contact_id,
        ?int $tag_relationships = null,
        ?\ck\Model\RestAccountsContactsContactIdPutRequest $_rest_accounts_contacts_contact_id = null,
        string $contentType = self::contentTypes['restAccountsContactsContactIdPut'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsContactIdPutAsyncWithHttpInfo($contact_id, $tag_relationships, $_rest_accounts_contacts_contact_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdPutAsyncWithHttpInfo
     *
     * Update contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int|null $tag_relationships When this parameter is used, the current relations between contacts and tags will be deleted and replaced by the given ones. If the parameter is not used, the current relations remain. (optional)
     * @param  \ck\Model\RestAccountsContactsContactIdPutRequest|null $_rest_accounts_contacts_contact_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactIdPutAsyncWithHttpInfo(
        $contact_id,
        $tag_relationships = null,
        $_rest_accounts_contacts_contact_id = null,
        string $contentType = self::contentTypes['restAccountsContactsContactIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Contact';
        $request = $this->restAccountsContactsContactIdPutRequest($contact_id, $tag_relationships, $_rest_accounts_contacts_contact_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdPut'
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  int|null $tag_relationships When this parameter is used, the current relations between contacts and tags will be deleted and replaced by the given ones. If the parameter is not used, the current relations remain. (optional)
     * @param  \ck\Model\RestAccountsContactsContactIdPutRequest|null $_rest_accounts_contacts_contact_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsContactIdPutRequest(
        $contact_id,
        $tag_relationships = null,
        $_rest_accounts_contacts_contact_id = null,
        string $contentType = self::contentTypes['restAccountsContactsContactIdPut'][0]
    ): Request
    {

        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdPut'
            );
        }




        $resourcePath = '/rest/accounts/contacts/{contactId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag_relationships,
            'tagRelationships', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_accounts_contacts_contact_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_accounts_contacts_contact_id));
            } else {
                $httpBody = $_rest_accounts_contacts_contact_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdRelatedDataGet
     *
     * List contact related data
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdRelatedDataGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Contact
     */
    public function restAccountsContactsContactIdRelatedDataGet(
        int $contact_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdRelatedDataGet'][0]
    ): \ck\Model\Contact
    {
        list($response) = $this->restAccountsContactsContactIdRelatedDataGetWithHttpInfo($contact_id, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdRelatedDataGetWithHttpInfo
     *
     * List contact related data
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdRelatedDataGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Contact, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdRelatedDataGetWithHttpInfo(
        int $contact_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdRelatedDataGet'][0]
    ): array
    {
        $request = $this->restAccountsContactsContactIdRelatedDataGetRequest($contact_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Contact' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Contact' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Contact', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Contact';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Contact',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdRelatedDataGetAsync
     *
     * List contact related data
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdRelatedDataGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactIdRelatedDataGetAsync(
        int $contact_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdRelatedDataGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsContactIdRelatedDataGetAsyncWithHttpInfo($contact_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdRelatedDataGetAsyncWithHttpInfo
     *
     * List contact related data
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdRelatedDataGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactIdRelatedDataGetAsyncWithHttpInfo(
        $contact_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdRelatedDataGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Contact';
        $request = $this->restAccountsContactsContactIdRelatedDataGetRequest($contact_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdRelatedDataGet'
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdRelatedDataGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsContactIdRelatedDataGetRequest(
        $contact_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdRelatedDataGet'][0]
    ): Request
    {

        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdRelatedDataGet'
            );
        }


        $resourcePath = '/rest/accounts/contacts/{contactId}/related_data';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdVcardGet
     *
     * Get vcard filestream of contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdVcardGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restAccountsContactsContactIdVcardGet(
        int $contact_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdVcardGet'][0]
    ): object
    {
        list($response) = $this->restAccountsContactsContactIdVcardGetWithHttpInfo($contact_id, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdVcardGetWithHttpInfo
     *
     * Get vcard filestream of contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdVcardGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdVcardGetWithHttpInfo(
        int $contact_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdVcardGet'][0]
    ): array
    {
        $request = $this->restAccountsContactsContactIdVcardGetRequest($contact_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdVcardGetAsync
     *
     * Get vcard filestream of contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdVcardGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactIdVcardGetAsync(
        int $contact_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdVcardGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsContactIdVcardGetAsyncWithHttpInfo($contact_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdVcardGetAsyncWithHttpInfo
     *
     * Get vcard filestream of contact
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdVcardGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsContactIdVcardGetAsyncWithHttpInfo(
        $contact_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdVcardGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restAccountsContactsContactIdVcardGetRequest($contact_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdVcardGet'
     *
     * @param  int $contact_id The ID of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsContactIdVcardGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsContactIdVcardGetRequest(
        $contact_id,
        string $contentType = self::contentTypes['restAccountsContactsContactIdVcardGet'][0]
    ): Request
    {

        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdVcardGet'
            );
        }


        $resourcePath = '/rest/accounts/contacts/{contactId}/vcard';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsDepartmentsDepartmentIdDelete
     *
     * Delete contact department
     *
     * @param  int $department_id The ID of the department (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsDepartmentsDepartmentIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restAccountsContactsDepartmentsDepartmentIdDelete(
        int $department_id,
        string $contentType = self::contentTypes['restAccountsContactsDepartmentsDepartmentIdDelete'][0]
    ): void
    {
        $this->restAccountsContactsDepartmentsDepartmentIdDeleteWithHttpInfo($department_id, $contentType);
    }

    /**
     * Operation restAccountsContactsDepartmentsDepartmentIdDeleteWithHttpInfo
     *
     * Delete contact department
     *
     * @param  int $department_id The ID of the department (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsDepartmentsDepartmentIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsDepartmentsDepartmentIdDeleteWithHttpInfo(
        int $department_id,
        string $contentType = self::contentTypes['restAccountsContactsDepartmentsDepartmentIdDelete'][0]
    ): array
    {
        $request = $this->restAccountsContactsDepartmentsDepartmentIdDeleteRequest($department_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsDepartmentsDepartmentIdDeleteAsync
     *
     * Delete contact department
     *
     * @param  int $department_id The ID of the department (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsDepartmentsDepartmentIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsDepartmentsDepartmentIdDeleteAsync(
        int $department_id,
        string $contentType = self::contentTypes['restAccountsContactsDepartmentsDepartmentIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsDepartmentsDepartmentIdDeleteAsyncWithHttpInfo($department_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsDepartmentsDepartmentIdDeleteAsyncWithHttpInfo
     *
     * Delete contact department
     *
     * @param  int $department_id The ID of the department (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsDepartmentsDepartmentIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsDepartmentsDepartmentIdDeleteAsyncWithHttpInfo(
        $department_id,
        string $contentType = self::contentTypes['restAccountsContactsDepartmentsDepartmentIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restAccountsContactsDepartmentsDepartmentIdDeleteRequest($department_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsDepartmentsDepartmentIdDelete'
     *
     * @param  int $department_id The ID of the department (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsDepartmentsDepartmentIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsDepartmentsDepartmentIdDeleteRequest(
        $department_id,
        string $contentType = self::contentTypes['restAccountsContactsDepartmentsDepartmentIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'department_id' is set
        if ($department_id === null || (is_array($department_id) && count($department_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $department_id when calling restAccountsContactsDepartmentsDepartmentIdDelete'
            );
        }


        $resourcePath = '/rest/accounts/contacts/departments/{departmentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($department_id !== null) {
            $resourcePath = str_replace(
                '{' . 'departmentId' . '}',
                ObjectSerializer::toPathValue($department_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsDepartmentsDepartmentIdGet
     *
     * Get contact department
     *
     * @param  int $department_id The ID of the department (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsDepartmentsDepartmentIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ContactDepartment
     */
    public function restAccountsContactsDepartmentsDepartmentIdGet(
        int $department_id,
        string $contentType = self::contentTypes['restAccountsContactsDepartmentsDepartmentIdGet'][0]
    ): \ck\Model\ContactDepartment
    {
        list($response) = $this->restAccountsContactsDepartmentsDepartmentIdGetWithHttpInfo($department_id, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsContactsDepartmentsDepartmentIdGetWithHttpInfo
     *
     * Get contact department
     *
     * @param  int $department_id The ID of the department (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsDepartmentsDepartmentIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ContactDepartment, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsDepartmentsDepartmentIdGetWithHttpInfo(
        int $department_id,
        string $contentType = self::contentTypes['restAccountsContactsDepartmentsDepartmentIdGet'][0]
    ): array
    {
        $request = $this->restAccountsContactsDepartmentsDepartmentIdGetRequest($department_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ContactDepartment' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ContactDepartment' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ContactDepartment', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ContactDepartment';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ContactDepartment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsDepartmentsDepartmentIdGetAsync
     *
     * Get contact department
     *
     * @param  int $department_id The ID of the department (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsDepartmentsDepartmentIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsDepartmentsDepartmentIdGetAsync(
        int $department_id,
        string $contentType = self::contentTypes['restAccountsContactsDepartmentsDepartmentIdGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsDepartmentsDepartmentIdGetAsyncWithHttpInfo($department_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsDepartmentsDepartmentIdGetAsyncWithHttpInfo
     *
     * Get contact department
     *
     * @param  int $department_id The ID of the department (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsDepartmentsDepartmentIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsDepartmentsDepartmentIdGetAsyncWithHttpInfo(
        $department_id,
        string $contentType = self::contentTypes['restAccountsContactsDepartmentsDepartmentIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ContactDepartment';
        $request = $this->restAccountsContactsDepartmentsDepartmentIdGetRequest($department_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsDepartmentsDepartmentIdGet'
     *
     * @param  int $department_id The ID of the department (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsDepartmentsDepartmentIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsDepartmentsDepartmentIdGetRequest(
        $department_id,
        string $contentType = self::contentTypes['restAccountsContactsDepartmentsDepartmentIdGet'][0]
    ): Request
    {

        // verify the required parameter 'department_id' is set
        if ($department_id === null || (is_array($department_id) && count($department_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $department_id when calling restAccountsContactsDepartmentsDepartmentIdGet'
            );
        }


        $resourcePath = '/rest/accounts/contacts/departments/{departmentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($department_id !== null) {
            $resourcePath = str_replace(
                '{' . 'departmentId' . '}',
                ObjectSerializer::toPathValue($department_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsDepartmentsDepartmentIdPut
     *
     * Update contact department
     *
     * @param  int $department_id The ID of the department (required)
     * @param  \ck\Model\RestAccountsContactsDepartmentsPostRequest|null $_rest_accounts_contacts_departments_department_id _rest_accounts_contacts_departments_department_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsDepartmentsDepartmentIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ContactDepartment
     */
    public function restAccountsContactsDepartmentsDepartmentIdPut(
        int $department_id,
        ?\ck\Model\RestAccountsContactsDepartmentsPostRequest $_rest_accounts_contacts_departments_department_id = null,
        string $contentType = self::contentTypes['restAccountsContactsDepartmentsDepartmentIdPut'][0]
    ): \ck\Model\ContactDepartment
    {
        list($response) = $this->restAccountsContactsDepartmentsDepartmentIdPutWithHttpInfo($department_id, $_rest_accounts_contacts_departments_department_id, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsContactsDepartmentsDepartmentIdPutWithHttpInfo
     *
     * Update contact department
     *
     * @param  int $department_id The ID of the department (required)
     * @param  \ck\Model\RestAccountsContactsDepartmentsPostRequest|null $_rest_accounts_contacts_departments_department_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsDepartmentsDepartmentIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ContactDepartment, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsDepartmentsDepartmentIdPutWithHttpInfo(
        int $department_id,
        ?\ck\Model\RestAccountsContactsDepartmentsPostRequest $_rest_accounts_contacts_departments_department_id = null,
        string $contentType = self::contentTypes['restAccountsContactsDepartmentsDepartmentIdPut'][0]
    ): array
    {
        $request = $this->restAccountsContactsDepartmentsDepartmentIdPutRequest($department_id, $_rest_accounts_contacts_departments_department_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ContactDepartment' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ContactDepartment' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ContactDepartment', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ContactDepartment';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ContactDepartment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsDepartmentsDepartmentIdPutAsync
     *
     * Update contact department
     *
     * @param  int $department_id The ID of the department (required)
     * @param  \ck\Model\RestAccountsContactsDepartmentsPostRequest|null $_rest_accounts_contacts_departments_department_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsDepartmentsDepartmentIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsDepartmentsDepartmentIdPutAsync(
        int $department_id,
        ?\ck\Model\RestAccountsContactsDepartmentsPostRequest $_rest_accounts_contacts_departments_department_id = null,
        string $contentType = self::contentTypes['restAccountsContactsDepartmentsDepartmentIdPut'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsDepartmentsDepartmentIdPutAsyncWithHttpInfo($department_id, $_rest_accounts_contacts_departments_department_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsDepartmentsDepartmentIdPutAsyncWithHttpInfo
     *
     * Update contact department
     *
     * @param  int $department_id The ID of the department (required)
     * @param  \ck\Model\RestAccountsContactsDepartmentsPostRequest|null $_rest_accounts_contacts_departments_department_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsDepartmentsDepartmentIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsDepartmentsDepartmentIdPutAsyncWithHttpInfo(
        $department_id,
        $_rest_accounts_contacts_departments_department_id = null,
        string $contentType = self::contentTypes['restAccountsContactsDepartmentsDepartmentIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ContactDepartment';
        $request = $this->restAccountsContactsDepartmentsDepartmentIdPutRequest($department_id, $_rest_accounts_contacts_departments_department_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsDepartmentsDepartmentIdPut'
     *
     * @param  int $department_id The ID of the department (required)
     * @param  \ck\Model\RestAccountsContactsDepartmentsPostRequest|null $_rest_accounts_contacts_departments_department_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsDepartmentsDepartmentIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsDepartmentsDepartmentIdPutRequest(
        $department_id,
        $_rest_accounts_contacts_departments_department_id = null,
        string $contentType = self::contentTypes['restAccountsContactsDepartmentsDepartmentIdPut'][0]
    ): Request
    {

        // verify the required parameter 'department_id' is set
        if ($department_id === null || (is_array($department_id) && count($department_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $department_id when calling restAccountsContactsDepartmentsDepartmentIdPut'
            );
        }



        $resourcePath = '/rest/accounts/contacts/departments/{departmentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($department_id !== null) {
            $resourcePath = str_replace(
                '{' . 'departmentId' . '}',
                ObjectSerializer::toPathValue($department_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_accounts_contacts_departments_department_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_accounts_contacts_departments_department_id));
            } else {
                $httpBody = $_rest_accounts_contacts_departments_department_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsDepartmentsGet
     *
     * List contact departments
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsDepartmentsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ContactDepartment[]
     */
    public function restAccountsContactsDepartmentsGet(
        string $contentType = self::contentTypes['restAccountsContactsDepartmentsGet'][0]
    ): array
    {
        list($response) = $this->restAccountsContactsDepartmentsGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restAccountsContactsDepartmentsGetWithHttpInfo
     *
     * List contact departments
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsDepartmentsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ContactDepartment[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsDepartmentsGetWithHttpInfo(
        string $contentType = self::contentTypes['restAccountsContactsDepartmentsGet'][0]
    ): array
    {
        $request = $this->restAccountsContactsDepartmentsGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ContactDepartment[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ContactDepartment[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ContactDepartment[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ContactDepartment[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ContactDepartment[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsDepartmentsGetAsync
     *
     * List contact departments
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsDepartmentsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsDepartmentsGetAsync(
        string $contentType = self::contentTypes['restAccountsContactsDepartmentsGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsDepartmentsGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsDepartmentsGetAsyncWithHttpInfo
     *
     * List contact departments
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsDepartmentsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsDepartmentsGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restAccountsContactsDepartmentsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ContactDepartment[]';
        $request = $this->restAccountsContactsDepartmentsGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsDepartmentsGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsDepartmentsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsDepartmentsGetRequest(
        string $contentType = self::contentTypes['restAccountsContactsDepartmentsGet'][0]
    ): Request
    {


        $resourcePath = '/rest/accounts/contacts/departments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsDepartmentsPost
     *
     * Create contact department
     *
     * @param  \ck\Model\RestAccountsContactsDepartmentsPostRequest|null $_rest_accounts_contacts_departments _rest_accounts_contacts_departments (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsDepartmentsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ContactDepartment
     */
    public function restAccountsContactsDepartmentsPost(
        ?\ck\Model\RestAccountsContactsDepartmentsPostRequest $_rest_accounts_contacts_departments = null,
        string $contentType = self::contentTypes['restAccountsContactsDepartmentsPost'][0]
    ): \ck\Model\ContactDepartment
    {
        list($response) = $this->restAccountsContactsDepartmentsPostWithHttpInfo($_rest_accounts_contacts_departments, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsContactsDepartmentsPostWithHttpInfo
     *
     * Create contact department
     *
     * @param  \ck\Model\RestAccountsContactsDepartmentsPostRequest|null $_rest_accounts_contacts_departments (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsDepartmentsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ContactDepartment, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsDepartmentsPostWithHttpInfo(
        ?\ck\Model\RestAccountsContactsDepartmentsPostRequest $_rest_accounts_contacts_departments = null,
        string $contentType = self::contentTypes['restAccountsContactsDepartmentsPost'][0]
    ): array
    {
        $request = $this->restAccountsContactsDepartmentsPostRequest($_rest_accounts_contacts_departments, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ContactDepartment' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ContactDepartment' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ContactDepartment', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ContactDepartment';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ContactDepartment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsDepartmentsPostAsync
     *
     * Create contact department
     *
     * @param  \ck\Model\RestAccountsContactsDepartmentsPostRequest|null $_rest_accounts_contacts_departments (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsDepartmentsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsDepartmentsPostAsync(
        ?\ck\Model\RestAccountsContactsDepartmentsPostRequest $_rest_accounts_contacts_departments = null,
        string $contentType = self::contentTypes['restAccountsContactsDepartmentsPost'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsDepartmentsPostAsyncWithHttpInfo($_rest_accounts_contacts_departments, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsDepartmentsPostAsyncWithHttpInfo
     *
     * Create contact department
     *
     * @param  \ck\Model\RestAccountsContactsDepartmentsPostRequest|null $_rest_accounts_contacts_departments (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsDepartmentsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsDepartmentsPostAsyncWithHttpInfo(
        $_rest_accounts_contacts_departments = null,
        string $contentType = self::contentTypes['restAccountsContactsDepartmentsPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ContactDepartment';
        $request = $this->restAccountsContactsDepartmentsPostRequest($_rest_accounts_contacts_departments, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsDepartmentsPost'
     *
     * @param  \ck\Model\RestAccountsContactsDepartmentsPostRequest|null $_rest_accounts_contacts_departments (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsDepartmentsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsDepartmentsPostRequest(
        $_rest_accounts_contacts_departments = null,
        string $contentType = self::contentTypes['restAccountsContactsDepartmentsPost'][0]
    ): Request
    {



        $resourcePath = '/rest/accounts/contacts/departments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_accounts_contacts_departments)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_accounts_contacts_departments));
            } else {
                $httpBody = $_rest_accounts_contacts_departments;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsGet
     *
     * List contacts
     *
     * @param  string|null $full_text Filter for a fulltext search (optional)
     * @param  string|null $contact_email Filter that restricts the search result to contacts resembling to the given email address (optional)
     * @param  string|null $email Filter that restricts the search result to contacts with a specific email address (optional)
     * @param  string|null $postal_code Filter that restricts the search result to contacts with a specific postcode (optional)
     * @param  int|null $plenty_id Filter that restricts the search result to contacts with a specific plentyId (optional)
     * @param  int|null $external_id Filter that restricts the search result to contacts with a specific externalId (optional)
     * @param  int|null $number Filter that restricts the search result to contacts with a specific number (optional)
     * @param  int|null $type_id Filter that restricts the search result to contacts with a specific contact type (optional)
     * @param  int|null $rating Filter that restricts the search result to contacts with a specific rating (optional)
     * @param  string|null $created_at_before Filter that restricts the search result to contacts that were created before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $created_at_after Filter that restricts the search result to contacts that were created after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $updated_at_before Filter that restricts the search result to contacts that were updated before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $updated_at_after Filter that restricts the search result to contacts that were updated after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $last_order_at_before Filter that restricts the search result to contacts whose last order was created before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $last_order_at_after Filter that restricts the search result to contacts whose last order was created after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $with Includes the specified contact information in the results. The following parameters are available: addresses, accounts, options, orderSummary, primaryBillingAddress, contactOrders. More than one parameter should be separated by commas. (optional)
     * @param  int|null $page The page of results to search for (optional)
     * @param  int|null $items_per_page The number of items to list per page (optional)
     * @param  string|null $newsletter_allowance_after Filter that restricts the search result to contacts who registered for the newsletter after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $newsletter_allowance_before Filter that restricts the search result to contacts who registered for the newsletter before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $newsletter_allowance Filter that restricts the search result to contacts who registered for the newsletter. Possible values: &#39;true&#39; and &#39;false&#39;. True: newsletter registration was successful. False: newsletter registration was not successful. (optional)
     * @param  int|null $contact_id Filter that restricts the search result to a specific contact (optional)
     * @param  string|null $contact_address Filter that restricts the search result to contacts with a specific address (optional)
     * @param  string|null $country_id Filter that restricts the search result to contacts with a specific country (optional)
     * @param  string|null $user_id Filter that restricts the search result to contacts with a specific user (optional)
     * @param  string|null $referrer_id Filter that restricts the search result to contacts with a specific referrer (optional)
     * @param  string|null $name Filter that restricts the search result to contacts with a specific name (optional)
     * @param  string|null $name_or_id Filter that restricts the search result to contacts with a specific name or ID. (optional)
     * @param  string|null $town Filter that restricts the search result to contacts with a specific town (optional)
     * @param  string|null $private_phone Filter that restricts the search result to contacts with a private phone number (optional)
     * @param  string|null $billing_address_id Filter that restricts the search result to contacts with a billing address with the ID provided (optional)
     * @param  string|null $delivery_address_id Filter that restricts the search result to contacts with a delivery address with the ID provided (optional)
     * @param  int|null $tag_ids Filter restricts the list of results to contacts with the specified tagIds. More than one ID should be separated by commas. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\RestAccountsContactsGet200Response
     */
    public function restAccountsContactsGet(
        ?string $full_text = null,
        ?string $contact_email = null,
        ?string $email = null,
        ?string $postal_code = null,
        ?int $plenty_id = null,
        ?int $external_id = null,
        ?int $number = null,
        ?int $type_id = null,
        ?int $rating = null,
        ?string $created_at_before = null,
        ?string $created_at_after = null,
        ?string $updated_at_before = null,
        ?string $updated_at_after = null,
        ?string $last_order_at_before = null,
        ?string $last_order_at_after = null,
        ?string $with = null,
        ?int $page = null,
        ?int $items_per_page = null,
        ?string $newsletter_allowance_after = null,
        ?string $newsletter_allowance_before = null,
        ?string $newsletter_allowance = null,
        ?int $contact_id = null,
        ?string $contact_address = null,
        ?string $country_id = null,
        ?string $user_id = null,
        ?string $referrer_id = null,
        ?string $name = null,
        ?string $name_or_id = null,
        ?string $town = null,
        ?string $private_phone = null,
        ?string $billing_address_id = null,
        ?string $delivery_address_id = null,
        ?int $tag_ids = null,
        string $contentType = self::contentTypes['restAccountsContactsGet'][0]
    ): \ck\Model\RestAccountsContactsGet200Response
    {
        list($response) = $this->restAccountsContactsGetWithHttpInfo($full_text, $contact_email, $email, $postal_code, $plenty_id, $external_id, $number, $type_id, $rating, $created_at_before, $created_at_after, $updated_at_before, $updated_at_after, $last_order_at_before, $last_order_at_after, $with, $page, $items_per_page, $newsletter_allowance_after, $newsletter_allowance_before, $newsletter_allowance, $contact_id, $contact_address, $country_id, $user_id, $referrer_id, $name, $name_or_id, $town, $private_phone, $billing_address_id, $delivery_address_id, $tag_ids, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsContactsGetWithHttpInfo
     *
     * List contacts
     *
     * @param  string|null $full_text Filter for a fulltext search (optional)
     * @param  string|null $contact_email Filter that restricts the search result to contacts resembling to the given email address (optional)
     * @param  string|null $email Filter that restricts the search result to contacts with a specific email address (optional)
     * @param  string|null $postal_code Filter that restricts the search result to contacts with a specific postcode (optional)
     * @param  int|null $plenty_id Filter that restricts the search result to contacts with a specific plentyId (optional)
     * @param  int|null $external_id Filter that restricts the search result to contacts with a specific externalId (optional)
     * @param  int|null $number Filter that restricts the search result to contacts with a specific number (optional)
     * @param  int|null $type_id Filter that restricts the search result to contacts with a specific contact type (optional)
     * @param  int|null $rating Filter that restricts the search result to contacts with a specific rating (optional)
     * @param  string|null $created_at_before Filter that restricts the search result to contacts that were created before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $created_at_after Filter that restricts the search result to contacts that were created after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $updated_at_before Filter that restricts the search result to contacts that were updated before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $updated_at_after Filter that restricts the search result to contacts that were updated after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $last_order_at_before Filter that restricts the search result to contacts whose last order was created before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $last_order_at_after Filter that restricts the search result to contacts whose last order was created after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $with Includes the specified contact information in the results. The following parameters are available: addresses, accounts, options, orderSummary, primaryBillingAddress, contactOrders. More than one parameter should be separated by commas. (optional)
     * @param  int|null $page The page of results to search for (optional)
     * @param  int|null $items_per_page The number of items to list per page (optional)
     * @param  string|null $newsletter_allowance_after Filter that restricts the search result to contacts who registered for the newsletter after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $newsletter_allowance_before Filter that restricts the search result to contacts who registered for the newsletter before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $newsletter_allowance Filter that restricts the search result to contacts who registered for the newsletter. Possible values: &#39;true&#39; and &#39;false&#39;. True: newsletter registration was successful. False: newsletter registration was not successful. (optional)
     * @param  int|null $contact_id Filter that restricts the search result to a specific contact (optional)
     * @param  string|null $contact_address Filter that restricts the search result to contacts with a specific address (optional)
     * @param  string|null $country_id Filter that restricts the search result to contacts with a specific country (optional)
     * @param  string|null $user_id Filter that restricts the search result to contacts with a specific user (optional)
     * @param  string|null $referrer_id Filter that restricts the search result to contacts with a specific referrer (optional)
     * @param  string|null $name Filter that restricts the search result to contacts with a specific name (optional)
     * @param  string|null $name_or_id Filter that restricts the search result to contacts with a specific name or ID. (optional)
     * @param  string|null $town Filter that restricts the search result to contacts with a specific town (optional)
     * @param  string|null $private_phone Filter that restricts the search result to contacts with a private phone number (optional)
     * @param  string|null $billing_address_id Filter that restricts the search result to contacts with a billing address with the ID provided (optional)
     * @param  string|null $delivery_address_id Filter that restricts the search result to contacts with a delivery address with the ID provided (optional)
     * @param  int|null $tag_ids Filter restricts the list of results to contacts with the specified tagIds. More than one ID should be separated by commas. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\RestAccountsContactsGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsGetWithHttpInfo(
        ?string $full_text = null,
        ?string $contact_email = null,
        ?string $email = null,
        ?string $postal_code = null,
        ?int $plenty_id = null,
        ?int $external_id = null,
        ?int $number = null,
        ?int $type_id = null,
        ?int $rating = null,
        ?string $created_at_before = null,
        ?string $created_at_after = null,
        ?string $updated_at_before = null,
        ?string $updated_at_after = null,
        ?string $last_order_at_before = null,
        ?string $last_order_at_after = null,
        ?string $with = null,
        ?int $page = null,
        ?int $items_per_page = null,
        ?string $newsletter_allowance_after = null,
        ?string $newsletter_allowance_before = null,
        ?string $newsletter_allowance = null,
        ?int $contact_id = null,
        ?string $contact_address = null,
        ?string $country_id = null,
        ?string $user_id = null,
        ?string $referrer_id = null,
        ?string $name = null,
        ?string $name_or_id = null,
        ?string $town = null,
        ?string $private_phone = null,
        ?string $billing_address_id = null,
        ?string $delivery_address_id = null,
        ?int $tag_ids = null,
        string $contentType = self::contentTypes['restAccountsContactsGet'][0]
    ): array
    {
        $request = $this->restAccountsContactsGetRequest($full_text, $contact_email, $email, $postal_code, $plenty_id, $external_id, $number, $type_id, $rating, $created_at_before, $created_at_after, $updated_at_before, $updated_at_after, $last_order_at_before, $last_order_at_after, $with, $page, $items_per_page, $newsletter_allowance_after, $newsletter_allowance_before, $newsletter_allowance, $contact_id, $contact_address, $country_id, $user_id, $referrer_id, $name, $name_or_id, $town, $private_phone, $billing_address_id, $delivery_address_id, $tag_ids, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\RestAccountsContactsGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\RestAccountsContactsGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\RestAccountsContactsGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\RestAccountsContactsGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\RestAccountsContactsGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsGetAsync
     *
     * List contacts
     *
     * @param  string|null $full_text Filter for a fulltext search (optional)
     * @param  string|null $contact_email Filter that restricts the search result to contacts resembling to the given email address (optional)
     * @param  string|null $email Filter that restricts the search result to contacts with a specific email address (optional)
     * @param  string|null $postal_code Filter that restricts the search result to contacts with a specific postcode (optional)
     * @param  int|null $plenty_id Filter that restricts the search result to contacts with a specific plentyId (optional)
     * @param  int|null $external_id Filter that restricts the search result to contacts with a specific externalId (optional)
     * @param  int|null $number Filter that restricts the search result to contacts with a specific number (optional)
     * @param  int|null $type_id Filter that restricts the search result to contacts with a specific contact type (optional)
     * @param  int|null $rating Filter that restricts the search result to contacts with a specific rating (optional)
     * @param  string|null $created_at_before Filter that restricts the search result to contacts that were created before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $created_at_after Filter that restricts the search result to contacts that were created after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $updated_at_before Filter that restricts the search result to contacts that were updated before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $updated_at_after Filter that restricts the search result to contacts that were updated after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $last_order_at_before Filter that restricts the search result to contacts whose last order was created before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $last_order_at_after Filter that restricts the search result to contacts whose last order was created after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $with Includes the specified contact information in the results. The following parameters are available: addresses, accounts, options, orderSummary, primaryBillingAddress, contactOrders. More than one parameter should be separated by commas. (optional)
     * @param  int|null $page The page of results to search for (optional)
     * @param  int|null $items_per_page The number of items to list per page (optional)
     * @param  string|null $newsletter_allowance_after Filter that restricts the search result to contacts who registered for the newsletter after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $newsletter_allowance_before Filter that restricts the search result to contacts who registered for the newsletter before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $newsletter_allowance Filter that restricts the search result to contacts who registered for the newsletter. Possible values: &#39;true&#39; and &#39;false&#39;. True: newsletter registration was successful. False: newsletter registration was not successful. (optional)
     * @param  int|null $contact_id Filter that restricts the search result to a specific contact (optional)
     * @param  string|null $contact_address Filter that restricts the search result to contacts with a specific address (optional)
     * @param  string|null $country_id Filter that restricts the search result to contacts with a specific country (optional)
     * @param  string|null $user_id Filter that restricts the search result to contacts with a specific user (optional)
     * @param  string|null $referrer_id Filter that restricts the search result to contacts with a specific referrer (optional)
     * @param  string|null $name Filter that restricts the search result to contacts with a specific name (optional)
     * @param  string|null $name_or_id Filter that restricts the search result to contacts with a specific name or ID. (optional)
     * @param  string|null $town Filter that restricts the search result to contacts with a specific town (optional)
     * @param  string|null $private_phone Filter that restricts the search result to contacts with a private phone number (optional)
     * @param  string|null $billing_address_id Filter that restricts the search result to contacts with a billing address with the ID provided (optional)
     * @param  string|null $delivery_address_id Filter that restricts the search result to contacts with a delivery address with the ID provided (optional)
     * @param  int|null $tag_ids Filter restricts the list of results to contacts with the specified tagIds. More than one ID should be separated by commas. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsGetAsync(
        ?string $full_text = null,
        ?string $contact_email = null,
        ?string $email = null,
        ?string $postal_code = null,
        ?int $plenty_id = null,
        ?int $external_id = null,
        ?int $number = null,
        ?int $type_id = null,
        ?int $rating = null,
        ?string $created_at_before = null,
        ?string $created_at_after = null,
        ?string $updated_at_before = null,
        ?string $updated_at_after = null,
        ?string $last_order_at_before = null,
        ?string $last_order_at_after = null,
        ?string $with = null,
        ?int $page = null,
        ?int $items_per_page = null,
        ?string $newsletter_allowance_after = null,
        ?string $newsletter_allowance_before = null,
        ?string $newsletter_allowance = null,
        ?int $contact_id = null,
        ?string $contact_address = null,
        ?string $country_id = null,
        ?string $user_id = null,
        ?string $referrer_id = null,
        ?string $name = null,
        ?string $name_or_id = null,
        ?string $town = null,
        ?string $private_phone = null,
        ?string $billing_address_id = null,
        ?string $delivery_address_id = null,
        ?int $tag_ids = null,
        string $contentType = self::contentTypes['restAccountsContactsGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsGetAsyncWithHttpInfo($full_text, $contact_email, $email, $postal_code, $plenty_id, $external_id, $number, $type_id, $rating, $created_at_before, $created_at_after, $updated_at_before, $updated_at_after, $last_order_at_before, $last_order_at_after, $with, $page, $items_per_page, $newsletter_allowance_after, $newsletter_allowance_before, $newsletter_allowance, $contact_id, $contact_address, $country_id, $user_id, $referrer_id, $name, $name_or_id, $town, $private_phone, $billing_address_id, $delivery_address_id, $tag_ids, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsGetAsyncWithHttpInfo
     *
     * List contacts
     *
     * @param  string|null $full_text Filter for a fulltext search (optional)
     * @param  string|null $contact_email Filter that restricts the search result to contacts resembling to the given email address (optional)
     * @param  string|null $email Filter that restricts the search result to contacts with a specific email address (optional)
     * @param  string|null $postal_code Filter that restricts the search result to contacts with a specific postcode (optional)
     * @param  int|null $plenty_id Filter that restricts the search result to contacts with a specific plentyId (optional)
     * @param  int|null $external_id Filter that restricts the search result to contacts with a specific externalId (optional)
     * @param  int|null $number Filter that restricts the search result to contacts with a specific number (optional)
     * @param  int|null $type_id Filter that restricts the search result to contacts with a specific contact type (optional)
     * @param  int|null $rating Filter that restricts the search result to contacts with a specific rating (optional)
     * @param  string|null $created_at_before Filter that restricts the search result to contacts that were created before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $created_at_after Filter that restricts the search result to contacts that were created after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $updated_at_before Filter that restricts the search result to contacts that were updated before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $updated_at_after Filter that restricts the search result to contacts that were updated after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $last_order_at_before Filter that restricts the search result to contacts whose last order was created before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $last_order_at_after Filter that restricts the search result to contacts whose last order was created after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $with Includes the specified contact information in the results. The following parameters are available: addresses, accounts, options, orderSummary, primaryBillingAddress, contactOrders. More than one parameter should be separated by commas. (optional)
     * @param  int|null $page The page of results to search for (optional)
     * @param  int|null $items_per_page The number of items to list per page (optional)
     * @param  string|null $newsletter_allowance_after Filter that restricts the search result to contacts who registered for the newsletter after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $newsletter_allowance_before Filter that restricts the search result to contacts who registered for the newsletter before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $newsletter_allowance Filter that restricts the search result to contacts who registered for the newsletter. Possible values: &#39;true&#39; and &#39;false&#39;. True: newsletter registration was successful. False: newsletter registration was not successful. (optional)
     * @param  int|null $contact_id Filter that restricts the search result to a specific contact (optional)
     * @param  string|null $contact_address Filter that restricts the search result to contacts with a specific address (optional)
     * @param  string|null $country_id Filter that restricts the search result to contacts with a specific country (optional)
     * @param  string|null $user_id Filter that restricts the search result to contacts with a specific user (optional)
     * @param  string|null $referrer_id Filter that restricts the search result to contacts with a specific referrer (optional)
     * @param  string|null $name Filter that restricts the search result to contacts with a specific name (optional)
     * @param  string|null $name_or_id Filter that restricts the search result to contacts with a specific name or ID. (optional)
     * @param  string|null $town Filter that restricts the search result to contacts with a specific town (optional)
     * @param  string|null $private_phone Filter that restricts the search result to contacts with a private phone number (optional)
     * @param  string|null $billing_address_id Filter that restricts the search result to contacts with a billing address with the ID provided (optional)
     * @param  string|null $delivery_address_id Filter that restricts the search result to contacts with a delivery address with the ID provided (optional)
     * @param  int|null $tag_ids Filter restricts the list of results to contacts with the specified tagIds. More than one ID should be separated by commas. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsGetAsyncWithHttpInfo(
        $full_text = null,
        $contact_email = null,
        $email = null,
        $postal_code = null,
        $plenty_id = null,
        $external_id = null,
        $number = null,
        $type_id = null,
        $rating = null,
        $created_at_before = null,
        $created_at_after = null,
        $updated_at_before = null,
        $updated_at_after = null,
        $last_order_at_before = null,
        $last_order_at_after = null,
        $with = null,
        $page = null,
        $items_per_page = null,
        $newsletter_allowance_after = null,
        $newsletter_allowance_before = null,
        $newsletter_allowance = null,
        $contact_id = null,
        $contact_address = null,
        $country_id = null,
        $user_id = null,
        $referrer_id = null,
        $name = null,
        $name_or_id = null,
        $town = null,
        $private_phone = null,
        $billing_address_id = null,
        $delivery_address_id = null,
        $tag_ids = null,
        string $contentType = self::contentTypes['restAccountsContactsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\RestAccountsContactsGet200Response';
        $request = $this->restAccountsContactsGetRequest($full_text, $contact_email, $email, $postal_code, $plenty_id, $external_id, $number, $type_id, $rating, $created_at_before, $created_at_after, $updated_at_before, $updated_at_after, $last_order_at_before, $last_order_at_after, $with, $page, $items_per_page, $newsletter_allowance_after, $newsletter_allowance_before, $newsletter_allowance, $contact_id, $contact_address, $country_id, $user_id, $referrer_id, $name, $name_or_id, $town, $private_phone, $billing_address_id, $delivery_address_id, $tag_ids, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsGet'
     *
     * @param  string|null $full_text Filter for a fulltext search (optional)
     * @param  string|null $contact_email Filter that restricts the search result to contacts resembling to the given email address (optional)
     * @param  string|null $email Filter that restricts the search result to contacts with a specific email address (optional)
     * @param  string|null $postal_code Filter that restricts the search result to contacts with a specific postcode (optional)
     * @param  int|null $plenty_id Filter that restricts the search result to contacts with a specific plentyId (optional)
     * @param  int|null $external_id Filter that restricts the search result to contacts with a specific externalId (optional)
     * @param  int|null $number Filter that restricts the search result to contacts with a specific number (optional)
     * @param  int|null $type_id Filter that restricts the search result to contacts with a specific contact type (optional)
     * @param  int|null $rating Filter that restricts the search result to contacts with a specific rating (optional)
     * @param  string|null $created_at_before Filter that restricts the search result to contacts that were created before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $created_at_after Filter that restricts the search result to contacts that were created after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $updated_at_before Filter that restricts the search result to contacts that were updated before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $updated_at_after Filter that restricts the search result to contacts that were updated after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $last_order_at_before Filter that restricts the search result to contacts whose last order was created before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $last_order_at_after Filter that restricts the search result to contacts whose last order was created after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $with Includes the specified contact information in the results. The following parameters are available: addresses, accounts, options, orderSummary, primaryBillingAddress, contactOrders. More than one parameter should be separated by commas. (optional)
     * @param  int|null $page The page of results to search for (optional)
     * @param  int|null $items_per_page The number of items to list per page (optional)
     * @param  string|null $newsletter_allowance_after Filter that restricts the search result to contacts who registered for the newsletter after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $newsletter_allowance_before Filter that restricts the search result to contacts who registered for the newsletter before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string|null $newsletter_allowance Filter that restricts the search result to contacts who registered for the newsletter. Possible values: &#39;true&#39; and &#39;false&#39;. True: newsletter registration was successful. False: newsletter registration was not successful. (optional)
     * @param  int|null $contact_id Filter that restricts the search result to a specific contact (optional)
     * @param  string|null $contact_address Filter that restricts the search result to contacts with a specific address (optional)
     * @param  string|null $country_id Filter that restricts the search result to contacts with a specific country (optional)
     * @param  string|null $user_id Filter that restricts the search result to contacts with a specific user (optional)
     * @param  string|null $referrer_id Filter that restricts the search result to contacts with a specific referrer (optional)
     * @param  string|null $name Filter that restricts the search result to contacts with a specific name (optional)
     * @param  string|null $name_or_id Filter that restricts the search result to contacts with a specific name or ID. (optional)
     * @param  string|null $town Filter that restricts the search result to contacts with a specific town (optional)
     * @param  string|null $private_phone Filter that restricts the search result to contacts with a private phone number (optional)
     * @param  string|null $billing_address_id Filter that restricts the search result to contacts with a billing address with the ID provided (optional)
     * @param  string|null $delivery_address_id Filter that restricts the search result to contacts with a delivery address with the ID provided (optional)
     * @param  int|null $tag_ids Filter restricts the list of results to contacts with the specified tagIds. More than one ID should be separated by commas. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsGetRequest(
        $full_text = null,
        $contact_email = null,
        $email = null,
        $postal_code = null,
        $plenty_id = null,
        $external_id = null,
        $number = null,
        $type_id = null,
        $rating = null,
        $created_at_before = null,
        $created_at_after = null,
        $updated_at_before = null,
        $updated_at_after = null,
        $last_order_at_before = null,
        $last_order_at_after = null,
        $with = null,
        $page = null,
        $items_per_page = null,
        $newsletter_allowance_after = null,
        $newsletter_allowance_before = null,
        $newsletter_allowance = null,
        $contact_id = null,
        $contact_address = null,
        $country_id = null,
        $user_id = null,
        $referrer_id = null,
        $name = null,
        $name_or_id = null,
        $town = null,
        $private_phone = null,
        $billing_address_id = null,
        $delivery_address_id = null,
        $tag_ids = null,
        string $contentType = self::contentTypes['restAccountsContactsGet'][0]
    ): Request
    {



































        $resourcePath = '/rest/accounts/contacts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $full_text,
            'fullText', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $contact_email,
            'contactEmail', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $email,
            'email', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $postal_code,
            'postalCode', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $plenty_id,
            'plentyId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $external_id,
            'externalId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $number,
            'number', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type_id,
            'typeId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rating,
            'rating', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_at_before,
            'createdAtBefore', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_at_after,
            'createdAtAfter', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_at_before,
            'updatedAtBefore', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_at_after,
            'updatedAtAfter', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_order_at_before,
            'lastOrderAtBefore', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_order_at_after,
            'lastOrderAtAfter', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $items_per_page,
            'itemsPerPage', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $newsletter_allowance_after,
            'newsletterAllowanceAfter', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $newsletter_allowance_before,
            'newsletterAllowanceBefore', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $newsletter_allowance,
            'newsletterAllowance', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $contact_id,
            'contactId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $contact_address,
            'contactAddress', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $country_id,
            'countryId', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_id,
            'userId', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $referrer_id,
            'referrerId', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name_or_id,
            'nameOrId', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $town,
            'town', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $private_phone,
            'privatePhone', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $billing_address_id,
            'billingAddressId', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $delivery_address_id,
            'deliveryAddressId', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag_ids,
            'tagIds', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsGroupFunctionsGet
     *
     * List all group function related data
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsGroupFunctionsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restAccountsContactsGroupFunctionsGet(
        string $contentType = self::contentTypes['restAccountsContactsGroupFunctionsGet'][0]
    ): object
    {
        list($response) = $this->restAccountsContactsGroupFunctionsGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restAccountsContactsGroupFunctionsGetWithHttpInfo
     *
     * List all group function related data
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsGroupFunctionsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsGroupFunctionsGetWithHttpInfo(
        string $contentType = self::contentTypes['restAccountsContactsGroupFunctionsGet'][0]
    ): array
    {
        $request = $this->restAccountsContactsGroupFunctionsGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsGroupFunctionsGetAsync
     *
     * List all group function related data
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsGroupFunctionsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsGroupFunctionsGetAsync(
        string $contentType = self::contentTypes['restAccountsContactsGroupFunctionsGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsGroupFunctionsGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsGroupFunctionsGetAsyncWithHttpInfo
     *
     * List all group function related data
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsGroupFunctionsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsGroupFunctionsGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restAccountsContactsGroupFunctionsGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restAccountsContactsGroupFunctionsGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsGroupFunctionsGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsGroupFunctionsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsGroupFunctionsGetRequest(
        string $contentType = self::contentTypes['restAccountsContactsGroupFunctionsGet'][0]
    ): Request
    {


        $resourcePath = '/rest/accounts/contacts/group_functions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsGroupFunctionsPost
     *
     * Apply selected group function options for given contact IDs
     *
     * @param  int|null $contact_list A list of contact IDs (optional)
     * @param  int|null $email_template An email template ID (optional)
     * @param  int|null $newsletter A newsletter folder ID (optional)
     * @param  int|null $address_label_template An address label template ID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsGroupFunctionsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restAccountsContactsGroupFunctionsPost(
        ?int $contact_list = null,
        ?int $email_template = null,
        ?int $newsletter = null,
        ?int $address_label_template = null,
        string $contentType = self::contentTypes['restAccountsContactsGroupFunctionsPost'][0]
    ): object
    {
        list($response) = $this->restAccountsContactsGroupFunctionsPostWithHttpInfo($contact_list, $email_template, $newsletter, $address_label_template, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsContactsGroupFunctionsPostWithHttpInfo
     *
     * Apply selected group function options for given contact IDs
     *
     * @param  int|null $contact_list A list of contact IDs (optional)
     * @param  int|null $email_template An email template ID (optional)
     * @param  int|null $newsletter A newsletter folder ID (optional)
     * @param  int|null $address_label_template An address label template ID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsGroupFunctionsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsGroupFunctionsPostWithHttpInfo(
        ?int $contact_list = null,
        ?int $email_template = null,
        ?int $newsletter = null,
        ?int $address_label_template = null,
        string $contentType = self::contentTypes['restAccountsContactsGroupFunctionsPost'][0]
    ): array
    {
        $request = $this->restAccountsContactsGroupFunctionsPostRequest($contact_list, $email_template, $newsletter, $address_label_template, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsGroupFunctionsPostAsync
     *
     * Apply selected group function options for given contact IDs
     *
     * @param  int|null $contact_list A list of contact IDs (optional)
     * @param  int|null $email_template An email template ID (optional)
     * @param  int|null $newsletter A newsletter folder ID (optional)
     * @param  int|null $address_label_template An address label template ID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsGroupFunctionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsGroupFunctionsPostAsync(
        ?int $contact_list = null,
        ?int $email_template = null,
        ?int $newsletter = null,
        ?int $address_label_template = null,
        string $contentType = self::contentTypes['restAccountsContactsGroupFunctionsPost'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsGroupFunctionsPostAsyncWithHttpInfo($contact_list, $email_template, $newsletter, $address_label_template, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsGroupFunctionsPostAsyncWithHttpInfo
     *
     * Apply selected group function options for given contact IDs
     *
     * @param  int|null $contact_list A list of contact IDs (optional)
     * @param  int|null $email_template An email template ID (optional)
     * @param  int|null $newsletter A newsletter folder ID (optional)
     * @param  int|null $address_label_template An address label template ID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsGroupFunctionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsGroupFunctionsPostAsyncWithHttpInfo(
        $contact_list = null,
        $email_template = null,
        $newsletter = null,
        $address_label_template = null,
        string $contentType = self::contentTypes['restAccountsContactsGroupFunctionsPost'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restAccountsContactsGroupFunctionsPostRequest($contact_list, $email_template, $newsletter, $address_label_template, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsGroupFunctionsPost'
     *
     * @param  int|null $contact_list A list of contact IDs (optional)
     * @param  int|null $email_template An email template ID (optional)
     * @param  int|null $newsletter A newsletter folder ID (optional)
     * @param  int|null $address_label_template An address label template ID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsGroupFunctionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsGroupFunctionsPostRequest(
        $contact_list = null,
        $email_template = null,
        $newsletter = null,
        $address_label_template = null,
        string $contentType = self::contentTypes['restAccountsContactsGroupFunctionsPost'][0]
    ): Request
    {






        $resourcePath = '/rest/accounts/contacts/group_functions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $contact_list,
            'contactList', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $email_template,
            'emailTemplate', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $newsletter,
            'newsletter', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $address_label_template,
            'addressLabelTemplate', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsOptionSubTypesGet
     *
     * List contact option sub-types
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionSubTypesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ContactOptionSubType[]
     */
    public function restAccountsContactsOptionSubTypesGet(
        string $contentType = self::contentTypes['restAccountsContactsOptionSubTypesGet'][0]
    ): array
    {
        list($response) = $this->restAccountsContactsOptionSubTypesGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restAccountsContactsOptionSubTypesGetWithHttpInfo
     *
     * List contact option sub-types
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionSubTypesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ContactOptionSubType[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsOptionSubTypesGetWithHttpInfo(
        string $contentType = self::contentTypes['restAccountsContactsOptionSubTypesGet'][0]
    ): array
    {
        $request = $this->restAccountsContactsOptionSubTypesGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ContactOptionSubType[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ContactOptionSubType[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ContactOptionSubType[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ContactOptionSubType[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ContactOptionSubType[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsOptionSubTypesGetAsync
     *
     * List contact option sub-types
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionSubTypesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsOptionSubTypesGetAsync(
        string $contentType = self::contentTypes['restAccountsContactsOptionSubTypesGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsOptionSubTypesGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsOptionSubTypesGetAsyncWithHttpInfo
     *
     * List contact option sub-types
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionSubTypesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsOptionSubTypesGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restAccountsContactsOptionSubTypesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ContactOptionSubType[]';
        $request = $this->restAccountsContactsOptionSubTypesGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsOptionSubTypesGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionSubTypesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsOptionSubTypesGetRequest(
        string $contentType = self::contentTypes['restAccountsContactsOptionSubTypesGet'][0]
    ): Request
    {


        $resourcePath = '/rest/accounts/contacts/option_sub_types';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsOptionSubTypesOptionSubTypeIdDelete
     *
     * Delete contact option sub-type
     *
     * @param  int $option_sub_type_id The ID of the contact option sub-type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionSubTypesOptionSubTypeIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restAccountsContactsOptionSubTypesOptionSubTypeIdDelete(
        int $option_sub_type_id,
        string $contentType = self::contentTypes['restAccountsContactsOptionSubTypesOptionSubTypeIdDelete'][0]
    ): void
    {
        $this->restAccountsContactsOptionSubTypesOptionSubTypeIdDeleteWithHttpInfo($option_sub_type_id, $contentType);
    }

    /**
     * Operation restAccountsContactsOptionSubTypesOptionSubTypeIdDeleteWithHttpInfo
     *
     * Delete contact option sub-type
     *
     * @param  int $option_sub_type_id The ID of the contact option sub-type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionSubTypesOptionSubTypeIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsOptionSubTypesOptionSubTypeIdDeleteWithHttpInfo(
        int $option_sub_type_id,
        string $contentType = self::contentTypes['restAccountsContactsOptionSubTypesOptionSubTypeIdDelete'][0]
    ): array
    {
        $request = $this->restAccountsContactsOptionSubTypesOptionSubTypeIdDeleteRequest($option_sub_type_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsOptionSubTypesOptionSubTypeIdDeleteAsync
     *
     * Delete contact option sub-type
     *
     * @param  int $option_sub_type_id The ID of the contact option sub-type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionSubTypesOptionSubTypeIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsOptionSubTypesOptionSubTypeIdDeleteAsync(
        int $option_sub_type_id,
        string $contentType = self::contentTypes['restAccountsContactsOptionSubTypesOptionSubTypeIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsOptionSubTypesOptionSubTypeIdDeleteAsyncWithHttpInfo($option_sub_type_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsOptionSubTypesOptionSubTypeIdDeleteAsyncWithHttpInfo
     *
     * Delete contact option sub-type
     *
     * @param  int $option_sub_type_id The ID of the contact option sub-type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionSubTypesOptionSubTypeIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsOptionSubTypesOptionSubTypeIdDeleteAsyncWithHttpInfo(
        $option_sub_type_id,
        string $contentType = self::contentTypes['restAccountsContactsOptionSubTypesOptionSubTypeIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restAccountsContactsOptionSubTypesOptionSubTypeIdDeleteRequest($option_sub_type_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsOptionSubTypesOptionSubTypeIdDelete'
     *
     * @param  int $option_sub_type_id The ID of the contact option sub-type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionSubTypesOptionSubTypeIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsOptionSubTypesOptionSubTypeIdDeleteRequest(
        $option_sub_type_id,
        string $contentType = self::contentTypes['restAccountsContactsOptionSubTypesOptionSubTypeIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'option_sub_type_id' is set
        if ($option_sub_type_id === null || (is_array($option_sub_type_id) && count($option_sub_type_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $option_sub_type_id when calling restAccountsContactsOptionSubTypesOptionSubTypeIdDelete'
            );
        }


        $resourcePath = '/rest/accounts/contacts/option_sub_types/{optionSubTypeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($option_sub_type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'optionSubTypeId' . '}',
                ObjectSerializer::toPathValue($option_sub_type_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsOptionSubTypesOptionSubTypeIdGet
     *
     * Get contact option sub-type
     *
     * @param  int $option_sub_type_id The ID of the contact option sub-type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionSubTypesOptionSubTypeIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ContactOptionSubType
     */
    public function restAccountsContactsOptionSubTypesOptionSubTypeIdGet(
        int $option_sub_type_id,
        string $contentType = self::contentTypes['restAccountsContactsOptionSubTypesOptionSubTypeIdGet'][0]
    ): \ck\Model\ContactOptionSubType
    {
        list($response) = $this->restAccountsContactsOptionSubTypesOptionSubTypeIdGetWithHttpInfo($option_sub_type_id, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsContactsOptionSubTypesOptionSubTypeIdGetWithHttpInfo
     *
     * Get contact option sub-type
     *
     * @param  int $option_sub_type_id The ID of the contact option sub-type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionSubTypesOptionSubTypeIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ContactOptionSubType, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsOptionSubTypesOptionSubTypeIdGetWithHttpInfo(
        int $option_sub_type_id,
        string $contentType = self::contentTypes['restAccountsContactsOptionSubTypesOptionSubTypeIdGet'][0]
    ): array
    {
        $request = $this->restAccountsContactsOptionSubTypesOptionSubTypeIdGetRequest($option_sub_type_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ContactOptionSubType' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ContactOptionSubType' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ContactOptionSubType', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ContactOptionSubType';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ContactOptionSubType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsOptionSubTypesOptionSubTypeIdGetAsync
     *
     * Get contact option sub-type
     *
     * @param  int $option_sub_type_id The ID of the contact option sub-type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionSubTypesOptionSubTypeIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsOptionSubTypesOptionSubTypeIdGetAsync(
        int $option_sub_type_id,
        string $contentType = self::contentTypes['restAccountsContactsOptionSubTypesOptionSubTypeIdGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsOptionSubTypesOptionSubTypeIdGetAsyncWithHttpInfo($option_sub_type_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsOptionSubTypesOptionSubTypeIdGetAsyncWithHttpInfo
     *
     * Get contact option sub-type
     *
     * @param  int $option_sub_type_id The ID of the contact option sub-type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionSubTypesOptionSubTypeIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsOptionSubTypesOptionSubTypeIdGetAsyncWithHttpInfo(
        $option_sub_type_id,
        string $contentType = self::contentTypes['restAccountsContactsOptionSubTypesOptionSubTypeIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ContactOptionSubType';
        $request = $this->restAccountsContactsOptionSubTypesOptionSubTypeIdGetRequest($option_sub_type_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsOptionSubTypesOptionSubTypeIdGet'
     *
     * @param  int $option_sub_type_id The ID of the contact option sub-type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionSubTypesOptionSubTypeIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsOptionSubTypesOptionSubTypeIdGetRequest(
        $option_sub_type_id,
        string $contentType = self::contentTypes['restAccountsContactsOptionSubTypesOptionSubTypeIdGet'][0]
    ): Request
    {

        // verify the required parameter 'option_sub_type_id' is set
        if ($option_sub_type_id === null || (is_array($option_sub_type_id) && count($option_sub_type_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $option_sub_type_id when calling restAccountsContactsOptionSubTypesOptionSubTypeIdGet'
            );
        }


        $resourcePath = '/rest/accounts/contacts/option_sub_types/{optionSubTypeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($option_sub_type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'optionSubTypeId' . '}',
                ObjectSerializer::toPathValue($option_sub_type_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsOptionSubTypesOptionSubTypeIdPut
     *
     * Update contact option sub-type
     *
     * @param  int $option_sub_type_id The ID of the contact option sub-type (required)
     * @param  \ck\Model\RestAccountsAddressesOptionTypesPostRequest|null $_rest_accounts_contacts_option_sub_types_option_sub_type_id _rest_accounts_contacts_option_sub_types_option_sub_type_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionSubTypesOptionSubTypeIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ContactOptionSubType
     */
    public function restAccountsContactsOptionSubTypesOptionSubTypeIdPut(
        int $option_sub_type_id,
        ?\ck\Model\RestAccountsAddressesOptionTypesPostRequest $_rest_accounts_contacts_option_sub_types_option_sub_type_id = null,
        string $contentType = self::contentTypes['restAccountsContactsOptionSubTypesOptionSubTypeIdPut'][0]
    ): \ck\Model\ContactOptionSubType
    {
        list($response) = $this->restAccountsContactsOptionSubTypesOptionSubTypeIdPutWithHttpInfo($option_sub_type_id, $_rest_accounts_contacts_option_sub_types_option_sub_type_id, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsContactsOptionSubTypesOptionSubTypeIdPutWithHttpInfo
     *
     * Update contact option sub-type
     *
     * @param  int $option_sub_type_id The ID of the contact option sub-type (required)
     * @param  \ck\Model\RestAccountsAddressesOptionTypesPostRequest|null $_rest_accounts_contacts_option_sub_types_option_sub_type_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionSubTypesOptionSubTypeIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ContactOptionSubType, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsOptionSubTypesOptionSubTypeIdPutWithHttpInfo(
        int $option_sub_type_id,
        ?\ck\Model\RestAccountsAddressesOptionTypesPostRequest $_rest_accounts_contacts_option_sub_types_option_sub_type_id = null,
        string $contentType = self::contentTypes['restAccountsContactsOptionSubTypesOptionSubTypeIdPut'][0]
    ): array
    {
        $request = $this->restAccountsContactsOptionSubTypesOptionSubTypeIdPutRequest($option_sub_type_id, $_rest_accounts_contacts_option_sub_types_option_sub_type_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ContactOptionSubType' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ContactOptionSubType' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ContactOptionSubType', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ContactOptionSubType';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ContactOptionSubType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsOptionSubTypesOptionSubTypeIdPutAsync
     *
     * Update contact option sub-type
     *
     * @param  int $option_sub_type_id The ID of the contact option sub-type (required)
     * @param  \ck\Model\RestAccountsAddressesOptionTypesPostRequest|null $_rest_accounts_contacts_option_sub_types_option_sub_type_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionSubTypesOptionSubTypeIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsOptionSubTypesOptionSubTypeIdPutAsync(
        int $option_sub_type_id,
        ?\ck\Model\RestAccountsAddressesOptionTypesPostRequest $_rest_accounts_contacts_option_sub_types_option_sub_type_id = null,
        string $contentType = self::contentTypes['restAccountsContactsOptionSubTypesOptionSubTypeIdPut'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsOptionSubTypesOptionSubTypeIdPutAsyncWithHttpInfo($option_sub_type_id, $_rest_accounts_contacts_option_sub_types_option_sub_type_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsOptionSubTypesOptionSubTypeIdPutAsyncWithHttpInfo
     *
     * Update contact option sub-type
     *
     * @param  int $option_sub_type_id The ID of the contact option sub-type (required)
     * @param  \ck\Model\RestAccountsAddressesOptionTypesPostRequest|null $_rest_accounts_contacts_option_sub_types_option_sub_type_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionSubTypesOptionSubTypeIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsOptionSubTypesOptionSubTypeIdPutAsyncWithHttpInfo(
        $option_sub_type_id,
        $_rest_accounts_contacts_option_sub_types_option_sub_type_id = null,
        string $contentType = self::contentTypes['restAccountsContactsOptionSubTypesOptionSubTypeIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ContactOptionSubType';
        $request = $this->restAccountsContactsOptionSubTypesOptionSubTypeIdPutRequest($option_sub_type_id, $_rest_accounts_contacts_option_sub_types_option_sub_type_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsOptionSubTypesOptionSubTypeIdPut'
     *
     * @param  int $option_sub_type_id The ID of the contact option sub-type (required)
     * @param  \ck\Model\RestAccountsAddressesOptionTypesPostRequest|null $_rest_accounts_contacts_option_sub_types_option_sub_type_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionSubTypesOptionSubTypeIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsOptionSubTypesOptionSubTypeIdPutRequest(
        $option_sub_type_id,
        $_rest_accounts_contacts_option_sub_types_option_sub_type_id = null,
        string $contentType = self::contentTypes['restAccountsContactsOptionSubTypesOptionSubTypeIdPut'][0]
    ): Request
    {

        // verify the required parameter 'option_sub_type_id' is set
        if ($option_sub_type_id === null || (is_array($option_sub_type_id) && count($option_sub_type_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $option_sub_type_id when calling restAccountsContactsOptionSubTypesOptionSubTypeIdPut'
            );
        }



        $resourcePath = '/rest/accounts/contacts/option_sub_types/{optionSubTypeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($option_sub_type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'optionSubTypeId' . '}',
                ObjectSerializer::toPathValue($option_sub_type_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_accounts_contacts_option_sub_types_option_sub_type_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_accounts_contacts_option_sub_types_option_sub_type_id));
            } else {
                $httpBody = $_rest_accounts_contacts_option_sub_types_option_sub_type_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsOptionSubTypesPost
     *
     * Create contact option sub-type
     *
     * @param  \ck\Model\RestAccountsAddressesOptionTypesPostRequest|null $_rest_accounts_contacts_option_sub_types _rest_accounts_contacts_option_sub_types (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionSubTypesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ContactOptionSubType
     */
    public function restAccountsContactsOptionSubTypesPost(
        ?\ck\Model\RestAccountsAddressesOptionTypesPostRequest $_rest_accounts_contacts_option_sub_types = null,
        string $contentType = self::contentTypes['restAccountsContactsOptionSubTypesPost'][0]
    ): \ck\Model\ContactOptionSubType
    {
        list($response) = $this->restAccountsContactsOptionSubTypesPostWithHttpInfo($_rest_accounts_contacts_option_sub_types, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsContactsOptionSubTypesPostWithHttpInfo
     *
     * Create contact option sub-type
     *
     * @param  \ck\Model\RestAccountsAddressesOptionTypesPostRequest|null $_rest_accounts_contacts_option_sub_types (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionSubTypesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ContactOptionSubType, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsOptionSubTypesPostWithHttpInfo(
        ?\ck\Model\RestAccountsAddressesOptionTypesPostRequest $_rest_accounts_contacts_option_sub_types = null,
        string $contentType = self::contentTypes['restAccountsContactsOptionSubTypesPost'][0]
    ): array
    {
        $request = $this->restAccountsContactsOptionSubTypesPostRequest($_rest_accounts_contacts_option_sub_types, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ContactOptionSubType' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ContactOptionSubType' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ContactOptionSubType', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ContactOptionSubType';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ContactOptionSubType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsOptionSubTypesPostAsync
     *
     * Create contact option sub-type
     *
     * @param  \ck\Model\RestAccountsAddressesOptionTypesPostRequest|null $_rest_accounts_contacts_option_sub_types (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionSubTypesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsOptionSubTypesPostAsync(
        ?\ck\Model\RestAccountsAddressesOptionTypesPostRequest $_rest_accounts_contacts_option_sub_types = null,
        string $contentType = self::contentTypes['restAccountsContactsOptionSubTypesPost'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsOptionSubTypesPostAsyncWithHttpInfo($_rest_accounts_contacts_option_sub_types, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsOptionSubTypesPostAsyncWithHttpInfo
     *
     * Create contact option sub-type
     *
     * @param  \ck\Model\RestAccountsAddressesOptionTypesPostRequest|null $_rest_accounts_contacts_option_sub_types (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionSubTypesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsOptionSubTypesPostAsyncWithHttpInfo(
        $_rest_accounts_contacts_option_sub_types = null,
        string $contentType = self::contentTypes['restAccountsContactsOptionSubTypesPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ContactOptionSubType';
        $request = $this->restAccountsContactsOptionSubTypesPostRequest($_rest_accounts_contacts_option_sub_types, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsOptionSubTypesPost'
     *
     * @param  \ck\Model\RestAccountsAddressesOptionTypesPostRequest|null $_rest_accounts_contacts_option_sub_types (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionSubTypesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsOptionSubTypesPostRequest(
        $_rest_accounts_contacts_option_sub_types = null,
        string $contentType = self::contentTypes['restAccountsContactsOptionSubTypesPost'][0]
    ): Request
    {



        $resourcePath = '/rest/accounts/contacts/option_sub_types';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_accounts_contacts_option_sub_types)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_accounts_contacts_option_sub_types));
            } else {
                $httpBody = $_rest_accounts_contacts_option_sub_types;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsOptionTypesGet
     *
     * List contact option types
     *
     * @param  string|null $with Lists possible option sub-types for each listed option if the parameter &#39;subTypes&#39; is set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionTypesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ContactOptionType[]
     */
    public function restAccountsContactsOptionTypesGet(
        ?string $with = null,
        string $contentType = self::contentTypes['restAccountsContactsOptionTypesGet'][0]
    ): array
    {
        list($response) = $this->restAccountsContactsOptionTypesGetWithHttpInfo($with, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsContactsOptionTypesGetWithHttpInfo
     *
     * List contact option types
     *
     * @param  string|null $with Lists possible option sub-types for each listed option if the parameter &#39;subTypes&#39; is set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionTypesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ContactOptionType[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsOptionTypesGetWithHttpInfo(
        ?string $with = null,
        string $contentType = self::contentTypes['restAccountsContactsOptionTypesGet'][0]
    ): array
    {
        $request = $this->restAccountsContactsOptionTypesGetRequest($with, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ContactOptionType[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ContactOptionType[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ContactOptionType[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ContactOptionType[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ContactOptionType[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsOptionTypesGetAsync
     *
     * List contact option types
     *
     * @param  string|null $with Lists possible option sub-types for each listed option if the parameter &#39;subTypes&#39; is set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionTypesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsOptionTypesGetAsync(
        ?string $with = null,
        string $contentType = self::contentTypes['restAccountsContactsOptionTypesGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsOptionTypesGetAsyncWithHttpInfo($with, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsOptionTypesGetAsyncWithHttpInfo
     *
     * List contact option types
     *
     * @param  string|null $with Lists possible option sub-types for each listed option if the parameter &#39;subTypes&#39; is set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionTypesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsOptionTypesGetAsyncWithHttpInfo(
        $with = null,
        string $contentType = self::contentTypes['restAccountsContactsOptionTypesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ContactOptionType[]';
        $request = $this->restAccountsContactsOptionTypesGetRequest($with, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsOptionTypesGet'
     *
     * @param  string|null $with Lists possible option sub-types for each listed option if the parameter &#39;subTypes&#39; is set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionTypesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsOptionTypesGetRequest(
        $with = null,
        string $contentType = self::contentTypes['restAccountsContactsOptionTypesGet'][0]
    ): Request
    {



        $resourcePath = '/rest/accounts/contacts/option_types';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with,
            'with', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsOptionTypesOptionTypeIdDelete
     *
     * Delete contact option type
     *
     * @param  int $option_type_id The ID of the contact option type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionTypesOptionTypeIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restAccountsContactsOptionTypesOptionTypeIdDelete(
        int $option_type_id,
        string $contentType = self::contentTypes['restAccountsContactsOptionTypesOptionTypeIdDelete'][0]
    ): void
    {
        $this->restAccountsContactsOptionTypesOptionTypeIdDeleteWithHttpInfo($option_type_id, $contentType);
    }

    /**
     * Operation restAccountsContactsOptionTypesOptionTypeIdDeleteWithHttpInfo
     *
     * Delete contact option type
     *
     * @param  int $option_type_id The ID of the contact option type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionTypesOptionTypeIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsOptionTypesOptionTypeIdDeleteWithHttpInfo(
        int $option_type_id,
        string $contentType = self::contentTypes['restAccountsContactsOptionTypesOptionTypeIdDelete'][0]
    ): array
    {
        $request = $this->restAccountsContactsOptionTypesOptionTypeIdDeleteRequest($option_type_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsOptionTypesOptionTypeIdDeleteAsync
     *
     * Delete contact option type
     *
     * @param  int $option_type_id The ID of the contact option type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionTypesOptionTypeIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsOptionTypesOptionTypeIdDeleteAsync(
        int $option_type_id,
        string $contentType = self::contentTypes['restAccountsContactsOptionTypesOptionTypeIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsOptionTypesOptionTypeIdDeleteAsyncWithHttpInfo($option_type_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsOptionTypesOptionTypeIdDeleteAsyncWithHttpInfo
     *
     * Delete contact option type
     *
     * @param  int $option_type_id The ID of the contact option type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionTypesOptionTypeIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsOptionTypesOptionTypeIdDeleteAsyncWithHttpInfo(
        $option_type_id,
        string $contentType = self::contentTypes['restAccountsContactsOptionTypesOptionTypeIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restAccountsContactsOptionTypesOptionTypeIdDeleteRequest($option_type_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsOptionTypesOptionTypeIdDelete'
     *
     * @param  int $option_type_id The ID of the contact option type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionTypesOptionTypeIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsOptionTypesOptionTypeIdDeleteRequest(
        $option_type_id,
        string $contentType = self::contentTypes['restAccountsContactsOptionTypesOptionTypeIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'option_type_id' is set
        if ($option_type_id === null || (is_array($option_type_id) && count($option_type_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $option_type_id when calling restAccountsContactsOptionTypesOptionTypeIdDelete'
            );
        }


        $resourcePath = '/rest/accounts/contacts/option_types/{optionTypeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($option_type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'optionTypeId' . '}',
                ObjectSerializer::toPathValue($option_type_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsOptionTypesOptionTypeIdGet
     *
     * Get contact option type
     *
     * @param  int $option_type_id The ID of the contact option type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionTypesOptionTypeIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ContactOptionType
     */
    public function restAccountsContactsOptionTypesOptionTypeIdGet(
        int $option_type_id,
        string $contentType = self::contentTypes['restAccountsContactsOptionTypesOptionTypeIdGet'][0]
    ): \ck\Model\ContactOptionType
    {
        list($response) = $this->restAccountsContactsOptionTypesOptionTypeIdGetWithHttpInfo($option_type_id, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsContactsOptionTypesOptionTypeIdGetWithHttpInfo
     *
     * Get contact option type
     *
     * @param  int $option_type_id The ID of the contact option type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionTypesOptionTypeIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ContactOptionType, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsOptionTypesOptionTypeIdGetWithHttpInfo(
        int $option_type_id,
        string $contentType = self::contentTypes['restAccountsContactsOptionTypesOptionTypeIdGet'][0]
    ): array
    {
        $request = $this->restAccountsContactsOptionTypesOptionTypeIdGetRequest($option_type_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ContactOptionType' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ContactOptionType' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ContactOptionType', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ContactOptionType';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ContactOptionType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsOptionTypesOptionTypeIdGetAsync
     *
     * Get contact option type
     *
     * @param  int $option_type_id The ID of the contact option type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionTypesOptionTypeIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsOptionTypesOptionTypeIdGetAsync(
        int $option_type_id,
        string $contentType = self::contentTypes['restAccountsContactsOptionTypesOptionTypeIdGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsOptionTypesOptionTypeIdGetAsyncWithHttpInfo($option_type_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsOptionTypesOptionTypeIdGetAsyncWithHttpInfo
     *
     * Get contact option type
     *
     * @param  int $option_type_id The ID of the contact option type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionTypesOptionTypeIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsOptionTypesOptionTypeIdGetAsyncWithHttpInfo(
        $option_type_id,
        string $contentType = self::contentTypes['restAccountsContactsOptionTypesOptionTypeIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ContactOptionType';
        $request = $this->restAccountsContactsOptionTypesOptionTypeIdGetRequest($option_type_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsOptionTypesOptionTypeIdGet'
     *
     * @param  int $option_type_id The ID of the contact option type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionTypesOptionTypeIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsOptionTypesOptionTypeIdGetRequest(
        $option_type_id,
        string $contentType = self::contentTypes['restAccountsContactsOptionTypesOptionTypeIdGet'][0]
    ): Request
    {

        // verify the required parameter 'option_type_id' is set
        if ($option_type_id === null || (is_array($option_type_id) && count($option_type_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $option_type_id when calling restAccountsContactsOptionTypesOptionTypeIdGet'
            );
        }


        $resourcePath = '/rest/accounts/contacts/option_types/{optionTypeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($option_type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'optionTypeId' . '}',
                ObjectSerializer::toPathValue($option_type_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsOptionTypesOptionTypeIdPut
     *
     * Update contact option type
     *
     * @param  int $option_type_id The ID of the contact option type (required)
     * @param  \ck\Model\RestAccountsAddressesOptionTypesPostRequest|null $_rest_accounts_contacts_option_types_option_type_id _rest_accounts_contacts_option_types_option_type_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionTypesOptionTypeIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ContactOptionType
     */
    public function restAccountsContactsOptionTypesOptionTypeIdPut(
        int $option_type_id,
        ?\ck\Model\RestAccountsAddressesOptionTypesPostRequest $_rest_accounts_contacts_option_types_option_type_id = null,
        string $contentType = self::contentTypes['restAccountsContactsOptionTypesOptionTypeIdPut'][0]
    ): \ck\Model\ContactOptionType
    {
        list($response) = $this->restAccountsContactsOptionTypesOptionTypeIdPutWithHttpInfo($option_type_id, $_rest_accounts_contacts_option_types_option_type_id, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsContactsOptionTypesOptionTypeIdPutWithHttpInfo
     *
     * Update contact option type
     *
     * @param  int $option_type_id The ID of the contact option type (required)
     * @param  \ck\Model\RestAccountsAddressesOptionTypesPostRequest|null $_rest_accounts_contacts_option_types_option_type_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionTypesOptionTypeIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ContactOptionType, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsOptionTypesOptionTypeIdPutWithHttpInfo(
        int $option_type_id,
        ?\ck\Model\RestAccountsAddressesOptionTypesPostRequest $_rest_accounts_contacts_option_types_option_type_id = null,
        string $contentType = self::contentTypes['restAccountsContactsOptionTypesOptionTypeIdPut'][0]
    ): array
    {
        $request = $this->restAccountsContactsOptionTypesOptionTypeIdPutRequest($option_type_id, $_rest_accounts_contacts_option_types_option_type_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ContactOptionType' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ContactOptionType' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ContactOptionType', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ContactOptionType';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ContactOptionType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsOptionTypesOptionTypeIdPutAsync
     *
     * Update contact option type
     *
     * @param  int $option_type_id The ID of the contact option type (required)
     * @param  \ck\Model\RestAccountsAddressesOptionTypesPostRequest|null $_rest_accounts_contacts_option_types_option_type_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionTypesOptionTypeIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsOptionTypesOptionTypeIdPutAsync(
        int $option_type_id,
        ?\ck\Model\RestAccountsAddressesOptionTypesPostRequest $_rest_accounts_contacts_option_types_option_type_id = null,
        string $contentType = self::contentTypes['restAccountsContactsOptionTypesOptionTypeIdPut'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsOptionTypesOptionTypeIdPutAsyncWithHttpInfo($option_type_id, $_rest_accounts_contacts_option_types_option_type_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsOptionTypesOptionTypeIdPutAsyncWithHttpInfo
     *
     * Update contact option type
     *
     * @param  int $option_type_id The ID of the contact option type (required)
     * @param  \ck\Model\RestAccountsAddressesOptionTypesPostRequest|null $_rest_accounts_contacts_option_types_option_type_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionTypesOptionTypeIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsOptionTypesOptionTypeIdPutAsyncWithHttpInfo(
        $option_type_id,
        $_rest_accounts_contacts_option_types_option_type_id = null,
        string $contentType = self::contentTypes['restAccountsContactsOptionTypesOptionTypeIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ContactOptionType';
        $request = $this->restAccountsContactsOptionTypesOptionTypeIdPutRequest($option_type_id, $_rest_accounts_contacts_option_types_option_type_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsOptionTypesOptionTypeIdPut'
     *
     * @param  int $option_type_id The ID of the contact option type (required)
     * @param  \ck\Model\RestAccountsAddressesOptionTypesPostRequest|null $_rest_accounts_contacts_option_types_option_type_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionTypesOptionTypeIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsOptionTypesOptionTypeIdPutRequest(
        $option_type_id,
        $_rest_accounts_contacts_option_types_option_type_id = null,
        string $contentType = self::contentTypes['restAccountsContactsOptionTypesOptionTypeIdPut'][0]
    ): Request
    {

        // verify the required parameter 'option_type_id' is set
        if ($option_type_id === null || (is_array($option_type_id) && count($option_type_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $option_type_id when calling restAccountsContactsOptionTypesOptionTypeIdPut'
            );
        }



        $resourcePath = '/rest/accounts/contacts/option_types/{optionTypeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($option_type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'optionTypeId' . '}',
                ObjectSerializer::toPathValue($option_type_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_accounts_contacts_option_types_option_type_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_accounts_contacts_option_types_option_type_id));
            } else {
                $httpBody = $_rest_accounts_contacts_option_types_option_type_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsOptionTypesPost
     *
     * Create contact option type
     *
     * @param  \ck\Model\RestAccountsAddressesOptionTypesPostRequest|null $_rest_accounts_contacts_option_types _rest_accounts_contacts_option_types (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionTypesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ContactOptionType
     */
    public function restAccountsContactsOptionTypesPost(
        ?\ck\Model\RestAccountsAddressesOptionTypesPostRequest $_rest_accounts_contacts_option_types = null,
        string $contentType = self::contentTypes['restAccountsContactsOptionTypesPost'][0]
    ): \ck\Model\ContactOptionType
    {
        list($response) = $this->restAccountsContactsOptionTypesPostWithHttpInfo($_rest_accounts_contacts_option_types, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsContactsOptionTypesPostWithHttpInfo
     *
     * Create contact option type
     *
     * @param  \ck\Model\RestAccountsAddressesOptionTypesPostRequest|null $_rest_accounts_contacts_option_types (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionTypesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ContactOptionType, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsOptionTypesPostWithHttpInfo(
        ?\ck\Model\RestAccountsAddressesOptionTypesPostRequest $_rest_accounts_contacts_option_types = null,
        string $contentType = self::contentTypes['restAccountsContactsOptionTypesPost'][0]
    ): array
    {
        $request = $this->restAccountsContactsOptionTypesPostRequest($_rest_accounts_contacts_option_types, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ContactOptionType' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ContactOptionType' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ContactOptionType', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ContactOptionType';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ContactOptionType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsOptionTypesPostAsync
     *
     * Create contact option type
     *
     * @param  \ck\Model\RestAccountsAddressesOptionTypesPostRequest|null $_rest_accounts_contacts_option_types (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionTypesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsOptionTypesPostAsync(
        ?\ck\Model\RestAccountsAddressesOptionTypesPostRequest $_rest_accounts_contacts_option_types = null,
        string $contentType = self::contentTypes['restAccountsContactsOptionTypesPost'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsOptionTypesPostAsyncWithHttpInfo($_rest_accounts_contacts_option_types, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsOptionTypesPostAsyncWithHttpInfo
     *
     * Create contact option type
     *
     * @param  \ck\Model\RestAccountsAddressesOptionTypesPostRequest|null $_rest_accounts_contacts_option_types (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionTypesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsOptionTypesPostAsyncWithHttpInfo(
        $_rest_accounts_contacts_option_types = null,
        string $contentType = self::contentTypes['restAccountsContactsOptionTypesPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ContactOptionType';
        $request = $this->restAccountsContactsOptionTypesPostRequest($_rest_accounts_contacts_option_types, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsOptionTypesPost'
     *
     * @param  \ck\Model\RestAccountsAddressesOptionTypesPostRequest|null $_rest_accounts_contacts_option_types (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionTypesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsOptionTypesPostRequest(
        $_rest_accounts_contacts_option_types = null,
        string $contentType = self::contentTypes['restAccountsContactsOptionTypesPost'][0]
    ): Request
    {



        $resourcePath = '/rest/accounts/contacts/option_types';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_accounts_contacts_option_types)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_accounts_contacts_option_types));
            } else {
                $httpBody = $_rest_accounts_contacts_option_types;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsOptionsOptionIdDelete
     *
     * Delete contact option
     *
     * @param  int $option_id The ID of the option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionsOptionIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restAccountsContactsOptionsOptionIdDelete(
        int $option_id,
        string $contentType = self::contentTypes['restAccountsContactsOptionsOptionIdDelete'][0]
    ): void
    {
        $this->restAccountsContactsOptionsOptionIdDeleteWithHttpInfo($option_id, $contentType);
    }

    /**
     * Operation restAccountsContactsOptionsOptionIdDeleteWithHttpInfo
     *
     * Delete contact option
     *
     * @param  int $option_id The ID of the option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionsOptionIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsOptionsOptionIdDeleteWithHttpInfo(
        int $option_id,
        string $contentType = self::contentTypes['restAccountsContactsOptionsOptionIdDelete'][0]
    ): array
    {
        $request = $this->restAccountsContactsOptionsOptionIdDeleteRequest($option_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsOptionsOptionIdDeleteAsync
     *
     * Delete contact option
     *
     * @param  int $option_id The ID of the option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionsOptionIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsOptionsOptionIdDeleteAsync(
        int $option_id,
        string $contentType = self::contentTypes['restAccountsContactsOptionsOptionIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsOptionsOptionIdDeleteAsyncWithHttpInfo($option_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsOptionsOptionIdDeleteAsyncWithHttpInfo
     *
     * Delete contact option
     *
     * @param  int $option_id The ID of the option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionsOptionIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsOptionsOptionIdDeleteAsyncWithHttpInfo(
        $option_id,
        string $contentType = self::contentTypes['restAccountsContactsOptionsOptionIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restAccountsContactsOptionsOptionIdDeleteRequest($option_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsOptionsOptionIdDelete'
     *
     * @param  int $option_id The ID of the option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionsOptionIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsOptionsOptionIdDeleteRequest(
        $option_id,
        string $contentType = self::contentTypes['restAccountsContactsOptionsOptionIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'option_id' is set
        if ($option_id === null || (is_array($option_id) && count($option_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $option_id when calling restAccountsContactsOptionsOptionIdDelete'
            );
        }


        $resourcePath = '/rest/accounts/contacts/options/{optionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($option_id !== null) {
            $resourcePath = str_replace(
                '{' . 'optionId' . '}',
                ObjectSerializer::toPathValue($option_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsOptionsOptionIdGet
     *
     * Get contact option
     *
     * @param  int $option_id The ID of the option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionsOptionIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ContactOption
     */
    public function restAccountsContactsOptionsOptionIdGet(
        int $option_id,
        string $contentType = self::contentTypes['restAccountsContactsOptionsOptionIdGet'][0]
    ): \ck\Model\ContactOption
    {
        list($response) = $this->restAccountsContactsOptionsOptionIdGetWithHttpInfo($option_id, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsContactsOptionsOptionIdGetWithHttpInfo
     *
     * Get contact option
     *
     * @param  int $option_id The ID of the option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionsOptionIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ContactOption, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsOptionsOptionIdGetWithHttpInfo(
        int $option_id,
        string $contentType = self::contentTypes['restAccountsContactsOptionsOptionIdGet'][0]
    ): array
    {
        $request = $this->restAccountsContactsOptionsOptionIdGetRequest($option_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ContactOption' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ContactOption' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ContactOption', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ContactOption';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ContactOption',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsOptionsOptionIdGetAsync
     *
     * Get contact option
     *
     * @param  int $option_id The ID of the option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionsOptionIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsOptionsOptionIdGetAsync(
        int $option_id,
        string $contentType = self::contentTypes['restAccountsContactsOptionsOptionIdGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsOptionsOptionIdGetAsyncWithHttpInfo($option_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsOptionsOptionIdGetAsyncWithHttpInfo
     *
     * Get contact option
     *
     * @param  int $option_id The ID of the option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionsOptionIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsOptionsOptionIdGetAsyncWithHttpInfo(
        $option_id,
        string $contentType = self::contentTypes['restAccountsContactsOptionsOptionIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ContactOption';
        $request = $this->restAccountsContactsOptionsOptionIdGetRequest($option_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsOptionsOptionIdGet'
     *
     * @param  int $option_id The ID of the option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionsOptionIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsOptionsOptionIdGetRequest(
        $option_id,
        string $contentType = self::contentTypes['restAccountsContactsOptionsOptionIdGet'][0]
    ): Request
    {

        // verify the required parameter 'option_id' is set
        if ($option_id === null || (is_array($option_id) && count($option_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $option_id when calling restAccountsContactsOptionsOptionIdGet'
            );
        }


        $resourcePath = '/rest/accounts/contacts/options/{optionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($option_id !== null) {
            $resourcePath = str_replace(
                '{' . 'optionId' . '}',
                ObjectSerializer::toPathValue($option_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsOptionsOptionIdPut
     *
     * Update contact option
     *
     * @param  int $option_id The ID of the option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionsOptionIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ContactOption
     */
    public function restAccountsContactsOptionsOptionIdPut(
        int $option_id,
        string $contentType = self::contentTypes['restAccountsContactsOptionsOptionIdPut'][0]
    ): \ck\Model\ContactOption
    {
        list($response) = $this->restAccountsContactsOptionsOptionIdPutWithHttpInfo($option_id, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsContactsOptionsOptionIdPutWithHttpInfo
     *
     * Update contact option
     *
     * @param  int $option_id The ID of the option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionsOptionIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ContactOption, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsOptionsOptionIdPutWithHttpInfo(
        int $option_id,
        string $contentType = self::contentTypes['restAccountsContactsOptionsOptionIdPut'][0]
    ): array
    {
        $request = $this->restAccountsContactsOptionsOptionIdPutRequest($option_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ContactOption' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ContactOption' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ContactOption', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ContactOption';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ContactOption',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsOptionsOptionIdPutAsync
     *
     * Update contact option
     *
     * @param  int $option_id The ID of the option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionsOptionIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsOptionsOptionIdPutAsync(
        int $option_id,
        string $contentType = self::contentTypes['restAccountsContactsOptionsOptionIdPut'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsOptionsOptionIdPutAsyncWithHttpInfo($option_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsOptionsOptionIdPutAsyncWithHttpInfo
     *
     * Update contact option
     *
     * @param  int $option_id The ID of the option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionsOptionIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsOptionsOptionIdPutAsyncWithHttpInfo(
        $option_id,
        string $contentType = self::contentTypes['restAccountsContactsOptionsOptionIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ContactOption';
        $request = $this->restAccountsContactsOptionsOptionIdPutRequest($option_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsOptionsOptionIdPut'
     *
     * @param  int $option_id The ID of the option (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsOptionsOptionIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsOptionsOptionIdPutRequest(
        $option_id,
        string $contentType = self::contentTypes['restAccountsContactsOptionsOptionIdPut'][0]
    ): Request
    {

        // verify the required parameter 'option_id' is set
        if ($option_id === null || (is_array($option_id) && count($option_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $option_id when calling restAccountsContactsOptionsOptionIdPut'
            );
        }


        $resourcePath = '/rest/accounts/contacts/options/{optionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($option_id !== null) {
            $resourcePath = str_replace(
                '{' . 'optionId' . '}',
                ObjectSerializer::toPathValue($option_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsPositionsGet
     *
     * List contact positions
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsPositionsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ContactPosition[]
     */
    public function restAccountsContactsPositionsGet(
        string $contentType = self::contentTypes['restAccountsContactsPositionsGet'][0]
    ): array
    {
        list($response) = $this->restAccountsContactsPositionsGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restAccountsContactsPositionsGetWithHttpInfo
     *
     * List contact positions
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsPositionsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ContactPosition[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsPositionsGetWithHttpInfo(
        string $contentType = self::contentTypes['restAccountsContactsPositionsGet'][0]
    ): array
    {
        $request = $this->restAccountsContactsPositionsGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ContactPosition[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ContactPosition[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ContactPosition[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ContactPosition[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ContactPosition[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsPositionsGetAsync
     *
     * List contact positions
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsPositionsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsPositionsGetAsync(
        string $contentType = self::contentTypes['restAccountsContactsPositionsGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsPositionsGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsPositionsGetAsyncWithHttpInfo
     *
     * List contact positions
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsPositionsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsPositionsGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restAccountsContactsPositionsGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ContactPosition[]';
        $request = $this->restAccountsContactsPositionsGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsPositionsGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsPositionsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsPositionsGetRequest(
        string $contentType = self::contentTypes['restAccountsContactsPositionsGet'][0]
    ): Request
    {


        $resourcePath = '/rest/accounts/contacts/positions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsPositionsPositionIdDelete
     *
     * Delete contact position
     *
     * @param  int $position_id The ID of the position (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsPositionsPositionIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restAccountsContactsPositionsPositionIdDelete(
        int $position_id,
        string $contentType = self::contentTypes['restAccountsContactsPositionsPositionIdDelete'][0]
    ): void
    {
        $this->restAccountsContactsPositionsPositionIdDeleteWithHttpInfo($position_id, $contentType);
    }

    /**
     * Operation restAccountsContactsPositionsPositionIdDeleteWithHttpInfo
     *
     * Delete contact position
     *
     * @param  int $position_id The ID of the position (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsPositionsPositionIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsPositionsPositionIdDeleteWithHttpInfo(
        int $position_id,
        string $contentType = self::contentTypes['restAccountsContactsPositionsPositionIdDelete'][0]
    ): array
    {
        $request = $this->restAccountsContactsPositionsPositionIdDeleteRequest($position_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsPositionsPositionIdDeleteAsync
     *
     * Delete contact position
     *
     * @param  int $position_id The ID of the position (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsPositionsPositionIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsPositionsPositionIdDeleteAsync(
        int $position_id,
        string $contentType = self::contentTypes['restAccountsContactsPositionsPositionIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsPositionsPositionIdDeleteAsyncWithHttpInfo($position_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsPositionsPositionIdDeleteAsyncWithHttpInfo
     *
     * Delete contact position
     *
     * @param  int $position_id The ID of the position (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsPositionsPositionIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsPositionsPositionIdDeleteAsyncWithHttpInfo(
        $position_id,
        string $contentType = self::contentTypes['restAccountsContactsPositionsPositionIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restAccountsContactsPositionsPositionIdDeleteRequest($position_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsPositionsPositionIdDelete'
     *
     * @param  int $position_id The ID of the position (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsPositionsPositionIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsPositionsPositionIdDeleteRequest(
        $position_id,
        string $contentType = self::contentTypes['restAccountsContactsPositionsPositionIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'position_id' is set
        if ($position_id === null || (is_array($position_id) && count($position_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $position_id when calling restAccountsContactsPositionsPositionIdDelete'
            );
        }


        $resourcePath = '/rest/accounts/contacts/positions/{positionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($position_id !== null) {
            $resourcePath = str_replace(
                '{' . 'positionId' . '}',
                ObjectSerializer::toPathValue($position_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsPositionsPositionIdGet
     *
     * Get contact position
     *
     * @param  int $position_id The ID of the position (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsPositionsPositionIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ContactPosition
     */
    public function restAccountsContactsPositionsPositionIdGet(
        int $position_id,
        string $contentType = self::contentTypes['restAccountsContactsPositionsPositionIdGet'][0]
    ): \ck\Model\ContactPosition
    {
        list($response) = $this->restAccountsContactsPositionsPositionIdGetWithHttpInfo($position_id, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsContactsPositionsPositionIdGetWithHttpInfo
     *
     * Get contact position
     *
     * @param  int $position_id The ID of the position (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsPositionsPositionIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ContactPosition, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsPositionsPositionIdGetWithHttpInfo(
        int $position_id,
        string $contentType = self::contentTypes['restAccountsContactsPositionsPositionIdGet'][0]
    ): array
    {
        $request = $this->restAccountsContactsPositionsPositionIdGetRequest($position_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ContactPosition' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ContactPosition' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ContactPosition', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ContactPosition';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ContactPosition',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsPositionsPositionIdGetAsync
     *
     * Get contact position
     *
     * @param  int $position_id The ID of the position (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsPositionsPositionIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsPositionsPositionIdGetAsync(
        int $position_id,
        string $contentType = self::contentTypes['restAccountsContactsPositionsPositionIdGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsPositionsPositionIdGetAsyncWithHttpInfo($position_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsPositionsPositionIdGetAsyncWithHttpInfo
     *
     * Get contact position
     *
     * @param  int $position_id The ID of the position (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsPositionsPositionIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsPositionsPositionIdGetAsyncWithHttpInfo(
        $position_id,
        string $contentType = self::contentTypes['restAccountsContactsPositionsPositionIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ContactPosition';
        $request = $this->restAccountsContactsPositionsPositionIdGetRequest($position_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsPositionsPositionIdGet'
     *
     * @param  int $position_id The ID of the position (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsPositionsPositionIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsPositionsPositionIdGetRequest(
        $position_id,
        string $contentType = self::contentTypes['restAccountsContactsPositionsPositionIdGet'][0]
    ): Request
    {

        // verify the required parameter 'position_id' is set
        if ($position_id === null || (is_array($position_id) && count($position_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $position_id when calling restAccountsContactsPositionsPositionIdGet'
            );
        }


        $resourcePath = '/rest/accounts/contacts/positions/{positionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($position_id !== null) {
            $resourcePath = str_replace(
                '{' . 'positionId' . '}',
                ObjectSerializer::toPathValue($position_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsPositionsPositionIdPut
     *
     * Update contact position
     *
     * @param  int $position_id The ID of the position (required)
     * @param  \ck\Model\RestAccountsContactsPositionsPostRequest|null $_rest_accounts_contacts_positions_position_id _rest_accounts_contacts_positions_position_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsPositionsPositionIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ContactPosition
     */
    public function restAccountsContactsPositionsPositionIdPut(
        int $position_id,
        ?\ck\Model\RestAccountsContactsPositionsPostRequest $_rest_accounts_contacts_positions_position_id = null,
        string $contentType = self::contentTypes['restAccountsContactsPositionsPositionIdPut'][0]
    ): \ck\Model\ContactPosition
    {
        list($response) = $this->restAccountsContactsPositionsPositionIdPutWithHttpInfo($position_id, $_rest_accounts_contacts_positions_position_id, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsContactsPositionsPositionIdPutWithHttpInfo
     *
     * Update contact position
     *
     * @param  int $position_id The ID of the position (required)
     * @param  \ck\Model\RestAccountsContactsPositionsPostRequest|null $_rest_accounts_contacts_positions_position_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsPositionsPositionIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ContactPosition, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsPositionsPositionIdPutWithHttpInfo(
        int $position_id,
        ?\ck\Model\RestAccountsContactsPositionsPostRequest $_rest_accounts_contacts_positions_position_id = null,
        string $contentType = self::contentTypes['restAccountsContactsPositionsPositionIdPut'][0]
    ): array
    {
        $request = $this->restAccountsContactsPositionsPositionIdPutRequest($position_id, $_rest_accounts_contacts_positions_position_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ContactPosition' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ContactPosition' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ContactPosition', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ContactPosition';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ContactPosition',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsPositionsPositionIdPutAsync
     *
     * Update contact position
     *
     * @param  int $position_id The ID of the position (required)
     * @param  \ck\Model\RestAccountsContactsPositionsPostRequest|null $_rest_accounts_contacts_positions_position_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsPositionsPositionIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsPositionsPositionIdPutAsync(
        int $position_id,
        ?\ck\Model\RestAccountsContactsPositionsPostRequest $_rest_accounts_contacts_positions_position_id = null,
        string $contentType = self::contentTypes['restAccountsContactsPositionsPositionIdPut'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsPositionsPositionIdPutAsyncWithHttpInfo($position_id, $_rest_accounts_contacts_positions_position_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsPositionsPositionIdPutAsyncWithHttpInfo
     *
     * Update contact position
     *
     * @param  int $position_id The ID of the position (required)
     * @param  \ck\Model\RestAccountsContactsPositionsPostRequest|null $_rest_accounts_contacts_positions_position_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsPositionsPositionIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsPositionsPositionIdPutAsyncWithHttpInfo(
        $position_id,
        $_rest_accounts_contacts_positions_position_id = null,
        string $contentType = self::contentTypes['restAccountsContactsPositionsPositionIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ContactPosition';
        $request = $this->restAccountsContactsPositionsPositionIdPutRequest($position_id, $_rest_accounts_contacts_positions_position_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsPositionsPositionIdPut'
     *
     * @param  int $position_id The ID of the position (required)
     * @param  \ck\Model\RestAccountsContactsPositionsPostRequest|null $_rest_accounts_contacts_positions_position_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsPositionsPositionIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsPositionsPositionIdPutRequest(
        $position_id,
        $_rest_accounts_contacts_positions_position_id = null,
        string $contentType = self::contentTypes['restAccountsContactsPositionsPositionIdPut'][0]
    ): Request
    {

        // verify the required parameter 'position_id' is set
        if ($position_id === null || (is_array($position_id) && count($position_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $position_id when calling restAccountsContactsPositionsPositionIdPut'
            );
        }



        $resourcePath = '/rest/accounts/contacts/positions/{positionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($position_id !== null) {
            $resourcePath = str_replace(
                '{' . 'positionId' . '}',
                ObjectSerializer::toPathValue($position_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_accounts_contacts_positions_position_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_accounts_contacts_positions_position_id));
            } else {
                $httpBody = $_rest_accounts_contacts_positions_position_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsPositionsPost
     *
     * Create contact position
     *
     * @param  \ck\Model\RestAccountsContactsPositionsPostRequest|null $_rest_accounts_contacts_positions _rest_accounts_contacts_positions (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsPositionsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ContactPosition
     */
    public function restAccountsContactsPositionsPost(
        ?\ck\Model\RestAccountsContactsPositionsPostRequest $_rest_accounts_contacts_positions = null,
        string $contentType = self::contentTypes['restAccountsContactsPositionsPost'][0]
    ): \ck\Model\ContactPosition
    {
        list($response) = $this->restAccountsContactsPositionsPostWithHttpInfo($_rest_accounts_contacts_positions, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsContactsPositionsPostWithHttpInfo
     *
     * Create contact position
     *
     * @param  \ck\Model\RestAccountsContactsPositionsPostRequest|null $_rest_accounts_contacts_positions (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsPositionsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ContactPosition, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsPositionsPostWithHttpInfo(
        ?\ck\Model\RestAccountsContactsPositionsPostRequest $_rest_accounts_contacts_positions = null,
        string $contentType = self::contentTypes['restAccountsContactsPositionsPost'][0]
    ): array
    {
        $request = $this->restAccountsContactsPositionsPostRequest($_rest_accounts_contacts_positions, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ContactPosition' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ContactPosition' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ContactPosition', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ContactPosition';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ContactPosition',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsPositionsPostAsync
     *
     * Create contact position
     *
     * @param  \ck\Model\RestAccountsContactsPositionsPostRequest|null $_rest_accounts_contacts_positions (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsPositionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsPositionsPostAsync(
        ?\ck\Model\RestAccountsContactsPositionsPostRequest $_rest_accounts_contacts_positions = null,
        string $contentType = self::contentTypes['restAccountsContactsPositionsPost'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsPositionsPostAsyncWithHttpInfo($_rest_accounts_contacts_positions, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsPositionsPostAsyncWithHttpInfo
     *
     * Create contact position
     *
     * @param  \ck\Model\RestAccountsContactsPositionsPostRequest|null $_rest_accounts_contacts_positions (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsPositionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsPositionsPostAsyncWithHttpInfo(
        $_rest_accounts_contacts_positions = null,
        string $contentType = self::contentTypes['restAccountsContactsPositionsPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ContactPosition';
        $request = $this->restAccountsContactsPositionsPostRequest($_rest_accounts_contacts_positions, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsPositionsPost'
     *
     * @param  \ck\Model\RestAccountsContactsPositionsPostRequest|null $_rest_accounts_contacts_positions (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsPositionsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsPositionsPostRequest(
        $_rest_accounts_contacts_positions = null,
        string $contentType = self::contentTypes['restAccountsContactsPositionsPost'][0]
    ): Request
    {



        $resourcePath = '/rest/accounts/contacts/positions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_accounts_contacts_positions)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_accounts_contacts_positions));
            } else {
                $httpBody = $_rest_accounts_contacts_positions;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsPost
     *
     * Create contact
     *
     * @param  \ck\Model\RestAccountsContactsPostRequest|null $_rest_accounts_contacts _rest_accounts_contacts (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Contact
     */
    public function restAccountsContactsPost(
        ?\ck\Model\RestAccountsContactsPostRequest $_rest_accounts_contacts = null,
        string $contentType = self::contentTypes['restAccountsContactsPost'][0]
    ): \ck\Model\Contact
    {
        list($response) = $this->restAccountsContactsPostWithHttpInfo($_rest_accounts_contacts, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsContactsPostWithHttpInfo
     *
     * Create contact
     *
     * @param  \ck\Model\RestAccountsContactsPostRequest|null $_rest_accounts_contacts (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Contact, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsPostWithHttpInfo(
        ?\ck\Model\RestAccountsContactsPostRequest $_rest_accounts_contacts = null,
        string $contentType = self::contentTypes['restAccountsContactsPost'][0]
    ): array
    {
        $request = $this->restAccountsContactsPostRequest($_rest_accounts_contacts, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Contact' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Contact' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Contact', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Contact';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Contact',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsPostAsync
     *
     * Create contact
     *
     * @param  \ck\Model\RestAccountsContactsPostRequest|null $_rest_accounts_contacts (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsPostAsync(
        ?\ck\Model\RestAccountsContactsPostRequest $_rest_accounts_contacts = null,
        string $contentType = self::contentTypes['restAccountsContactsPost'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsPostAsyncWithHttpInfo($_rest_accounts_contacts, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsPostAsyncWithHttpInfo
     *
     * Create contact
     *
     * @param  \ck\Model\RestAccountsContactsPostRequest|null $_rest_accounts_contacts (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsPostAsyncWithHttpInfo(
        $_rest_accounts_contacts = null,
        string $contentType = self::contentTypes['restAccountsContactsPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Contact';
        $request = $this->restAccountsContactsPostRequest($_rest_accounts_contacts, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsPost'
     *
     * @param  \ck\Model\RestAccountsContactsPostRequest|null $_rest_accounts_contacts (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsPostRequest(
        $_rest_accounts_contacts = null,
        string $contentType = self::contentTypes['restAccountsContactsPost'][0]
    ): Request
    {



        $resourcePath = '/rest/accounts/contacts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_accounts_contacts)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_accounts_contacts));
            } else {
                $httpBody = $_rest_accounts_contacts;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsTypesGet
     *
     * List contact types
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsTypesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ContactType[]
     */
    public function restAccountsContactsTypesGet(
        string $contentType = self::contentTypes['restAccountsContactsTypesGet'][0]
    ): array
    {
        list($response) = $this->restAccountsContactsTypesGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restAccountsContactsTypesGetWithHttpInfo
     *
     * List contact types
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsTypesGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ContactType[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsTypesGetWithHttpInfo(
        string $contentType = self::contentTypes['restAccountsContactsTypesGet'][0]
    ): array
    {
        $request = $this->restAccountsContactsTypesGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ContactType[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ContactType[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ContactType[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ContactType[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ContactType[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsTypesGetAsync
     *
     * List contact types
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsTypesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsTypesGetAsync(
        string $contentType = self::contentTypes['restAccountsContactsTypesGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsTypesGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsTypesGetAsyncWithHttpInfo
     *
     * List contact types
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsTypesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsTypesGetAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restAccountsContactsTypesGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ContactType[]';
        $request = $this->restAccountsContactsTypesGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsTypesGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsTypesGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsTypesGetRequest(
        string $contentType = self::contentTypes['restAccountsContactsTypesGet'][0]
    ): Request
    {


        $resourcePath = '/rest/accounts/contacts/types';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsTypesPost
     *
     * Create contact type
     *
     * @param  \ck\Model\RestAccountsAddressesOptionTypesPostRequest|null $_rest_accounts_contacts_types _rest_accounts_contacts_types (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsTypesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ContactType
     */
    public function restAccountsContactsTypesPost(
        ?\ck\Model\RestAccountsAddressesOptionTypesPostRequest $_rest_accounts_contacts_types = null,
        string $contentType = self::contentTypes['restAccountsContactsTypesPost'][0]
    ): \ck\Model\ContactType
    {
        list($response) = $this->restAccountsContactsTypesPostWithHttpInfo($_rest_accounts_contacts_types, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsContactsTypesPostWithHttpInfo
     *
     * Create contact type
     *
     * @param  \ck\Model\RestAccountsAddressesOptionTypesPostRequest|null $_rest_accounts_contacts_types (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsTypesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ContactType, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsTypesPostWithHttpInfo(
        ?\ck\Model\RestAccountsAddressesOptionTypesPostRequest $_rest_accounts_contacts_types = null,
        string $contentType = self::contentTypes['restAccountsContactsTypesPost'][0]
    ): array
    {
        $request = $this->restAccountsContactsTypesPostRequest($_rest_accounts_contacts_types, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ContactType' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ContactType' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ContactType', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ContactType';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ContactType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsTypesPostAsync
     *
     * Create contact type
     *
     * @param  \ck\Model\RestAccountsAddressesOptionTypesPostRequest|null $_rest_accounts_contacts_types (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsTypesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsTypesPostAsync(
        ?\ck\Model\RestAccountsAddressesOptionTypesPostRequest $_rest_accounts_contacts_types = null,
        string $contentType = self::contentTypes['restAccountsContactsTypesPost'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsTypesPostAsyncWithHttpInfo($_rest_accounts_contacts_types, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsTypesPostAsyncWithHttpInfo
     *
     * Create contact type
     *
     * @param  \ck\Model\RestAccountsAddressesOptionTypesPostRequest|null $_rest_accounts_contacts_types (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsTypesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsTypesPostAsyncWithHttpInfo(
        $_rest_accounts_contacts_types = null,
        string $contentType = self::contentTypes['restAccountsContactsTypesPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ContactType';
        $request = $this->restAccountsContactsTypesPostRequest($_rest_accounts_contacts_types, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsTypesPost'
     *
     * @param  \ck\Model\RestAccountsAddressesOptionTypesPostRequest|null $_rest_accounts_contacts_types (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsTypesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsTypesPostRequest(
        $_rest_accounts_contacts_types = null,
        string $contentType = self::contentTypes['restAccountsContactsTypesPost'][0]
    ): Request
    {



        $resourcePath = '/rest/accounts/contacts/types';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_accounts_contacts_types)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_accounts_contacts_types));
            } else {
                $httpBody = $_rest_accounts_contacts_types;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsTypesTypeIdDelete
     *
     * Delete contact type
     *
     * @param  int $type_id The ID of the contact type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsTypesTypeIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function restAccountsContactsTypesTypeIdDelete(
        int $type_id,
        string $contentType = self::contentTypes['restAccountsContactsTypesTypeIdDelete'][0]
    ): void
    {
        $this->restAccountsContactsTypesTypeIdDeleteWithHttpInfo($type_id, $contentType);
    }

    /**
     * Operation restAccountsContactsTypesTypeIdDeleteWithHttpInfo
     *
     * Delete contact type
     *
     * @param  int $type_id The ID of the contact type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsTypesTypeIdDelete'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsTypesTypeIdDeleteWithHttpInfo(
        int $type_id,
        string $contentType = self::contentTypes['restAccountsContactsTypesTypeIdDelete'][0]
    ): array
    {
        $request = $this->restAccountsContactsTypesTypeIdDeleteRequest($type_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsTypesTypeIdDeleteAsync
     *
     * Delete contact type
     *
     * @param  int $type_id The ID of the contact type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsTypesTypeIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsTypesTypeIdDeleteAsync(
        int $type_id,
        string $contentType = self::contentTypes['restAccountsContactsTypesTypeIdDelete'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsTypesTypeIdDeleteAsyncWithHttpInfo($type_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsTypesTypeIdDeleteAsyncWithHttpInfo
     *
     * Delete contact type
     *
     * @param  int $type_id The ID of the contact type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsTypesTypeIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsTypesTypeIdDeleteAsyncWithHttpInfo(
        $type_id,
        string $contentType = self::contentTypes['restAccountsContactsTypesTypeIdDelete'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->restAccountsContactsTypesTypeIdDeleteRequest($type_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsTypesTypeIdDelete'
     *
     * @param  int $type_id The ID of the contact type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsTypesTypeIdDelete'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsTypesTypeIdDeleteRequest(
        $type_id,
        string $contentType = self::contentTypes['restAccountsContactsTypesTypeIdDelete'][0]
    ): Request
    {

        // verify the required parameter 'type_id' is set
        if ($type_id === null || (is_array($type_id) && count($type_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $type_id when calling restAccountsContactsTypesTypeIdDelete'
            );
        }


        $resourcePath = '/rest/accounts/contacts/types/{typeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'typeId' . '}',
                ObjectSerializer::toPathValue($type_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsTypesTypeIdGet
     *
     * Get contact type
     *
     * @param  int $type_id The ID of the contact type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsTypesTypeIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ContactType
     */
    public function restAccountsContactsTypesTypeIdGet(
        int $type_id,
        string $contentType = self::contentTypes['restAccountsContactsTypesTypeIdGet'][0]
    ): \ck\Model\ContactType
    {
        list($response) = $this->restAccountsContactsTypesTypeIdGetWithHttpInfo($type_id, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsContactsTypesTypeIdGetWithHttpInfo
     *
     * Get contact type
     *
     * @param  int $type_id The ID of the contact type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsTypesTypeIdGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ContactType, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsTypesTypeIdGetWithHttpInfo(
        int $type_id,
        string $contentType = self::contentTypes['restAccountsContactsTypesTypeIdGet'][0]
    ): array
    {
        $request = $this->restAccountsContactsTypesTypeIdGetRequest($type_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ContactType' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ContactType' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ContactType', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ContactType';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ContactType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsTypesTypeIdGetAsync
     *
     * Get contact type
     *
     * @param  int $type_id The ID of the contact type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsTypesTypeIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsTypesTypeIdGetAsync(
        int $type_id,
        string $contentType = self::contentTypes['restAccountsContactsTypesTypeIdGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsTypesTypeIdGetAsyncWithHttpInfo($type_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsTypesTypeIdGetAsyncWithHttpInfo
     *
     * Get contact type
     *
     * @param  int $type_id The ID of the contact type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsTypesTypeIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsTypesTypeIdGetAsyncWithHttpInfo(
        $type_id,
        string $contentType = self::contentTypes['restAccountsContactsTypesTypeIdGet'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ContactType';
        $request = $this->restAccountsContactsTypesTypeIdGetRequest($type_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsTypesTypeIdGet'
     *
     * @param  int $type_id The ID of the contact type (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsTypesTypeIdGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsTypesTypeIdGetRequest(
        $type_id,
        string $contentType = self::contentTypes['restAccountsContactsTypesTypeIdGet'][0]
    ): Request
    {

        // verify the required parameter 'type_id' is set
        if ($type_id === null || (is_array($type_id) && count($type_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $type_id when calling restAccountsContactsTypesTypeIdGet'
            );
        }


        $resourcePath = '/rest/accounts/contacts/types/{typeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'typeId' . '}',
                ObjectSerializer::toPathValue($type_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsTypesTypeIdPut
     *
     * Update contact type
     *
     * @param  int $type_id The ID of the contact type (required)
     * @param  \ck\Model\RestAccountsAddressesOptionTypesPostRequest|null $_rest_accounts_contacts_types_type_id _rest_accounts_contacts_types_type_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsTypesTypeIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\ContactType
     */
    public function restAccountsContactsTypesTypeIdPut(
        int $type_id,
        ?\ck\Model\RestAccountsAddressesOptionTypesPostRequest $_rest_accounts_contacts_types_type_id = null,
        string $contentType = self::contentTypes['restAccountsContactsTypesTypeIdPut'][0]
    ): \ck\Model\ContactType
    {
        list($response) = $this->restAccountsContactsTypesTypeIdPutWithHttpInfo($type_id, $_rest_accounts_contacts_types_type_id, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsContactsTypesTypeIdPutWithHttpInfo
     *
     * Update contact type
     *
     * @param  int $type_id The ID of the contact type (required)
     * @param  \ck\Model\RestAccountsAddressesOptionTypesPostRequest|null $_rest_accounts_contacts_types_type_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsTypesTypeIdPut'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\ContactType, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsTypesTypeIdPutWithHttpInfo(
        int $type_id,
        ?\ck\Model\RestAccountsAddressesOptionTypesPostRequest $_rest_accounts_contacts_types_type_id = null,
        string $contentType = self::contentTypes['restAccountsContactsTypesTypeIdPut'][0]
    ): array
    {
        $request = $this->restAccountsContactsTypesTypeIdPutRequest($type_id, $_rest_accounts_contacts_types_type_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\ContactType' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\ContactType' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\ContactType', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\ContactType';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\ContactType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsTypesTypeIdPutAsync
     *
     * Update contact type
     *
     * @param  int $type_id The ID of the contact type (required)
     * @param  \ck\Model\RestAccountsAddressesOptionTypesPostRequest|null $_rest_accounts_contacts_types_type_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsTypesTypeIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsTypesTypeIdPutAsync(
        int $type_id,
        ?\ck\Model\RestAccountsAddressesOptionTypesPostRequest $_rest_accounts_contacts_types_type_id = null,
        string $contentType = self::contentTypes['restAccountsContactsTypesTypeIdPut'][0]
    ): PromiseInterface
    {
        return $this->restAccountsContactsTypesTypeIdPutAsyncWithHttpInfo($type_id, $_rest_accounts_contacts_types_type_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsTypesTypeIdPutAsyncWithHttpInfo
     *
     * Update contact type
     *
     * @param  int $type_id The ID of the contact type (required)
     * @param  \ck\Model\RestAccountsAddressesOptionTypesPostRequest|null $_rest_accounts_contacts_types_type_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsTypesTypeIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsContactsTypesTypeIdPutAsyncWithHttpInfo(
        $type_id,
        $_rest_accounts_contacts_types_type_id = null,
        string $contentType = self::contentTypes['restAccountsContactsTypesTypeIdPut'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\ContactType';
        $request = $this->restAccountsContactsTypesTypeIdPutRequest($type_id, $_rest_accounts_contacts_types_type_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsTypesTypeIdPut'
     *
     * @param  int $type_id The ID of the contact type (required)
     * @param  \ck\Model\RestAccountsAddressesOptionTypesPostRequest|null $_rest_accounts_contacts_types_type_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsContactsTypesTypeIdPut'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsContactsTypesTypeIdPutRequest(
        $type_id,
        $_rest_accounts_contacts_types_type_id = null,
        string $contentType = self::contentTypes['restAccountsContactsTypesTypeIdPut'][0]
    ): Request
    {

        // verify the required parameter 'type_id' is set
        if ($type_id === null || (is_array($type_id) && count($type_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $type_id when calling restAccountsContactsTypesTypeIdPut'
            );
        }



        $resourcePath = '/rest/accounts/contacts/types/{typeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'typeId' . '}',
                ObjectSerializer::toPathValue($type_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_accounts_contacts_types_type_id)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_accounts_contacts_types_type_id));
            } else {
                $httpBody = $_rest_accounts_contacts_types_type_id;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsGet
     *
     * List accounts
     *
     * @param  string|null $updated_at Filter that restricts the search result to accounts that were updated according to given filters.                                    &lt;br&gt; Usage: &lt;ul&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;between:yyyy-mm-dd,yyyy-mm-dd&#39;&lt;/li&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;eq:yyyy-mm-dd&#39; (&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;gt:yyyy-mm-dd&#39; (&gt;)&lt;/li&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;gte:yyyy-mm-dd&#39; (&gt;&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;lt:yyyy-mm-dd&#39; (&lt;)&lt;/li&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;lte:yyyy-mm-dd&#39; (&lt;&#x3D;)&lt;/li&gt;                                    &lt;li&gt;Dates can also include the time. Example: 2017-03-08 13:24:17&lt;/li&gt;                                    &lt;li&gt;Without including the time we will use 00:00:00 as default. Example: 2017-03-08 00:00:00&lt;/li&gt;                                    &lt;/ul&gt; (optional)
     * @param  string|null $created_at Filter that restricts the search result to accounts that were created according to given filters.                                    &lt;br&gt; Usage: &lt;ul&gt;                                    &lt;li&gt;&#39;createdAt&#x3D;between:yyyy-mm-dd,yyyy-mm-dd&#39;&lt;/li&gt;                                    &lt;li&gt;&#39;createdAt&#x3D;eq:yyyy-mm-dd&#39; (&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#39;createdAt&#x3D;gt:yyyy-mm-dd&#39; (&gt;)&lt;/li&gt;                                    &lt;li&gt;&#39;createdAt&#x3D;gte:yyyy-mm-dd&#39; (&gt;&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#39;createdAt&#x3D;lt:yyyy-mm-dd&#39; (&lt;)&lt;/li&gt;                                   &lt;li&gt;&#39;createdAt&#x3D;lte:yyyy-mm-dd&#39; (&lt;&#x3D;)&lt;/li&gt;                                   &lt;li&gt;Dates can also include the time. Example: 2017-03-08 13:24:17&lt;/li&gt;                                    &lt;li&gt;Without including the time we will use 00:00:00 as default. Example: 2017-03-08 00:00:00&lt;/li&gt;          &lt;/ul&gt; (optional)
     * @param  string|null $company_name Filter that restricts the search result to accounts that have a company name according to given filters.                                    &lt;br&gt; Usage: &lt;ul&gt;                                    &lt;li&gt;&#39;companyName&#x3D;like:expamle&#39;&lt;/li&gt;                                    &lt;li&gt;&#39;companyName&#x3D;eq:example&#39; (&#x3D;)&lt;/li&gt;                                    &lt;/ul&gt; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return object
     */
    public function restAccountsGet(
        ?string $updated_at = null,
        ?string $created_at = null,
        ?string $company_name = null,
        string $contentType = self::contentTypes['restAccountsGet'][0]
    ): object
    {
        list($response) = $this->restAccountsGetWithHttpInfo($updated_at, $created_at, $company_name, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsGetWithHttpInfo
     *
     * List accounts
     *
     * @param  string|null $updated_at Filter that restricts the search result to accounts that were updated according to given filters.                                    &lt;br&gt; Usage: &lt;ul&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;between:yyyy-mm-dd,yyyy-mm-dd&#39;&lt;/li&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;eq:yyyy-mm-dd&#39; (&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;gt:yyyy-mm-dd&#39; (&gt;)&lt;/li&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;gte:yyyy-mm-dd&#39; (&gt;&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;lt:yyyy-mm-dd&#39; (&lt;)&lt;/li&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;lte:yyyy-mm-dd&#39; (&lt;&#x3D;)&lt;/li&gt;                                    &lt;li&gt;Dates can also include the time. Example: 2017-03-08 13:24:17&lt;/li&gt;                                    &lt;li&gt;Without including the time we will use 00:00:00 as default. Example: 2017-03-08 00:00:00&lt;/li&gt;                                    &lt;/ul&gt; (optional)
     * @param  string|null $created_at Filter that restricts the search result to accounts that were created according to given filters.                                    &lt;br&gt; Usage: &lt;ul&gt;                                    &lt;li&gt;&#39;createdAt&#x3D;between:yyyy-mm-dd,yyyy-mm-dd&#39;&lt;/li&gt;                                    &lt;li&gt;&#39;createdAt&#x3D;eq:yyyy-mm-dd&#39; (&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#39;createdAt&#x3D;gt:yyyy-mm-dd&#39; (&gt;)&lt;/li&gt;                                    &lt;li&gt;&#39;createdAt&#x3D;gte:yyyy-mm-dd&#39; (&gt;&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#39;createdAt&#x3D;lt:yyyy-mm-dd&#39; (&lt;)&lt;/li&gt;                                   &lt;li&gt;&#39;createdAt&#x3D;lte:yyyy-mm-dd&#39; (&lt;&#x3D;)&lt;/li&gt;                                   &lt;li&gt;Dates can also include the time. Example: 2017-03-08 13:24:17&lt;/li&gt;                                    &lt;li&gt;Without including the time we will use 00:00:00 as default. Example: 2017-03-08 00:00:00&lt;/li&gt;          &lt;/ul&gt; (optional)
     * @param  string|null $company_name Filter that restricts the search result to accounts that have a company name according to given filters.                                    &lt;br&gt; Usage: &lt;ul&gt;                                    &lt;li&gt;&#39;companyName&#x3D;like:expamle&#39;&lt;/li&gt;                                    &lt;li&gt;&#39;companyName&#x3D;eq:example&#39; (&#x3D;)&lt;/li&gt;                                    &lt;/ul&gt; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsGet'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsGetWithHttpInfo(
        ?string $updated_at = null,
        ?string $created_at = null,
        ?string $company_name = null,
        string $contentType = self::contentTypes['restAccountsGet'][0]
    ): array
    {
        $request = $this->restAccountsGetRequest($updated_at, $created_at, $company_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsGetAsync
     *
     * List accounts
     *
     * @param  string|null $updated_at Filter that restricts the search result to accounts that were updated according to given filters.                                    &lt;br&gt; Usage: &lt;ul&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;between:yyyy-mm-dd,yyyy-mm-dd&#39;&lt;/li&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;eq:yyyy-mm-dd&#39; (&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;gt:yyyy-mm-dd&#39; (&gt;)&lt;/li&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;gte:yyyy-mm-dd&#39; (&gt;&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;lt:yyyy-mm-dd&#39; (&lt;)&lt;/li&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;lte:yyyy-mm-dd&#39; (&lt;&#x3D;)&lt;/li&gt;                                    &lt;li&gt;Dates can also include the time. Example: 2017-03-08 13:24:17&lt;/li&gt;                                    &lt;li&gt;Without including the time we will use 00:00:00 as default. Example: 2017-03-08 00:00:00&lt;/li&gt;                                    &lt;/ul&gt; (optional)
     * @param  string|null $created_at Filter that restricts the search result to accounts that were created according to given filters.                                    &lt;br&gt; Usage: &lt;ul&gt;                                    &lt;li&gt;&#39;createdAt&#x3D;between:yyyy-mm-dd,yyyy-mm-dd&#39;&lt;/li&gt;                                    &lt;li&gt;&#39;createdAt&#x3D;eq:yyyy-mm-dd&#39; (&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#39;createdAt&#x3D;gt:yyyy-mm-dd&#39; (&gt;)&lt;/li&gt;                                    &lt;li&gt;&#39;createdAt&#x3D;gte:yyyy-mm-dd&#39; (&gt;&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#39;createdAt&#x3D;lt:yyyy-mm-dd&#39; (&lt;)&lt;/li&gt;                                   &lt;li&gt;&#39;createdAt&#x3D;lte:yyyy-mm-dd&#39; (&lt;&#x3D;)&lt;/li&gt;                                   &lt;li&gt;Dates can also include the time. Example: 2017-03-08 13:24:17&lt;/li&gt;                                    &lt;li&gt;Without including the time we will use 00:00:00 as default. Example: 2017-03-08 00:00:00&lt;/li&gt;          &lt;/ul&gt; (optional)
     * @param  string|null $company_name Filter that restricts the search result to accounts that have a company name according to given filters.                                    &lt;br&gt; Usage: &lt;ul&gt;                                    &lt;li&gt;&#39;companyName&#x3D;like:expamle&#39;&lt;/li&gt;                                    &lt;li&gt;&#39;companyName&#x3D;eq:example&#39; (&#x3D;)&lt;/li&gt;                                    &lt;/ul&gt; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsGetAsync(
        ?string $updated_at = null,
        ?string $created_at = null,
        ?string $company_name = null,
        string $contentType = self::contentTypes['restAccountsGet'][0]
    ): PromiseInterface
    {
        return $this->restAccountsGetAsyncWithHttpInfo($updated_at, $created_at, $company_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsGetAsyncWithHttpInfo
     *
     * List accounts
     *
     * @param  string|null $updated_at Filter that restricts the search result to accounts that were updated according to given filters.                                    &lt;br&gt; Usage: &lt;ul&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;between:yyyy-mm-dd,yyyy-mm-dd&#39;&lt;/li&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;eq:yyyy-mm-dd&#39; (&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;gt:yyyy-mm-dd&#39; (&gt;)&lt;/li&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;gte:yyyy-mm-dd&#39; (&gt;&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;lt:yyyy-mm-dd&#39; (&lt;)&lt;/li&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;lte:yyyy-mm-dd&#39; (&lt;&#x3D;)&lt;/li&gt;                                    &lt;li&gt;Dates can also include the time. Example: 2017-03-08 13:24:17&lt;/li&gt;                                    &lt;li&gt;Without including the time we will use 00:00:00 as default. Example: 2017-03-08 00:00:00&lt;/li&gt;                                    &lt;/ul&gt; (optional)
     * @param  string|null $created_at Filter that restricts the search result to accounts that were created according to given filters.                                    &lt;br&gt; Usage: &lt;ul&gt;                                    &lt;li&gt;&#39;createdAt&#x3D;between:yyyy-mm-dd,yyyy-mm-dd&#39;&lt;/li&gt;                                    &lt;li&gt;&#39;createdAt&#x3D;eq:yyyy-mm-dd&#39; (&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#39;createdAt&#x3D;gt:yyyy-mm-dd&#39; (&gt;)&lt;/li&gt;                                    &lt;li&gt;&#39;createdAt&#x3D;gte:yyyy-mm-dd&#39; (&gt;&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#39;createdAt&#x3D;lt:yyyy-mm-dd&#39; (&lt;)&lt;/li&gt;                                   &lt;li&gt;&#39;createdAt&#x3D;lte:yyyy-mm-dd&#39; (&lt;&#x3D;)&lt;/li&gt;                                   &lt;li&gt;Dates can also include the time. Example: 2017-03-08 13:24:17&lt;/li&gt;                                    &lt;li&gt;Without including the time we will use 00:00:00 as default. Example: 2017-03-08 00:00:00&lt;/li&gt;          &lt;/ul&gt; (optional)
     * @param  string|null $company_name Filter that restricts the search result to accounts that have a company name according to given filters.                                    &lt;br&gt; Usage: &lt;ul&gt;                                    &lt;li&gt;&#39;companyName&#x3D;like:expamle&#39;&lt;/li&gt;                                    &lt;li&gt;&#39;companyName&#x3D;eq:example&#39; (&#x3D;)&lt;/li&gt;                                    &lt;/ul&gt; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsGetAsyncWithHttpInfo(
        $updated_at = null,
        $created_at = null,
        $company_name = null,
        string $contentType = self::contentTypes['restAccountsGet'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->restAccountsGetRequest($updated_at, $created_at, $company_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsGet'
     *
     * @param  string|null $updated_at Filter that restricts the search result to accounts that were updated according to given filters.                                    &lt;br&gt; Usage: &lt;ul&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;between:yyyy-mm-dd,yyyy-mm-dd&#39;&lt;/li&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;eq:yyyy-mm-dd&#39; (&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;gt:yyyy-mm-dd&#39; (&gt;)&lt;/li&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;gte:yyyy-mm-dd&#39; (&gt;&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;lt:yyyy-mm-dd&#39; (&lt;)&lt;/li&gt;                                    &lt;li&gt;&#39;updatedAt&#x3D;lte:yyyy-mm-dd&#39; (&lt;&#x3D;)&lt;/li&gt;                                    &lt;li&gt;Dates can also include the time. Example: 2017-03-08 13:24:17&lt;/li&gt;                                    &lt;li&gt;Without including the time we will use 00:00:00 as default. Example: 2017-03-08 00:00:00&lt;/li&gt;                                    &lt;/ul&gt; (optional)
     * @param  string|null $created_at Filter that restricts the search result to accounts that were created according to given filters.                                    &lt;br&gt; Usage: &lt;ul&gt;                                    &lt;li&gt;&#39;createdAt&#x3D;between:yyyy-mm-dd,yyyy-mm-dd&#39;&lt;/li&gt;                                    &lt;li&gt;&#39;createdAt&#x3D;eq:yyyy-mm-dd&#39; (&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#39;createdAt&#x3D;gt:yyyy-mm-dd&#39; (&gt;)&lt;/li&gt;                                    &lt;li&gt;&#39;createdAt&#x3D;gte:yyyy-mm-dd&#39; (&gt;&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#39;createdAt&#x3D;lt:yyyy-mm-dd&#39; (&lt;)&lt;/li&gt;                                   &lt;li&gt;&#39;createdAt&#x3D;lte:yyyy-mm-dd&#39; (&lt;&#x3D;)&lt;/li&gt;                                   &lt;li&gt;Dates can also include the time. Example: 2017-03-08 13:24:17&lt;/li&gt;                                    &lt;li&gt;Without including the time we will use 00:00:00 as default. Example: 2017-03-08 00:00:00&lt;/li&gt;          &lt;/ul&gt; (optional)
     * @param  string|null $company_name Filter that restricts the search result to accounts that have a company name according to given filters.                                    &lt;br&gt; Usage: &lt;ul&gt;                                    &lt;li&gt;&#39;companyName&#x3D;like:expamle&#39;&lt;/li&gt;                                    &lt;li&gt;&#39;companyName&#x3D;eq:example&#39; (&#x3D;)&lt;/li&gt;                                    &lt;/ul&gt; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsGet'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsGetRequest(
        $updated_at = null,
        $created_at = null,
        $company_name = null,
        string $contentType = self::contentTypes['restAccountsGet'][0]
    ): Request
    {





        $resourcePath = '/rest/accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_at,
            'updatedAt', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_at,
            'createdAt', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $company_name,
            'companyName', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsPost
     *
     * Create account
     *
     * @param  \ck\Model\RestAccountsPostRequest|null $_rest_accounts _rest_accounts (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\Account
     */
    public function restAccountsPost(
        ?\ck\Model\RestAccountsPostRequest $_rest_accounts = null,
        string $contentType = self::contentTypes['restAccountsPost'][0]
    ): \ck\Model\Account
    {
        list($response) = $this->restAccountsPostWithHttpInfo($_rest_accounts, $contentType);
        return $response;
    }

    /**
     * Operation restAccountsPostWithHttpInfo
     *
     * Create account
     *
     * @param  \ck\Model\RestAccountsPostRequest|null $_rest_accounts (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\Account, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsPostWithHttpInfo(
        ?\ck\Model\RestAccountsPostRequest $_rest_accounts = null,
        string $contentType = self::contentTypes['restAccountsPost'][0]
    ): array
    {
        $request = $this->restAccountsPostRequest($_rest_accounts, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\Account' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\Account' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\Account', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\Account';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\Account',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsPostAsync
     *
     * Create account
     *
     * @param  \ck\Model\RestAccountsPostRequest|null $_rest_accounts (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsPostAsync(
        ?\ck\Model\RestAccountsPostRequest $_rest_accounts = null,
        string $contentType = self::contentTypes['restAccountsPost'][0]
    ): PromiseInterface
    {
        return $this->restAccountsPostAsyncWithHttpInfo($_rest_accounts, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsPostAsyncWithHttpInfo
     *
     * Create account
     *
     * @param  \ck\Model\RestAccountsPostRequest|null $_rest_accounts (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restAccountsPostAsyncWithHttpInfo(
        $_rest_accounts = null,
        string $contentType = self::contentTypes['restAccountsPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\Account';
        $request = $this->restAccountsPostRequest($_rest_accounts, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsPost'
     *
     * @param  \ck\Model\RestAccountsPostRequest|null $_rest_accounts (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restAccountsPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restAccountsPostRequest(
        $_rest_accounts = null,
        string $contentType = self::contentTypes['restAccountsPost'][0]
    ): Request
    {



        $resourcePath = '/rest/accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($_rest_accounts)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($_rest_accounts));
            } else {
                $httpBody = $_rest_accounts;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersAddressesPost
     *
     * Create address for existing order
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersAddressesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\AddressOrderRelation
     */
    public function restOrdersAddressesPost(
        string $contentType = self::contentTypes['restOrdersAddressesPost'][0]
    ): \ck\Model\AddressOrderRelation
    {
        list($response) = $this->restOrdersAddressesPostWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restOrdersAddressesPostWithHttpInfo
     *
     * Create address for existing order
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersAddressesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\AddressOrderRelation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersAddressesPostWithHttpInfo(
        string $contentType = self::contentTypes['restOrdersAddressesPost'][0]
    ): array
    {
        $request = $this->restOrdersAddressesPostRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\AddressOrderRelation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\AddressOrderRelation' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\AddressOrderRelation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\AddressOrderRelation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\AddressOrderRelation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersAddressesPostAsync
     *
     * Create address for existing order
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersAddressesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersAddressesPostAsync(
        string $contentType = self::contentTypes['restOrdersAddressesPost'][0]
    ): PromiseInterface
    {
        return $this->restOrdersAddressesPostAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersAddressesPostAsyncWithHttpInfo
     *
     * Create address for existing order
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersAddressesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restOrdersAddressesPostAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restOrdersAddressesPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\AddressOrderRelation';
        $request = $this->restOrdersAddressesPostRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersAddressesPost'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restOrdersAddressesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restOrdersAddressesPostRequest(
        string $contentType = self::contentTypes['restOrdersAddressesPost'][0]
    ): Request
    {


        $resourcePath = '/rest/orders/addresses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restStockmanagementWarehousesAddressesPost
     *
     * Create address for existing warehouse
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restStockmanagementWarehousesAddressesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \ck\Model\AddressWarehouseRelation
     */
    public function restStockmanagementWarehousesAddressesPost(
        string $contentType = self::contentTypes['restStockmanagementWarehousesAddressesPost'][0]
    ): \ck\Model\AddressWarehouseRelation
    {
        list($response) = $this->restStockmanagementWarehousesAddressesPostWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation restStockmanagementWarehousesAddressesPostWithHttpInfo
     *
     * Create address for existing warehouse
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restStockmanagementWarehousesAddressesPost'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \ck\Model\AddressWarehouseRelation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restStockmanagementWarehousesAddressesPostWithHttpInfo(
        string $contentType = self::contentTypes['restStockmanagementWarehousesAddressesPost'][0]
    ): array
    {
        $request = $this->restStockmanagementWarehousesAddressesPostRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ck\Model\AddressWarehouseRelation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ck\Model\AddressWarehouseRelation' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ck\Model\AddressWarehouseRelation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ck\Model\AddressWarehouseRelation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ck\Model\AddressWarehouseRelation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restStockmanagementWarehousesAddressesPostAsync
     *
     * Create address for existing warehouse
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restStockmanagementWarehousesAddressesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restStockmanagementWarehousesAddressesPostAsync(
        string $contentType = self::contentTypes['restStockmanagementWarehousesAddressesPost'][0]
    ): PromiseInterface
    {
        return $this->restStockmanagementWarehousesAddressesPostAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restStockmanagementWarehousesAddressesPostAsyncWithHttpInfo
     *
     * Create address for existing warehouse
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restStockmanagementWarehousesAddressesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function restStockmanagementWarehousesAddressesPostAsyncWithHttpInfo(
        string $contentType = self::contentTypes['restStockmanagementWarehousesAddressesPost'][0]
    ): PromiseInterface
    {
        $returnType = '\ck\Model\AddressWarehouseRelation';
        $request = $this->restStockmanagementWarehousesAddressesPostRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restStockmanagementWarehousesAddressesPost'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restStockmanagementWarehousesAddressesPost'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restStockmanagementWarehousesAddressesPostRequest(
        string $contentType = self::contentTypes['restStockmanagementWarehousesAddressesPost'][0]
    ): Request
    {


        $resourcePath = '/rest/stockmanagement/warehouses/addresses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption(): array
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
